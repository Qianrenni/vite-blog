## **2. 线程同步**

### **2.1 `synchronized` 关键字**

`synchronized` 是Java提供的内置锁机制，用于保证多线程环境下的数据一致性。

#### **2.1.1 方法级同步**

```java
public synchronized void method() {
    // 同步代码块
}
```

#### **2.1.2 块级同步**

```java
public void method() {
    synchronized (this) {
        // 同步代码块
    }
}
```

#### **2.1.3 锁的对象**

- `synchronized` 可以作用于实例方法、静态方法或指定对象。
- 静态方法的锁是类对象（`Class` 对象）。

---

### **2.2 死锁的概念与避免**

- **死锁定义**：多个线程相互持有对方所需的资源，导致彼此永久阻塞。
- **死锁条件**（必要条件）：
  1. **互斥**：资源只能被一个线程占用。
  2. **占有且等待**：线程持有资源的同时等待其他资源。
  3. **不可剥夺**：资源不能被强行抢占。
  4. **循环等待**：存在一个线程等待环路。

- **避免死锁的方法**：
  - 按顺序获取锁。
  - 使用定时锁（`tryLock`）。
  - 减少锁的粒度。

---

### **2.3 `volatile` 关键字**

- **作用**：确保变量的可见性，即每次读取时都从主内存加载最新值。
- **适用场景**：适用于简单的标志位变量。
- **注意**：`volatile` 不保证原子性，不能替代锁。

```java
private volatile boolean flag = true;

public void stop() {
    flag = false;
}
```

---