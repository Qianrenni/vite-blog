## 10.1 微服务架构

### 微服务概念

微服务架构是一种将单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，并通过轻量级机制（通常是HTTP资源API）进行通信。

```go
// 微服务架构示例
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"
)

// 用户服务
type UserService struct {
    port string
}

func NewUserService(port string) *UserService {
    return &UserService{port: port}
}

func (us *UserService) Start() {
    http.HandleFunc("/users", us.getUsers)
    http.HandleFunc("/users/", us.getUser)
    
    log.Printf("User service starting on port %s", us.port)
    log.Fatal(http.ListenAndServe(":"+us.port, nil))
}

func (us *UserService) getUsers(w http.ResponseWriter, r *http.Request) {
    users := []User{
        {ID: 1, Name: "Alice", Email: "alice@example.com"},
        {ID: 2, Name: "Bob", Email: "bob@example.com"},
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func (us *UserService) getUser(w http.ResponseWriter, r *http.Request) {
    // 从URL中提取用户ID
    // 实际实现中需要更完善的解析
    user := User{ID: 1, Name: "Alice", Email: "alice@example.com"}
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// 订单服务
type OrderService struct {
    port string
}

func NewOrderService(port string) *OrderService {
    return &OrderService{port: port}
}

func (os *OrderService) Start() {
    http.HandleFunc("/orders", os.getOrders)
    http.HandleFunc("/orders/", os.getOrder)
    
    log.Printf("Order service starting on port %s", os.port)
    log.Fatal(http.ListenAndServe(":"+os.port, nil))
}

func (os *OrderService) getOrders(w http.ResponseWriter, r *http.Request) {
    orders := []Order{
        {ID: 1, UserID: 1, Amount: 100.0, Status: "completed"},
        {ID: 2, UserID: 2, Amount: 200.0, Status: "pending"},
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(orders)
}

func (os *OrderService) getOrder(w http.ResponseWriter, r *http.Request) {
    order := Order{ID: 1, UserID: 1, Amount: 100.0, Status: "completed"}
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(order)
}

// 数据结构定义
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type Order struct {
    ID     int     `json:"id"`
    UserID int     `json:"user_id"`
    Amount float64 `json:"amount"`
    Status string  `json:"status"`
}

// API网关 - 聚合服务
type APIGateway struct {
    userServiceURL  string
    orderServiceURL string
}

func NewAPIGateway(userURL, orderURL string) *APIGateway {
    return &APIGateway{
        userServiceURL:  userURL,
        orderServiceURL: orderURL,
    }
}

func (ag *APIGateway) Start(port string) {
    http.HandleFunc("/api/users", ag.handleUsers)
    http.HandleFunc("/api/orders", ag.handleOrders)
    http.HandleFunc("/api/dashboard", ag.handleDashboard)
    
    log.Printf("API Gateway starting on port %s", port)
    log.Fatal(http.ListenAndServe(":"+port, nil))
}

func (ag *APIGateway) handleUsers(w http.ResponseWriter, r *http.Request) {
    // 代理到用户服务
    resp, err := http.Get(ag.userServiceURL + "/users")
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()
    
    w.Header().Set("Content-Type", "application/json")
    // 直接转发响应
    // 实际应用中可能需要处理响应体
}

func (ag *APIGateway) handleOrders(w http.ResponseWriter, r *http.Request) {
    // 代理到订单服务
    resp, err := http.Get(ag.orderServiceURL + "/orders")
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    defer resp.Body.Close()
    
    w.Header().Set("Content-Type", "application/json")
}

func (ag *APIGateway) handleDashboard(w http.ResponseWriter, r *http.Request) {
    // 聚合多个服务的数据
    type DashboardData struct {
        Users  []User  `json:"users"`
        Orders []Order `json:"orders"`
        Stats  Stats   `json:"stats"`
    }
    
    type Stats struct {
        TotalUsers  int `json:"total_users"`
        TotalOrders int `json:"total_orders"`
        Revenue     int `json:"revenue"`
    }
    
    // 并行调用多个服务
    dashboard := DashboardData{
        Users: []User{
            {ID: 1, Name: "Alice", Email: "alice@example.com"},
            {ID: 2, Name: "Bob", Email: "bob@example.com"},
        },
        Orders: []Order{
            {ID: 1, UserID: 1, Amount: 100.0, Status: "completed"},
            {ID: 2, UserID: 2, Amount: 200.0, Status: "pending"},
        },
        Stats: Stats{
            TotalUsers:  2,
            TotalOrders: 2,
            Revenue:     300,
        },
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(dashboard)
}
```

### 服务拆分原则

```go
// 服务拆分原则实现示例

// 1. 业务领域驱动拆分
type UserService struct {
    // 用户相关业务逻辑
    userRepository UserRepository
    emailService   EmailService
}

type OrderService struct {
    // 订单相关业务逻辑
    orderRepository OrderRepository
    paymentService  PaymentService
}

type InventoryService struct {
    // 库存相关业务逻辑
    inventoryRepository InventoryRepository
}

// 2. 数据库分离
type UserDatabase struct {
    // 用户数据库连接
    db *sql.DB
}

type OrderDatabase struct {
    // 订单数据库连接
    db *sql.DB
}

type InventoryDatabase struct {
    // 库存数据库连接
    db *sql.DB
}

// 3. 独立部署配置
type ServiceConfig struct {
    Port     string `json:"port"`
    Database struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        Database string `json:"database"`
    } `json:"database"`
    Redis struct {
        Host string `json:"host"`
        Port int    `json:"port"`
    } `json:"redis"`
}

// 4. 独立监控和日志
type ServiceLogger struct {
    serviceName string
    logger      *log.Logger
}

func (sl *ServiceLogger) Info(message string, args ...interface{}) {
    sl.logger.Printf("[%s] INFO: %s", sl.serviceName, fmt.Sprintf(message, args...))
}

func (sl *ServiceLogger) Error(message string, args ...interface{}) {
    sl.logger.Printf("[%s] ERROR: %s", sl.serviceName, fmt.Sprintf(message, args...))
}

// 5. 独立的健康检查
type HealthChecker struct {
    checks map[string]func() error
}

func NewHealthChecker() *HealthChecker {
    return &HealthChecker{
        checks: make(map[string]func() error),
    }
}

func (hc *HealthChecker) AddCheck(name string, check func() error) {
    hc.checks[name] = check
}

func (hc *HealthChecker) Check() map[string]string {
    results := make(map[string]string)
    for name, check := range hc.checks {
        if err := check(); err != nil {
            results[name] = fmt.Sprintf("FAILED: %v", err)
        } else {
            results[name] = "OK"
        }
    }
    return results
}

// 服务健康检查端点
func (us *UserService) HealthCheck(w http.ResponseWriter, r *http.Request) {
    healthChecker := NewHealthChecker()
    healthChecker.AddCheck("database", func() error {
        // 检查数据库连接
        return nil // 实际实现中需要真正的检查
    })
    
    healthChecker.AddCheck("cache", func() error {
        // 检查缓存连接
        return nil
    })
    
    results := healthChecker.Check()
    
    // 检查是否有失败的检查
    allHealthy := true
    for _, status := range results {
        if status != "OK" {
            allHealthy = false
            break
        }
    }
    
    statusCode := http.StatusOK
    if !allHealthy {
        statusCode = http.StatusServiceUnavailable
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(results)
}
```

### 服务通信方式

```go
// 服务间通信方式示例

// 1. HTTP REST API通信
type HTTPClient struct {
    baseURL string
    client  *http.Client
}

func NewHTTPClient(baseURL string) *HTTPClient {
    return &HTTPClient{
        baseURL: baseURL,
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (hc *HTTPClient) GetUser(userID int) (*User, error) {
    url := fmt.Sprintf("%s/users/%d", hc.baseURL, userID)
    
    resp, err := hc.client.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("HTTP error: %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}

// 2. gRPC通信
// 这里展示gRPC客户端和服务端的基本结构

// 3. 消息队列通信
import (
    "github.com/streadway/amqp"
)

type MessageQueueClient struct {
    conn    *amqp.Connection
    channel *amqp.Channel
}

func NewMessageQueueClient(url string) (*MessageQueueClient, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    channel, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    
    return &MessageQueueClient{
        conn:    conn,
        channel: channel,
    }, nil
}

func (mqc *MessageQueueClient) Publish(queueName string, message []byte) error {
    // 声明队列
    _, err := mqc.channel.QueueDeclare(
        queueName, // name
        true,      // durable
        false,     // delete when unused
        false,     // exclusive
        false,     // no-wait
        nil,       // arguments
    )
    if err != nil {
        return err
    }
    
    // 发布消息
    err = mqc.channel.Publish(
        "",        // exchange
        queueName, // routing key
        false,     // mandatory
        false,     // immediate
        amqp.Publishing{
            ContentType: "application/json",
            Body:        message,
        })
    
    return err
}

func (mqc *MessageQueueClient) Consume(queueName string, handler func([]byte)) error {
    msgs, err := mqc.channel.Consume(
        queueName, // queue
        "",        // consumer
        true,      // auto-ack
        false,     // exclusive
        false,     // no-local
        false,     // no-wait
        nil,       // args
    )
    if err != nil {
        return err
    }
    
    go func() {
        for d := range msgs {
            handler(d.Body)
        }
    }()
    
    return nil
}

// 4. 事件驱动通信
type EventBus struct {
    subscribers map[string][]chan interface{}
    mutex       sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        subscribers: make(map[string][]chan interface{}),
    }
}

func (eb *EventBus) Subscribe(eventType string, ch chan interface{}) {
    eb.mutex.Lock()
    defer eb.mutex.Unlock()
    
    eb.subscribers[eventType] = append(eb.subscribers[eventType], ch)
}

func (eb *EventBus) Publish(eventType string, event interface{}) {
    eb.mutex.RLock()
    defer eb.mutex.RUnlock()
    
    if subscribers, ok := eb.subscribers[eventType]; ok {
        for _, ch := range subscribers {
            select {
            case ch <- event:
            default:
                // 非阻塞发送，如果通道满则丢弃
            }
        }
    }
}

// 5. 服务网格通信（示例）
type ServiceMeshClient struct {
    serviceDiscovery ServiceDiscovery
    loadBalancer     LoadBalancer
    circuitBreaker   CircuitBreaker
}

func (smc *ServiceMeshClient) CallService(serviceName string, endpoint string) ([]byte, error) {
    // 服务发现
    instances, err := smc.serviceDiscovery.Discover(serviceName)
    if err != nil {
        return nil, err
    }
    
    // 负载均衡
    instance := smc.loadBalancer.Select(instances)
    
    // 熔断器
    if !smc.circuitBreaker.AllowRequest(serviceName) {
        return nil, fmt.Errorf("circuit breaker open for service %s", serviceName)
    }
    
    // 发起请求
    url := fmt.Sprintf("http://%s:%d%s", instance.Host, instance.Port, endpoint)
    
    resp, err := http.Get(url)
    if err != nil {
        smc.circuitBreaker.RecordFailure(serviceName)
        return nil, err
    }
    defer resp.Body.Close()
    
    smc.circuitBreaker.RecordSuccess(serviceName)
    
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    
    return body, nil
}
```

### 服务治理

```go
// 服务治理组件

// 1. 配置管理
type ConfigManager struct {
    configs map[string]interface{}
    mutex   sync.RWMutex
    watchers map[string][]chan interface{}
}

func NewConfigManager() *ConfigManager {
    return &ConfigManager{
        configs:  make(map[string]interface{}),
        watchers: make(map[string][]chan interface{}),
    }
}

func (cm *ConfigManager) Set(key string, value interface{}) {
    cm.mutex.Lock()
    cm.configs[key] = value
    cm.mutex.Unlock()
    
    // 通知监听者
    cm.notifyWatchers(key, value)
}

func (cm *ConfigManager) Get(key string) interface{} {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    return cm.configs[key]
}

func (cm *ConfigManager) Watch(key string) chan interface{} {
    ch := make(chan interface{}, 1)
    
    cm.mutex.Lock()
    cm.watchers[key] = append(cm.watchers[key], ch)
    cm.mutex.Unlock()
    
    return ch
}

func (cm *ConfigManager) notifyWatchers(key string, value interface{}) {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    if watchers, ok := cm.watchers[key]; ok {
        for _, ch := range watchers {
            select {
            case ch <- value:
            default:
            }
        }
    }
}

// 2. 熔断器
type CircuitBreaker struct {
    name          string
    state         CircuitState
    failureCount  int
    successCount  int
    lastFailure   time.Time
    failureThreshold int
    timeout       time.Duration
    mutex         sync.RWMutex
}

type CircuitState int

const (
    Closed CircuitState = iota
    Open
    HalfOpen
)

func NewCircuitBreaker(name string, failureThreshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        name:             name,
        state:            Closed,
        failureThreshold: failureThreshold,
        timeout:          timeout,
    }
}

func (cb *CircuitBreaker) AllowRequest(serviceName string) bool {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    
    switch cb.state {
    case Closed:
        return true
    case Open:
        if time.Since(cb.lastFailure) > cb.timeout {
            // 尝试半开状态
            cb.state = HalfOpen
            return true
        }
        return false
    case HalfOpen:
        return true
    }
    return true
}

func (cb *CircuitBreaker) RecordSuccess(serviceName string) {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    cb.successCount++
    if cb.state == HalfOpen && cb.successCount >= 2 {
        // 恢复正常状态
        cb.state = Closed
        cb.failureCount = 0
        cb.successCount = 0
    }
}

func (cb *CircuitBreaker) RecordFailure(serviceName string) {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    cb.failureCount++
    cb.lastFailure = time.Now()
    
    if cb.state == HalfOpen || cb.failureCount >= cb.failureThreshold {
        cb.state = Open
    }
}

// 3. 负载均衡
type LoadBalancer interface {
    Select(instances []ServiceInstance) ServiceInstance
}

type RoundRobinLoadBalancer struct {
    currentIndex int
    mutex        sync.Mutex
}

func (rr *RoundRobinLoadBalancer) Select(instances []ServiceInstance) ServiceInstance {
    if len(instances) == 0 {
        return ServiceInstance{}
    }
    
    rr.mutex.Lock()
    defer rr.mutex.Unlock()
    
    instance := instances[rr.currentIndex%len(instances)]
    rr.currentIndex++
    
    return instance
}

type RandomLoadBalancer struct{}

func (r *RandomLoadBalancer) Select(instances []ServiceInstance) ServiceInstance {
    if len(instances) == 0 {
        return ServiceInstance{}
    }
    
    index := rand.Intn(len(instances))
    return instances[index]
}

// 4. 服务实例
type ServiceInstance struct {
    ID       string
    Name     string
    Host     string
    Port     int
    Metadata map[string]string
    Status   ServiceStatus
}

type ServiceStatus string

const (
    StatusUp   ServiceStatus = "UP"
    StatusDown ServiceStatus = "DOWN"
    StatusOut  ServiceStatus = "OUT_OF_SERVICE"
)

// 5. 服务注册中心
type ServiceRegistry struct {
    services map[string][]ServiceInstance
    mutex    sync.RWMutex
}

func NewServiceRegistry() *ServiceRegistry {
    return &ServiceRegistry{
        services: make(map[string][]ServiceInstance),
    }
}

func (sr *ServiceRegistry) Register(instance ServiceInstance) {
    sr.mutex.Lock()
    defer sr.mutex.Unlock()
    
    sr.services[instance.Name] = append(sr.services[instance.Name], instance)
}

func (sr *ServiceRegistry) Deregister(instance ServiceInstance) {
    sr.mutex.Lock()
    defer sr.mutex.Unlock()
    
    if instances, ok := sr.services[instance.Name]; ok {
        for i, inst := range instances {
            if inst.ID == instance.ID {
                sr.services[instance.Name] = append(instances[:i], instances[i+1:]...)
                break
            }
        }
    }
}

func (sr *ServiceRegistry) Discover(serviceName string) []ServiceInstance {
    sr.mutex.RLock()
    defer sr.mutex.RUnlock()
    
    if instances, ok := sr.services[serviceName]; ok {
        // 只返回健康的服务实例
        var healthyInstances []ServiceInstance
        for _, instance := range instances {
            if instance.Status == StatusUp {
                healthyInstances = append(healthyInstances, instance)
            }
        }
        return healthyInstances
    }
    
    return []ServiceInstance{}
}
```

### 微服务挑战

```go
// 微服务挑战及解决方案

// 1. 分布式事务处理
type DistributedTransaction struct {
    ID          string
    Status      TransactionStatus
    Participants []TransactionParticipant
    mutex       sync.Mutex
}

type TransactionStatus string

const (
    StatusPending   TransactionStatus = "PENDING"
    StatusCommitted TransactionStatus = "COMMITTED"
    StatusRolledBack TransactionStatus = "ROLLED_BACK"
)

type TransactionParticipant struct {
    ServiceName string
    PrepareURL  string
    CommitURL   string
    RollbackURL string
}

func (dt *DistributedTransaction) Execute() error {
    dt.mutex.Lock()
    defer dt.mutex.Unlock()
    
    // 1. 准备阶段
    for _, participant := range dt.Participants {
        if err := dt.prepare(participant); err != nil {
            dt.rollback()
            return err
        }
    }
    
    // 2. 提交阶段
    for _, participant := range dt.Participants {
        if err := dt.commit(participant); err != nil {
            dt.rollback()
            return err
        }
    }
    
    dt.Status = StatusCommitted
    return nil
}

func (dt *DistributedTransaction) prepare(participant TransactionParticipant) error {
    // 调用参与者的prepare接口
    resp, err := http.Post(participant.PrepareURL, "application/json", nil)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("prepare failed for %s", participant.ServiceName)
    }
    
    return nil
}

func (dt *DistributedTransaction) commit(participant TransactionParticipant) error {
    // 调用参与者的commit接口
    resp, err := http.Post(participant.CommitURL, "application/json", nil)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("commit failed for %s", participant.ServiceName)
    }
    
    return nil
}

func (dt *DistributedTransaction) rollback() {
    // 回滚所有参与者
    for _, participant := range dt.Participants {
        http.Post(participant.RollbackURL, "application/json", nil)
        // 忽略错误，尽力而为
    }
    
    dt.Status = StatusRolledBack
}

// 2. 链路追踪
type Tracer struct {
    serviceName string
    traces      map[string]*Trace
    mutex       sync.RWMutex
}

type Trace struct {
    ID         string
    Spans      []*Span
    startTime  time.Time
    endTime    time.Time
}

type Span struct {
    ID        string
    ParentID  string
    Operation string
    StartTime time.Time
    EndTime   time.Time
    Tags      map[string]string
}

func NewTracer(serviceName string) *Tracer {
    return &Tracer{
        serviceName: serviceName,
        traces:      make(map[string]*Trace),
    }
}

func (t *Tracer) StartTrace(operation string) *Trace {
    traceID := generateTraceID()
    trace := &Trace{
        ID:        traceID,
        startTime: time.Now(),
    }
    
    t.mutex.Lock()
    t.traces[traceID] = trace
    t.mutex.Unlock()
    
    return trace
}

func (t *Tracer) StartSpan(trace *Trace, parentSpan *Span, operation string) *Span {
    spanID := generateSpanID()
    span := &Span{
        ID:        spanID,
        Operation: operation,
        StartTime: time.Now(),
        Tags:      make(map[string]string),
    }
    
    if parentSpan != nil {
        span.ParentID = parentSpan.ID
    }
    
    trace.Spans = append(trace.Spans, span)
    return span
}

func (t *Tracer) EndSpan(span *Span) {
    span.EndTime = time.Now()
}

func (t *Tracer) EndTrace(trace *Trace) {
    trace.endTime = time.Now()
    
    // 上报追踪数据
    t.reportTrace(trace)
}

func (t *Tracer) reportTrace(trace *Trace) {
    // 发送到追踪系统（如Jaeger、Zipkin）
    // 这里简化处理
    log.Printf("Trace %s completed, duration: %v", 
        trace.ID, trace.endTime.Sub(trace.startTime))
}

// 3. 监控和告警
type MetricsCollector struct {
    metrics map[string]*Metric
    mutex   sync.RWMutex
}

type Metric struct {
    Name      string
    Value     float64
    Timestamp time.Time
    Labels    map[string]string
}

type AlertRule struct {
    Name     string
    Metric   string
    Operator string
    Threshold float64
    Duration time.Duration
}

type AlertManager struct {
    rules    []AlertRule
    alerts   map[string]bool
    notifier Notifier
}

type Notifier interface {
    Notify(message string) error
}

func (mc *MetricsCollector) Record(name string, value float64, labels map[string]string) {
    mc.mutex.Lock()
    defer mc.mutex.Unlock()
    
    metric := &Metric{
        Name:      name,
        Value:     value,
        Timestamp: time.Now(),
        Labels:    labels,
    }
    
    mc.metrics[name] = metric
}

func (am *AlertManager) CheckAlerts(collector *MetricsCollector) {
    for _, rule := range am.rules {
        // 检查是否触发告警
        if am.shouldTriggerAlert(rule, collector) {
            if !am.alerts[rule.Name] {
                am.alerts[rule.Name] = true
                am.notifier.Notify(fmt.Sprintf("Alert triggered: %s", rule.Name))
            }
        } else {
            am.alerts[rule.Name] = false
        }
    }
}

func (am *AlertManager) shouldTriggerAlert(rule AlertRule, collector *MetricsCollector) bool {
    // 实现告警逻辑
    return false // 简化处理
}

// 4. 日志聚合
type LogAggregator struct {
    logs   []LogEntry
    mutex  sync.RWMutex
    writer io.Writer
}

type LogEntry struct {
    Timestamp time.Time
    Service   string
    Level     string
    Message   string
    TraceID   string
    SpanID    string
}

func (la *LogAggregator) Log(entry LogEntry) {
    la.mutex.Lock()
    defer la.mutex.Unlock()
    
    la.logs = append(la.logs, entry)
    
    // 写入到集中式日志系统
    if la.writer != nil {
        json.NewEncoder(la.writer).Encode(entry)
    }
}

// 5. 安全认证和授权
type AuthService struct {
    jwtSecret []byte
    users     map[string]UserAuth
}

type UserAuth struct {
    Username string
    Password string // 实际应用中应该是哈希值
    Roles    []string
}

type Claims struct {
    Username string   `json:"username"`
    Roles    []string `json:"roles"`
    jwt.StandardClaims
}

func (as *AuthService) GenerateToken(username string) (string, error) {
    user, exists := as.users[username]
    if !exists {
        return "", fmt.Errorf("user not found")
    }
    
    claims := Claims{
        Username: username,
        Roles:    user.Roles,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: time.Now().Add(time.Hour * 24).Unix(),
            Issuer:    "AuthService",
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(as.jwtSecret)
}

func (as *AuthService) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, 
        func(token *jwt.Token) (interface{}, error) {
            return as.jwtSecret, nil
        })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}

func (as *AuthService) Authorize(claims *Claims, requiredRole string) bool {
    for _, role := range claims.Roles {
        if role == requiredRole {
            return true
        }
    }
    return false
}
```

### 架构演进

```go
// 微服务架构演进示例

// 第一阶段：单体应用
type MonolithApplication struct {
    userModule    UserModule
    orderModule   OrderModule
    paymentModule PaymentModule
}

// 第二阶段：服务拆分
type UserService struct {
    repository UserRepository
}

type OrderService struct {
    repository OrderRepository
}

type PaymentService struct {
    repository PaymentRepository
}

// 第三阶段：引入服务网格
type ServiceMesh struct {
    proxy        *Proxy
    config       *MeshConfig
    observability *Observability
}

type Proxy struct {
    inboundListeners  []Listener
    outboundListeners []Listener
    clusters          []Cluster
}

type Listener struct {
    Port     int
    Protocol string
    Filters  []Filter
}

type Cluster struct {
    Name     string
    Endpoints []Endpoint
}

type Endpoint struct {
    Address string
    Port    int
    Weight  int
}

// 第四阶段：无服务器架构
type FunctionRuntime struct {
    functions map[string]Function
    trigger   Trigger
}

type Function struct {
    Name     string
    Handler  func(context.Context, interface{}) (interface{}, error)
    Runtime  string
    Memory   int
    Timeout  time.Duration
}

type Trigger struct {
    Type string
    Config map[string]interface{}
}

// 架构演进工具
type ArchitectureEvolution struct {
    currentPhase ArchitecturePhase
    migrationPlan MigrationPlan
}

type ArchitecturePhase string

const (
    PhaseMonolith    ArchitecturePhase = "MONOLITH"
    PhaseMicroservices ArchitecturePhase = "MICROSERVICES"
    PhaseServiceMesh ArchitecturePhase = "SERVICE_MESH"
    PhaseServerless  ArchitecturePhase = "SERVERLESS"
)

type MigrationPlan struct {
    Phases []MigrationPhase
    Timeline map[string]time.Time
    Risks    []MigrationRisk
}

type MigrationPhase struct {
    Name        string
    Description string
    Services    []string
    Dependencies []string
    EstimatedTime time.Duration
}

type MigrationRisk struct {
    Name        string
    Probability float64
    Impact      float64
    Mitigation  string
}

func (ae *ArchitectureEvolution) PlanMigration() *MigrationPlan {
    plan := &MigrationPlan{
        Phases: []MigrationPhase{
            {
                Name:        "Service Identification",
                Description: "Identify and define service boundaries",
                Services:    []string{"user-service", "order-service", "payment-service"},
                Dependencies: []string{},
                EstimatedTime: 2 * time.Week,
            },
            {
                Name:        "Database Separation",
                Description: "Separate databases for each service",
                Services:    []string{"user-db", "order-db", "payment-db"},
                Dependencies: []string{"Service Identification"},
                EstimatedTime: 3 * time.Week,
            },
            {
                Name:        "API Gateway Implementation",
                Description: "Implement API gateway for service orchestration",
                Services:    []string{"api-gateway"},
                Dependencies: []string{"Service Identification"},
                EstimatedTime: 2 * time.Week,
            },
        },
        Timeline: make(map[string]time.Time),
        Risks: []MigrationRisk{
            {
                Name:        "Data Consistency",
                Probability: 0.7,
                Impact:      0.8,
                Mitigation:  "Implement eventual consistency patterns",
            },
            {
                Name:        "Network Latency",
                Probability: 0.6,
                Impact:      0.6,
                Mitigation:  "Implement caching and circuit breaker patterns",
            },
        },
    }
    
    return plan
}

// 演进监控
type EvolutionMetrics struct {
    ServicesCount     int
    CommunicationLatency time.Duration
    ErrorRate         float64
    DeploymentFrequency int
    MeanTimeToRecovery time.Duration
}

func (em *EvolutionMetrics) CollectMetrics() *EvolutionMetrics {
    // 收集演进过程中的指标
    return em
}

// 演进回滚机制
type RollbackManager struct {
    snapshots map[string]ArchitectureSnapshot
    currentVersion string
}

type ArchitectureSnapshot struct {
    Version     string
    Services    []ServiceConfig
    Databases   []DatabaseConfig
    Networks    []NetworkConfig
    Timestamp   time.Time
}

func (rm *RollbackManager) CreateSnapshot(version string) error {
    snapshot := ArchitectureSnapshot{
        Version:   version,
        Timestamp: time.Now(),
        // 保存当前架构状态
    }
    
    rm.snapshots[version] = snapshot
    rm.currentVersion = version
    
    return nil
}

func (rm *RollbackManager) RollbackTo(version string) error {
    snapshot, exists := rm.snapshots[version]
    if !exists {
        return fmt.Errorf("snapshot not found: %s", version)
    }
    
    // 恢复到指定版本的架构状态
    // 实际实现需要根据具体架构进行恢复
    
    rm.currentVersion = version
    return nil
}
```