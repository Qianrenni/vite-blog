## 13.3 系统优化

### GC调优

#### Go垃圾回收器原理

Go的垃圾回收器采用三色标记-清除算法，具有并发执行、增量执行的特点。从Go 1.8开始，GC暂停时间目标为100微秒。

#### GC调优参数

```go
package main

import (
    "runtime"
    "runtime/debug"
)

func main() {
    // 设置GC目标百分比（默认100）
    // 表示GC花费的时间不超过程序执行时间的100%
    debug.SetGCPercent(50) // 更激进的GC
    
    // 或者禁用GC（谨慎使用）
    // debug.SetGCPercent(-1)
    
    // 手动触发GC
    runtime.GC()
    
    // 获取GC统计信息
    var stats debug.GCStats
    debug.ReadGCStats(&stats)
    println("Last GC:", stats.LastGC)
    println("Num GC:", stats.NumGC)
}
```

#### 内存分配优化

```go
package main

import (
    "runtime"
    "unsafe"
)

// 优化前：频繁分配小对象
func badAllocation() {
    for i := 0; i < 1000000; i++ {
        slice := make([]int, 1)  // 每次都分配新内存
        slice[0] = i
        _ = slice
    }
}

// 优化后：预分配和重用
func goodAllocation() {
    const batchSize = 1000
    slice := make([]int, batchSize)
    
    for i := 0; i < 1000000; i++ {
        if i%batchSize == 0 {
            slice = make([]int, batchSize)  // 批量分配
        }
        slice[i%batchSize] = i
    }
}

// 使用内存池
type Object struct {
    data [1024]byte
    id   int
}

var objectPool = make(chan *Object, 100)

func getObject() *Object {
    select {
    case obj := <-objectPool:
        return obj
    default:
        return &Object{}
    }
}

func putObject(obj *Object) {
    obj.id = 0  // 重置状态
    select {
    case objectPool <- obj:
    default:
        // 池满时丢弃
    }
}
```

#### 监控GC性能

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func monitorGC() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        fmt.Printf("=== GC Stats ===\n")
        fmt.Printf("Alloc: %d KB\n", m.Alloc/1024)
        fmt.Printf("TotalAlloc: %d KB\n", m.TotalAlloc/1024)
        fmt.Printf("Sys: %d KB\n", m.Sys/1024)
        fmt.Printf("NumGC: %d\n", m.NumGC)
        fmt.Printf("GCCPUFraction: %.2f%%\n", m.GCCPUFraction*100)
        fmt.Printf("PauseTotalNs: %d ms\n", m.PauseTotalNs/1000000)
        fmt.Println()
    }
}

func main() {
    go monitorGC()
    
    // 模拟内存密集型操作
    for i := 0; i < 1000000; i++ {
        data := make([]byte, 1024)
        _ = len(data)
        if i%10000 == 0 {
            time.Sleep(10 * time.Millisecond)
        }
    }
}
```

### 连接池优化

#### 数据库连接池优化

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
)

func configureConnectionPool(db *sql.DB) {
    // 设置最大打开连接数
    db.SetMaxOpenConns(25)
    
    // 设置最大空闲连接数
    db.SetMaxIdleConns(25)
    
    // 设置连接最大生存时间
    db.SetConnMaxLifetime(5 * time.Minute)
    
    // 设置空闲连接最大生存时间
    db.SetConnMaxIdleTime(5 * time.Minute)
}

func main() {
    // 连接数据库
    db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/dbname")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    configureConnectionPool(db)
    
    // 测试连接
    if err := db.Ping(); err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("Connection pool configured successfully")
}
```

#### HTTP客户端连接池

```go
package main

import (
    "context"
    "fmt"
    "net"
    "net/http"
    "time"
)

func createOptimizedHTTPClient() *http.Client {
    transport := &http.Transport{
        // 连接池配置
        MaxIdleConns:          100,              // 最大空闲连接数
        MaxIdleConnsPerHost:   10,               // 每个主机最大空闲连接数
        MaxConnsPerHost:       100,              // 每个主机最大连接数
        IdleConnTimeout:       90 * time.Second, // 空闲连接超时时间
        TLSHandshakeTimeout:   10 * time.Second, // TLS握手超时
        ExpectContinueTimeout: 1 * time.Second,  // 期望继续超时
        
        // DNS解析优化
        DialContext: (&net.Dialer{
            Timeout:   30 * time.Second,
            KeepAlive: 30 * time.Second,
        }).DialContext,
        
        // 禁用压缩（如果不需要）
        // DisableCompression: true,
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second,
    }
}

func main() {
    client := createOptimizedHTTPClient()
    
    // 发送多个请求测试连接池
    for i := 0; i < 50; i++ {
        go func(id int) {
            req, _ := http.NewRequest("GET", "http://httpbin.org/get", nil)
            req = req.WithContext(context.Background())
            
            resp, err := client.Do(req)
            if err != nil {
                fmt.Printf("Request %d failed: %v\n", id, err)
                return
            }
            defer resp.Body.Close()
            
            fmt.Printf("Request %d completed\n", id)
        }(i)
    }
    
    time.Sleep(10 * time.Second)
}
```

#### 自定义连接池

```go
package main

import (
    "context"
    "sync"
    "time"
)

type Connection struct {
    id        int
    createdAt time.Time
    lastUsed  time.Time
}

type ConnectionPool struct {
    mu          sync.Mutex
    connections chan *Connection
    maxConns    int
    created     int
    timeout     time.Duration
}

func NewConnectionPool(maxConns int, timeout time.Duration) *ConnectionPool {
    return &ConnectionPool{
        connections: make(chan *Connection, maxConns),
        maxConns:    maxConns,
        timeout:     timeout,
    }
}

func (cp *ConnectionPool) Get(ctx context.Context) (*Connection, error) {
    select {
    case conn := <-cp.connections:
        conn.lastUsed = time.Now()
        return conn, nil
    default:
        cp.mu.Lock()
        if cp.created < cp.maxConns {
            cp.created++
            id := cp.created
            cp.mu.Unlock()
            return &Connection{
                id:        id,
                createdAt: time.Now(),
                lastUsed:  time.Now(),
            }, nil
        }
        cp.mu.Unlock()
        
        // 等待可用连接
        select {
        case conn := <-cp.connections:
            conn.lastUsed = time.Now()
            return conn, nil
        case <-ctx.Done():
            return nil, ctx.Err()
        case <-time.After(cp.timeout):
            return nil, fmt.Errorf("connection timeout")
        }
    }
}

func (cp *ConnectionPool) Put(conn *Connection) {
    if conn == nil {
        return
    }
    
    select {
    case cp.connections <- conn:
    default:
        // 连接池已满，丢弃连接
    }
}

func (cp *ConnectionPool) Close() {
    close(cp.connections)
    for conn := range cp.connections {
        // 关闭连接
        fmt.Printf("Closing connection %d\n", conn.id)
    }
}
```

### 缓存优化

#### LRU缓存实现

```go
package main

import (
    "container/list"
    "fmt"
    "sync"
    "time"
)

type CacheItem struct {
    key       string
    value     interface{}
    expireAt  time.Time
    element   *list.Element
}

type LRUCache struct {
    mu        sync.RWMutex
    capacity  int
    items     map[string]*CacheItem
    evictList *list.List
    ttl       time.Duration
}

func NewLRUCache(capacity int, ttl time.Duration) *LRUCache {
    return &LRUCache{
        capacity:  capacity,
        items:     make(map[string]*CacheItem),
        evictList: list.New(),
        ttl:       ttl,
    }
}

func (c *LRUCache) Get(key string) (interface{}, bool) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if item, exists := c.items[key]; exists {
        // 检查是否过期
        if !item.expireAt.IsZero() && time.Now().After(item.expireAt) {
            c.removeElement(item.element)
            return nil, false
        }
        
        // 移动到列表前端（最近使用）
        c.evictList.MoveToFront(item.element)
        return item.value, true
    }
    
    return nil, false
}

func (c *LRUCache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    if item, exists := c.items[key]; exists {
        // 更新现有项
        item.value = value
        item.expireAt = time.Now().Add(c.ttl)
        c.evictList.MoveToFront(item.element)
        return
    }
    
    // 添加新项
    item := &CacheItem{
        key:      key,
        value:    value,
        expireAt: time.Now().Add(c.ttl),
    }
    
    item.element = c.evictList.PushFront(item)
    c.items[key] = item
    
    // 检查容量限制
    if c.evictList.Len() > c.capacity {
        c.removeOldest()
    }
}

func (c *LRUCache) removeOldest() {
    if element := c.evictList.Back(); element != nil {
        c.removeElement(element)
    }
}

func (c *LRUCache) removeElement(element *list.Element) {
    c.evictList.Remove(element)
    item := element.Value.(*CacheItem)
    delete(c.items, item.key)
}

func (c *LRUCache) Len() int {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.evictList.Len()
}

func (c *LRUCache) Clear() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.items = make(map[string]*CacheItem)
    c.evictList.Init()
}
```

#### 分布式缓存优化

```go
package main

import (
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type CacheManager struct {
    redisClient *redis.Client
    localCache  *LRUCache
}

func NewCacheManager(redisAddr string) *CacheManager {
    rdb := redis.NewClient(&redis.Options{
        Addr:     redisAddr,
        PoolSize: 100,
    })
    
    return &CacheManager{
        redisClient: rdb,
        localCache:  NewLRUCache(1000, 5*time.Minute),
    }
}

func (cm *CacheManager) Get(key string, dest interface{}) error {
    // 先查本地缓存
    if value, ok := cm.localCache.Get(key); ok {
        return json.Unmarshal(value.([]byte), dest)
    }
    
    // 查Redis缓存
    ctx := context.Background()
    val, err := cm.redisClient.Get(ctx, key).Result()
    if err == redis.Nil {
        return fmt.Errorf("key not found")
    } else if err != nil {
        return err
    }
    
    // 反序列化
    if err := json.Unmarshal([]byte(val), dest); err != nil {
        return err
    }
    
    // 存入本地缓存
    cm.localCache.Set(key, []byte(val))
    
    return nil
}

func (cm *CacheManager) Set(key string, value interface{}, expiration time.Duration) error {
    // 序列化
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    // 存入Redis
    ctx := context.Background()
    if err := cm.redisClient.Set(ctx, key, data, expiration).Err(); err != nil {
        return err
    }
    
    // 存入本地缓存
    cm.localCache.Set(key, data)
    
    return nil
}
```

### 数据库优化

#### 查询优化

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

// 优化前：N+1查询问题
func getUsersBad(db *sql.DB) ([]User, error) {
    rows, err := db.Query("SELECT id FROM users LIMIT 100")
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []User
    for rows.Next() {
        var id int
        if err := rows.Scan(&id); err != nil {
            return nil, err
        }
        
        // N+1查询：每次循环都执行一次查询
        var user User
        err := db.QueryRow("SELECT id, name, email, age FROM users WHERE id = ?", id).
            Scan(&user.ID, &user.Name, &user.Email, &user.Age)
        if err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, nil
}

// 优化后：单次查询
func getUsersGood(db *sql.DB) ([]User, error) {
    rows, err := db.Query("SELECT id, name, email, age FROM users LIMIT 100")
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []User
    for rows.Next() {
        var user User
        if err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.Age); err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, nil
}

// 批量插入优化
func batchInsertUsers(db *sql.DB, users []User) error {
    // 使用事务
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 预编译语句
    stmt, err := tx.Prepare("INSERT INTO users (name, email, age) VALUES (?, ?, ?)")
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    // 批量插入
    for _, user := range users {
        if _, err := stmt.Exec(user.Name, user.Email, user.Age); err != nil {
            return err
        }
    }
    
    return tx.Commit()
}
```

#### 数据库索引优化

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
)

// 创建索引
func createIndexes(db *sql.DB) error {
    queries := []string{
        // 为常用查询字段创建索引
        "CREATE INDEX idx_users_email ON users(email)",
        "CREATE INDEX idx_users_age ON users(age)",
        "CREATE INDEX idx_users_created_at ON users(created_at)",
        
        // 复合索引
        "CREATE INDEX idx_users_age_email ON users(age, email)",
    }
    
    for _, query := range queries {
        if _, err := db.Exec(query); err != nil {
            log.Printf("Failed to create index: %v", err)
        }
    }
    
    return nil
}

// 使用索引的查询示例
func optimizedQueries(db *sql.DB) {
    // 使用索引的查询
    queries := map[string]string{
        "by_email":      "SELECT * FROM users WHERE email = ?",
        "by_age_range":  "SELECT * FROM users WHERE age BETWEEN ? AND ?",
        "by_created_at": "SELECT * FROM users WHERE created_at >= ? ORDER BY created_at DESC",
        "composite":     "SELECT * FROM users WHERE age = ? AND email LIKE ?",
    }
    
    for name, query := range queries {
        start := time.Now()
        rows, err := db.Query(query, "test@example.com", 18, 65, time.Now().AddDate(0, -1, 0), 25, "%gmail%")
        if err != nil {
            log.Printf("Query %s failed: %v", name, err)
            continue
        }
        rows.Close()
        
        fmt.Printf("Query %s took: %v\n", name, time.Since(start))
    }
}
```

### 网络优化

#### TCP连接优化

```go
package main

import (
    "context"
    "fmt"
    "net"
    "time"
)

func createOptimizedTCPClient() {
    dialer := &net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
        DualStack: true, // 同时使用IPv4和IPv6
    }
    
    conn, err := dialer.Dial("tcp", "example.com:80")
    if err != nil {
        fmt.Printf("Dial failed: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Println("Connected successfully")
}

func createTCPServer() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        fmt.Printf("Listen failed: %v\n", err)
        return
    }
    defer listener.Close()
    
    // 设置TCP选项
    if tcpListener, ok := listener.(*net.TCPListener); ok {
        // 可以设置更多TCP选项
        _ = tcpListener
    }
    
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Printf("Accept failed: %v\n", err)
            continue
        }
        
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    
    // 设置读写超时
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    conn.SetWriteDeadline(time.Now().Add(30 * time.Second))
    
    // 处理连接
    buffer := make([]byte, 1024)
    for {
        n, err := conn.Read(buffer)
        if err != nil {
            break
        }
        
        // 回显
        conn.Write(buffer[:n])
    }
}
```

#### HTTP服务器优化

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

func createOptimizedHTTPServer() *http.Server {
    mux := http.NewServeMux()
    
    // 注册处理函数
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    })
    
    server := &http.Server{
        Addr:         ":8080",
        Handler:      mux,
        ReadTimeout:  5 * time.Second,  // 读取超时
        WriteTimeout: 10 * time.Second, // 写入超时
        IdleTimeout:  60 * time.Second, // 空闲连接超时
        
        // 最大请求头大小
        MaxHeaderBytes: 1 << 20, // 1MB
        
        // 连接状态回调
        ConnState: func(conn net.Conn, state http.ConnState) {
            // 可以在这里监控连接状态
        },
    }
    
    return server
}

// 中间件优化
func timeoutMiddleware(next http.Handler) http.Handler {
    return http.TimeoutHandler(next, 30*time.Second, "Request timeout")
}

func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        fmt.Printf("%s %s %v\n", r.Method, r.URL.Path, time.Since(start))
    })
}
```

### 系统资源监控

#### 内存监控

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

type MemoryMonitor struct {
    ticker *time.Ticker
    stop   chan struct{}
}

func NewMemoryMonitor(interval time.Duration) *MemoryMonitor {
    return &MemoryMonitor{
        ticker: time.NewTicker(interval),
        stop:   make(chan struct{}),
    }
}

func (mm *MemoryMonitor) Start() {
    go func() {
        for {
            select {
            case <-mm.ticker.C:
                mm.printMemoryStats()
            case <-mm.stop:
                return
            }
        }
    }()
}

func (mm *MemoryMonitor) Stop() {
    mm.ticker.Stop()
    close(mm.stop)
}

func (mm *MemoryMonitor) printMemoryStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    fmt.Printf("=== Memory Stats ===\n")
    fmt.Printf("Alloc: %d MB\n", m.Alloc/1024/1024)
    fmt.Printf("TotalAlloc: %d MB\n", m.TotalAlloc/1024/1024)
    fmt.Printf("Sys: %d MB\n", m.Sys/1024/1024)
    fmt.Printf("NumGC: %d\n", m.NumGC)
    fmt.Printf("GCCPUFraction: %.2f%%\n", m.GCCPUFraction*100)
    fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
    fmt.Printf("Threads: %d\n", runtime.GOMAXPROCS(0))
    fmt.Println()
}

func main() {
    monitor := NewMemoryMonitor(5 * time.Second)
    monitor.Start()
    defer monitor.Stop()
    
    // 模拟内存使用
    for i := 0; i < 1000000; i++ {
        data := make([]byte, 1024)
        _ = len(data)
        if i%100000 == 0 {
            time.Sleep(100 * time.Millisecond)
        }
    }
}
```

#### CPU监控

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

type CPUMonitor struct {
    ticker *time.Ticker
    stop   chan struct{}
    last   runtime.MemStats
}

func NewCPUMonitor(interval time.Duration) *CPUMonitor {
    cm := &CPUMonitor{
        ticker: time.NewTicker(interval),
        stop:   make(chan struct{}),
    }
    runtime.ReadMemStats(&cm.last)
    return cm
}

func (cm *CPUMonitor) Start() {
    go func() {
        for {
            select {
            case <-cm.ticker.C:
                cm.printCPUStats()
            case <-cm.stop:
                return
            }
        }
    }()
}

func (cm *CPUMonitor) Stop() {
    cm.ticker.Stop()
    close(cm.stop)
}

func (cm *CPUMonitor) printCPUStats() {
    var current runtime.MemStats
    runtime.ReadMemStats(&current)
    
    // 计算CPU使用率
    duration := current.PauseTotalNs - cm.last.PauseTotalNs
    fmt.Printf("=== CPU Stats ===\n")
    fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("GC Pause Time: %d ms\n", duration/1000000)
    fmt.Println()
    
    cm.last = current
}
```

#### 综合监控系统

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "_http/pprof"
    "runtime"
    "sync"
    "time"
)

type SystemMonitor struct {
    mu       sync.RWMutex
    stats    SystemStats
    ticker   *time.Ticker
    stopChan chan struct{}
}

type SystemStats struct {
    Memory    MemoryStats
    CPU       CPUStats
    Goroutine int
    Thread    int
}

type MemoryStats struct {
    Alloc      uint64
    TotalAlloc uint64
    Sys        uint64
    NumGC      uint32
}

type CPUStats struct {
    GOMAXPROCS int
    NumCPU     int
}

func NewSystemMonitor() *SystemMonitor {
    return &SystemMonitor{
        stopChan: make(chan struct{}),
        stats:    SystemStats{},
    }
}

func (sm *SystemMonitor) Start(ctx context.Context) {
    sm.ticker = time.NewTicker(10 * time.Second)
    
    go func() {
        defer sm.ticker.Stop()
        
        for {
            select {
            case <-sm.ticker.C:
                sm.collectStats()
            case <-ctx.Done():
                return
            case <-sm.stopChan:
                return
            }
        }
    }()
}

func (sm *SystemMonitor) collectStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    sm.mu.Lock()
    sm.stats = SystemStats{
        Memory: MemoryStats{
            Alloc:      m.Alloc,
            TotalAlloc: m.TotalAlloc,
            Sys:        m.Sys,
            NumGC:      m.NumGC,
        },
        CPU: CPUStats{
            GOMAXPROCS: runtime.GOMAXPROCS(0),
            NumCPU:     runtime.NumCPU(),
        },
        Goroutine: runtime.NumGoroutine(),
        Thread:    0, // runtime.NumThread() in newer Go versions
    }
    sm.mu.Unlock()
}

func (sm *SystemMonitor) GetStats() SystemStats {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    return sm.stats
}

func (sm *SystemMonitor) Stop() {
    close(sm.stopChan)
}

// HTTP监控端点
func setupMonitoringEndpoints() {
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "OK")
    })
    
    http.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        fmt.Fprintf(w, "goroutines: %d\n", runtime.NumGoroutine())
        fmt.Fprintf(w, "alloc: %d MB\n", m.Alloc/1024/1024)
        fmt.Fprintf(w, "sys: %d MB\n", m.Sys/1024/1024)
        fmt.Fprintf(w, "num_gc: %d\n", m.NumGC)
    })
    
    // 启动监控服务器
    go func() {
        fmt.Println("Monitoring server starting on :8081")
        if err := http.ListenAndServe(":8081", nil); err != nil {
            fmt.Printf("Monitoring server error: %v\n", err)
        }
    }()
}

func main() {
    // 设置监控端点
    setupMonitoringEndpoints()
    
    // 启动系统监控
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    monitor := NewSystemMonitor()
    monitor.Start(ctx)
    defer monitor.Stop()
    
    // 模拟应用运行
    fmt.Println("Application started. Monitoring at http://localhost:8081")
    
    for i := 0; i < 1000000; i++ {
        go func(n int) {
            data := make([]byte, 1024)
            _ = len(data)
        }(i)
        
        if i%10000 == 0 {
            time.Sleep(10 * time.Millisecond)
        }
    }
    
    time.Sleep(60 * time.Second)
}
```