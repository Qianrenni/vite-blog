## 5.3 同步机制

### sync包详解

#### Mutex互斥锁

```go
import (
    "fmt"
    "sync"
    "time"
)

type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func demonstrateMutex() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    // 多个Goroutine同时访问
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Println("Final counter value:", counter.Value()) // 应该是1000
}
```

#### RWMutex读写锁

```go
import (
    "fmt"
    "sync"
    "time"
)

type SafeMap struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]int),
    }
}

func (sm *SafeMap) Write(key string, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.data[key] = value
}

func (sm *SafeMap) Read(key string) (int, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    value, ok := sm.data[key]
    return value, ok
}

func demonstrateRWMutex() {
    safeMap := NewSafeMap()
    var wg sync.WaitGroup
    
    // 写操作
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            safeMap.Write(fmt.Sprintf("key%d", id), id*10)
        }(i)
    }
    
    // 读操作（可以并发执行）
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            if value, ok := safeMap.Read("key5"); ok {
                _ = value // 使用值
            }
        }()
    }
    
    wg.Wait()
    fmt.Println("Map operations completed")
}
```

#### WaitGroup

```go
import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // 完成时调用
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Duration(id) * time.Second)
    fmt.Printf("Worker %d completed\n", id)
}

func demonstrateWaitGroup() {
    var wg sync.WaitGroup
    
    // 启动多个worker
    for i := 1; i <= 5; i++ {
        wg.Add(1) // 增加计数
        go worker(i, &wg)
    }
    
    fmt.Println("Waiting for workers to complete...")
    wg.Wait() // 等待所有worker完成
    fmt.Println("All workers completed")
}
```

#### Once

```go
import (
    "fmt"
    "sync"
    "time"
)

type Database struct {
    connectionString string
}

var (
    db   *Database
    once sync.Once
)

func GetDatabase() *Database {
    once.Do(func() {
        fmt.Println("Initializing database connection...")
        time.Sleep(2 * time.Second) // 模拟初始化时间
        db = &Database{connectionString: "localhost:5432"}
        fmt.Println("Database initialized")
    })
    return db
}

func demonstrateOnce() {
    var wg sync.WaitGroup
    
    // 多个Goroutine同时请求数据库实例
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            db := GetDatabase()
            fmt.Printf("Goroutine %d got database: %p\n", id, db)
        }(i)
    }
    
    wg.Wait()
}
```

#### Cond条件变量

```go
import (
    "fmt"
    "sync"
    "time"
)

func demonstrateCond() {
    var mu sync.Mutex
    cond := sync.NewCond(&mu)
    queue := make([]string, 0)
    
    // 生产者
    go func() {
        for i := 1; i <= 5; i++ {
            mu.Lock()
            queue = append(queue, fmt.Sprintf("item-%d", i))
            fmt.Printf("Produced: item-%d\n", i)
            cond.Signal() // 通知等待的消费者
            mu.Unlock()
            time.Sleep(1 * time.Second)
        }
    }()
    
    // 消费者
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for {
                mu.Lock()
                for len(queue) == 0 {
                    fmt.Printf("Consumer %d waiting...\n", id)
                    cond.Wait() // 等待生产者通知
                }
                
                if len(queue) > 0 {
                    item := queue[0]
                    queue = queue[1:]
                    fmt.Printf("Consumer %d consumed: %s\n", id, item)
                }
                mu.Unlock()
                
                time.Sleep(500 * time.Millisecond)
            }
        }(i)
    }
    
    time.Sleep(10 * time.Second)
    wg.Wait()
}
```

#### Pool对象池

```go
import (
    "bytes"
    "fmt"
    "sync"
)

var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func processWithPool(data string) string {
    // 从池中获取对象
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()           // 清空缓冲区
        bufferPool.Put(buf)   // 归还到池中
    }()
    
    buf.WriteString("Processed: ")
    buf.WriteString(data)
    return buf.String()
}

func demonstratePool() {
    var wg sync.WaitGroup
    
    // 并发处理大量数据
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            result := processWithPool(fmt.Sprintf("data-%d", id))
            _ = result // 使用结果
        }(i)
    }
    
    wg.Wait()
    fmt.Println("Pool demonstration completed")
}
```

#### Map并发安全映射

```go
import (
    "fmt"
    "sync"
)

func demonstrateSyncMap() {
    var sm sync.Map
    
    var wg sync.WaitGroup
    
    // 并发写入
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            sm.Store(fmt.Sprintf("key%d", id), id*2)
        }(i)
    }
    
    wg.Wait()
    
    // 并发读取
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            if value, ok := sm.Load(fmt.Sprintf("key%d", id)); ok {
                fmt.Printf("key%d: %v\n", id, value)
            }
        }(i)
    }
    
    wg.Wait()
    
    // 遍历所有键值对
    fmt.Println("All key-value pairs:")
    sm.Range(func(key, value interface{}) bool {
        fmt.Printf("%v: %v\n", key, value)
        return true // 继续遍历
    })
}
```

### 原子操作（atomic包）

```go
import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

func demonstrateAtomic() {
    var counter int64
    var wg sync.WaitGroup
    
    // 使用原子操作的计数器
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    
    wg.Wait()
    fmt.Println("Atomic counter:", atomic.LoadInt64(&counter))
    
    // 原子布尔值
    var flag int32
    fmt.Println("Initial flag:", atomic.LoadInt32(&flag))
    
    atomic.StoreInt32(&flag, 1)
    fmt.Println("Set flag:", atomic.LoadInt32(&flag))
    
    // 原子比较并交换
    swapped := atomic.CompareAndSwapInt32(&flag, 1, 0)
    fmt.Println("CAS swapped:", swapped)
    fmt.Println("Final flag:", atomic.LoadInt32(&flag))
}
```

### 互斥锁vs读写锁

```go
import (
    "fmt"
    "sync"
    "time"
)

type MutexCounter struct {
    mu    sync.Mutex
    value int64
}

func (mc *MutexCounter) Increment() {
    mc.mu.Lock()
    defer mc.mu.Unlock()
    mc.value++
}

func (mc *MutexCounter) GetValue() int64 {
    mc.mu.Lock()
    defer mc.mu.Unlock()
    return mc.value
}

type RWMutexCounter struct {
    mu    sync.RWMutex
    value int64
}

func (rc *RWMutexCounter) Increment() {
    rc.mu.Lock()
    defer rc.mu.Unlock()
    rc.value++
}

func (rc *RWMutexCounter) GetValue() int64 {
    rc.mu.RLock()
    defer rc.mu.RUnlock()
    return rc.value
}

func benchmarkLocks() {
    const numOperations = 100000
    
    // 测试互斥锁
    mutexCounter := &MutexCounter{}
    start := time.Now()
    
    var wg sync.WaitGroup
    for i := 0; i < numOperations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mutexCounter.Increment()
        }()
    }
    wg.Wait()
    
    mutexTime := time.Since(start)
    fmt.Printf("Mutex time: %v, Value: %d\n", mutexTime, mutexCounter.GetValue())
    
    // 测试读写锁
    rwMutexCounter := &RWMutexCounter{}
    start = time.Now()
    
    var wg2 sync.WaitGroup
    for i := 0; i < numOperations; i++ {
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            rwMutexCounter.Increment()
        }()
    }
    wg2.Wait()
    
    rwMutexTime := time.Since(start)
    fmt.Printf("RWMutex time: %v, Value: %d\n", rwMutexTime, rwMutexCounter.GetValue())
}
```

### 死锁预防

```go
import (
    "fmt"
    "sync"
    "time"
)

// 错误的死锁示例
func deadlockExample() {
    var mu1, mu2 sync.Mutex
    
    go func() {
        mu1.Lock()
        fmt.Println("Goroutine 1: Locked mu1")
        time.Sleep(100 * time.Millisecond)
        
        mu2.Lock() // 可能导致死锁
        fmt.Println("Goroutine 1: Locked mu2")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        mu2.Lock()
        fmt.Println("Goroutine 2: Locked mu2")
        time.Sleep(100 * time.Millisecond)
        
        mu1.Lock() // 可能导致死锁
        fmt.Println("Goroutine 2: Locked mu1")
        mu1.Unlock()
        mu2.Unlock()
    }()
    
    time.Sleep(time.Second)
}

// 正确的死锁预防 - 统一加锁顺序
func noDeadlockExample() {
    var mu1, mu2 sync.Mutex
    
    lockInOrder := func(first, second *sync.Mutex) {
        first.Lock()
        second.Lock()
    }
    
    unlockInOrder := func(first, second *sync.Mutex) {
        second.Unlock()
        first.Unlock()
    }
    
    go func() {
        lockInOrder(&mu1, &mu2)
        fmt.Println("Goroutine 1: Locked both mutexes")
        time.Sleep(100 * time.Millisecond)
        unlockInOrder(&mu1, &mu2)
        fmt.Println("Goroutine 1: Unlocked both mutexes")
    }()
    
    go func() {
        lockInOrder(&mu1, &mu2) // 使用相同的顺序
        fmt.Println("Goroutine 2: Locked both mutexes")
        time.Sleep(100 * time.Millisecond)
        unlockInOrder(&mu1, &mu2)
        fmt.Println("Goroutine 2: Unlocked both mutexes")
    }()
    
    time.Sleep(time.Second)
}

// 使用超时避免死锁
func timeoutExample() {
    var mu sync.Mutex
    
    // 模拟可能的死锁情况
    done := make(chan bool, 1)
    
    go func() {
        mu.Lock()
        fmt.Println("Goroutine: Acquired lock")
        time.Sleep(2 * time.Second) // 模拟长时间操作
        mu.Unlock()
        done <- true
    }()
    
    // 主Goroutine尝试获取锁，但设置超时
    go func() {
        timer := time.NewTimer(1 * time.Second)
        defer timer.Stop()
        
        select {
        case <-timer.C:
            fmt.Println("Timeout: Could not acquire lock")
        case done <- func() bool {
            mu.Lock()
            defer mu.Unlock()
            fmt.Println("Main: Acquired lock")
            return true
        }():
            fmt.Println("Main: Successfully acquired lock")
        }
    }()
    
    <-done
    time.Sleep(100 * time.Millisecond)
}
```