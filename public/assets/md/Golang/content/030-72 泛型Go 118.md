## 7.2 泛型（Go 1.18+）

### 泛型基本语法

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 基本泛型函数
func BasicGenericFunction[T any](value T) T {
    return value
}

// 带约束的泛型函数
func ConstrainedGenericFunction[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

// 多类型参数的泛型函数
func MultiTypeGenericFunction[T, U any](t T, u U) (T, U) {
    return t, u
}

func demonstrateBasicSyntax() {
    fmt.Println("=== 泛型基本语法 ===")
    
    // 使用基本泛型函数
    fmt.Printf("BasicGenericFunction(42): %v\n", BasicGenericFunction(42))
    fmt.Printf("BasicGenericFunction(\"hello\"): %v\n", BasicGenericFunction("hello"))
    fmt.Printf("BasicGenericFunction(true): %v\n", BasicGenericFunction(true))
    
    // 使用带约束的泛型函数
    fmt.Printf("ConstrainedGenericFunction(5, 3): %v\n", ConstrainedGenericFunction(5, 3))
    fmt.Printf("ConstrainedGenericFunction(3.14, 2.71): %v\n", ConstrainedGenericFunction(3.14, 2.71))
    fmt.Printf("ConstrainedGenericFunction(\"hello\", \"world\"): %v\n", ConstrainedGenericFunction("hello", "world"))
    
    // 使用多类型参数的泛型函数
    t, u := MultiTypeGenericFunction(42, "hello")
    fmt.Printf("MultiTypeGenericFunction(42, \"hello\"): %v, %v\n", t, u)
    
    t2, u2 := MultiTypeGenericFunction("world", 3.14)
    fmt.Printf("MultiTypeGenericFunction(\"world\", 3.14): %v, %v\n", t2, u2)
}

// 泛型结构体
type GenericStruct[T any] struct {
    Value T
    Count int
}

// 泛型结构体方法
func (g *GenericStruct[T]) SetValue(value T) {
    g.Value = value
}

func (g *GenericStruct[T]) GetValue() T {
    return g.Value
}

func (g *GenericStruct[T]) IncrementCount() {
    g.Count++
}

// 带约束的泛型结构体
type NumberStruct[T constraints.Number] struct {
    Value T
    Sum   T
}

func (n *NumberStruct[T]) Add(value T) {
    n.Sum += value
}

func (n *NumberStruct[T]) GetAverage(count int) float64 {
    if count == 0 {
        return 0
    }
    return float64(n.Sum) / float64(count)
}

func demonstrateGenericStructs() {
    fmt.Println("\n=== 泛型结构体 ===")
    
    // 使用泛型结构体
    stringStruct := &GenericStruct[string]{Value: "hello", Count: 1}
    fmt.Printf("String struct: %+v\n", stringStruct)
    
    intStruct := &GenericStruct[int]{Value: 42, Count: 1}
    fmt.Printf("Int struct: %+v\n", intStruct)
    
    // 调用方法
    stringStruct.SetValue("world")
    stringStruct.IncrementCount()
    fmt.Printf("Modified string struct: %+v, Value: %v\n", 
        stringStruct, stringStruct.GetValue())
    
    // 使用带约束的泛型结构体
    numberStruct := &NumberStruct[float64]{Value: 3.14, Sum: 0}
    numberStruct.Add(1.0)
    numberStruct.Add(2.0)
    numberStruct.Add(3.0)
    fmt.Printf("Number struct sum: %v, average: %v\n", 
        numberStruct.Sum, numberStruct.GetAverage(3))
}

// 泛型接口
type GenericInterface[T any] interface {
    Process(T) T
    Get() T
}

// 实现泛型接口
type StringProcessor struct {
    value string
}

func (s *StringProcessor) Process(input string) string {
    return s.value + " " + input
}

func (s *StringProcessor) Get() string {
    return s.value
}

type IntProcessor struct {
    value int
}

func (i *IntProcessor) Process(input int) int {
    return i.value + input
}

func (i *IntProcessor) Get() int {
    return i.value
}

// 泛型接口的泛型实现
type GenericProcessor[T any] struct {
    value T
}

func (g *GenericProcessor[T]) Process(input T) T {
    // 这里需要约束来支持操作
    return input // 简化实现
}

func (g *GenericProcessor[T]) Get() T {
    return g.value
}

func demonstrateGenericInterfaces() {
    fmt.Println("\n=== 泛型接口 ===")
    
    // 使用具体类型实现
    stringProc := &StringProcessor{value: "Hello"}
    fmt.Printf("String processor result: %v\n", stringProc.Process("World"))
    
    intProc := &IntProcessor{value: 42}
    fmt.Printf("Int processor result: %v\n", intProc.Process(8))
    
    // 使用泛型实现
    genericStringProc := &GenericProcessor[string]{value: "Generic Hello"}
    fmt.Printf("Generic string processor: %v\n", genericStringProc.Get())
    
    genericIntProc := &GenericProcessor[int]{value: 100}
    fmt.Printf("Generic int processor: %v\n", genericIntProc.Get())
}

// 泛型方法
type Container[T any] struct {
    items []T
}

// 泛型方法
func (c *Container[T]) Add(item T) {
    c.items = append(c.items, item)
}

func (c *Container[T]) Get(index int) (T, bool) {
    var zero T
    if index < 0 || index >= len(c.items) {
        return zero, false
    }
    return c.items[index], true
}

func (c *Container[T]) Len() int {
    return len(c.items)
}

func (c *Container[T]) Remove(index int) bool {
    if index < 0 || index >= len(c.items) {
        return false
    }
    c.items = append(c.items[:index], c.items[index+1:]...)
    return true
}

// 带约束的泛型方法
func (c *Container[T]) Find(item T) int where T : comparable {
    for i, v := range c.items {
        if v == item {
            return i
        }
    }
    return -1
}

func demonstrateGenericMethods() {
    fmt.Println("\n=== 泛型方法 ===")
    
    // 字符串容器
    stringContainer := &Container[string]{}
    stringContainer.Add("apple")
    stringContainer.Add("banana")
    stringContainer.Add("cherry")
    
    fmt.Printf("String container length: %d\n", stringContainer.Len())
    
    if item, ok := stringContainer.Get(1); ok {
        fmt.Printf("Item at index 1: %s\n", item)
    }
    
    // 整数容器
    intContainer := &Container[int]{}
    intContainer.Add(1)
    intContainer.Add(2)
    intContainer.Add(3)
    intContainer.Add(4)
    intContainer.Add(5)
    
    fmt.Printf("Int container length: %d\n", intContainer.Len())
    
    if item, ok := intContainer.Get(2); ok {
        fmt.Printf("Item at index 2: %d\n", item)
    }
    
    // 查找操作
    index := intContainer.Find(3)
    fmt.Printf("Found 3 at index: %d\n", index)
    
    index = stringContainer.Find("banana")
    fmt.Printf("Found 'banana' at index: %d\n", index)
}

// 泛型别名
type StringMap[T any] map[string]T
type IntMap[T any] map[int]T
type Slice[T any] []T

func demonstrateTypeAliases() {
    fmt.Println("\n=== 泛型类型别名 ===")
    
    // 使用泛型类型别名
    stringToInt := make(StringMap[int])
    stringToInt["one"] = 1
    stringToInt["two"] = 2
    fmt.Printf("StringMap[int]: %+v\n", stringToInt)
    
    intToString := make(IntMap[string])
    intToString[1] = "one"
    intToString[2] = "two"
    fmt.Printf("IntMap[string]: %+v\n", intToString)
    
    // 泛型切片
    intSlice := Slice[int]{1, 2, 3, 4, 5}
    fmt.Printf("Int slice: %v\n", intSlice)
    
    stringSlice := Slice[string]{"hello", "world", "go"}
    fmt.Printf("String slice: %v\n", stringSlice)
}

// 泛型组合
type Pair[T, U any] struct {
    First  T
    Second U
}

type Triple[T, U, V any] struct {
    First  T
    Second U
    Third  V
}

func demonstrateGenericComposition() {
    fmt.Println("\n=== 泛型组合 ===")
    
    // 使用泛型组合类型
    stringIntPair := Pair[string, int]{"hello", 42}
    fmt.Printf("String-Int pair: %+v\n", stringIntPair)
    
    intStringPair := Pair[int, string]{100, "world"}
    fmt.Printf("Int-String pair: %+v\n", intStringPair)
    
    // 三元组
    triple := Triple[string, int, bool]{"test", 123, true}
    fmt.Printf("Triple: %+v\n", triple)
    
    // 嵌套泛型类型
    nested := Pair[Pair[string, int], Pair[int, string]]{
        First:  Pair[string, int]{"nested", 1},
        Second: Pair[int, string]{2, "pair"},
    }
    fmt.Printf("Nested pair: %+v\n", nested)
}

// 泛型最佳实践示例
func demonstrateBestPractices() {
    fmt.Println("\n=== 泛型最佳实践 ===")
    
    fmt.Println("1. 使用适当的类型约束:")
    fmt.Println("   - any: 任意类型")
    fmt.Println("   - comparable: 可比较类型")
    fmt.Println("   - constraints.Ordered: 有序类型")
    fmt.Println("   - constraints.Number: 数值类型")
    
    fmt.Println("\n2. 保持简单:")
    fmt.Println("   - 避免过度复杂的泛型设计")
    fmt.Println("   - 优先考虑具体实现")
    fmt.Println("   - 适度使用泛型")
    
    fmt.Println("\n3. 性能考虑:")
    fmt.Println("   - 泛型通常比反射性能更好")
    fmt.Println("   - 避免不必要的类型参数")
    fmt.Println("   - 考虑内联和优化")
    
    fmt.Println("\n4. 可读性:")
    fmt.Println("   - 使用有意义的类型参数名称")
    fmt.Println("   - 提供清晰的文档")
    fmt.Println("   - 避免过于抽象")
}

func main() {
    demonstrateBasicSyntax()
    demonstrateGenericStructs()
    demonstrateGenericInterfaces()
    demonstrateGenericMethods()
    demonstrateTypeAliases()
    demonstrateGenericComposition()
    demonstrateBestPractices()
}
```

### 类型约束

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 基本类型约束
type Integer interface {
    int | int8 | int16 | int32 | int64
}

type Unsigned interface {
    uint | uint8 | uint16 | uint32 | uint64
}

type Float interface {
    float32 | float64
}

type Number interface {
    Integer | Unsigned | Float
}

type Ordered interface {
    Integer | Unsigned | Float | ~string
}

func demonstrateBasicConstraints() {
    fmt.Println("=== 基本类型约束 ===")
    
    // 使用整数约束
    func IntSum[T Integer](a, b T) T {
        return a + b
    }
    
    fmt.Printf("IntSum(5, 3): %v\n", IntSum(5, 3))
    fmt.Printf("IntSum(int64(100), int64(200)): %v\n", IntSum(int64(100), int64(200)))
    
    // 使用数值约束
    func NumberProduct[T Number](a, b T) T {
        return a * b
    }
    
    fmt.Printf("NumberProduct(5, 3): %v\n", NumberProduct(5, 3))
    fmt.Printf("NumberProduct(3.14, 2.0): %v\n", NumberProduct(3.14, 2.0))
    
    // 使用有序约束
    func Max[T Ordered](a, b T) T {
        if a > b {
            return a
        }
        return b
    }
    
    fmt.Printf("Max(5, 3): %v\n", Max(5, 3))
    fmt.Printf("Max(3.14, 2.71): %v\n", Max(3.14, 2.71))
    fmt.Printf("Max(\"hello\", \"world\"): %v\n", Max("hello", "world"))
}

// 复合类型约束
type SliceConstraint[T any] interface {
    ~[]T
}

type MapConstraint[K comparable, V any] interface {
    ~map[K]V
}

type ComparableSlice[T comparable] interface {
    ~[]T
}

func demonstrateCompositeConstraints() {
    fmt.Println("\n=== 复合类型约束 ===")
    
    // 切片约束
    func ProcessSlice[T any, S ~[]T](slice S) int {
        return len(slice)
    }
    
    intSlice := []int{1, 2, 3, 4, 5}
    stringSlice := []string{"a", "b", "c"}
    
    fmt.Printf("ProcessSlice(intSlice): %d\n", ProcessSlice(intSlice))
    fmt.Printf("ProcessSlice(stringSlice): %d\n", ProcessSlice(stringSlice))
    
    // 映射约束
    func ProcessMap[K comparable, V any, M ~map[K]V](m M) int {
        return len(m)
    }
    
    stringIntMap := map[string]int{"a": 1, "b": 2, "c": 3}
    intStringMap := map[int]string{1: "one", 2: "two"}
    
    fmt.Printf("ProcessMap(stringIntMap): %d\n", ProcessMap(stringIntMap))
    fmt.Printf("ProcessMap(intStringMap): %d\n", ProcessMap(intStringMap))
}

// 方法约束
type Stringer interface {
    String() string
}

type StringWriter interface {
    WriteString(string) (int, error)
}

// 组合约束
type Printable interface {
    Stringer
    fmt.Stringer
}

func demonstrateMethodConstraints() {
    fmt.Println("\n=== 方法约束 ===")
    
    // 使用Stringer约束
    func Format[T Stringer](value T) string {
        return "Formatted: " + value.String()
    }
    
    // 实现Stringer接口的类型
    type MyInt int
    
    func (m MyInt) String() string {
        return fmt.Sprintf("MyInt(%d)", int(m))
    }
    
    myInt := MyInt(42)
    fmt.Printf("Format(myInt): %s\n", Format(myInt))
    
    // 使用fmt.Stringer约束
    func FormatAny[T fmt.Stringer](value T) string {
        return "Any: " + value.String()
    }
    
    fmt.Printf("FormatAny(myInt): %s\n", FormatAny(myInt))
}

// 近似类型约束（~操作符）
type MyString string
type MyInt int

func demonstrateApproximateConstraints() {
    fmt.Println("\n=== 近似类型约束 ===")
    
    // 使用~string约束，包括所有基于string的类型
    func ProcessString[T ~string](s T) string {
        return "Processed: " + string(s)
    }
    
    regularString := "hello"
    myString := MyString("world")
    
    fmt.Printf("ProcessString(regularString): %s\n", ProcessString(regularString))
    fmt.Printf("ProcessString(myString): %s\n", ProcessString(myString))
    
    // 使用~int约束
    func ProcessInt[T ~int](i T) int {
        return int(i) * 2
    }
    
    regularInt := 21
    myInt := MyInt(21)
    
    fmt.Printf("ProcessInt(regularInt): %d\n", ProcessInt(regularInt))
    fmt.Printf("ProcessInt(myInt): %d\n", ProcessInt(myInt))
}

// 联合约束
type Numeric interface {
    constraints.Integer | constraints.Float
}

type ComparableNumeric interface {
    constraints.Ordered
}

func demonstrateUnionConstraints() {
    fmt.Println("\n=== 联合约束 ===")
    
    // 使用联合约束
    func Abs[T Numeric](value T) T {
        switch any(value).(type) {
        case int, int8, int16, int32, int64:
            if any(value).(int64) < 0 {
                return -value
            }
        case float32, float64:
            if any(value).(float64) < 0 {
                return -value
            }
        }
        return value
    }
    
    fmt.Printf("Abs(-5): %v\n", Abs(-5))
    fmt.Printf("Abs(-3.14): %v\n", Abs(-3.14))
    fmt.Printf("Abs(10): %v\n", Abs(10))
    
    // 复杂联合约束
    type ComplexConstraint interface {
        constraints.Ordered
        ~int | ~float64 | ~string
    }
    
    func Compare[T ComplexConstraint](a, b T) int {
        if a < b {
            return -1
        } else if a > b {
            return 1
        }
        return 0
    }
    
    fmt.Printf("Compare(5, 3): %d\n", Compare(5, 3))
    fmt.Printf("Compare(3.14, 2.71): %d\n", Compare(3.14, 2.71))
    fmt.Printf("Compare(\"hello\", \"world\"): %d\n", Compare("hello", "world"))
}

// 约束接口
type Addable interface {
    type int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, complex64, complex128,
         string
}

type Subtractable interface {
    type int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, complex64, complex128
}

func demonstrateConstraintInterfaces() {
    fmt.Println("\n=== 约束接口 ===")
    
    // 使用Addable约束
    func Add[T Addable](a, b T) T {
        return a + b
    }
    
    fmt.Printf("Add(5, 3): %v\n", Add(5, 3))
    fmt.Printf("Add(3.14, 2.71): %v\n", Add(3.14, 2.71))
    fmt.Printf("Add(\"hello\", \" world\"): %v\n", Add("hello", " world"))
    
    // 使用Subtractable约束
    func Subtract[T Subtractable](a, b T) T {
        return a - b
    }
    
    fmt.Printf("Subtract(10, 3): %v\n", Subtract(10, 3))
    fmt.Printf("Subtract(5.5, 2.2): %v\n", Subtract(5.5, 2.2))
}

// 自定义约束示例
type Sortable interface {
    constraints.Ordered
}

type NumericCalculator interface {
    constraints.Integer | constraints.Float
}

func demonstrateCustomConstraints() {
    fmt.Println("\n=== 自定义约束示例 ===")
    
    // 排序约束
    func BubbleSort[T Sortable](slice []T) {
        n := len(slice)
        for i := 0; i < n-1; i++ {
            for j := 0; j < n-i-1; j++ {
                if slice[j] > slice[j+1] {
                    slice[j], slice[j+1] = slice[j+1], slice[j]
                }
            }
        }
    }
    
    intSlice := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Printf("Original int slice: %v\n", intSlice)
    BubbleSort(intSlice)
    fmt.Printf("Sorted int slice: %v\n", intSlice)
    
    stringSlice := []string{"banana", "apple", "cherry", "date"}
    fmt.Printf("Original string slice: %v\n", stringSlice)
    BubbleSort(stringSlice)
    fmt.Printf("Sorted string slice: %v\n", stringSlice)
    
    // 数值计算约束
    func CalculateAverage[T NumericCalculator](numbers []T) float64 {
        if len(numbers) == 0 {
            return 0
        }
        
        var sum T
        for _, num := range numbers {
            sum += num
        }
        
        return float64(sum) / float64(len(numbers))
    }
    
    intNumbers := []int{1, 2, 3, 4, 5}
    floatNumbers := []float64{1.1, 2.2, 3.3, 4.4, 5.5}
    
    fmt.Printf("Average of int numbers: %.2f\n", CalculateAverage(intNumbers))
    fmt.Printf("Average of float numbers: %.2f\n", CalculateAverage(floatNumbers))
}

// 约束继承和组合
type BasicConstraint interface {
    constraints.Ordered
}

type ExtendedConstraint interface {
    BasicConstraint
    fmt.Stringer
}

func demonstrateConstraintInheritance() {
    fmt.Println("\n=== 约束继承和组合 ===")
    
    // 基础约束
    func BasicCompare[T BasicConstraint](a, b T) bool {
        return a == b
    }
    
    fmt.Printf("BasicCompare(5, 5): %t\n", BasicCompare(5, 5))
    fmt.Printf("BasicCompare(\"hello\", \"world\"): %t\n", BasicCompare("hello", "world"))
    
    // 扩展约束
    type PrintableInt int
    
    func (p PrintableInt) String() string {
        return fmt.Sprintf("PrintableInt(%d)", int(p))
    }
    
    func ExtendedProcess[T ExtendedConstraint](value T) string {
        return "Extended: " + value.String()
    }
    
    printableInt := PrintableInt(42)
    fmt.Printf("ExtendedProcess(printableInt): %s\n", ExtendedProcess(printableInt))
}

// 约束最佳实践
func constraintBestPractices() {
    fmt.Println("\n=== 约束最佳实践 ===")
    
    fmt.Println("1. 选择合适的约束:")
    fmt.Println("   - 使用标准库提供的约束")
    fmt.Println("   - 避免过于宽泛的约束")
    fmt.Println("   - 考虑性能影响")
    
    fmt.Println("\n2. 约束设计原则:")
    fmt.Println("   - 保持约束简单明确")
    fmt.Println("   - 避免复杂的联合约束")
    fmt.Println("   - 考虑约束的可组合性")
    
    fmt.Println("\n3. 常用约束模式:")
    fmt.Println("   - any: 通用约束")
    fmt.Println("   - comparable: 相等性约束")
    fmt.Println("   - constraints.Ordered: 有序约束")
    fmt.Println("   - constraints.Number: 数值约束")
    
    fmt.Println("\n4. 约束命名:")
    fmt.Println("   - 使用描述性的名称")
    fmt.Println("   - 遵循Go命名约定")
    fmt.Println("   - 避免缩写和模糊名称")
}

func main() {
    demonstrateBasicConstraints()
    demonstrateCompositeConstraints()
    demonstrateMethodConstraints()
    demonstrateApproximateConstraints()
    demonstrateUnionConstraints()
    demonstrateConstraintInterfaces()
    demonstrateCustomConstraints()
    demonstrateConstraintInheritance()
    constraintBestPractices()
}
```

### 泛型函数

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 基本泛型函数
func Identity[T any](value T) T {
    return value
}

func Swap[T any](a, b T) (T, T) {
    return b, a
}

func demonstrateBasicGenericFunctions() {
    fmt.Println("=== 基本泛型函数 ===")
    
    // 使用Identity函数
    fmt.Printf("Identity(42): %v\n", Identity(42))
    fmt.Printf("Identity(\"hello\"): %v\n", Identity("hello"))
    fmt.Printf("Identity(true): %v\n", Identity(true))
    
    // 使用Swap函数
    a, b := Swap(1, 2)
    fmt.Printf("Swap(1, 2): %v, %v\n", a, b)
    
    x, y := Swap("hello", "world")
    fmt.Printf("Swap(\"hello\", \"world\"): %v, %v\n", x, y)
}

// 带约束的泛型函数
func Max[T constraints.Ordered](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

func Equal[T comparable](a, b T) bool {
    return a == b
}

func demonstrateConstrainedGenericFunctions() {
    fmt.Println("\n=== 带约束的泛型函数 ===")
    
    // 使用Max函数
    fmt.Printf("Max(5, 3): %v\n", Max(5, 3))
    fmt.Printf("Max(3.14, 2.71): %v\n", Max(3.14, 2.71))
    fmt.Printf("Max(\"hello\", \"world\"): %v\n", Max("hello", "world"))
    
    // 使用Min函数
    fmt.Printf("Min(5, 3): %v\n", Min(5, 3))
    fmt.Printf("Min(3.14, 2.71): %v\n", Min(3.14, 2.71))
    fmt.Printf("Min(\"hello\", \"world\"): %v\n", Min("hello", "world"))
    
    // 使用Equal函数
    fmt.Printf("Equal(5, 5): %t\n", Equal(5, 5))
    fmt.Printf("Equal(\"hello\", \"world\"): %t\n", Equal("hello", "world"))
    fmt.Printf("Equal(true, false): %t\n", Equal(true, false))
}

// 数值计算泛型函数
func Add[T constraints.Number](a, b T) T {
    return a + b
}

func Subtract[T constraints.Number](a, b T) T {
    return a - b
}

func Multiply[T constraints.Number](a, b T) T {
    return a * b
}

func Divide[T constraints.Float](a, b T) T {
    if b == 0 {
        panic("division by zero")
    }
    return a / b
}

func demonstrateNumericFunctions() {
    fmt.Println("\n=== 数值计算泛型函数 ===")
    
    // 整数运算
    fmt.Printf("Add(5, 3): %v\n", Add(5, 3))
    fmt.Printf("Subtract(10, 4): %v\n", Subtract(10, 4))
    fmt.Printf("Multiply(6, 7): %v\n", Multiply(6, 7))
    
    // 浮点数运算
    fmt.Printf("Add(3.14, 2.71): %v\n", Add(3.14, 2.71))
    fmt.Printf("Divide(10.0, 3.0): %v\n", Divide(10.0, 3.0))
    
    // 不同类型的数值
    fmt.Printf("Add(int64(100), int64(200)): %v\n", Add(int64(100), int64(200)))
    fmt.Printf("Multiply(float32(2.5), float32(4.0)): %v\n", Multiply(float32(2.5), float32(4.0)))
}

// 集合操作泛型函数
func Contains[T comparable](slice []T, item T) bool {
    for _, v := range slice {
        if v == item {
            return true
        }
    }
    return false
}

func Index[T comparable](slice []T, item T) int {
    for i, v := range slice {
        if v == item {
            return i
        }
    }
    return -1
}

func Filter[T any](slice []T, predicate func(T) bool) []T {
    result := make([]T, 0)
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

func Map[T, U any](slice []T, mapper func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = mapper(v)
    }
    return result
}

func Reduce[T, U any](slice []T, initial U, reducer func(U, T) U) U {
    result := initial
    for _, v := range slice {
        result = reducer(result, v)
    }
    return result
}

func demonstrateCollectionFunctions() {
    fmt.Println("\n=== 集合操作泛型函数 ===")
    
    // Contains函数
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Printf("Contains(numbers, 3): %t\n", Contains(numbers, 3))
    fmt.Printf("Contains(numbers, 6): %t\n", Contains(numbers, 6))
    
    strings := []string{"apple", "banana", "cherry"}
    fmt.Printf("Contains(strings, \"banana\"): %t\n", Contains(strings, "banana"))
    fmt.Printf("Index(strings, \"cherry\"): %d\n", Index(strings, "cherry"))
    
    // Filter函数
    evenNumbers := Filter(numbers, func(n int) bool {
        return n%2 == 0
    })
    fmt.Printf("Even numbers: %v\n", evenNumbers)
    
    longStrings := Filter(strings, func(s string) bool {
        return len(s) > 5
    })
    fmt.Printf("Long strings: %v\n", longStrings)
    
    // Map函数
    squared := Map(numbers, func(n int) int {
        return n * n
    })
    fmt.Printf("Squared numbers: %v\n", squared)
    
    upperStrings := Map(strings, func(s string) string {
        return fmt.Sprintf("[%s]", s)
    })
    fmt.Printf("Formatted strings: %v\n", upperStrings)
    
    // Reduce函数
    sum := Reduce(numbers, 0, func(acc int, n int) int {
        return acc + n
    })
    fmt.Printf("Sum of numbers: %d\n", sum)
    
    concat := Reduce(strings, "", func(acc string, s string) string {
        if acc == "" {
            return s
        }
        return acc + ", " + s
    })
    fmt.Printf("Concatenated strings: %s\n", concat)
}

// 排序泛型函数
func BubbleSort[T constraints.Ordered](slice []T) {
    n := len(slice)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if slice[j] > slice[j+1] {
                slice[j], slice[j+1] = slice[j+1], slice[j]
            }
        }
    }
}

func QuickSort[T constraints.Ordered](slice []T) {
    if len(slice) <= 1 {
        return
    }
    
    quickSortHelper(slice, 0, len(slice)-1)
}

func quickSortHelper[T constraints.Ordered](slice []T, low, high int) {
    if low < high {
        pivot := partition(slice, low, high)
        quickSortHelper(slice, low, pivot-1)
        quickSortHelper(slice, pivot+1, high)
    }
}

func partition[T constraints.Ordered](slice []T, low, high int) int {
    pivot := slice[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if slice[j] <= pivot {
            i++
            slice[i], slice[j] = slice[j], slice[i]
        }
    }
    
    slice[i+1], slice[high] = slice[high], slice[i+1]
    return i + 1
}

func demonstrateSortingFunctions() {
    fmt.Println("\n=== 排序泛型函数 ===")
    
    // 冒泡排序
    intSlice := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Printf("Original int slice: %v\n", intSlice)
    BubbleSort(intSlice)
    fmt.Printf("Bubble sorted: %v\n", intSlice)
    
    stringSlice := []string{"banana", "apple", "cherry", "date"}
    fmt.Printf("Original string slice: %v\n", stringSlice)
    BubbleSort(stringSlice)
    fmt.Printf("Bubble sorted: %v\n", stringSlice)
    
    // 快速排序
    floatSlice := []float64{3.14, 2.71, 1.41, 1.73, 0.57}
    fmt.Printf("Original float slice: %v\n", floatSlice)
    QuickSort(floatSlice)
    fmt.Printf("Quick sorted: %v\n", floatSlice)
}

// 搜索泛型函数
func LinearSearch[T comparable](slice []T, target T) int {
    for i, v := range slice {
        if v == target {
            return i
        }
    }
    return -1
}

func BinarySearch[T constraints.Ordered](slice []T, target T) int {
    low, high := 0, len(slice)-1
    
    for low <= high {
        mid := (low + high) / 2
        if slice[mid] == target {
            return mid
        } else if slice[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    
    return -1
}

func demonstrateSearchFunctions() {
    fmt.Println("\n=== 搜索泛型函数 ===")
    
    // 线性搜索
    numbers := []int{10, 20, 30, 40, 50}
    fmt.Printf("LinearSearch(numbers, 30): %d\n", LinearSearch(numbers, 30))
    fmt.Printf("LinearSearch(numbers, 35): %d\n", LinearSearch(numbers, 35))
    
    strings := []string{"apple", "banana", "cherry", "date"}
    fmt.Printf("LinearSearch(strings, \"cherry\"): %d\n", LinearSearch(strings, "cherry"))
    
    // 二分搜索（需要排序的数组）
    sortedNumbers := []int{10, 20, 30, 40, 50}
    fmt.Printf("BinarySearch(sortedNumbers, 30): %d\n", BinarySearch(sortedNumbers, 30))
    fmt.Printf("BinarySearch(sortedNumbers, 35): %d\n", BinarySearch(sortedNumbers, 35))
}

// 数学泛型函数
func Abs[T constraints.Signed](value T) T {
    if value < 0 {
        return -value
    }
    return value
}

func Sign[T constraints.Signed](value T) int {
    if value > 0 {
        return 1
    } else if value < 0 {
        return -1
    }
    return 0
}

func Clamp[T constraints.Ordered](value, min, max T) T {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}

func demonstrateMathFunctions() {
    fmt.Println("\n=== 数学泛型函数 ===")
    
    // 绝对值
    fmt.Printf("Abs(-5): %v\n", Abs(-5))
    fmt.Printf("Abs(-3.14): %v\n", Abs(-3.14))
    fmt.Printf("Abs(int64(-100)): %v\n", Abs(int64(-100)))
    
    // 符号函数
    fmt.Printf("Sign(5): %d\n", Sign(5))
    fmt.Printf("Sign(-3): %d\n", Sign(-3))
    fmt.Printf("Sign(0): %d\n", Sign(0))
    
    // 夹紧函数
    fmt.Printf("Clamp(15, 10, 20): %v\n", Clamp(15, 10, 20))
    fmt.Printf("Clamp(5, 10, 20): %v\n", Clamp(5, 10, 20))
    fmt.Printf("Clamp(25, 10, 20): %v\n", Clamp(25, 10, 20))
    fmt.Printf("Clamp(3.14, 1.0, 5.0): %v\n", Clamp(3.14, 1.0, 5.0))
}

// 泛型函数组合
func Compose[T, U, V any](f func(U) V, g func(T) U) func(T) V {
    return func(t T) V {
        return f(g(t))
    }
}

func demonstrateFunctionComposition() {
    fmt.Println("\n=== 泛型函数组合 ===")
    
    // 函数组合示例
    addOne := func(x int) int { return x + 1 }
    multiplyByTwo := func(x int) int { return x * 2 }
    
    composed := Compose(multiplyByTwo, addOne)
    result := composed(5)
    fmt.Printf("Composed function result (5 -> 6 -> 12): %d\n", result)
    
    // 字符串处理组合
    toUpper := func(s string) string { return fmt.Sprintf("[%s]", s) }
    addSuffix := func(s string) string { return s + "!" }
    
    stringComposed := Compose(addSuffix, toUpper)
    stringResult := stringComposed("hello")
    fmt.Printf("String composed result: %s\n", stringResult)
}

// 泛型函数最佳实践
func genericFunctionBestPractices() {
    fmt.Println("\n=== 泛型函数最佳实践 ===")
    
    fmt.Println("1. 选择合适的约束:")
    fmt.Println("   - 使用最具体的约束")
    fmt.Println("   - 避免过度通用的约束")
    fmt.Println("   - 考虑性能影响")
    
    fmt.Println("\n2. 函数设计原则:")
    fmt.Println("   - 保持函数简单明确")
    fmt.Println("   - 避免复杂的类型参数")
    fmt.Println("   - 提供清晰的文档")
    
    fmt.Println("\n3. 常用模式:")
    fmt.Println("   - 集合操作函数")
    fmt.Println("   - 数值计算函数")
    fmt.Println("   - 排序和搜索函数")
    fmt.Println("   - 转换和映射函数")
    
    fmt.Println("\n4. 性能考虑:")
    fmt.Println("   - 避免不必要的内存分配")
    fmt.Println("   - 考虑内联优化")
    fmt.Println("   - 使用切片而非创建新切片")
    
    fmt.Println("\n5. 错误处理:")
    fmt.Println("   - 返回错误而非panic")
    fmt.Println("   - 提供合理的默认值")
    fmt.Println("   - 文档化边界条件")
}

func main() {
    demonstrateBasicGenericFunctions()
    demonstrateConstrainedGenericFunctions()
    demonstrateNumericFunctions()
    demonstrateCollectionFunctions()
    demonstrateSortingFunctions()
    demonstrateSearchFunctions()
    demonstrateMathFunctions()
    demonstrateFunctionComposition()
    genericFunctionBestPractices()
}
```

### 泛型结构体

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 基本泛型结构体
type Box[T any] struct {
    Value T
}

func NewBox[T any](value T) *Box[T] {
    return &Box[T]{Value: value}
}

func (b *Box[T]) GetValue() T {
    return b.Value
}

func (b *Box[T]) SetValue(value T) {
    b.Value = value
}

func (b *Box[T]) String() string {
    return fmt.Sprintf("Box{%v}", b.Value)
}

func demonstrateBasicGenericStructs() {
    fmt.Println("=== 基本泛型结构体 ===")
    
    // 创建不同类型的Box
    intBox := NewBox(42)
    fmt.Printf("Int box: %s\n", intBox)
    fmt.Printf("Int box value: %v\n", intBox.GetValue())
    
    stringBox := NewBox("hello")
    fmt.Printf("String box: %s\n", stringBox)
    fmt.Printf("String box value: %v\n", stringBox.GetValue())
    
    boolBox := NewBox(true)
    fmt.Printf("Bool box: %s\n", boolBox)
    fmt.Printf("Bool box value: %v\n", boolBox.GetValue())
    
    // 修改值
    intBox.SetValue(100)
    fmt.Printf("Modified int box: %s\n", intBox)
}

// 带约束的泛型结构体
type NumberBox[T constraints.Number] struct {
    Value T
    Sum   T
}

func NewNumberBox[T constraints.Number](value T) *NumberBox[T] {
    return &NumberBox[T]{Value: value, Sum: value}
}

func (nb *NumberBox[T]) Add(value T) {
    nb.Sum += value
}

func (nb *NumberBox[T]) GetSum() T {
    return nb.Sum
}

func (nb *NumberBox[T]) GetAverage(count int) float64 {
    if count == 0 {
        return 0
    }
    return float64(nb.Sum) / float64(count)
}

func demonstrateConstrainedGenericStructs() {
    fmt.Println("\n=== 带约束的泛型结构体 ===")
    
    // 整数NumberBox
    intBox := NewNumberBox(10)
    intBox.Add(20)
    intBox.Add(30)
    fmt.Printf("Int box sum: %v\n", intBox.GetSum())
    fmt.Printf("Int box average (3 values): %.2f\n", intBox.GetAverage(3))
    
    // 浮点数NumberBox
    floatBox := NewNumberBox(3.14)
    floatBox.Add(2.71)
    floatBox.Add(1.41)
    fmt.Printf("Float box sum: %v\n", floatBox.GetSum())
    fmt.Printf("Float box average (3 values): %.2f\n", floatBox.GetAverage(3))
}

// 多类型参数的泛型结构体
type Pair[T, U any] struct {
    First  T
    Second U
}

func NewPair[T, U any](first T, second U) *Pair[T, U] {
    return &Pair[T, U]{First: first, Second: second}
}

func (p *Pair[T, U]) GetFirst() T {
    return p.First
}

func (p *Pair[T, U]) GetSecond() U {
    return p.Second
}

func (p *Pair[T, U]) SetFirst(first T) {
    p.First = first
}

func (p *Pair[T, U]) SetSecond(second U) {
    p.Second = second
}

func (p *Pair[T, U]) String() string {
    return fmt.Sprintf("Pair{%v, %v}", p.First, p.Second)
}

func demonstrateMultiTypeGenericStructs() {
    fmt.Println("\n=== 多类型参数的泛型结构体 ===")
    
    // 不同类型的Pair
    stringIntPair := NewPair("hello", 42)
    fmt.Printf("String-Int pair: %s\n", stringIntPair)
    
    intStringPair := NewPair(100, "world")
    fmt.Printf("Int-String pair: %s\n", intStringPair)
    
    floatBoolPair := NewPair(3.14, true)
    fmt.Printf("Float-Bool pair: %s\n", floatBoolPair)
    
    // 修改值
    stringIntPair.SetFirst("modified")
    stringIntPair.SetSecond(99)
    fmt.Printf("Modified pair: %s\n", stringIntPair)
}

// 泛型容器结构体
type Container[T any] struct {
    items []T
    size  int
}

func NewContainer[T any](capacity int) *Container[T] {
    return &Container[T]{
        items: make([]T, 0, capacity),
        size:  0,
    }
}

func (c *Container[T]) Add(item T) {
    c.items = append(c.items, item)
    c.size++
}

func (c *Container[T]) Get(index int) (T, bool) {
    var zero T
    if index < 0 || index >= c.size {
        return zero, false
    }
    return c.items[index], true
}

func (c *Container[T]) Remove(index int) bool {
    if index < 0 || index >= c.size {
        return false
    }
    
    c.items = append(c.items[:index], c.items[index+1:]...)
    c.size--
    return true
}

func (c *Container[T]) Size() int {
    return c.size
}

func (c *Container[T]) Capacity() int {
    return cap(c.items)
}

func (c *Container[T]) IsEmpty() bool {
    return c.size == 0
}

func (c *Container[T]) Clear() {
    c.items = c.items[:0]
    c.size = 0
}

func (c *Container[T]) ForEach(fn func(T)) {
    for _, item := range c.items {
        fn(item)
    }
}

func demonstrateGenericContainers() {
    fmt.Println("\n=== 泛型容器结构体 ===")
    
    // 整数容器
    intContainer := NewContainer[int](5)
    intContainer.Add(1)
    intContainer.Add(2)
    intContainer.Add(3)
    
    fmt.Printf("Int container size: %d\n", intContainer.Size())
    fmt.Printf("Int container capacity: %d\n", intContainer.Capacity())
    
    if value, ok := intContainer.Get(1); ok {
        fmt.Printf("Value at index 1: %d\n", value)
    }
    
    // 字符串容器
    stringContainer := NewContainer[string](3)
    stringContainer.Add("apple")
    stringContainer.Add("banana")
    stringContainer.Add("cherry")
    
    fmt.Printf("String container size: %d\n", stringContainer.Size())
    
    // 遍历容器
    fmt.Println("String container items:")
    stringContainer.ForEach(func(s string) {
        fmt.Printf("  %s\n", s)
    })
    
    // 移除元素
    stringContainer.Remove(1)
    fmt.Printf("After removal, size: %d\n", stringContainer.Size())
    fmt.Println("Remaining items:")
    stringContainer.ForEach(func(s string) {
        fmt.Printf("  %s\n", s)
    })
}

// 泛型栈结构体
type Stack[T any] struct {
    items []T
}

func NewStack[T any]() *Stack[T] {
    return &Stack[T]{items: make([]T, 0)}
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    var zero T
    if len(s.items) == 0 {
        return zero, false
    }
    
    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index]
    return item, true
}

func (s *Stack[T]) Peek() (T, bool) {
    var zero T
    if len(s.items) == 0 {
        return zero, false
    }
    return s.items[len(s.items)-1], true
}

func (s *Stack[T]) Size() int {
    return len(s.items)
}

func (s *Stack[T]) IsEmpty() bool {
    return len(s.items) == 0
}

func (s *Stack[T]) Clear() {
    s.items = s.items[:0]
}

func demonstrateGenericStacks() {
    fmt.Println("\n=== 泛型栈结构体 ===")
    
    // 整数栈
    intStack := NewStack[int]()
    intStack.Push(1)
    intStack.Push(2)
    intStack.Push(3)
    
    fmt.Printf("Int stack size: %d\n", intStack.Size())
    
    if top, ok := intStack.Peek(); ok {
        fmt.Printf("Top of int stack: %d\n", top)
    }
    
    for !intStack.IsEmpty() {
        if item, ok := intStack.Pop(); ok {
            fmt.Printf("Popped: %d\n", item)
        }
    }
    
    // 字符串栈
    stringStack := NewStack[string]()
    stringStack.Push("hello")
    stringStack.Push("world")
    stringStack.Push("go")
    
    fmt.Printf("String stack size: %d\n", stringStack.Size())
    
    for !stringStack.IsEmpty() {
        if item, ok := stringStack.Pop(); ok {
            fmt.Printf("Popped: %s\n", item)
        }
    }
}

// 泛型队列结构体
type Queue[T any] struct {
    items []T
}

func NewQueue[T any]() *Queue[T] {
    return &Queue[T]{items: make([]T, 0)}
}

func (q *Queue[T]) Enqueue(item T) {
    q.items = append(q.items, item)
}

func (q *Queue[T]) Dequeue() (T, bool) {
    var zero T
    if len(q.items) == 0 {
        return zero, false
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    return item, true
}

func (q *Queue[T]) Front() (T, bool) {
    var zero T
    if len(q.items) == 0 {
        return zero, false
    }
    return q.items[0], true
}

func (q *Queue[T]) Size() int {
    return len(q.items)
}

func (q *Queue[T]) IsEmpty() bool {
    return len(q.items) == 0
}

func (q *Queue[T]) Clear() {
    q.items = q.items[:0]
}

func demonstrateGenericQueues() {
    fmt.Println("\n=== 泛型队列结构体 ===")
    
    // 整数队列
    intQueue := NewQueue[int]()
    intQueue.Enqueue(1)
    intQueue.Enqueue(2)
    intQueue.Enqueue(3)
    
    fmt.Printf("Int queue size: %d\n", intQueue.Size())
    
    if front, ok := intQueue.Front(); ok {
        fmt.Printf("Front of int queue: %d\n", front)
    }
    
    for !intQueue.IsEmpty() {
        if item, ok := intQueue.Dequeue(); ok {
            fmt.Printf("Dequeued: %d\n", item)
        }
    }
    
    // 字符串队列
    stringQueue := NewQueue[string]()
    stringQueue.Enqueue("first")
    stringQueue.Enqueue("second")
    stringQueue.Enqueue("third")
    
    fmt.Printf("String queue size: %d\n", stringQueue.Size())
    
    for !stringQueue.IsEmpty() {
        if item, ok := stringQueue.Dequeue(); ok {
            fmt.Printf("Dequeued: %s\n", item)
        }
    }
}

// 泛型链表节点
type ListNode[T any] struct {
    Value T
    Next  *ListNode[T]
}

type LinkedList[T any] struct {
    head *ListNode[T]
    size int
}

func NewLinkedList[T any]() *LinkedList[T] {
    return &LinkedList[T]{}
}

func (ll *LinkedList[T]) Add(value T) {
    newNode := &ListNode[T]{Value: value, Next: ll.head}
    ll.head = newNode
    ll.size++
}

func (ll *LinkedList[T]) Remove(value T) bool where T : comparable {
    if ll.head == nil {
        return false
    }
    
    if ll.head.Value == value {
        ll.head = ll.head.Next
        ll.size--
        return true
    }
    
    current := ll.head
    for current.Next != nil {
        if current.Next.Value == value {
            current.Next = current.Next.Next
            ll.size--
            return true
        }
        current = current.Next
    }
    
    return false
}

func (ll *LinkedList[T]) Contains(value T) bool where T : comparable {
    current := ll.head
    for current != nil {
        if current.Value == value {
            return true
        }
        current = current.Next
    }
    return false
}

func (ll *LinkedList[T]) Size() int {
    return ll.size
}

func (ll *LinkedList[T]) IsEmpty() bool {
    return ll.size == 0
}

func (ll *LinkedList[T]) ToSlice() []T {
    result := make([]T, 0, ll.size)
    current := ll.head
    for current != nil {
        result = append(result, current.Value)
        current = current.Next
    }
    return result
}

func demonstrateGenericLinkedLists() {
    fmt.Println("\n=== 泛型链表结构体 ===")
    
    // 整数链表
    intList := NewLinkedList[int]()
    intList.Add(1)
    intList.Add(2)
    intList.Add(3)
    
    fmt.Printf("Int list size: %d\n", intList.Size())
    fmt.Printf("Int list contains 2: %t\n", intList.Contains(2))
    fmt.Printf("Int list to slice: %v\n", intList.ToSlice())
    
    intList.Remove(2)
    fmt.Printf("After removing 2, size: %d\n", intList.Size())
    fmt.Printf("Int list to slice: %v\n", intList.ToSlice())
    
    // 字符串链表
    stringList := NewLinkedList[string]()
    stringList.Add("apple")
    stringList.Add("banana")
    stringList.Add("cherry")
    
    fmt.Printf("String list size: %d\n", stringList.Size())
    fmt.Printf("String list contains \"banana\": %t\n", stringList.Contains("banana"))
    fmt.Printf("String list to slice: %v\n", stringList.ToSlice())
}

// 泛型结构体嵌套
type NestedStruct[T, U any] struct {
    Box     *Box[T]
    Pair    *Pair[T, U]
    Stack   *Stack[T]
    Queue   *Queue[U]
}

func NewNestedStruct[T, U any](t T, u U) *NestedStruct[T, U] {
    return &NestedStruct[T, U]{
        Box:   NewBox(t),
        Pair:  NewPair(t, u),
        Stack: NewStack[T](),
        Queue: NewQueue[U](),
    }
}

func (ns *NestedStruct[T, U]) String() string {
    return fmt.Sprintf("NestedStruct{Box: %s, Pair: %s}", ns.Box, ns.Pair)
}

func demonstrateNestedGenericStructs() {
    fmt.Println("\n=== 泛型结构体嵌套 ===")
    
    nested := NewNestedStruct(42, "hello")
    fmt.Printf("Nested struct: %s\n", nested)
    
    nested.Stack.Push(1)
    nested.Stack.Push(2)
    nested.Queue.Enqueue("first")
    nested.Queue.Enqueue("second")
    
    fmt.Printf("Stack size: %d\n", nested.Stack.Size())
    fmt.Printf("Queue size: %d\n", nested.Queue.Size())
}

// 泛型结构体最佳实践
func genericStructBestPractices() {
    fmt.Println("\n=== 泛型结构体最佳实践 ===")
    
    fmt.Println("1. 结构体设计:")
    fmt.Println("   - 保持结构体简单明确")
    fmt.Println("   - 使用合适的类型约束")
    fmt.Println("   - 提供构造函数")
    
    fmt.Println("\n2. 方法设计:")
    fmt.Println("   - 提供基本的CRUD操作")
    fmt.Println("   - 考虑零值处理")
    fmt.Println("   - 提供迭代和遍历方法")
    
    fmt.Println("\n3. 常用模式:")
    fmt.Println("   - 容器类结构体")
    fmt.Println("   - 数据结构实现")
    fmt.Println("   - 配置和选项模式")
    fmt.Println("   - 包装器模式")
    
    fmt.Println("\n4. 性能考虑:")
    fmt.Println("   - 预分配内存")
    fmt.Println("   - 避免不必要的内存分配")
    fmt.Println("   - 考虑缓存友好性")
    
    fmt.Println("\n5. 接口兼容:")
    fmt.Println("   - 实现标准接口")
    fmt.Println("   - 提供类型转换方法")
    fmt.Println("   - 考虑与其他库的集成")
}

func main() {
    demonstrateBasicGenericStructs()
    demonstrateConstrainedGenericStructs()
    demonstrateMultiTypeGenericStructs()
    demonstrateGenericContainers()
    demonstrateGenericStacks()
    demonstrateGenericQueues()
    demonstrateGenericLinkedLists()
    demonstrateNestedGenericStructs()
    genericStructBestPractices()
}
```

### 泛型接口

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 基本泛型接口
type GenericInterface[T any] interface {
    Process(T) T
    Get() T
}

// 实现泛型接口的具体类型
type StringProcessor[T ~string] struct {
    value T
}

func NewStringProcessor[T ~string](value T) *StringProcessor[T] {
    return &StringProcessor[T]{value: value}
}

func (sp *StringProcessor[T]) Process(input T) T {
    return sp.value + " " + input
}

func (sp *StringProcessor[T]) Get() T {
    return sp.value
}

type NumberProcessor[T constraints.Number] struct {
    value T
}

func NewNumberProcessor[T constraints.Number](value T) *NumberProcessor[T] {
    return &NumberProcessor[T]{value: value}
}

func (np *NumberProcessor[T]) Process(input T) T {
    return np.value + input
}

func (np *NumberProcessor[T]) Get() T {
    return np.value
}

func demonstrateBasicGenericInterfaces() {
    fmt.Println("=== 基本泛型接口 ===")
    
    // 使用字符串处理器
    stringProc := NewStringProcessor("Hello")
    result := stringProc.Process("World")
    fmt.Printf("String processor result: %s\n", result)
    fmt.Printf("String processor get: %s\n", stringProc.Get())
    
    // 使用MyString类型
    type MyString string
    myStringProc := NewStringProcessor(MyString("Hi"))
    myResult := myStringProc.Process(MyString("Go"))
    fmt.Printf("MyString processor result: %s\n", myResult)
    
    // 使用数字处理器
    intProc := NewNumberProcessor(10)
    intResult := intProc.Process(5)
    fmt.Printf("Int processor result: %d\n", intResult)
    fmt.Printf("Int processor get: %d\n", intProc.Get())
    
    floatProc := NewNumberProcessor(3.14)
    floatResult := floatProc.Process(2.71)
    fmt.Printf("Float processor result: %.2f\n", floatResult)
    fmt.Printf("Float processor get: %.2f\n", floatProc.Get())
}

// 带方法约束的泛型接口
type Printable[T any] interface {
    String() string
    SetValue(T)
    GetValue() T
}

// 实现Printable接口
type GenericPrintable[T any] struct {
    value T
}

func NewGenericPrintable[T any](value T) *GenericPrintable[T] {
    return &GenericPrintable[T]{value: value}
}

func (gp *GenericPrintable[T]) String() string {
    return fmt.Sprintf("GenericPrintable{%v}", gp.value)
}

func (gp *GenericPrintable[T]) SetValue(value T) {
    gp.value = value
}

func (gp *GenericPrintable[T]) GetValue() T {
    return gp.value
}

func demonstrateMethodConstrainedInterfaces() {
    fmt.Println("\n=== 带方法约束的泛型接口 ===")
    
    // 整数可打印对象
    intPrintable := NewGenericPrintable(42)
    fmt.Printf("Int printable: %s\n", intPrintable.String())
    fmt.Printf("Int printable value: %v\n", intPrintable.GetValue())
    
    // 字符串可打印对象
    stringPrintable := NewGenericPrintable("hello")
    fmt.Printf("String printable: %s\n", stringPrintable.String())
    fmt.Printf("String printable value: %v\n", stringPrintable.GetValue())
    
    // 修改值
    stringPrintable.SetValue("world")
    fmt.Printf("Modified string printable: %s\n", stringPrintable.String())
}

// 多类型参数的泛型接口
type PairProcessor[T, U any] interface {
    ProcessPair(T, U) (T, U)
    GetPair() (T, U)
    SetPair(T, U)
}

// 实现多类型参数接口
type GenericPairProcessor[T, U any] struct {
    first  T
    second U
}

func NewGenericPairProcessor[T, U any](first T, second U) *GenericPairProcessor[T, U] {
    return &GenericPairProcessor[T, U]{first: first, second: second}
}

func (gpp *GenericPairProcessor[T, U]) ProcessPair(first T, second U) (T, U) {
    return first, second
}

func (gpp *GenericPairProcessor[T, U]) GetPair() (T, U) {
    return gpp.first, gpp.second
}

func (gpp *GenericPairProcessor[T, U]) SetPair(first T, second U) {
    gpp.first = first
    gpp.second = second
}

func demonstrateMultiTypeInterfaces() {
    fmt.Println("\n=== 多类型参数的泛型接口 ===")
    
    // 字符串-整数对处理器
    stringIntProcessor := NewGenericPairProcessor("hello", 42)
    first, second := stringIntProcessor.GetPair()
    fmt.Printf("String-Int pair: %s, %d\n", first, second)
    
    // 处理对
    newFirst, newSecond := stringIntProcessor.ProcessPair("world", 100)
    fmt.Printf("Processed pair: %s, %d\n", newFirst, newSecond)
    
    // 设置新对
    stringIntProcessor.SetPair("go", 200)
    first, second = stringIntProcessor.GetPair()
    fmt.Printf("New pair: %s, %d\n", first, second)
}

// 泛型接口组合
type Readable[T any] interface {
    Read() T
}

type Writable[T any] interface {
    Write(T)
}

type ReadWrite[T any] interface {
    Readable[T]
    Writable[T]
}

// 实现组合接口
type GenericBuffer[T any] struct {
    data []T
}

func NewGenericBuffer[T any]() *GenericBuffer[T] {
    return &GenericBuffer[T]{data: make([]T, 0)}
}

func (gb *GenericBuffer[T]) Read() T {
    var zero T
    if len(gb.data) == 0 {
        return zero
    }
    
    value := gb.data[0]
    gb.data = gb.data[1:]
    return value
}

func (gb *GenericBuffer[T]) Write(value T) {
    gb.data = append(gb.data, value)
}

func (gb *GenericBuffer[T]) Size() int {
    return len(gb.data)
}

func demonstrateInterfaceComposition() {
    fmt.Println("\n=== 泛型接口组合 ===")
    
    // 整数缓冲区
    intBuffer := NewGenericBuffer[int]()
    intBuffer.Write(1)
    intBuffer.Write(2)
    intBuffer.Write(3)
    
    fmt.Printf("Int buffer size: %d\n", intBuffer.Size())
    
    value := intBuffer.Read()
    fmt.Printf("Read from int buffer: %d\n", value)
    fmt.Printf("Buffer size after read: %d\n", intBuffer.Size())
    
    // 字符串缓冲区
    stringBuffer := NewGenericBuffer[string]()
    stringBuffer.Write("hello")
    stringBuffer.Write("world")
    
    fmt.Printf("String buffer size: %d\n", stringBuffer.Size())
    
    stringValue := stringBuffer.Read()
    fmt.Printf("Read from string buffer: %s\n", stringValue)
}

// 泛型接口约束
type ComparableProcessor[T comparable] interface {
    Process(T) T
    Equals(T) bool
}

type OrderedProcessor[T constraints.Ordered] interface {
    ComparableProcessor[T]
    Compare(T) int
}

// 实现有序处理器
type GenericOrderedProcessor[T constraints.Ordered] struct {
    value T
}

func NewGenericOrderedProcessor[T constraints.Ordered](value T) *GenericOrderedProcessor[T] {
    return &GenericOrderedProcessor[T]{value: value}
}

func (gop *GenericOrderedProcessor[T]) Process(input T) T {
    return gop.value
}

func (gop *GenericOrderedProcessor[T]) Equals(other T) bool {
    return gop.value == other
}

func (gop *GenericOrderedProcessor[T]) Compare(other T) int {
    if gop.value < other {
        return -1
    } else if gop.value > other {
        return 1
    }
    return 0
}

func demonstrateInterfaceConstraints() {
    fmt.Println("\n=== 泛型接口约束 ===")
    
    // 整数有序处理器
    intProcessor := NewGenericOrderedProcessor(42)
    fmt.Printf("Int processor equals 42: %t\n", intProcessor.Equals(42))
    fmt.Printf("Int processor equals 50: %t\n", intProcessor.Equals(50))
    fmt.Printf("Int processor compare 30: %d\n", intProcessor.Compare(30))
    fmt.Printf("Int processor compare 50: %d\n", intProcessor.Compare(50))
    
    // 字符串有序处理器
    stringProcessor := NewGenericOrderedProcessor("hello")
    fmt.Printf("String processor equals \"hello\": %t\n", stringProcessor.Equals("hello"))
    fmt.Printf("String processor compare \"world\": %d\n", stringProcessor.Compare("world"))
    fmt.Printf("String processor compare \"abc\": %d\n", stringProcessor.Compare("abc"))
}

// 泛型接口工厂模式
type GenericFactory[T any] interface {
    Create() T
}

type GenericIntFactory struct {
    defaultValue int
}

func NewGenericIntFactory(defaultValue int) *GenericIntFactory {
    return &GenericIntFactory{defaultValue: defaultValue}
}

func (gif *GenericIntFactory) Create() int {
    return gif.defaultValue
}

type GenericStringFactory struct {
    defaultValue string
}

func NewGenericStringFactory(defaultValue string) *GenericStringFactory {
    return &GenericStringFactory{defaultValue: defaultValue}
}

func (gsf *GenericStringFactory) Create() string {
    return gsf.defaultValue
}

func demonstrateFactoryPattern() {
    fmt.Println("\n=== 泛型接口工厂模式 ===")
    
    // 整数工厂
    intFactory := NewGenericIntFactory(42)
    intValue := intFactory.Create()
    fmt.Printf("Int factory created: %d\n", intValue)
    
    // 字符串工厂
    stringFactory := NewGenericStringFactory("hello")
    stringValue := stringFactory.Create()
    fmt.Printf("String factory created: %s\n", stringValue)
    
    // 泛型工厂函数
    createFactory := func[T any](defaultValue T) GenericFactory[T] {
        return &genericFactoryImpl[T]{value: defaultValue}
    }
    
    // 使用泛型工厂
    genericIntFactory := createFactory(100)
    genericIntValue := genericIntFactory.Create()
    fmt.Printf("Generic int factory created: %d\n", genericIntValue)
    
    genericStringFactory := createFactory("world")
    genericStringValue := genericStringFactory.Create()
    fmt.Printf("Generic string factory created: %s\n", genericStringValue)
}

type genericFactoryImpl[T any] struct {
    value T
}

func (gfi *genericFactoryImpl[T]) Create() T {
    return gfi.value
}

// 泛型接口策略模式
type GenericStrategy[T any] interface {
    Execute(T) T
}

type AddStrategy[T constraints.Number] struct {
    value T
}

func NewAddStrategy[T constraints.Number](value T) *AddStrategy[T] {
    return &AddStrategy[T]{value: value}
}

func (as *AddStrategy[T]) Execute(input T) T {
    return input + as.value
}

type MultiplyStrategy[T constraints.Number] struct {
    value T
}

func NewMultiplyStrategy[T constraints.Number](value T) *MultiplyStrategy[T] {
    return &MultiplyStrategy[T]{value: value}
}

func (ms *MultiplyStrategy[T]) Execute(input T) T {
    return input * ms.value
}

type GenericContext[T any] struct {
    strategy GenericStrategy[T]
}

func NewGenericContext[T any](strategy GenericStrategy[T]) *GenericContext[T] {
    return &GenericContext[T]{strategy: strategy}
}

func (gc *GenericContext[T]) SetStrategy(strategy GenericStrategy[T]) {
    gc.strategy = strategy
}

func (gc *GenericContext[T]) Execute(value T) T {
    return gc.strategy.Execute(value)
}

func demonstrateStrategyPattern() {
    fmt.Println("\n=== 泛型接口策略模式 ===")
    
    // 加法策略
    addStrategy := NewAddStrategy(10)
    context := NewGenericContext(addStrategy)
    result := context.Execute(5)
    fmt.Printf("Add strategy result: %d\n", result)
    
    // 乘法策略
    multiplyStrategy := NewMultiplyStrategy(3)
    context.SetStrategy(multiplyStrategy)
    result = context.Execute(5)
    fmt.Printf("Multiply strategy result: %d\n", result)
    
    // 浮点数策略
    floatAddStrategy := NewAddStrategy(2.5)
    floatContext := NewGenericContext(floatAddStrategy)
    floatResult := floatContext.Execute(3.14)
    fmt.Printf("Float add strategy result: %.2f\n", floatResult)
}

// 泛型接口观察者模式
type GenericObserver[T any] interface {
    Update(T)
}

type GenericSubject[T any] interface {
    Attach(GenericObserver[T])
    Detach(GenericObserver[T])
    Notify(T)
}

type GenericSubjectImpl[T any] struct {
    observers []GenericObserver[T]
}

func NewGenericSubjectImpl[T any]() *GenericSubjectImpl[T] {
    return &GenericSubjectImpl[T]{observers: make([]GenericObserver[T], 0)}
}

func (gsi *GenericSubjectImpl[T]) Attach(observer GenericObserver[T]) {
    gsi.observers = append(gsi.observers, observer)
}

func (gsi *GenericSubjectImpl[T]) Detach(observer GenericObserver[T]) {
    for i, obs := range gsi.observers {
        if obs == observer {
            gsi.observers = append(gsi.observers[:i], gsi.observers[i+1:]...)
            break
        }
    }
}

func (gsi *GenericSubjectImpl[T]) Notify(data T) {
    for _, observer := range gsi.observers {
        observer.Update(data)
    }
}

// 具体观察者实现
type ConsoleObserver[T any] struct {
    name string
}

func NewConsoleObserver[T any](name string) *ConsoleObserver[T] {
    return &ConsoleObserver[T]{name: name}
}

func (co *ConsoleObserver[T]) Update(data T) {
    fmt.Printf("Observer %s received: %v\n", co.name, data)
}

func demonstrateObserverPattern() {
    fmt.Println("\n=== 泛型接口观察者模式 ===")
    
    // 创建主题
    subject := NewGenericSubjectImpl[int]()
    
    // 创建观察者
    observer1 := NewConsoleObserver[int]("Observer1")
    observer2 := NewConsoleObserver[int]("Observer2")
    
    // 注册观察者
    subject.Attach(observer1)
    subject.Attach(observer2)
    
    // 通知观察者
    subject.Notify(42)
    subject.Notify(100)
    
    // 移除观察者
    subject.Detach(observer1)
    subject.Notify(200)
}

// 泛型接口最佳实践
func genericInterfaceBestPractices() {
    fmt.Println("\n=== 泛型接口最佳实践 ===")
    
    fmt.Println("1. 接口设计原则:")
    fmt.Println("   - 保持接口简单明确")
    fmt.Println("   - 使用合适的类型约束")
    fmt.Println("   - 避免过度复杂的接口")
    
    fmt.Println("\n2. 约束选择:")
    fmt.Println("   - any: 通用约束")
    fmt.Println("   - comparable: 相等性约束")
    fmt.Println("   - constraints.Ordered: 有序约束")
    fmt.Println("   - 自定义约束: 特定需求")
    
    fmt.Println("\n3. 设计模式:")
    fmt.Println("   - 工厂模式")
    fmt.Println("   - 策略模式")
    fmt.Println("   - 观察者模式")
    fmt.Println("   - 适配器模式")
    
    fmt.Println("\n4. 性能考虑:")
    fmt.Println("   - 避免不必要的接口调用")
    fmt.Println("   - 考虑内联优化")
    fmt.Println("   - 减少内存分配")
    
    fmt.Println("\n5. 可维护性:")
    fmt.Println("   - 提供清晰的文档")
    fmt.Println("   - 使用有意义的名称")
    fmt.Println("   - 考虑向后兼容性")
}

func main() {
    demonstrateBasicGenericInterfaces()
    demonstrateMethodConstrainedInterfaces()
    demonstrateMultiTypeInterfaces()
    demonstrateInterfaceComposition()
    demonstrateInterfaceConstraints()
    demonstrateFactoryPattern()
    demonstrateStrategyPattern()
    demonstrateObserverPattern()
    genericInterfaceBestPractices()
}
```

### 约束接口

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 基本约束接口
type Integer interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type Float interface {
    ~float32 | ~float64
}

type Complex interface {
    ~complex64 | ~complex128
}

type Number interface {
    Integer | Unsigned | Float | Complex
}

type Ordered interface {
    Integer | Unsigned | Float | ~string
}

func demonstrateBasicConstraints() {
    fmt.Println("=== 基本约束接口 ===")
    
    // 使用整数约束
    func Sum[T Integer](a, b T) T {
        return a + b
    }
    
    fmt.Printf("Sum(5, 3): %v\n", Sum(5, 3))
    fmt.Printf("Sum(int64(100), int64(200)): %v\n", Sum(int64(100), int64(200)))
    
    // 使用数值约束
    func Product[T Number](a, b T) T {
        return a * b
    }
    
    fmt.Printf("Product(5, 3): %v\n", Product(5, 3))
    fmt.Printf("Product(3.14, 2.0): %v\n", Product(3.14, 2.0))
    fmt.Printf("Product(complex(1, 2), complex(3, 4)): %v\n", 
        Product(complex(1, 2), complex(3, 4)))
    
    // 使用有序约束
    func Max[T Ordered](a, b T) T {
        if a > b {
            return a
        }
        return b
    }
    
    fmt.Printf("Max(5, 3): %v\n", Max(5, 3))
    fmt.Printf("Max(3.14, 2.71): %v\n", Max(3.14, 2.71))
    fmt.Printf("Max(\"hello\", \"world\"): %v\n", Max("hello", "world"))
}

// 复合约束接口
type ComparableNumber interface {
    constraints.Ordered
    constraints.Number
}

type SignedNumber interface {
    constraints.Signed
    constraints.Number
}

type UnsignedNumber interface {
    constraints.Unsigned
    constraints.Number
}

type FloatNumber interface {
    constraints.Float
    constraints.Number
}

func demonstrateCompositeConstraints() {
    fmt.Println("\n=== 复合约束接口 ===")
    
    // 使用可比较数值约束
    func CompareNumbers[T ComparableNumber](a, b T) int {
        if a < b {
            return -1
        } else if a > b {
            return 1
        }
        return 0
    }
    
    fmt.Printf("CompareNumbers(5, 3): %d\n", CompareNumbers(5, 3))
    fmt.Printf("CompareNumbers(3.14, 2.71): %d\n", CompareNumbers(3.14, 2.71))
    
    // 使用有符号数值约束
    func Abs[T SignedNumber](value T) T {
        if value < 0 {
            return -value
        }
        return value
    }
    
    fmt.Printf("Abs(-5): %v\n", Abs(-5))
    fmt.Printf("Abs(-3.14): %v\n", Abs(-3.14))
    fmt.Printf("Abs(int64(-100)): %v\n", Abs(int64(-100)))
    
    // 使用无符号数值约束
    func Double[T UnsignedNumber](value T) T {
        return value * 2
    }
    
    fmt.Printf("Double(uint(5)): %v\n", Double(uint(5)))
    fmt.Printf("Double(uint64(100)): %v\n", Double(uint64(100)))
    
    // 使用浮点数约束
    func Round[T FloatNumber](value T) T {
        // 简化实现
        return value
    }
    
    fmt.Printf("Round(3.14159): %v\n", Round(3.14159))
    fmt.Printf("Round(float32(2.71828)): %v\n", Round(float32(2.71828)))
}

// 自定义约束接口
type Addable interface {
    type int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, complex64, complex128,
         string
}

type Subtractable interface {
    type int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, complex64, complex128
}

type Multiplicable interface {
    type int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, complex64, complex128
}

type Divisible interface {
    type int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, complex64, complex128
}

func demonstrateCustomConstraints() {
    fmt.Println("\n=== 自定义约束接口 ===")
    
    // 使用可加约束
    func Add[T Addable](a, b T) T {
        return a + b
    }
    
    fmt.Printf("Add(5, 3): %v\n", Add(5, 3))
    fmt.Printf("Add(3.14, 2.71): %v\n", Add(3.14, 2.71))
    fmt.Printf("Add(\"hello\", \" world\"): %v\n", Add("hello", " world"))
    
    // 使用可减约束
    func Subtract[T Subtractable](a, b T) T {
        return a - b
    }
    
    fmt.Printf("Subtract(10, 3): %v\n", Subtract(10, 3))
    fmt.Printf("Subtract(5.5, 2.2): %v\n", Subtract(5.5, 2.2))
    
    // 使用可乘约束
    func Multiply[T Multiplicable](a, b T) T {
        return a * b
    }
    
    fmt.Printf("Multiply(6, 7): %v\n", Multiply(6, 7))
    fmt.Printf("Multiply(3.14, 2.0): %v\n", Multiply(3.14, 2.0))
    
    // 使用可除约束
    func Divide[T Divisible](a, b T) T {
        if b == 0 {
            panic("division by zero")
        }
        return a / b
    }
    
    fmt.Printf("Divide(10, 2): %v\n", Divide(10, 2))
    fmt.Printf("Divide(3.14, 2.0): %v\n", Divide(3.14, 2.0))
}

// 约束接口继承
type BasicConstraint interface {
    constraints.Ordered
}

type ExtendedConstraint interface {
    BasicConstraint
    fmt.Stringer
}

type AdvancedConstraint interface {
    ExtendedConstraint
    constraints.Complex
}

func demonstrateConstraintInheritance() {
    fmt.Println("\n=== 约束接口继承 ===")
    
    // 使用基础约束
    func BasicCompare[T BasicConstraint](a, b T) bool {
        return a == b
    }
    
    fmt.Printf("BasicCompare(5, 5): %t\n", BasicCompare(5, 5))
    fmt.Printf("BasicCompare(\"hello\", \"world\"): %t\n", BasicCompare("hello", "world"))
    
    // 使用扩展约束
    type PrintableInt int
    
    func (p PrintableInt) String() string {
        return fmt.Sprintf("PrintableInt(%d)", int(p))
    }
    
    func ExtendedProcess[T ExtendedConstraint](value T) string {
        return "Extended: " + value.String()
    }
    
    printableInt := PrintableInt(42)
    fmt.Printf("ExtendedProcess(printableInt): %s\n", ExtendedProcess(printableInt))
    
    // 使用高级约束
    func AdvancedOperation[T AdvancedConstraint](value T) string {
        return fmt.Sprintf("Advanced: %s, Complex: %v", value.String(), value)
    }
    
    type AdvancedType struct {
        value complex128
    }
    
    func (at AdvancedType) String() string {
        return fmt.Sprintf("AdvancedType(%v)", at.value)
    }
    
    advancedValue := AdvancedType{value: complex(1, 2)}
    // fmt.Printf("AdvancedOperation(advancedValue): %s\n", AdvancedOperation(advancedValue))
}

// 约束接口组合
type Readable interface {
    Read() []byte
}

type Writable interface {
    Write([]byte) (int, error)
}

type ReadWrite interface {
    Readable
    Writable
}

type Closeable interface {
    Close() error
}

type ReadWriteCloseable interface {
    ReadWrite
    Closeable
}

func demonstrateConstraintComposition() {
    fmt.Println("\n=== 约束接口组合 ===")
    
    // 模拟文件类型实现接口
    type MockFile struct {
        data []byte
        pos  int
    }
    
    func NewMockFile(data []byte) *MockFile {
        return &MockFile{data: data}
    }
    
    func (mf *MockFile) Read() []byte {
        if mf.pos >= len(mf.data) {
            return nil
        }
        result := mf.data[mf.pos:]
        mf.pos = len(mf.data)
        return result
    }
    
    func (mf *MockFile) Write(data []byte) (int, error) {
        mf.data = append(mf.data, data...)
        return len(data), nil
    }
    
    func (mf *MockFile) Close() error {
        mf.data = nil
        mf.pos = 0
        return nil
    }
    
    // 使用读写关闭约束
    func ProcessReadWriteCloseable[T ReadWriteCloseable](rwc T) error {
        data := rwc.Read()
        if data != nil {
            fmt.Printf("Read data: %s\n", string(data))
        }
        
        _, err := rwc.Write([]byte("Hello, World!"))
        if err != nil {
            return err
        }
        
        return rwc.Close()
    }
    
    mockFile := NewMockFile([]byte("Initial data"))
    err := ProcessReadWriteCloseable(mockFile)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Println("ReadWriteCloseable processed successfully")
    }
}

// 约束接口参数化
type Container[T any] interface {
    Add(T)
    Get(int) (T, bool)
    Size() int
}

type SliceContainer[T any] struct {
    items []T
}

func NewSliceContainer[T any]() *SliceContainer[T] {
    return &SliceContainer[T]{items: make([]T, 0)}
}

func (sc *SliceContainer[T]) Add(item T) {
    sc.items = append(sc.items, item)
}

func (sc *SliceContainer[T]) Get(index int) (T, bool) {
    var zero T
    if index < 0 || index >= len(sc.items) {
        return zero, false
    }
    return sc.items[index], true
}

func (sc *SliceContainer[T]) Size() int {
    return len(sc.items)
}

func demonstrateParameterizedConstraints() {
    fmt.Println("\n=== 约束接口参数化 ===")
    
    // 使用容器约束
    func ProcessContainer[T any, C Container[T]](container C, items []T) {
        for _, item := range items {
            container.Add(item)
        }
        
        fmt.Printf("Container size: %d\n", container.Size())
        
        for i := 0; i < container.Size(); i++ {
            if item, ok := container.Get(i); ok {
                fmt.Printf("  Item %d: %v\n", i, item)
            }
        }
    }
    
    // 整数容器
    intContainer := NewSliceContainer[int]()
    intItems := []int{1, 2, 3, 4, 5}
    ProcessContainer(intContainer, intItems)
    
    // 字符串容器
    stringContainer := NewSliceContainer[string]()
    stringItems := []string{"apple", "banana", "cherry"}
    ProcessContainer(stringContainer, stringItems)
}

// 约束接口与泛型函数结合
func Filter[T any](slice []T, predicate func(T) bool) []T {
    result := make([]T, 0)
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

func Map[T, U any](slice []T, mapper func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = mapper(v)
    }
    return result
}

func Reduce[T, U any](slice []T, initial U, reducer func(U, T) U) U {
    result := initial
    for _, v := range slice {
        result = reducer(result, v)
    }
    return result
}

func demonstrateConstraintWithGenericFunctions() {
    fmt.Println("\n=== 约束接口与泛型函数结合 ===")
    
    // 使用约束的泛型函数
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    // 过滤偶数
    evenNumbers := Filter(numbers, func(n int) bool {
        return n%2 == 0
    })
    fmt.Printf("Even numbers: %v\n", evenNumbers)
    
    // 映射平方
    squares := Map(numbers, func(n int) int {
        return n * n
    })
    fmt.Printf("Squares: %v\n", squares)
    
    // 归约求和
    sum := Reduce(numbers, 0, func(acc int, n int) int {
        return acc + n
    })
    fmt.Printf("Sum: %d\n", sum)
    
    // 字符串操作
    strings := []string{"apple", "banana", "cherry", "date"}
    
    // 过滤长字符串
    longStrings := Filter(strings, func(s string) bool {
        return len(s) > 5
    })
    fmt.Printf("Long strings: %v\n", longStrings)
    
    // 映射大写
    upperStrings := Map(strings, func(s string) string {
        return fmt.Sprintf("[%s]", s)
    })
    fmt.Printf("Formatted strings: %v\n", upperStrings)
    
    // 归约连接
    concat := Reduce(strings, "", func(acc string, s string) string {
        if acc == "" {
            return s
        }
        return acc + ", " + s
    })
    fmt.Printf("Concatenated: %s\n", concat)
}

// 约束接口性能优化
type FastNumber interface {
    constraints.Integer | constraints.Float
}

func demonstratePerformanceOptimization() {
    fmt.Println("\n=== 约束接口性能优化 ===")
    
    // 性能测试函数
    func BenchmarkOperation[T FastNumber](data []T, operation func(T, T) T) T {
        result := data[0]
        for i := 1; i < len(data); i++ {
            result = operation(result, data[i])
        }
        return result
    }
    
    // 整数数组
    intData := make([]int, 1000000)
    for i := range intData {
        intData[i] = i
    }
    
    // 浮点数数组
    floatData := make([]float64, 1000000)
    for i := range floatData {
        floatData[i] = float64(i) * 0.1
    }
    
    fmt.Println("Performance optimization example:")
    fmt.Printf("Integer data size: %d\n", len(intData))
    fmt.Printf("Float data size: %d\n", len(floatData))
    
    // 这些操作会被编译器优化为具体类型的代码
    intSum := BenchmarkOperation(intData, func(a, b int) int { return a + b })
    floatSum := BenchmarkOperation(floatData, func(a, b float64) float64 { return a + b })
    
    fmt.Printf("Integer sum (first 10): %d\n", intSum)
    fmt.Printf("Float sum (first 10): %.2f\n", floatSum)
}

// 约束接口最佳实践
func constraintInterfaceBestPractices() {
    fmt.Println("\n=== 约束接口最佳实践 ===")
    
    fmt.Println("1. 约束设计:")
    fmt.Println("   - 使用标准库约束")
    fmt.Println("   - 避免过度复杂的约束")
    fmt.Println("   - 考虑约束的可组合性")
    
    fmt.Println("\n2. 命名规范:")
    fmt.Println("   - 使用描述性名称")
    fmt.Println("   - 遵循Go命名约定")
    fmt.Println("   - 避免缩写和模糊名称")
    
    fmt.Println("\n3. 性能考虑:")
    fmt.Println("   - 选择合适的约束")
    fmt.Println("   - 避免不必要的约束")
    fmt.Println("   - 考虑编译时优化")
    
    fmt.Println("\n4. 可维护性:")
    fmt.Println("   - 提供清晰的文档")
    fmt.Println("   - 使用示例代码")
    fmt.Println("   - 考虑向后兼容性")
    
    fmt.Println("\n5. 常用模式:")
    fmt.Println("   - 数值类型约束")
    fmt.Println("   - 有序类型约束")
    fmt.Println("   - 可比较类型约束")
    fmt.Println("   - 接口组合约束")
}

func main() {
    demonstrateBasicConstraints()
    demonstrateCompositeConstraints()
    demonstrateCustomConstraints()
    demonstrateConstraintInheritance()
    demonstrateConstraintComposition()
    demonstrateParameterizedConstraints()
    demonstrateConstraintWithGenericFunctions()
    demonstratePerformanceOptimization()
    constraintInterfaceBestPractices()
}
```

### 泛型性能优化

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
    "testing"
    "time"
)

// 基本性能对比
func demonstrateBasicPerformance() {
    fmt.Println("=== 基本性能对比 ===")
    
    // 非泛型函数
    func IntMax(a, b int) int {
        if a > b {
            return a
        }
        return b
    }
    
    // 泛型函数
    func GenericMax[T constraints.Ordered](a, b T) T {
        if a > b {
            return a
        }
        return b
    }
    
    // 性能测试
    iterations := 10000000
    a, b := 5, 3
    
    // 测试非泛型函数
    start := time.Now()
    for i := 0; i < iterations; i++ {
        _ = IntMax(a, b)
    }
    intTime := time.Since(start)
    
    // 测试泛型函数
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = GenericMax(a, b)
    }
    genericTime := time.Since(start)
    
    fmt.Printf("IntMax time: %v\n", intTime)
    fmt.Printf("GenericMax time: %v\n", genericTime)
    fmt.Printf("Performance ratio: %.2fx\n", float64(genericTime)/float64(intTime))
}

// 内存分配优化
func demonstrateMemoryOptimization() {
    fmt.Println("\n=== 内存分配优化 ===")
    
    // 低效的泛型函数（会产生内存分配）
    func InefficientFilter[T any](slice []T, predicate func(T) bool) []T {
        result := make([]T, 0)  // 每次都分配新切片
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)  // 可能触发重新分配
            }
        }
        return result
    }
    
    // 优化的泛型函数
    func EfficientFilter[T any](slice []T, predicate func(T) bool) []T {
        if len(slice) == 0 {
            return slice
        }
        
        // 预分配合理容量
        result := make([]T, 0, len(slice)/2+1)
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    // 零分配过滤器
    func ZeroAllocFilter[T any](slice []T, predicate func(T) bool, result []T) []T {
        result = result[:0]  // 重用现有切片
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    // 性能测试
    data := make([]int, 10000)
    for i := range data {
        data[i] = i
    }
    
    // 测试低效版本
    start := time.Now()
    for i := 0; i < 1000; i++ {
        result := InefficientFilter(data, func(n int) bool { return n%2 == 0 })
        _ = len(result)
    }
    inefficientTime := time.Since(start)
    
    // 测试优化版本
    start = time.Now()
    for i := 0; i < 1000; i++ {
        result := EfficientFilter(data, func(n int) bool { return n%2 == 0 })
        _ = len(result)
    }
    efficientTime := time.Since(start)
    
    // 测试零分配版本
    reusableSlice := make([]int, 0, len(data))
    start = time.Now()
    for i := 0; i < 1000; i++ {
        result := ZeroAllocFilter(data, func(n int) bool { return n%2 == 0 }, reusableSlice)
        _ = len(result)
        reusableSlice = result  // 重用结果切片
    }
    zeroAllocTime := time.Since(start)
    
    fmt.Printf("Inefficient filter time: %v\n", inefficientTime)
    fmt.Printf("Efficient filter time: %v\n", efficientTime)
    fmt.Printf("Zero alloc filter time: %v\n", zeroAllocTime)
    fmt.Printf("Improvement ratio: %.2fx\n", float64(inefficientTime)/float64(zeroAllocTime))
}

// 编译时优化示例
func demonstrateCompileTimeOptimization() {
    fmt.Println("\n=== 编译时优化示例 ===")
    
    // 泛型函数会被编译器为每个具体类型生成优化版本
    func ProcessNumbers[T constraints.Number](numbers []T) T {
        var sum T
        for _, n := range numbers {
            sum += n
        }
        return sum
    }
    
    // 编译器会为int和float64分别生成优化版本
    intNumbers := []int{1, 2, 3, 4, 5}
    floatNumbers := []float64{1.1, 2.2, 3.3, 4.4, 5.5}
    
    intSum := ProcessNumbers(intNumbers)
    floatSum := ProcessNumbers(floatNumbers)
    
    fmt.Printf("Int sum: %d\n", intSum)
    fmt.Printf("Float sum: %.2f\n", floatSum)
    
    // 这些调用在编译时会被优化为具体类型的高效代码
}

// 缓存友好的泛型设计
func demonstrateCacheFriendlyDesign() {
    fmt.Println("\n=== 缓存友好的泛型设计 ===")
    
    // 紧凑的数据结构
    type CompactStruct[T constraints.Number] struct {
        X, Y, Z T
    }
    
    // 松散的数据结构
    type LooseStruct[T constraints.Number] struct {
        X T
        _ [7]T  // 填充字段
        Y T
        _ [7]T  // 填充字段
        Z T
    }
    
    // 性能测试
    const size = 1000000
    
    // 紧凑结构测试
    compactData := make([]CompactStruct[int], size)
    for i := range compactData {
        compactData[i] = CompactStruct[int]{X: int(i), Y: int(i * 2), Z: int(i * 3)}
    }
    
    start := time.Now()
    var compactSum int
    for _, s := range compactData {
        compactSum += s.X + s.Y + s.Z
    }
    compactTime := time.Since(start)
    
    // 松散结构测试
    looseData := make([]LooseStruct[int], size)
    for i := range looseData {
        looseData[i] = LooseStruct[int]{X: int(i), Y: int(i * 2), Z: int(i * 3)}
    }
    
    start = time.Now()
    var looseSum int
    for _, s := range looseData {
        looseSum += s.X + s.Y + s.Z
    }
    looseTime := time.Since(start)
    
    fmt.Printf("Compact struct time: %v\n", compactTime)
    fmt.Printf("Loose struct time: %v\n", looseTime)
    fmt.Printf("Compact is %.2fx faster\n", float64(looseTime)/float64(compactTime))
    fmt.Printf("Results: %d, %d\n", compactSum, looseSum)
}

// 算法优化示例
func demonstrateAlgorithmOptimization() {
    fmt.Println("\n=== 算法优化示例 ===")
    
    // 优化的排序算法
    func OptimizedQuickSort[T constraints.Ordered](slice []T) {
        if len(slice) <= 1 {
            return
        }
        optimizedQuickSortHelper(slice, 0, len(slice)-1)
    }
    
    func optimizedQuickSortHelper[T constraints.Ordered](slice []T, low, high int) {
        // 对于小数组使用插入排序
        if high-low < 10 {
            insertionSort(slice[low : high+1])
            return
        }
        
        if low < high {
            pivot := optimizedPartition(slice, low, high)
            optimizedQuickSortHelper(slice, low, pivot-1)
            optimizedQuickSortHelper(slice, pivot+1, high)
        }
    }
    
    func optimizedPartition[T constraints.Ordered](slice []T, low, high int) int {
        // 三数取中法选择基准
        mid := (low + high) / 2
        if slice[mid] < slice[low] {
            slice[low], slice[mid] = slice[mid], slice[low]
        }
        if slice[high] < slice[low] {
            slice[low], slice[high] = slice[high], slice[low]
        }
        if slice[high] < slice[mid] {
            slice[mid], slice[high] = slice[high], slice[mid]
        }
        
        pivot := slice[high]
        i := low - 1
        
        for j := low; j < high; j++ {
            if slice[j] <= pivot {
                i++
                slice[i], slice[j] = slice[j], slice[i]
            }
        }
        
        slice[i+1], slice[high] = slice[high], slice[i+1]
        return i + 1
    }
    
    func insertionSort[T constraints.Ordered](slice []T) {
        for i := 1; i < len(slice); i++ {
            key := slice[i]
            j := i - 1
            for j >= 0 && slice[j] > key {
                slice[j+1] = slice[j]
                j--
            }
            slice[j+1] = key
        }
    }
    
    // 标准库排序对比
    import "sort"
    
    // 生成测试数据
    data1 := make([]int, 10000)
    data2 := make([]int, 10000)
    for i := range data1 {
        data1[i] = 10000 - i  // 逆序数据
        data2[i] = data1[i]
    }
    
    // 测试优化的快速排序
    start := time.Now()
    OptimizedQuickSort(data1)
    optimizedTime := time.Since(start)
    
    // 测试标准库排序
    start = time.Now()
    sort.Ints(data2)
    standardTime := time.Since(start)
    
    fmt.Printf("Optimized quicksort time: %v\n", optimizedTime)
    fmt.Printf("Standard library sort time: %v\n", standardTime)
    fmt.Printf("Performance ratio: %.2fx\n", float64(standardTime)/float64(optimizedTime))
}

// 内联优化示例
func demonstrateInliningOptimization() {
    fmt.Println("\n=== 内联优化示例 ===")
    
    // 简单的泛型函数更容易被内联
    func SimpleAdd[T constraints.Number](a, b T) T {
        return a + b
    }
    
    // 复杂的泛型函数可能不会被内联
    func ComplexOperation[T constraints.Number](a, b T) T {
        if a > b {
            return a * 2 + b
        } else if a < b {
            return b * 2 + a
        } else {
            return a * b
        }
    }
    
    // 性能测试
    iterations := 10000000
    a, b := 5, 3
    
    // 测试简单函数
    start := time.Now()
    for i := 0; i < iterations; i++ {
        _ = SimpleAdd(a, b)
    }
    simpleTime := time.Since(start)
    
    // 测试复杂函数
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = ComplexOperation(a, b)
    }
    complexTime := time.Since(start)
    
    fmt.Printf("Simple function time: %v\n", simpleTime)
    fmt.Printf("Complex function time: %v\n", complexTime)
    fmt.Printf("Simple function is %.2fx faster\n", float64(complexTime)/float64(simpleTime))
}

// 并发安全的泛型优化
func demonstrateConcurrentOptimization() {
    fmt.Println("\n=== 并发安全的泛型优化 ===")
    
    import "sync"
    
    // 线程安全的泛型计数器
    type SafeCounter[T comparable] struct {
        mu    sync.RWMutex
        count map[T]int
    }
    
    func NewSafeCounter[T comparable]() *SafeCounter[T] {
        return &SafeCounter[T]{
            count: make(map[T]int),
        }
    }
    
    func (sc *SafeCounter[T]) Increment(key T) {
        sc.mu.Lock()
        sc.count[key]++
        sc.mu.Unlock()
    }
    
    func (sc *SafeCounter[T]) Get(key T) int {
        sc.mu.RLock()
        defer sc.mu.RUnlock()
        return sc.count[key]
    }
    
    // 无锁的泛型计数器（使用原子操作）
    import "sync/atomic"
    
    type AtomicCounter struct {
        count int64
    }
    
    func (ac *AtomicCounter) Increment() int64 {
        return atomic.AddInt64(&ac.count, 1)
    }
    
    func (ac *AtomicCounter) Get() int64 {
        return atomic.LoadInt64(&ac.count)
    }
    
    // 性能测试
    const goroutines = 100
    const operations = 10000
    
    // 测试线程安全计数器
    safeCounter := NewSafeCounter[string]()
    start := time.Now()
    
    var wg sync.WaitGroup
    for i := 0; i < goroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < operations; j++ {
                safeCounter.Increment(fmt.Sprintf("key_%d", id))
            }
        }(i)
    }
    wg.Wait()
    
    safeTime := time.Since(start)
    fmt.Printf("Safe counter time: %v\n", safeTime)
    fmt.Printf("Safe counter final count: %d\n", safeCounter.Get("key_0"))
    
    // 测试原子计数器
    atomicCounter := &AtomicCounter{}
    start = time.Now()
    
    var wg2 sync.WaitGroup
    for i := 0; i < goroutines; i++ {
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            for j := 0; j < operations; j++ {
                atomicCounter.Increment()
            }
        }()
    }
    wg2.Wait()
    
    atomicTime := time.Since(start)
    fmt.Printf("Atomic counter time: %v\n", atomicTime)
    fmt.Printf("Atomic counter final count: %d\n", atomicCounter.Get())
    fmt.Printf("Atomic is %.2fx faster\n", float64(safeTime)/float64(atomicTime))
}

// 内存池优化
func demonstrateMemoryPoolOptimization() {
    fmt.Println("\n=== 内存池优化示例 ===")
    
    import "sync"
    
    // 泛型对象池
    type ObjectPool[T any] struct {
        pool sync.Pool
    }
    
    func NewObjectPool[T any](factory func() T) *ObjectPool[T] {
        return &ObjectPool[T]{
            pool: sync.Pool{
                New: func() interface{} {
                    return factory()
                },
            },
        }
    }
    
    func (op *ObjectPool[T]) Get() T {
        return op.pool.Get().(T)
    }
    
    func (op *ObjectPool[T]) Put(obj T) {
        op.pool.Put(obj)
    }
    
    // 测试对象
    type TestObject struct {
        data [1024]byte
        id   int
    }
    
    // 使用内存池
    pool := NewObjectPool(func() *TestObject {
        return &TestObject{}
    })
    
    // 不使用内存池
    start := time.Now()
    for i := 0; i < 100000; i++ {
        obj := &TestObject{id: i}
        _ = obj.id
    }
    withoutPoolTime := time.Since(start)
    
    // 使用内存池
    start = time.Now()
    for i := 0; i < 100000; i++ {
        obj := pool.Get()
        obj.id = i
        _ = obj.id
        pool.Put(obj)
    }
    withPoolTime := time.Since(start)
    
    fmt.Printf("Without pool time: %v\n", withoutPoolTime)
    fmt.Printf("With pool time: %v\n", withPoolTime)
    fmt.Printf("Pool optimization: %.2fx faster\n", float64(withoutPoolTime)/float64(withPoolTime))
}

// 性能分析工具示例
func demonstratePerformanceAnalysis() {
    fmt.Println("\n=== 性能分析工具示例 ===")
    
    // 基准测试示例
    func BenchmarkGenericAdd(b *testing.B) {
        a, b := 5, 3
        for i := 0; i < b.N; i++ {
            _ = GenericAdd(a, b)
        }
    }
    
    func GenericAdd[T constraints.Number](a, b T) T {
        return a + b
    }
    
    // 内存分析示例
    func BenchmarkMemoryAllocation(b *testing.B) {
        data := make([]int, 1000)
        for i := range data {
            data[i] = i
        }
        
        b.ResetTimer()
        b.ReportAllocs()
        
        for i := 0; i < b.N; i++ {
            result := processSlice(data)
            _ = len(result)
        }
    }
    
    func processSlice[T any](slice []T) []T {
        // 避免内存分配的处理
        result := make([]T, 0, len(slice))
        for _, v := range slice {
            result = append(result, v)
        }
        return result
    }
    
    fmt.Println("Performance analysis tools:")
    fmt.Println("  - go test -bench=.")
    fmt.Println("  - go test -bench=. -benchmem")
    fmt.Println("  - go test -bench=. -cpuprofile=cpu.prof")
    fmt.Println("  - go test -bench=. -memprofile=mem.prof")
    fmt.Println("  - go tool pprof cpu.prof")
    fmt.Println("  - go tool pprof mem.prof")
}

// 泛型性能优化最佳实践
func genericPerformanceBestPractices() {
    fmt.Println("\n=== 泛型性能优化最佳实践 ===")
    
    fmt.Println("1. 编译时优化:")
    fmt.Println("   - 泛型函数为每个具体类型生成优化代码")
    fmt.Println("   - 简单的泛型函数更容易被内联")
    fmt.Println("   - 避免复杂的类型约束")
    
    fmt.Println("\n2. 内存优化:")
    fmt.Println("   - 预分配合理的切片容量")
    fmt.Println("   - 重用现有数据结构")
    fmt.Println("   - 避免不必要的内存分配")
    fmt.Println("   - 使用对象池减少GC压力")
    
    fmt.Println("\n3. 算法优化:")
    fmt.Println("   - 选择适合数据规模的算法")
    fmt.Println("   - 考虑缓存友好的数据布局")
    fmt.Println("   - 优化循环和递归")
    fmt.Println("   - 使用适当的排序和搜索算法")
    
    fmt.Println("\n4. 并发优化:")
    fmt.Println("   - 选择合适的同步机制")
    fmt.Println("   - 减少锁竞争")
    fmt.Println("   - 使用无锁数据结构")
    fmt.Println("   - 考虑并行处理")
    
    fmt.Println("\n5. 性能监控:")
    fmt.Println("   - 使用基准测试")
    fmt.Println("   - 分析内存分配")
    fmt.Println("   - 监控CPU使用")
    fmt.Println("   - 使用性能分析工具")
    
    fmt.Println("\n6. 设计原则:")
    fmt.Println("   - 优先考虑简单性")
    fmt.Println("   - 避免过早优化")
    fmt.Println("   - 基于实际性能数据优化")
    fmt.Println("   - 考虑维护性和可读性")
}

func main() {
    demonstrateBasicPerformance()
    demonstrateMemoryOptimization()
    demonstrateCompileTimeOptimization()
    demonstrateCacheFriendlyDesign()
    demonstrateAlgorithmOptimization()
    demonstrateInliningOptimization()
    demonstrateConcurrentOptimization()
    demonstrateMemoryPoolOptimization()
    demonstratePerformanceAnalysis()
    genericPerformanceBestPractices()
}
```

### 泛型最佳实践

```go
package main

import (
    "fmt"
    "golang.org/x/exp/constraints"
)

// 1. 选择合适的约束
func demonstrateConstraintSelection() {
    fmt.Println("=== 选择合适的约束 ===")
    
    // 好的做法：使用最具体的约束
    func GoodMax[T constraints.Ordered](a, b T) T {
        if a > b {
            return a
        }
        return b
    }
    
    // 不好的做法：使用过于宽泛的约束
    func BadMax[T any](a, b T) T {
        // 这里无法比较，因为any不保证可比较
        return a // 编译错误
    }
    
    // 示例使用
    fmt.Printf("GoodMax(5, 3): %v\n", GoodMax(5, 3))
    fmt.Printf("GoodMax(3.14, 2.71): %v\n", GoodMax(3.14, 2.71))
    fmt.Printf("GoodMax(\"hello\", \"world\"): %v\n", GoodMax("hello", "world"))
}

// 2. 保持简单明确
func demonstrateSimplicity() {
    fmt.Println("\n=== 保持简单明确 ===")
    
    // 好的做法：简单明确的泛型函数
    func SimpleFilter[T any](slice []T, predicate func(T) bool) []T {
        result := make([]T, 0)
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    // 不好的做法：过度复杂的泛型函数
    func ComplexFilter[T any, U any, V any](
        slice []T, 
        predicate func(T) bool,
        mapper func(T) U,
        reducer func([]U) V,
    ) V {
        // 过于复杂，难以理解和维护
        filtered := make([]T, 0)
        for _, v := range slice {
            if predicate(v) {
                filtered = append(filtered, v)
            }
        }
        
        mapped := make([]U, len(filtered))
        for i, v := range filtered {
            mapped[i] = mapper(v)
        }
        
        return reducer(mapped)
    }
    
    // 示例使用
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    evenNumbers := SimpleFilter(numbers, func(n int) bool {
        return n%2 == 0
    })
    fmt.Printf("Even numbers: %v\n", evenNumbers)
}

// 3. 提供清晰的文档
func demonstrateDocumentation() {
    fmt.Println("\n=== 提供清晰的文档 ===")
    
    // 好的做法：详细的文档注释
    // Max returns the larger of two values.
    // Both values must be of the same ordered type.
    // Supported types include numbers and strings.
    func Max[T constraints.Ordered](a, b T) T {
        if a > b {
            return a
        }
        return b
    }
    
    // 不好的做法：缺乏文档
    func Min[T constraints.Ordered](a, b T) T {
        if a < b {
            return a
        }
        return b
    }
    
    // 示例使用
    fmt.Printf("Max(5, 3): %v\n", Max(5, 3))
    fmt.Printf("Min(5, 3): %v\n", Min(5, 3))
}

// 4. 使用有意义的类型参数名称
func demonstrateMeaningfulNames() {
    fmt.Println("\n=== 使用有意义的类型参数名称 ===")
    
    // 好的做法：有意义的类型参数名称
    func ProcessMap[KeyType comparable, ValueType any](m map[KeyType]ValueType) int {
        return len(m)
    }
    
    // 不好的做法：模糊的类型参数名称
    func ProcessSlice[T any](s []T) int {
        return len(s)
    }
    
    // 更好的做法：根据用途命名
    func ProcessItems[Item any](items []Item) int {
        return len(items)
    }
    
    // 示例使用
    stringIntMap := map[string]int{"a": 1, "b": 2, "c": 3}
    fmt.Printf("Map size: %d\n", ProcessMap(stringIntMap))
    
    items := []string{"apple", "banana", "cherry"}
    fmt.Printf("Items count: %d\n", ProcessItems(items))
}

// 5. 错误处理和边界条件
func demonstrateErrorHandling() {
    fmt.Println("\n=== 错误处理和边界条件 ===")
    
    // 好的做法：处理边界条件
    func SafeDivide[T constraints.Float](a, b T) (T, error) {
        if b == 0 {
            var zero T
            return zero, fmt.Errorf("division by zero")
        }
        return a / b, nil
    }
    
    // 不好的做法：忽略错误处理
    func UnsafeDivide[T constraints.Float](a, b T) T {
        return a / b // 可能导致运行时错误
    }
    
    // 好的做法：处理空切片
    func SafeAverage[T constraints.Number](numbers []T) (float64, error) {
        if len(numbers) == 0 {
            return 0, fmt.Errorf("empty slice")
        }
        
        var sum T
        for _, n := range numbers {
            sum += n
        }
        
        return float64(sum) / float64(len(numbers)), nil
    }
    
    // 示例使用
    if result, err := SafeDivide(10.0, 2.0); err == nil {
        fmt.Printf("Safe division result: %.2f\n", result)
    }
    
    if result, err := SafeDivide(10.0, 0.0); err != nil {
        fmt.Printf("Division error: %v\n", err)
    }
    
    numbers := []int{1, 2, 3, 4, 5}
    if avg, err := SafeAverage(numbers); err == nil {
        fmt.Printf("Average: %.2f\n", avg)
    }
    
    emptyNumbers := []int{}
    if avg, err := SafeAverage(emptyNumbers); err != nil {
        fmt.Printf("Average error: %v\n", err)
    }
}

// 6. 性能考虑
func demonstratePerformanceConsiderations() {
    fmt.Println("\n=== 性能考虑 ===")
    
    // 好的做法：避免不必要的内存分配
    func EfficientFilter[T any](slice []T, predicate func(T) bool) []T {
        if len(slice) == 0 {
            return slice
        }
        
        // 预分配合理容量
        result := make([]T, 0, len(slice)/2+1)
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    // 不好的做法：每次都分配新切片
    func InefficientFilter[T any](slice []T, predicate func(T) bool) []T {
        result := make([]T, 0)  // 每次都分配
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)  // 可能触发重新分配
            }
        }
        return result
    }
    
    // 好的做法：重用数据结构
    func ReuseFilter[T any](slice []T, predicate func(T) bool, result []T) []T {
        result = result[:0]  // 重用现有切片
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    // 示例使用
    data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    evenNumbers := EfficientFilter(data, func(n int) bool {
        return n%2 == 0
    })
    fmt.Printf("Even numbers: %v\n", evenNumbers)
}

// 7. 接口兼容性
func demonstrateInterfaceCompatibility() {
    fmt.Println("\n=== 接口兼容性 ===")
    
    // 定义接口
    type Stringer interface {
        String() string
    }
    
    // 好的做法：实现标准接口
    type GenericStringer[T any] struct {
        value T
    }
    
    func NewGenericStringer[T any](value T) *GenericStringer[T] {
        return &GenericStringer[T]{value: value}
    }
    
    func (gs *GenericStringer[T]) String() string {
        return fmt.Sprintf("GenericStringer{%v}", gs.value)
    }
    
    func (gs *GenericStringer[T]) GetValue() T {
        return gs.value
    }
    
    // 示例使用
    intStringer := NewGenericStringer(42)
    fmt.Printf("Int stringer: %s\n", intStringer.String())
    
    stringStringer := NewGenericStringer("hello")
    fmt.Printf("String stringer: %s\n", stringStringer.String())
}

// 8. 测试和验证
func demonstrateTesting() {
    fmt.Println("\n=== 测试和验证 ===")
    
    // 泛型函数
    func GenericAdd[T constraints.Number](a, b T) T {
        return a + b
    }
    
    // 测试函数
    func TestGenericAdd() {
        // 测试整数
        result := GenericAdd(5, 3)
        if result != 8 {
            fmt.Printf("Integer test failed: expected 8, got %v\n", result)
        } else {
            fmt.Println("Integer test passed")
        }
        
        // 测试浮点数
        floatResult := GenericAdd(3.14, 2.71)
        if floatResult != 5.85 {
            fmt.Printf("Float test failed: expected 5.85, got %v\n", floatResult)
        } else {
            fmt.Println("Float test passed")
        }
        
        // 测试不同类型的数值
        int64Result := GenericAdd(int64(100), int64(200))
        if int64Result != 300 {
            fmt.Printf("Int64 test failed: expected 300, got %v\n", int64Result)
        } else {
            fmt.Println("Int64 test passed")
        }
    }
    
    TestGenericAdd()
}

// 9. 向后兼容性
func demonstrateBackwardCompatibility() {
    fmt.Println("\n=== 向后兼容性 ===")
    
    // 好的做法：保持API稳定
    type GenericContainer[T any] struct {
        items []T
    }
    
    func NewGenericContainer[T any]() *GenericContainer[T] {
        return &GenericContainer[T]{items: make([]T, 0)}
    }
    
    // 添加新方法而不改变现有API
    func (gc *GenericContainer[T]) Add(item T) {
        gc.items = append(gc.items, item)
    }
    
    func (gc *GenericContainer[T]) Get(index int) (T, bool) {
        var zero T
        if index < 0 || index >= len(gc.items) {
            return zero, false
        }
        return gc.items[index], true
    }
    
    // 新增方法
    func (gc *GenericContainer[T]) Size() int {
        return len(gc.items)
    }
    
    // 示例使用
    container := NewGenericContainer[string]()
    container.Add("hello")
    container.Add("world")
    
    if item, ok := container.Get(0); ok {
        fmt.Printf("First item: %s\n", item)
    }
    
    fmt.Printf("Container size: %d\n", container.Size())
}

// 10. 设计模式应用
func demonstrateDesignPatterns() {
    fmt.Println("\n=== 设计模式应用 ===")
    
    // 工厂模式
    type GenericFactory[T any] interface {
        Create() T
    }
    
    type IntFactory struct {
        defaultValue int
    }
    
    func NewIntFactory(defaultValue int) *IntFactory {
        return &IntFactory{defaultValue: defaultValue}
    }
    
    func (ifac *IntFactory) Create() int {
        return ifac.defaultValue
    }
    
    // 策略模式
    type GenericStrategy[T any] interface {
        Execute(T) T
    }
    
    type AddStrategy[T constraints.Number] struct {
        value T
    }
    
    func NewAddStrategy[T constraints.Number](value T) *AddStrategy[T] {
        return &AddStrategy[T]{value: value}
    }
    
    func (as *AddStrategy[T]) Execute(input T) T {
        return input + as.value
    }
    
    type GenericContext[T any] struct {
        strategy GenericStrategy[T]
    }
    
    func NewGenericContext[T any](strategy GenericStrategy[T]) *GenericContext[T] {
        return &GenericContext[T]{strategy: strategy}
    }
    
    func (gc *GenericContext[T]) SetStrategy(strategy GenericStrategy[T]) {
        gc.strategy = strategy
    }
    
    func (gc *GenericContext[T]) Execute(value T) T {
        return gc.strategy.Execute(value)
    }
    
    // 示例使用
    factory := NewIntFactory(42)
    value := factory.Create()
    fmt.Printf("Factory created: %d\n", value)
    
    addStrategy := NewAddStrategy(10)
    context := NewGenericContext(addStrategy)
    result := context.Execute(5)
    fmt.Printf("Strategy result: %d\n", result)
}

// 11. 错误和异常处理
func demonstrateErrorHandlingBestPractices() {
    fmt.Println("\n=== 错误和异常处理最佳实践 ===")
    
    // 好的做法：返回错误而不是panic
    func SafeParse[T constraints.Integer](s string) (T, error) {
        var result T
        // 简化实现
        if s == "invalid" {
            return result, fmt.Errorf("invalid input: %s", s)
        }
        return result, nil
    }
    
    // 不好的做法：使用panic
    func UnsafeParse[T constraints.Integer](s string) T {
        if s == "invalid" {
            panic("invalid input")  // 应该避免
        }
        var result T
        return result
    }
    
    // 好的做法：提供默认值
    func ParseWithDefault[T constraints.Integer](s string, defaultValue T) T {
        if result, err := SafeParse[T](s); err == nil {
            return result
        }
        return defaultValue
    }
    
    // 示例使用
    if result, err := SafeParse[int]("123"); err == nil {
        fmt.Printf("Parsed result: %d\n", result)
    }
    
    defaultValue := ParseWithDefault[int]("invalid", 42)
    fmt.Printf("Default value: %d\n", defaultValue)
}

// 12. 代码组织和结构
func demonstrateCodeOrganization() {
    fmt.Println("\n=== 代码组织和结构 ===")
    
    // 好的做法：将相关类型和函数组织在一起
    type MathOperations[T constraints.Number] struct{}
    
    func NewMathOperations[T constraints.Number]() *MathOperations[T] {
        return &MathOperations[T]{}
    }
    
    func (mo *MathOperations[T]) Add(a, b T) T {
        return a + b
    }
    
    func (mo *MathOperations[T]) Subtract(a, b T) T {
        return a - b
    }
    
    func (mo *MathOperations[T]) Multiply(a, b T) T {
        return a * b
    }
    
    func (mo *MathOperations[T]) Divide(a, b T) (T, error) {
        if b == 0 {
            var zero T
            return zero, fmt.Errorf("division by zero")
        }
        return a / b, nil
    }
    
    // 示例使用
    mathOps := NewMathOperations[float64]()
    fmt.Printf("Add: %.2f\n", mathOps.Add(5.5, 3.3))
    fmt.Printf("Subtract: %.2f\n", mathOps.Subtract(5.5, 3.3))
    fmt.Printf("Multiply: %.2f\n", mathOps.Multiply(5.5, 3.3))
    
    if result, err := mathOps.Divide(5.5, 2.0); err == nil {
        fmt.Printf("Divide: %.2f\n", result)
    }
}

// 泛型最佳实践总结
func genericBestPracticesSummary() {
    fmt.Println("\n=== 泛型最佳实践总结 ===")
    
    fmt.Println("1. 约束选择:")
    fmt.Println("   - 使用最具体的约束")
    fmt.Println("   - 避免过度宽泛的约束")
    fmt.Println("   - 考虑性能影响")
    
    fmt.Println("\n2. 设计原则:")
    fmt.Println("   - 保持简单明确")
    fmt.Println("   - 提供清晰的文档")
    fmt.Println("   - 使用有意义的名称")
    
    fmt.Println("\n3. 错误处理:")
    fmt.Println("   - 返回错误而非panic")
    fmt.Println("   - 处理边界条件")
    fmt.Println("   - 提供合理的默认值")
    
    fmt.Println("\n4. 性能优化:")
    fmt.Println("   - 避免不必要的内存分配")
    fmt.Println("   - 考虑缓存友好性")
    fmt.Println("   - 使用对象池减少GC压力")
    
    fmt.Println("\n5. 兼容性:")
    fmt.Println("   - 保持API稳定")
    fmt.Println("   - 考虑向后兼容性")
    fmt.Println("   - 遵循Go语言约定")
    
    fmt.Println("\n6. 测试验证:")
    fmt.Println("   - 为不同类型编写测试")
    fmt.Println("   - 验证边界条件")
    fmt.Println("   - 性能基准测试")
    
    fmt.Println("\n7. 设计模式:")
    fmt.Println("   - 工厂模式")
    fmt.Println("   - 策略模式")
    fmt.Println("   - 观察者模式")
    fmt.Println("   - 适配器模式")
    
    fmt.Println("\n8. 代码组织:")
    fmt.Println("   - 相关功能组织在一起")
    fmt.Println("   - 提供构造函数")
    fmt.Println("   - 实现标准接口")
}

func main() {
    demonstrateConstraintSelection()
    demonstrateSimplicity()
    demonstrateDocumentation()
    demonstrateMeaningfulNames()
    demonstrateErrorHandling()
    demonstratePerformanceConsiderations()
    demonstrateInterfaceCompatibility()
    demonstrateTesting()
    demonstrateBackwardCompatibility()
    demonstrateDesignPatterns()
    demonstrateErrorHandlingBestPractices()
    demonstrateCodeOrganization()
    genericBestPracticesSummary()
}
```