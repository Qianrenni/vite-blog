## 2.3 运算符

### 算术运算符

Go语言支持基本的算术运算符：

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // 基本算术运算符
    a, b := 10, 3
    
    fmt.Printf("a = %d, b = %d\n", a, b)
    fmt.Printf("a + b = %d\n", a+b)    // 加法
    fmt.Printf("a - b = %d\n", a-b)    // 减法
    fmt.Printf("a * b = %d\n", a*b)    // 乘法
    fmt.Printf("a / b = %d\n", a/b)    // 除法
    fmt.Printf("a %% b = %d\n", a%b)   // 取模
    
    // 浮点数运算
    x, y := 10.5, 3.2
    fmt.Printf("x = %.1f, y = %.1f\n", x, y)
    fmt.Printf("x + y = %.2f\n", x+y)
    fmt.Printf("x - y = %.2f\n", x-y)
    fmt.Printf("x * y = %.2f\n", x*y)
    fmt.Printf("x / y = %.2f\n", x/y)
    
    // 一元运算符
    c := 5
    fmt.Printf("+c = %d\n", +c)        // 正号
    fmt.Printf("-c = %d\n", -c)        // 负号
    
    // 自增自减（只能作为语句使用）
    d := 10
    d++        // 等价于 d = d + 1
    fmt.Printf("d++ = %d\n", d)
    d--
    fmt.Printf("d-- = %d\n", d)
    
    // 复数运算
    z1 := complex(3, 4)    // 3 + 4i
    z2 := complex(1, 2)    // 1 + 2i
    fmt.Printf("z1 = %v, z2 = %v\n", z1, z2)
    fmt.Printf("z1 + z2 = %v\n", z1+z2)
    fmt.Printf("z1 - z2 = %v\n", z1-z2)
    fmt.Printf("z1 * z2 = %v\n", z1*z2)
    fmt.Printf("z1 / z2 = %v\n", z1/z2)
    
    // 字符串连接
    str1 := "Hello"
    str2 := "World"
    fmt.Printf("str1 + str2 = %s\n", str1+" "+str2)
    
    // 特殊情况处理
    fmt.Printf("0 / 5 = %d\n", 0/5)        // 0
    // fmt.Printf("5 / 0 = %d\n", 5/0)     // 运行时错误：除零异常
    
    // 取模运算
    fmt.Printf("10 %% 3 = %d\n", 10%3)     // 1
    fmt.Printf("-10 %% 3 = %d\n", -10%3)   // -1 (符号与被除数相同)
    fmt.Printf("10 %% -3 = %d\n", 10%-3)   // 1
    fmt.Printf("-10 %% -3 = %d\n", -10%-3) // -1
}
```

### 比较运算符

比较运算符用于比较两个值的关系：

```go
package main

import "fmt"

func main() {
    // 数值比较
    a, b := 10, 20
    fmt.Printf("a = %d, b = %d\n", a, b)
    fmt.Printf("a == b: %t\n", a == b)    // 等于
    fmt.Printf("a != b: %t\n", a != b)    // 不等于
    fmt.Printf("a < b: %t\n", a < b)      // 小于
    fmt.Printf("a <= b: %t\n", a <= b)    // 小于等于
    fmt.Printf("a > b: %t\n", a > b)      // 大于
    fmt.Printf("a >= b: %t\n", a >= b)    // 大于等于
    
    // 字符串比较（字典序）
    str1, str2 := "apple", "banana"
    fmt.Printf("str1 = %s, str2 = %s\n", str1, str2)
    fmt.Printf("str1 == str2: %t\n", str1 == str2)
    fmt.Printf("str1 < str2: %t\n", str1 < str2)    // "a" < "b"
    
    // 浮点数比较
    x, y := 3.14, 3.14159
    fmt.Printf("x = %.2f, y = %.5f\n", x, y)
    fmt.Printf("x == y: %t\n", x == y)
    fmt.Printf("x < y: %t\n", x < y)
    
    // 布尔值比较
    flag1, flag2 := true, false
    fmt.Printf("flag1 = %t, flag2 = %t\n", flag1, flag2)
    fmt.Printf("flag1 == flag2: %t\n", flag1 == flag2)
    fmt.Printf("flag1 != flag2: %t\n", flag1 != flag2)
    
    // 指针比较
    var ptr1, ptr2 *int
    fmt.Printf("ptr1 == ptr2: %t\n", ptr1 == ptr2)    // 都是nil
    
    num := 42
    ptr1 = &num
    ptr2 = &num
    fmt.Printf("ptr1 == ptr2: %t\n", ptr1 == ptr2)    // 指向同一地址
    
    // 结构体比较
    type Point struct {
        X, Y int
    }
    
    p1 := Point{1, 2}
    p2 := Point{1, 2}
    p3 := Point{2, 1}
    
    fmt.Printf("p1 == p2: %t\n", p1 == p2)    // true
    fmt.Printf("p1 == p3: %t\n", p1 == p3)    // false
    
    // 切片、映射、函数不能直接比较
    // slice1 := []int{1, 2, 3}
    // slice2 := []int{1, 2, 3}
    // fmt.Printf("slice1 == slice2: %t\n", slice1 == slice2) // 编译错误
}
```

### 逻辑运算符

逻辑运算符用于布尔值的逻辑运算：

```go
package main

import "fmt"

func main() {
    a, b := true, false
    
    fmt.Printf("a = %t, b = %t\n", a, b)
    
    // 逻辑与 (&&)
    fmt.Printf("a && b = %t\n", a && b)        // false
    fmt.Printf("a && true = %t\n", a && true)  // true
    fmt.Printf("b && false = %t\n", b && false) // false
    
    // 逻辑或 (||)
    fmt.Printf("a || b = %t\n", a || b)        // true
    fmt.Printf("a || false = %t\n", a || false) // true
    fmt.Printf("b || false = %t\n", b || false) // false
    
    // 逻辑非 (!)
    fmt.Printf("!a = %t\n", !a)                // false
    fmt.Printf("!b = %t\n", !b)                // true
    
    // 短路求值
    fmt.Println("短路求值示例:")
    
    // && 短路：如果第一个操作数为false，则不计算第二个操作数
    x := 0
    result1 := false && (x == 0 || increment(&x))  // increment不会被调用
    fmt.Printf("x after false && ...: %d, result: %t\n", x, result1)
    
    // || 短路：如果第一个操作数为true，则不计算第二个操作数
    y := 0
    result2 := true || increment(&y)  // increment不会被调用
    fmt.Printf("y after true || ...: %d, result: %t\n", y, result2)
    
    // 复杂逻辑表达式
    age := 25
    hasLicense := true
    hasCar := false
    
    canDrive := age >= 18 && hasLicense
    canGo := canDrive && (hasCar || age >= 65)
    
    fmt.Printf("Age: %d\n", age)
    fmt.Printf("Can drive: %t\n", canDrive)
    fmt.Printf("Can go: %t\n", canGo)
}

func increment(x *int) bool {
    *x++
    fmt.Printf("increment called, x = %d\n", *x)
    return true
}
```

### 位运算符

位运算符对整数的二进制位进行操作：

```go
package main

import (
    "fmt"
    "math/bits"
)

func main() {
    a, b := 12, 25    // 12 = 1100, 25 = 11001
    
    fmt.Printf("a = %d (binary: %08b)\n", a, a)
    fmt.Printf("b = %d (binary: %08b)\n", b, b)
    
    // 按位与 (&)
    result1 := a & b
    fmt.Printf("a & b = %d (binary: %08b)\n", result1, result1)
    // 1100 & 11001 = 01000 = 8
    
    // 按位或 (|)
    result2 := a | b
    fmt.Printf("a | b = %d (binary: %08b)\n", result2, result2)
    // 1100 | 11001 = 11101 = 29
    
    // 按位异或 (^)
    result3 := a ^ b
    fmt.Printf("a ^ b = %d (binary: %08b)\n", result3, result3)
    // 1100 ^ 11001 = 10101 = 21
    
    // 按位取反 (&^) - Go特有，清除位运算
    result4 := a &^ b
    fmt.Printf("a &^ b = %d (binary: %08b)\n", result4, result4)
    // 1100 &^ 11001 = 1100 & 00110 = 00000 = 0
    
    // 左移 (<<)
    result5 := a << 2
    fmt.Printf("a << 2 = %d (binary: %08b)\n", result5, result5)
    // 1100 << 2 = 110000 = 48
    
    // 右移 (>>)
    result6 := a >> 2
    fmt.Printf("a >> 2 = %d (binary: %08b)\n", result6, result6)
    // 1100 >> 2 = 0011 = 3
    
    // 一元按位取反 (^)
    result7 := ^a
    fmt.Printf("^a = %d (binary: %08b)\n", result7, result7)
    // ^1100 = ...11110011 (补码表示)
    
    // 位操作的实际应用
    fmt.Println("\n位操作应用示例:")
    
    // 设置位
    flags := 0
    const (
        Readable = 1 << iota  // 1
        Writable              // 2
        Executable            // 4
    )
    
    flags |= Readable | Writable  // 设置读写权限
    fmt.Printf("Flags after setting: %03b\n", flags)
    
    // 检查位
    if flags&Readable != 0 {
        fmt.Println("Readable flag is set")
    }
    
    // 清除位
    flags &^= Writable  // 清除写权限
    fmt.Printf("Flags after clearing writable: %03b\n", flags)
    
    // 切换位
    flags ^= Executable  // 切换执行权限
    fmt.Printf("Flags after toggling executable: %03b\n", flags)
    
    // 使用标准库函数
    fmt.Printf("Leading zeros in %d: %d\n", a, bits.LeadingZeros8(uint8(a)))
    fmt.Printf("Trailing zeros in %d: %d\n", a, bits.TrailingZeros8(uint8(a)))
    fmt.Printf("Ones count in %d: %d\n", a, bits.OnesCount8(uint8(a)))
    fmt.Printf("Reverse bits in %d: %08b\n", a, bits.Reverse8(uint8(a)))
}
```

### 赋值运算符

Go语言支持多种赋值运算符：

```go
package main

import "fmt"

func main() {
    // 基本赋值
    var a int = 10
    fmt.Printf("a = %d\n", a)
    
    // 简单赋值
    a = 20
    fmt.Printf("a = %d\n", a)
    
    // 复合赋值运算符
    a += 5    // 等价于 a = a + 5
    fmt.Printf("a += 5: %d\n", a)
    
    a -= 3    // 等价于 a = a - 3
    fmt.Printf("a -= 3: %d\n", a)
    
    a *= 2    // 等价于 a = a * 2
    fmt.Printf("a *= 2: %d\n", a)
    
    a /= 4    // 等价于 a = a / 4
    fmt.Printf("a /= 4: %d\n", a)
    
    a %= 3    // 等价于 a = a % 3
    fmt.Printf("a %%= 3: %d\n", a)
    
    // 位运算赋值
    a <<= 2   // 等价于 a = a << 2
    fmt.Printf("a <<= 2: %d\n", a)
    
    a >>= 1   // 等价于 a = a >> 1
    fmt.Printf("a >>= 1: %d\n", a)
    
    a &= 15   // 等价于 a = a & 15
    fmt.Printf("a &= 15: %d\n", a)
    
    a |= 8    // 等价于 a = a | 8
    fmt.Printf("a |= 8: %d\n", a)
    
    a ^= 4    // 等价于 a = a ^ 4
    fmt.Printf("a ^= 4: %d\n", a)
    
    a &^= 2   // 等价于 a = a &^ 2
    fmt.Printf("a &^= 2: %d\n", a)
    
    // 多重赋值
    x, y := 1, 2
    fmt.Printf("Before swap: x = %d, y = %d\n", x, y)
    
    // 交换变量值
    x, y = y, x
    fmt.Printf("After swap: x = %d, y = %d\n", x, y)
    
    // 多重赋值与函数返回值
    a, b, c := multipleReturn()
    fmt.Printf("Multiple return: a = %d, b = %d, c = %d\n", a, b, c)
    
    // 忽略某些返回值
    d, _, f := multipleReturn()
    fmt.Printf("Partial return: d = %d, f = %d\n", d, f)
    
    // 同时赋值多个变量
    var i, j, k int
    i, j, k = 10, 20, 30
    fmt.Printf("i = %d, j = %d, k = %d\n", i, j, k)
    
    // 在赋值中使用表达式
    nums := []int{1, 2, 3, 4, 5}
    index := 0
    nums[index], index = 100, index+1  // 先赋值，再更新index
    fmt.Printf("nums after assignment: %v, index: %d\n", nums, index)
}

func multipleReturn() (int, int, int) {
    return 100, 200, 300
}
```

### 运算符优先级

Go语言运算符按照优先级从高到低排列：

```go
package main

import "fmt"

func main() {
    // 运算符优先级演示
    a, b, c := 10, 5, 2
    
    // 算术运算符优先级
    result1 := a + b * c        // 乘法优先级高于加法
    result2 := (a + b) * c      // 使用括号改变优先级
    fmt.Printf("a + b * c = %d\n", result1)    // 10 + 5 * 2 = 20
    fmt.Printf("(a + b) * c = %d\n", result2)  // (10 + 5) * 2 = 30
    
    // 位运算符优先级
    x, y, z := 8, 4, 2
    result3 := x | y ^ z        // ^ 优先级高于 |
    result4 := x | (y ^ z)      // 明确指定优先级
    fmt.Printf("x | y ^ z = %d (binary: %04b)\n", result3, result3)  // 8 | 4 ^ 2 = 8 | 6 = 14
    fmt.Printf("x | (y ^ z) = %d (binary: %04b)\n", result4, result4)
    
    // 逻辑运算符优先级
    p, q, r := true, false, true
    result5 := p || q && r      // && 优先级高于 ||
    result6 := (p || q) && r    // 使用括号改变优先级
    fmt.Printf("p || q && r = %t\n", result5)    // true || false && true = true
    fmt.Printf("(p || q) && r = %t\n", result6)  // (true || false) && true = true
    
    // 比较运算符优先级
    result7 := a > b == c < b   // 比较运算符优先级高于 ==
    fmt.Printf("a > b == c < b = %t\n", result7) // 10 > 5 == 2 < 5 = true == true = true
    
    // 复杂表达式
    result8 := a + b*c - d/e<<f&g|h^i||j&&k
    // 计算顺序: b*c, d/e, <<, &, |, ^, ||, &&
    
    // 推荐使用括号明确优先级
    complex1 := ((a + (b * c)) - ((d / e) << f)) & g | h ^ i || (j && k)
    
    fmt.Println("复杂表达式示例:")
    fmt.Printf("Without parentheses: %d\n", complex1)
    
    // 实际应用中的优先级
    flags := 0
    const (
        Readable = 1 << iota
        Writable
        Executable
    )
    
    // 设置多个标志位
    flags = flags | Readable | Writable  // | 运算符从左到右结合
    fmt.Printf("Flags: %03b\n", flags)
    
    // 检查多个标志位
    hasPermissions := flags&Readable != 0 && flags&Writable != 0
    fmt.Printf("Has read and write permissions: %t\n", hasPermissions)
}
```

### 运算符重载（概念）

Go语言不支持运算符重载，但可以通过方法实现类似功能：

```go
package main

import (
    "fmt"
    "math"
)

// 自定义类型Vector
type Vector struct {
    X, Y float64
}

// 为Vector类型添加方法来模拟运算符重载
func (v Vector) Add(other Vector) Vector {
    return Vector{v.X + other.X, v.Y + other.Y}
}

func (v Vector) Sub(other Vector) Vector {
    return Vector{v.X - other.X, v.Y - other.Y}
}

func (v Vector) Mul(scalar float64) Vector {
    return Vector{v.X * scalar, v.Y * scalar}
}

func (v Vector) Div(scalar float64) Vector {
    if scalar == 0 {
        panic("division by zero")
    }
    return Vector{v.X / scalar, v.Y / scalar}
}

func (v Vector) Dot(other Vector) float64 {
    return v.X*other.X + v.Y*other.Y
}

func (v Vector) Length() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v Vector) String() string {
    return fmt.Sprintf("Vector(%.2f, %.2f)", v.X, v.Y)
}

// Matrix类型示例
type Matrix struct {
    Data [2][2]float64
}

func (m Matrix) MulVector(v Vector) Vector {
    return Vector{
        m.Data[0][0]*v.X + m.Data[0][1]*v.Y,
        m.Data[1][0]*v.X + m.Data[1][1]*v.Y,
    }
}

func (m Matrix) Mul(other Matrix) Matrix {
    result := Matrix{}
    for i := 0; i < 2; i++ {
        for j := 0; j < 2; j++ {
            for k := 0; k < 2; k++ {
                result.Data[i][j] += m.Data[i][k] * other.Data[k][j]
            }
        }
    }
    return result
}

func (m Matrix) String() string {
    return fmt.Sprintf("Matrix[[%.2f, %.2f], [%.2f, %.2f]]",
        m.Data[0][0], m.Data[0][1], m.Data[1][0], m.Data[1][1])
}

func main() {
    // 使用Vector类型
    v1 := Vector{3, 4}
    v2 := Vector{1, 2}
    
    fmt.Printf("v1: %s\n", v1)
    fmt.Printf("v2: %s\n", v2)
    
    // 模拟运算符重载
    sum := v1.Add(v2)
    diff := v1.Sub(v2)
    scaled := v1.Mul(2.0)
    divided := v1.Div(2.0)
    
    fmt.Printf("v1 + v2 = %s\n", sum)
    fmt.Printf("v1 - v2 = %s\n", diff)
    fmt.Printf("v1 * 2 = %s\n", scaled)
    fmt.Printf("v1 / 2 = %s\n", divided)
    
    // 点积
    dotProduct := v1.Dot(v2)
    fmt.Printf("v1 · v2 = %.2f\n", dotProduct)
    
    // 向量长度
    length := v1.Length()
    fmt.Printf("|v1| = %.2f\n", length)
    
    // 矩阵运算
    m1 := Matrix{
        Data: [2][2]float64{{1, 2}, {3, 4}},
    }
    m2 := Matrix{
        Data: [2][2]float64{{5, 6}, {7, 8}},
    }
    
    fmt.Printf("m1: %s\n", m1)
    fmt.Printf("m2: %s\n", m2)
    
    // 矩阵乘法
    matrixProduct := m1.Mul(m2)
    fmt.Printf("m1 * m2 = %s\n", matrixProduct)
    
    // 矩阵乘向量
    transformed := m1.MulVector(v1)
    fmt.Printf("m1 * v1 = %s\n", transformed)
    
    // 链式调用
    result := v1.Add(v2).Mul(2.0).Sub(Vector{1, 1})
    fmt.Printf("Chain operation result: %s\n", result)
}
```