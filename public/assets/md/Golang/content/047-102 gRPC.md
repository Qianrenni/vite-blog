## 10.2 gRPC

### Protocol Buffers

```go
// user.proto
syntax = "proto3";

package user;

option go_package = "./pb";

message User {
    int32 id = 1;
    string name = 2;
    string email = 3;
    string phone = 4;
    int64 created_at = 5;
}

message GetUserRequest {
    int32 id = 1;
}

message GetUserResponse {
    User user = 1;
    bool found = 2;
}

message ListUsersRequest {
    int32 page = 1;
    int32 limit = 2;
}

message ListUsersResponse {
    repeated User users = 1;
    int32 total = 2;
    int32 page = 3;
    int32 limit = 4;
}

message CreateUserRequest {
    string name = 1;
    string email = 2;
    string phone = 3;
}

message CreateUserResponse {
    User user = 1;
    bool success = 2;
}

service UserService {
    rpc GetUser(GetUserRequest) returns (GetUserResponse);
    rpc ListUsers(ListUsersRequest) returns (ListUsersResponse);
    rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}
```

### gRPC服务定义

```go
// gRPC服务实现
package main

import (
    "context"
    "database/sql"
    "log"
    "net"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    pb "your-project/pb"
)

type UserServer struct {
    pb.UnimplementedUserServiceServer
    db *sql.DB
}

func NewUserServer(db *sql.DB) *UserServer {
    return &UserServer{db: db}
}

func (s *UserServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    user, err := s.findUserByID(req.Id)
    if err != nil {
        if err == sql.ErrNoRows {
            return &pb.GetUserResponse{Found: false}, nil
        }
        return nil, status.Errorf(codes.Internal, "failed to get user: %v", err)
    }
    
    return &pb.GetUserResponse{
        User:  user,
        Found: true,
    }, nil
}

func (s *UserServer) ListUsers(ctx context.Context, req *pb.ListUsersRequest) (*pb.ListUsersResponse, error) {
    if req.Page <= 0 {
        req.Page = 1
    }
    if req.Limit <= 0 || req.Limit > 100 {
        req.Limit = 10
    }
    
    users, total, err := s.listUsers(int(req.Page), int(req.Limit))
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to list users: %v", err)
    }
    
    return &pb.ListUsersResponse{
        Users: users,
        Total: int32(total),
        Page:  req.Page,
        Limit: req.Limit,
    }, nil
}

func (s *UserServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
    if req.Name == "" || req.Email == "" {
        return nil, status.Errorf(codes.InvalidArgument, "name and email are required")
    }
    
    user := &pb.User{
        Name:      req.Name,
        Email:     req.Email,
        Phone:     req.Phone,
        CreatedAt: time.Now().Unix(),
    }
    
    createdUser, err := s.createUser(user)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to create user: %v", err)
    }
    
    return &pb.CreateUserResponse{
        User:    createdUser,
        Success: true,
    }, nil
}

// 数据库操作方法
func (s *UserServer) findUserByID(id int32) (*pb.User, error) {
    var user pb.User
    var createdAt int64
    
    query := "SELECT id, name, email, phone, created_at FROM users WHERE id = ?"
    err := s.db.QueryRow(query, id).Scan(
        &user.Id, &user.Name, &user.Email, &user.Phone, &createdAt)
    
    if err != nil {
        return nil, err
    }
    
    user.CreatedAt = createdAt
    return &user, nil
}

func (s *UserServer) listUsers(page, limit int) ([]*pb.User, int, error) {
    offset := (page - 1) * limit
    
    // 获取总数
    var total int
    err := s.db.QueryRow("SELECT COUNT(*) FROM users").Scan(&total)
    if err != nil {
        return nil, 0, err
    }
    
    // 获取用户列表
    query := "SELECT id, name, email, phone, created_at FROM users LIMIT ? OFFSET ?"
    rows, err := s.db.Query(query, limit, offset)
    if err != nil {
        return nil, 0, err
    }
    defer rows.Close()
    
    var users []*pb.User
    for rows.Next() {
        var user pb.User
        var createdAt int64
        err := rows.Scan(&user.Id, &user.Name, &user.Email, &user.Phone, &createdAt)
        if err != nil {
            return nil, 0, err
        }
        user.CreatedAt = createdAt
        users = append(users, &user)
    }
    
    return users, total, nil
}

func (s *UserServer) createUser(user *pb.User) (*pb.User, error) {
    query := "INSERT INTO users (name, email, phone, created_at) VALUES (?, ?, ?, ?)"
    result, err := s.db.Exec(query, user.Name, user.Email, user.Phone, user.CreatedAt)
    if err != nil {
        return nil, err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return nil, err
    }
    
    user.Id = int32(id)
    return user, nil
}

// gRPC服务器启动
func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    grpcServer := grpc.NewServer()
    pb.RegisterUserServiceServer(grpcServer, NewUserServer(nil)) // 实际应用中需要传入数据库连接
    
    log.Println("gRPC server listening on :50051")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
```

### gRPC客户端和服务端

```go
// gRPC客户端实现
package main

import (
    "context"
    "log"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    pb "your-project/pb"
)

type GRPCClient struct {
    conn   *grpc.ClientConn
    client pb.UserServiceClient
}

func NewGRPCClient(address string) (*GRPCClient, error) {
    conn, err := grpc.Dial(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        return nil, err
    }
    
    client := pb.NewUserServiceClient(conn)
    
    return &GRPCClient{
        conn:   conn,
        client: client,
    }, nil
}

func (c *GRPCClient) Close() error {
    return c.conn.Close()
}

func (c *GRPCClient) GetUser(id int32) (*pb.User, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    req := &pb.GetUserRequest{Id: id}
    resp, err := c.client.GetUser(ctx, req)
    if err != nil {
        return nil, err
    }
    
    if !resp.Found {
        return nil, nil // 用户不存在
    }
    
    return resp.User, nil
}

func (c *GRPCClient) ListUsers(page, limit int32) (*pb.ListUsersResponse, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    req := &pb.ListUsersRequest{Page: page, Limit: limit}
    return c.client.ListUsers(ctx, req)
}

func (c *GRPCClient) CreateUser(name, email, phone string) (*pb.User, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    req := &pb.CreateUserRequest{
        Name:  name,
        Email: email,
        Phone: phone,
    }
    
    resp, err := c.client.CreateUser(ctx, req)
    if err != nil {
        return nil, err
    }
    
    if !resp.Success {
        return nil, nil // 创建失败
    }
    
    return resp.User, nil
}

// 客户端使用示例
func main() {
    client, err := NewGRPCClient("localhost:50051")
    if err != nil {
        log.Fatalf("failed to create client: %v", err)
    }
    defer client.Close()
    
    // 获取用户
    user, err := client.GetUser(1)
    if err != nil {
        log.Printf("failed to get user: %v", err)
    } else if user != nil {
        log.Printf("User: %+v", user)
    } else {
        log.Println("User not found")
    }
    
    // 创建用户
    newUser, err := client.CreateUser("John Doe", "john@example.com", "+1234567890")
    if err != nil {
        log.Printf("failed to create user: %v", err)
    } else {
        log.Printf("Created user: %+v", newUser)
    }
    
    // 列出用户
    users, err := client.ListUsers(1, 10)
    if err != nil {
        log.Printf("failed to list users: %v", err)
    } else {
        log.Printf("Total users: %d", users.Total)
        for _, user := range users.Users {
            log.Printf("User: %+v", user)
        }
    }
}
```

### 流式RPC

```go
// 流式RPC示例
// 在proto文件中添加流式方法
/*
service UserService {
    // 服务器流式RPC
    rpc ListUsersStream(ListUsersRequest) returns (stream User);
    
    // 客户端流式RPC
    rpc CreateUsersStream(stream CreateUserRequest) returns (CreateUsersResponse);
    
    // 双向流式RPC
    rpc ChatUsers(stream ChatMessage) returns (stream ChatMessage);
}
*/

// 服务器流式RPC实现
func (s *UserServer) ListUsersStream(req *pb.ListUsersRequest, stream pb.UserService_ListUsersStreamServer) error {
    if req.Page <= 0 {
        req.Page = 1
    }
    if req.Limit <= 0 || req.Limit > 100 {
        req.Limit = 10
    }
    
    users, _, err := s.listUsers(int(req.Page), int(req.Limit))
    if err != nil {
        return status.Errorf(codes.Internal, "failed to list users: %v", err)
    }
    
    // 逐个发送用户数据
    for _, user := range users {
        if err := stream.Send(user); err != nil {
            return err
        }
        
        // 模拟处理延迟
        time.Sleep(100 * time.Millisecond)
    }
    
    return nil
}

// 客户端流式RPC实现
func (s *UserServer) CreateUsersStream(stream pb.UserService_CreateUsersStreamServer) error {
    var createdUsers []*pb.User
    var errors []string
    
    for {
        req, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                break
            }
            return err
        }
        
        // 验证请求
        if req.Name == "" || req.Email == "" {
            errors = append(errors, fmt.Sprintf("invalid request: name and email required"))
            continue
        }
        
        // 创建用户
        user := &pb.User{
            Name:      req.Name,
            Email:     req.Email,
            Phone:     req.Phone,
            CreatedAt: time.Now().Unix(),
        }
        
        createdUser, err := s.createUser(user)
        if err != nil {
            errors = append(errors, fmt.Sprintf("failed to create user %s: %v", req.Name, err))
            continue
        }
        
        createdUsers = append(createdUsers, createdUser)
    }
    
    // 发送响应
    resp := &pb.CreateUsersResponse{
        Users:  createdUsers,
        Errors: errors,
        Count:  int32(len(createdUsers)),
    }
    
    return stream.SendAndClose(resp)
}

// 双向流式RPC实现
func (s *UserServer) ChatUsers(stream pb.UserService_ChatUsersServer) error {
    // 处理双向流
    for {
        msg, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                return nil
            }
            return err
        }
        
        // 处理接收到的消息
        log.Printf("Received message from %s: %s", msg.From, msg.Content)
        
        // 回复消息
        reply := &pb.ChatMessage{
            From:    "server",
            To:      msg.From,
            Content: fmt.Sprintf("Echo: %s", msg.Content),
            Timestamp: time.Now().Unix(),
        }
        
        if err := stream.Send(reply); err != nil {
            return err
        }
    }
}

// 客户端流式RPC使用示例
func (c *GRPCClient) CreateUsersStream(users []pb.CreateUserRequest) (*pb.CreateUsersResponse, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    stream, err := c.client.CreateUsersStream(ctx)
    if err != nil {
        return nil, err
    }
    
    // 发送用户数据
    for _, user := range users {
        if err := stream.Send(&user); err != nil {
            return nil, err
        }
    }
    
    // 关闭发送流并接收响应
    return stream.CloseAndRecv()
}

// 服务器流式RPC使用示例
func (c *GRPCClient) ListUsersStream(page, limit int32) ([]*pb.User, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    req := &pb.ListUsersRequest{Page: page, Limit: limit}
    stream, err := c.client.ListUsersStream(ctx, req)
    if err != nil {
        return nil, err
    }
    
    var users []*pb.User
    for {
        user, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                break
            }
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, nil
}
```

### 认证和授权

```go
// gRPC认证和授权
import (
    "context"
    "crypto/rsa"
    "fmt"
    "io/ioutil"

    "github.com/dgrijalva/jwt-go"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/status"
)

// JWT认证中间件
type AuthInterceptor struct {
    publicKey *rsa.PublicKey
}

func NewAuthInterceptor(publicKeyPath string) (*AuthInterceptor, error) {
    keyData, err := ioutil.ReadFile(publicKeyPath)
    if err != nil {
        return nil, err
    }
    
    publicKey, err := jwt.ParseRSAPublicKeyFromPEM(keyData)
    if err != nil {
        return nil, err
    }
    
    return &AuthInterceptor{publicKey: publicKey}, nil
}

func (ai *AuthInterceptor) Unary() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 跳过认证的方法
        if ai.shouldSkipAuth(info.FullMethod) {
            return handler(ctx, req)
        }
        
        // 验证token
        claims, err := ai.validateToken(ctx)
        if err != nil {
            return nil, status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
        }
        
        // 将用户信息添加到上下文
        ctx = context.WithValue(ctx, "user_claims", claims)
        
        return handler(ctx, req)
    }
}

func (ai *AuthInterceptor) Stream() grpc.StreamServerInterceptor {
    return func(
        srv interface{},
        ss grpc.ServerStream,
        info *grpc.StreamServerInfo,
        handler grpc.StreamHandler,
    ) error {
        // 跳过认证的方法
        if ai.shouldSkipAuth(info.FullMethod) {
            return handler(srv, ss)
        }
        
        // 验证token
        claims, err := ai.validateToken(ss.Context())
        if err != nil {
            return status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
        }
        
        // 创建包装的流
        wrapped := &wrappedServerStream{
            ServerStream: ss,
            ctx:          context.WithValue(ss.Context(), "user_claims", claims),
        }
        
        return handler(srv, wrapped)
    }
}

func (ai *AuthInterceptor) shouldSkipAuth(method string) bool {
    // 定义不需要认证的方法
    skipMethods := map[string]bool{
        "/user.UserService/Login": true,
        "/user.UserService/Register": true,
    }
    return skipMethods[method]
}

func (ai *AuthInterceptor) validateToken(ctx context.Context) (*jwt.StandardClaims, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, fmt.Errorf("no metadata found")
    }
    
    authHeaders := md["authorization"]
    if len(authHeaders) == 0 {
        return nil, fmt.Errorf("no authorization header")
    }
    
    tokenString := authHeaders[0]
    if len(tokenString) > 7 && tokenString[:7] == "Bearer " {
        tokenString = tokenString[7:]
    }
    
    token, err := jwt.ParseWithClaims(tokenString, &jwt.StandardClaims{}, 
        func(token *jwt.Token) (interface{}, error) {
            return ai.publicKey, nil
        })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*jwt.StandardClaims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}

// 包装的服务器流
type wrappedServerStream struct {
    grpc.ServerStream
    ctx context.Context
}

func (w *wrappedServerStream) Context() context.Context {
    return w.ctx
}

// 权限检查中间件
type PermissionInterceptor struct {
    permissions map[string][]string // method -> required roles
}

func NewPermissionInterceptor() *PermissionInterceptor {
    return &PermissionInterceptor{
        permissions: map[string][]string{
            "/user.UserService/DeleteUser": {"admin"},
            "/user.UserService/UpdateUser": {"admin", "user"},
        },
    }
}

func (pi *PermissionInterceptor) Unary() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 检查权限
        if err := pi.checkPermission(ctx, info.FullMethod); err != nil {
            return nil, err
        }
        
        return handler(ctx, req)
    }
}

func (pi *PermissionInterceptor) checkPermission(ctx context.Context, method string) error {
    requiredRoles, exists := pi.permissions[method]
    if !exists {
        // 如果没有定义权限要求，则允许访问
        return nil
    }
    
    // 从上下文获取用户角色
    claims, ok := ctx.Value("user_claims").(*jwt.StandardClaims)
    if !ok {
        return status.Errorf(codes.PermissionDenied, "no user claims found")
    }
    
    // 检查用户角色是否满足要求
    userRoles := []string{} // 从claims中提取用户角色
    if !hasRequiredRole(userRoles, requiredRoles) {
        return status.Errorf(codes.PermissionDenied, "insufficient permissions")
    }
    
    return nil
}

func hasRequiredRole(userRoles, requiredRoles []string) bool {
    for _, requiredRole := range requiredRoles {
        for _, userRole := range userRoles {
            if userRole == requiredRole {
                return true
            }
        }
    }
    return false
}

// 服务器配置认证和权限
func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    // 创建认证拦截器
    authInterceptor, err := NewAuthInterceptor("public.pem")
    if err != nil {
        log.Fatalf("failed to create auth interceptor: %v", err)
    }
    
    // 创建权限拦截器
    permissionInterceptor := NewPermissionInterceptor()
    
    // 创建gRPC服务器
    grpcServer := grpc.NewServer(
        grpc.UnaryInterceptor(authInterceptor.Unary()),
        grpc.StreamInterceptor(authInterceptor.Stream()),
        grpc.UnaryInterceptor(permissionInterceptor.Unary()),
        grpc.StreamInterceptor(permissionInterceptor.Stream()),
    )
    
    pb.RegisterUserServiceServer(grpcServer, NewUserServer(nil))
    
    log.Println("gRPC server with auth listening on :50051")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
```

### 负载均衡

```go
// gRPC负载均衡实现
import (
    "context"
    "fmt"
    "sync"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/balancer"
    "google.golang.org/grpc/balancer/base"
    "google.golang.org/grpc/resolver"
)

// 自定义负载均衡器
type customBalancer struct {
    subConns map[resolver.Address]balancer.SubConn
    scStates map[balancer.SubConn]connectivity.State
    csEvltr  *connectivityStateEvaluator
    state    connectivity.State
    clientConn balancer.ClientConn
    mutex    sync.RWMutex
}

func newCustomBalancer(cc balancer.ClientConn, opts balancer.BuildOptions) balancer.Balancer {
    return &customBalancer{
        subConns: make(map[resolver.Address]balancer.SubConn),
        scStates: make(map[balancer.SubConn]connectivity.State),
        clientConn: cc,
        csEvltr:    &connectivityStateEvaluator{},
    }
}

func (b *customBalancer) UpdateClientConnState(ccs balancer.ClientConnState) error {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    // 添加新的子连接
    for _, addr := range ccs.ResolverState.Addresses {
        if _, ok := b.subConns[addr]; !ok {
            sc, err := b.clientConn.NewSubConn([]resolver.Address{addr}, balancer.NewSubConnOptions{})
            if err != nil {
                continue
            }
            b.subConns[addr] = sc
            b.scStates[sc] = connectivity.Idle
            sc.Connect()
        }
    }
    
    // 移除旧的子连接
    for addr, sc := range b.subConns {
        found := false
        for _, newAddr := range ccs.ResolverState.Addresses {
            if addr == newAddr {
                found = true
                break
            }
        }
        if !found {
            b.clientConn.RemoveSubConn(sc)
            delete(b.subConns, addr)
            delete(b.scStates, sc)
        }
    }
    
    return nil
}

func (b *customBalancer) ResolverError(err error) {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    b.state = connectivity.TransientFailure
    b.clientConn.UpdateState(balancer.State{
        ConnectivityState: b.state,
        Picker:            base.NewErrPicker(fmt.Errorf("resolver error: %v", err)),
    })
}

func (b *customBalancer) UpdateSubConnState(sc balancer.SubConn, scs balancer.SubConnState) {
    b.mutex.Lock()
    defer b.mutex.Unlock()
    
    oldState := b.scStates[sc]
    b.scStates[sc] = scs.ConnectivityState
    
    if oldState == connectivity.TransientFailure && 
       (scs.ConnectivityState == connectivity.Connecting || scs.ConnectivityState == connectivity.Idle) {
        sc.Connect()
    }
    
    b.state = b.csEvltr.recordTransition(oldState, scs.ConnectivityState)
    
    switch b.state {
    case connectivity.Ready:
        b.clientConn.UpdateState(balancer.State{
            ConnectivityState: b.state,
            Picker:            &customPicker{subConns: b.subConns},
        })
    case connectivity.TransientFailure:
        b.clientConn.UpdateState(balancer.State{
            ConnectivityState: b.state,
            Picker:            base.NewErrPicker(fmt.Errorf("all subConns are in TransientFailure")),
        })
    }
}

func (b *customBalancer) Close() {}

// 自定义选择器
type customPicker struct {
    subConns map[resolver.Address]balancer.SubConn
    mutex    sync.RWMutex
    index    int
}

func (p *customPicker) Pick(info balancer.PickInfo) (balancer.PickResult, error) {
    p.mutex.RLock()
    defer p.mutex.RUnlock()
    
    if len(p.subConns) == 0 {
        return balancer.PickResult{}, balancer.ErrNoSubConnAvailable
    }
    
    // 轮询选择
    addrs := make([]resolver.Address, 0, len(p.subConns))
    for addr := range p.subConns {
        addrs = append(addrs, addr)
    }
    
    selectedAddr := addrs[p.index%len(addrs)]
    p.index++
    
    return balancer.PickResult{
        SubConn: p.subConns[selectedAddr],
    }, nil
}

// 注册自定义负载均衡器
func init() {
    balancer.Register(&customBalancerBuilder{})
}

type customBalancerBuilder struct{}

func (customBalancerBuilder) Build(cc balancer.ClientConn, opts balancer.BuildOptions) balancer.Balancer {
    return newCustomBalancer(cc, opts)
}

func (customBalancerBuilder) Name() string {
    return "custom_balancer"
}

// 客户端负载均衡配置
func NewLoadBalancedClient(target string) (*grpc.ClientConn, error) {
    return grpc.Dial(
        target,
        grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"custom_balancer"}`),
        grpc.WithTransportCredentials(insecure.NewCredentials()),
    )
}

// 服务发现集成
type ServiceDiscoveryResolver struct {
    target  string
    cc      resolver.ClientConn
    serviceDiscovery ServiceDiscovery
    closeCh chan struct{}
}

func (r *ServiceDiscoveryResolver) ResolveNow(o resolver.ResolveNowOptions) {
    // 重新解析服务地址
    addresses, err := r.serviceDiscovery.Discover(r.target)
    if err != nil {
        r.cc.ReportError(err)
        return
    }
    
    var addrs []resolver.Address
    for _, addr := range addresses {
        addrs = append(addrs, resolver.Address{
            Addr: fmt.Sprintf("%s:%d", addr.Host, addr.Port),
        })
    }
    
    r.cc.UpdateState(resolver.State{
        Addresses: addrs,
    })
}

func (r *ServiceDiscoveryResolver) Close() {
    close(r.closeCh)
}

// 健康检查
type HealthChecker struct {
    client pb.HealthClient
}

func NewHealthChecker(conn *grpc.ClientConn) *HealthChecker {
    return &HealthChecker{
        client: pb.NewHealthClient(conn),
    }
}

func (hc *HealthChecker) Check(ctx context.Context) error {
    req := &pb.HealthCheckRequest{
        Service: "user.UserService",
    }
    
    resp, err := hc.client.Check(ctx, req)
    if err != nil {
        return err
    }
    
    if resp.Status != pb.HealthCheckResponse_SERVING {
        return fmt.Errorf("service not serving")
    }
    
    return nil
}
```

### 拦截器

```go
// gRPC拦截器实现
import (
    "context"
    "log"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "google.golang.org/grpc/metadata"
)

// 日志拦截器
func LoggingInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        log.Printf("Starting gRPC call: %s", info.FullMethod)
        
        resp, err := handler(ctx, req)
        
        duration := time.Since(start)
        if err != nil {
            log.Printf("gRPC call failed: %s, duration: %v, error: %v", 
                info.FullMethod, duration, err)
        } else {
            log.Printf("gRPC call completed: %s, duration: %v", 
                info.FullMethod, duration)
        }
        
        return resp, err
    }
}

// 监控拦截器
type MonitoringInterceptor struct {
    metrics MetricsCollector
}

func NewMonitoringInterceptor(metrics MetricsCollector) *MonitoringInterceptor {
    return &MonitoringInterceptor{metrics: metrics}
}

func (mi *MonitoringInterceptor) Unary() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        start := time.Now()
        
        // 记录请求数
        mi.metrics.IncCounter("grpc_requests_total", map[string]string{
            "method": info.FullMethod,
            "type":   "unary",
        })
        
        resp, err := handler(ctx, req)
        
        duration := time.Since(start)
        // 记录请求延迟
        mi.metrics.RecordHistogram("grpc_request_duration_seconds", duration.Seconds(), 
            map[string]string{
                "method": info.FullMethod,
                "type":   "unary",
            })
        
        // 记录错误数
        if err != nil {
            mi.metrics.IncCounter("grpc_request_errors_total", map[string]string{
                "method": info.FullMethod,
                "code":   status.Code(err).String(),
            })
        }
        
        return resp, err
    }
}

// 限流拦截器
type RateLimiterInterceptor struct {
    limiter RateLimiter
}

func NewRateLimiterInterceptor(limiter RateLimiter) *RateLimiterInterceptor {
    return &RateLimiterInterceptor{limiter: limiter}
}

func (rli *RateLimiterInterceptor) Unary() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 从上下文获取客户端IP
        clientIP := getClientIP(ctx)
        
        // 检查是否超过限流
        if !rli.limiter.Allow(clientIP) {
            return nil, status.Errorf(codes.ResourceExhausted, "rate limit exceeded")
        }
        
        return handler(ctx, req)
    }
}

// 重试拦截器
func RetryInterceptor(maxRetries int, retryableCodes []codes.Code) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        var lastErr error
        
        for i := 0; i <= maxRetries; i++ {
            err := invoker(ctx, method, req, reply, cc, opts...)
            if err == nil {
                return nil
            }
            
            lastErr = err
            code := status.Code(err)
            
            // 检查是否可重试
            retryable := false
            for _, retryableCode := range retryableCodes {
                if code == retryableCode {
                    retryable = true
                    break
                }
            }
            
            if !retryable || i == maxRetries {
                break
            }
            
            // 指数退避
            backoff := time.Duration(1<<uint(i)) * time.Second
            select {
            case <-time.After(backoff):
            case <-ctx.Done():
                return ctx.Err()
            }
        }
        
        return lastErr
    }
}

// 超时拦截器
func TimeoutInterceptor(timeout time.Duration) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
        
        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

// 链路追踪拦截器
type TracingInterceptor struct {
    tracer Tracer
}

func NewTracingInterceptor(tracer Tracer) *TracingInterceptor {
    return &TracingInterceptor{tracer: tracer}
}

func (ti *TracingInterceptor) Unary() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 从metadata中提取trace信息
        md, _ := metadata.FromIncomingContext(ctx)
        traceID := getTraceIDFromMetadata(md)
        parentSpanID := getParentSpanIDFromMetadata(md)
        
        // 创建新的span
        span := ti.tracer.StartSpan(info.FullMethod, traceID, parentSpanID)
        defer ti.tracer.EndSpan(span)
        
        // 将trace信息添加到上下文
        ctx = context.WithValue(ctx, "trace_id", span.TraceID)
        ctx = context.WithValue(ctx, "span_id", span.SpanID)
        
        return handler(ctx, req)
    }
}

// 客户端拦截器链
func ChainUnaryClientInterceptors(interceptors ...grpc.UnaryClientInterceptor) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        chainedInvoker := invoker
        for i := len(interceptors) - 1; i >= 0; i-- {
            interceptor := interceptors[i]
            innerInvoker := chainedInvoker
            chainedInvoker = func(currentCtx context.Context, currentMethod string, currentReq, currentRepl interface{}, currentConn *grpc.ClientConn, currentOpts ...grpc.CallOption) error {
                return interceptor(currentCtx, currentMethod, currentReq, currentRepl, currentConn, innerInvoker, currentOpts...)
            }
        }
        
        return chainedInvoker(ctx, method, req, reply, cc, opts...)
    }
}

// 服务器拦截器链
func ChainUnaryServerInterceptors(interceptors ...grpc.UnaryServerInterceptor) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        chainedHandler := handler
        for i := len(interceptors) - 1; i >= 0; i-- {
            interceptor := interceptors[i]
            innerHandler := chainedHandler
            chainedHandler = func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
                return interceptor(currentCtx, currentReq, info, innerHandler)
            }
        }
        
        return chainedHandler(ctx, req)
    }
}

// 实际使用示例
func main() {
    // 创建各种拦截器
    loggingInterceptor := LoggingInterceptor()
    monitoringInterceptor := NewMonitoringInterceptor(NewPrometheusMetricsCollector())
    rateLimiterInterceptor := NewRateLimiterInterceptor(NewTokenBucketRateLimiter())
    tracingInterceptor := NewTracingInterceptor(NewJaegerTracer())
    
    // 创建gRPC服务器并应用拦截器
    grpcServer := grpc.NewServer(
        grpc.UnaryInterceptor(ChainUnaryServerInterceptors(
            loggingInterceptor,
            monitoringInterceptor.Unary(),
            rateLimiterInterceptor.Unary(),
            tracingInterceptor.Unary(),
        )),
    )
    
    pb.RegisterUserServiceServer(grpcServer, NewUserServer(nil))
    
    // 客户端拦截器
    clientInterceptors := ChainUnaryClientInterceptors(
        TimeoutInterceptor(5*time.Second),
        RetryInterceptor(3, []codes.Code{codes.Unavailable, codes.DeadlineExceeded}),
    )
    
    conn, err := grpc.Dial("localhost:50051", 
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithUnaryInterceptor(clientInterceptors))
    if err != nil {
        log.Fatalf("failed to dial: %v", err)
    }
    defer conn.Close()
    
    client := pb.NewUserServiceClient(conn)
    // 使用客户端...
}
```

### 健康检查

```go
// gRPC健康检查实现
import (
    "context"
    "sync"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/health/grpc_health_v1"
    "google.golang.org/grpc/status"
)

// 健康检查服务
type HealthServer struct {
    grpc_health_v1.UnimplementedHealthServer
    statusMap map[string]grpc_health_v1.HealthCheckResponse_ServingStatus
    mutex     sync.RWMutex
}

func NewHealthServer() *HealthServer {
    return &HealthServer{
        statusMap: make(map[string]grpc_health_v1.HealthCheckResponse_ServingStatus),
    }
}

func (s *HealthServer) Check(ctx context.Context, req *grpc_health_v1.HealthCheckRequest) (*grpc_health_v1.HealthCheckResponse, error) {
    s.mutex.RLock()
    defer s.mutex.RUnlock()
    
    status, ok := s.statusMap[req.Service]
    if !ok {
        // 如果服务未注册，返回UNKNOWN状态
        return &grpc_health_v1.HealthCheckResponse{
            Status: grpc_health_v1.HealthCheckResponse_UNKNOWN,
        }, nil
    }
    
    return &grpc_health_v1.HealthCheckResponse{
        Status: status,
    }, nil
}

func (s *HealthServer) Watch(req *grpc_health_v1.HealthCheckRequest, ws grpc_health_v1.Health_WatchServer) error {
    s.mutex.RLock()
    status, ok := s.statusMap[req.Service]
    initialStatus := status
    s.mutex.RUnlock()
    
    if !ok {
        initialStatus = grpc_health_v1.HealthCheckResponse_UNKNOWN
    }
    
    // 发送初始状态
    if err := ws.Send(&grpc_health_v1.HealthCheckResponse{Status: initialStatus}); err != nil {
        return err
    }
    
    // 持续监控状态变化
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ws.Context().Done():
            return ws.Context().Err()
        case <-ticker.C:
            s.mutex.RLock()
            currentStatus, exists := s.statusMap[req.Service]
            s.mutex.RUnlock()
            
            if !exists {
                currentStatus = grpc_health_v1.HealthCheckResponse_UNKNOWN
            }
            
            if currentStatus != initialStatus {
                if err := ws.Send(&grpc_health_v1.HealthCheckResponse{Status: currentStatus}); err != nil {
                    return err
                }
                initialStatus = currentStatus
            }
        }
    }
}

func (s *HealthServer) SetServingStatus(service string, status grpc_health_v1.HealthCheckResponse_ServingStatus) {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    s.statusMap[service] = status
}

func (s *HealthServer) SetAllServingStatus(status grpc_health_v1.HealthCheckResponse_ServingStatus) {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    for service := range s.statusMap {
        s.statusMap[service] = status
    }
}

// 健康检查管理器
type HealthManager struct {
    healthServer *HealthServer
    checkers     []HealthChecker
    stopCh       chan struct{}
}

type HealthChecker interface {
    Name() string
    Check() error
}

type DatabaseHealthChecker struct {
    db *sql.DB
}

func (dhc *DatabaseHealthChecker) Name() string {
    return "database"
}

func (dhc *DatabaseHealthChecker) Check() error {
    return dhc.db.Ping()
}

type CacheHealthChecker struct {
    client *redis.Client
}

func (chc *CacheHealthChecker) Name() string {
    return "cache"
}

func (chc *CacheHealthChecker) Check() error {
    return chc.client.Ping(context.Background()).Err()
}

func NewHealthManager(healthServer *HealthServer, checkers []HealthChecker) *HealthManager {
    return &HealthManager{
        healthServer: healthServer,
        checkers:     checkers,
        stopCh:       make(chan struct{}),
    }
}

func (hm *HealthManager) Start() {
    // 设置初始状态为SERVING
    hm.healthServer.SetAllServingStatus(grpc_health_v1.HealthCheckResponse_SERVING)
    
    // 启动定期健康检查
    go hm.runHealthChecks()
}

func (hm *HealthManager) Stop() {
    close(hm.stopCh)
}

func (hm *HealthManager) runHealthChecks() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-hm.stopCh:
            return
        case <-ticker.C:
            hm.performHealthChecks()
        }
    }
}

func (hm *HealthManager) performHealthChecks() {
    for _, checker := range hm.checkers {
        status := grpc_health_v1.HealthCheckResponse_SERVING
        if err := checker.Check(); err != nil {
            log.Printf("Health check failed for %s: %v", checker.Name(), err)
            status = grpc_health_v1.HealthCheckResponse_NOT_SERVING
        }
        
        hm.healthServer.SetServingStatus(checker.Name(), status)
    }
}

// 整合到gRPC服务器
func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    // 创建健康检查服务器
    healthServer := NewHealthServer()
    
    // 创建健康检查管理器
    healthManager := NewHealthManager(healthServer, []HealthChecker{
        &DatabaseHealthChecker{db: nil}, // 实际应用中需要传入数据库连接
        &CacheHealthChecker{client: nil}, // 实际应用中需要传入缓存客户端
    })
    
    // 启动健康检查
    healthManager.Start()
    defer healthManager.Stop()
    
    // 创建gRPC服务器
    grpcServer := grpc.NewServer()
    
    // 注册健康检查服务
    grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)
    
    // 注册业务服务
    pb.RegisterUserServiceServer(grpcServer, NewUserServer(nil))
    
    log.Println("gRPC server with health check listening on :50051")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}

// 客户端健康检查
func checkServiceHealth(ctx context.Context, conn *grpc.ClientConn) error {
    healthClient := grpc_health_v1.NewHealthClient(conn)
    
    req := &grpc_health_v1.HealthCheckRequest{
        Service: "user.UserService",
    }
    
    resp, err := healthClient.Check(ctx, req)
    if err != nil {
        return err
    }
    
    if resp.Status != grpc_health_v1.HealthCheckResponse_SERVING {
        return status.Errorf(codes.Unavailable, "service not serving, status: %v", resp.Status)
    }
    
    return nil
}

// 健康检查端点（HTTP）
func healthHTTPHandler(w http.ResponseWriter, r *http.Request) {
    // 这里可以检查多个服务的健康状态
    healthStatus := map[string]interface{}{
        "status": "healthy",
        "timestamp": time.Now().Unix(),
        "services": map[string]string{
            "user-service": "SERVING",
            "database": "SERVING",
            "cache": "SERVING",
        },
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(healthStatus)
}
```