## 13.2 代码优化

### 算法优化

#### 优化前的冒泡排序
```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

#### 优化后的快速排序
```go
func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

### 数据结构选择

#### 使用sync.Map优化并发访问
```go
package main

import (
    "sync"
    "testing"
)

// 普通map + mutex
type SafeMap struct {
    mu sync.RWMutex
    m  map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        m: make(map[string]int),
    }
}

func (sm *SafeMap) Set(key string, value int) {
    sm.mu.Lock()
    sm.m[key] = value
    sm.mu.Unlock()
}

func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.RLock()
    value, ok := sm.m[key]
    sm.mu.RUnlock()
    return value, ok
}

// 使用sync.Map
func BenchmarkSafeMap(b *testing.B) {
    sm := NewSafeMap()
    b.RunParallel(func(pb *testing.PB) {
        i := 0
        for pb.Next() {
            key := fmt.Sprintf("key%d", i)
            sm.Set(key, i)
            sm.Get(key)
            i++
        }
    })
}

func BenchmarkSyncMap(b *testing.B) {
    var sm sync.Map
    b.RunParallel(func(pb *testing.PB) {
        i := 0
        for pb.Next() {
            key := fmt.Sprintf("key%d", i)
            sm.Store(key, i)
            sm.Load(key)
            i++
        }
    })
}
```

### 并发优化

#### 工作池模式
```go
package main

import (
    "runtime"
    "sync"
)

type WorkerPool struct {
    workerCount int
    jobQueue    chan func()
    wg          sync.WaitGroup
}

func NewWorkerPool(workerCount int) *WorkerPool {
    if workerCount <= 0 {
        workerCount = runtime.NumCPU()
    }
    
    wp := &WorkerPool{
        workerCount: workerCount,
        jobQueue:    make(chan func(), 1000),
    }
    
    wp.start()
    return wp
}

func (wp *WorkerPool) start() {
    for i := 0; i < wp.workerCount; i++ {
        wp.wg.Add(1)
        go func() {
            defer wp.wg.Done()
            for job := range wp.jobQueue {
                if job != nil {
                    job()
                }
            }
        }()
    }
}

func (wp *WorkerPool) Submit(job func()) {
    wp.jobQueue <- job
}

func (wp *WorkerPool) Close() {
    close(wp.jobQueue)
    wp.wg.Wait()
}
```

#### 批处理优化
```go
package main

import (
    "sync"
    "time"
)

type BatchProcessor struct {
    batchSize    int
    maxWaitTime  time.Duration
    items        []interface{}
    mu           sync.Mutex
    processFunc  func([]interface{})
    timer        *time.Timer
}

func NewBatchProcessor(batchSize int, maxWaitTime time.Duration, 
                      processFunc func([]interface{})) *BatchProcessor {
    bp := &BatchProcessor{
        batchSize:   batchSize,
        maxWaitTime: maxWaitTime,
        processFunc: processFunc,
        items:       make([]interface{}, 0, batchSize),
    }
    
    bp.timer = time.AfterFunc(maxWaitTime, bp.flush)
    return bp
}

func (bp *BatchProcessor) Add(item interface{}) {
    bp.mu.Lock()
    defer bp.mu.Unlock()
    
    bp.items = append(bp.items, item)
    
    if len(bp.items) >= bp.batchSize {
        bp.flushLocked()
    } else {
        bp.timer.Reset(bp.maxWaitTime)
    }
}

func (bp *BatchProcessor) flush() {
    bp.mu.Lock()
    defer bp.mu.Unlock()
    bp.flushLocked()
}

func (bp *BatchProcessor) flushLocked() {
    if len(bp.items) == 0 {
        return
    }
    
    items := make([]interface{}, len(bp.items))
    copy(items, bp.items)
    bp.items = bp.items[:0]
    
    go bp.processFunc(items)
}
```

### 内存优化

#### 对象池优化
```go
package main

import (
    "sync"
)

type Message struct {
    Data []byte
    ID   int
}

var messagePool = sync.Pool{
    New: func() interface{} {
        return &Message{
            Data: make([]byte, 1024),
        }
    },
}

func GetMessage() *Message {
    return messagePool.Get().(*Message)
}

func PutMessage(msg *Message) {
    // 重置状态
    msg.ID = 0
    msg.Data = msg.Data[:0]
    messagePool.Put(msg)
}

// 使用示例
func processMessages() {
    for i := 0; i < 1000; i++ {
        msg := GetMessage()
        msg.ID = i
        // 处理消息...
        PutMessage(msg)
    }
}
```

#### 预分配内存
```go
// 不好的做法
func badConcat(strs []string) string {
    var result string
    for _, s := range strs {
        result += s  // 每次都创建新字符串
    }
    return result
}

// 好的做法
func goodConcat(strs []string) string {
    var builder strings.Builder
    builder.Grow(calculateTotalLen(strs)) // 预分配
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}

func calculateTotalLen(strs []string) int {
    total := 0
    for _, s := range strs {
        total += len(s)
    }
    return total
}
```

### 编译器优化

#### 使用编译器优化标志
```bash
# 禁用优化（调试用）
go build -gcflags="-N -l" main.go

# 最大优化
go build -ldflags="-s -w" main.go

# 指定优化级别
go build -gcflags="-m -m" main.go  # 查看逃逸分析
```

#### 避免逃逸分析
```go
// 会导致逃逸到堆
func badFunc() *int {
    x := 42
    return &x  // x逃逸到堆
}

// 优化版本
var globalInt int

func goodFunc() *int {
    globalInt = 42
    return &globalInt  // 不逃逸
}

// 或者使用返回值
func betterFunc() int {
    return 42  // 不逃逸
}
```

### 代码重构

#### 减少重复计算
```go
// 重构前
func processData(data []int) []int {
    result := make([]int, 0)
    for i := 0; i < len(data); i++ {  // 重复调用len
        if i%2 == 0 {
            result = append(result, data[i]*2)  // 重复计算
        }
    }
    return result
}

// 重构后
func processDataOptimized(data []int) []int {
    dataLen := len(data)  // 缓存长度
    result := make([]int, 0, dataLen/2)  // 预分配容量
    
    for i := 0; i < dataLen; i += 2 {  // 直接跳过奇数索引
        result = append(result, data[i]<<1)  // 使用位运算
    }
    return result
}
```

#### 使用结构体嵌入优化
```go
// 重构前
type UserService struct {
    db *sql.DB
}

func (us *UserService) GetUser(id int) (*User, error) {
    // 实现
}

type OrderService struct {
    db *sql.DB
}

func (os *OrderService) GetOrder(id int) (*Order, error) {
    // 实现
}

// 重构后
type BaseRepository struct {
    db *sql.DB
}

func (br *BaseRepository) GetDB() *sql.DB {
    return br.db
}

type UserService struct {
    BaseRepository
}

func (us *UserService) GetUser(id int) (*User, error) {
    // 使用 us.GetDB()
}

type OrderService struct {
    BaseRepository
}

func (os *OrderService) GetOrder(id int) (*Order, error) {
    // 使用 os.GetDB()
}
```