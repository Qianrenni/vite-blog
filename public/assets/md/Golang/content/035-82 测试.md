## 8.2 测试

### 单元测试编写

```go
// math/math.go
package math

func Add(a, b int) int {
    return a + b
}

func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// math/math_test.go
package math

import (
    "testing"
)

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    if result != expected {
        t.Errorf("Add(2, 3) = %d; expected %d", result, expected)
    }
}

func TestDivide(t *testing.T) {
    result, err := Divide(10, 2)
    if err != nil {
        t.Fatalf("Divide(10, 2) returned error: %v", err)
    }
    if result != 5 {
        t.Errorf("Divide(10, 2) = %f; expected 5", result)
    }
}

func TestDivideByZero(t *testing.T) {
    _, err := Divide(10, 0)
    if err == nil {
        t.Error("Divide(10, 0) should return error")
    }
}
```

### 表格驱动测试

```go
func TestAddTable(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative numbers", -2, -3, -5},
        {"mixed numbers", -2, 3, 1},
        {"zero", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", 
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}

func TestValidateEmail(t *testing.T) {
    tests := []struct {
        email    string
        expected bool
    }{
        {"test@example.com", true},
        {"invalid-email", false},
        {"", false},
        {"test@", false},
        {"@example.com", false},
    }

    for _, tt := range tests {
        t.Run(tt.email, func(t *testing.T) {
            result := ValidateEmail(tt.email)
            if result != tt.expected {
                t.Errorf("ValidateEmail(%s) = %v; expected %v", 
                    tt.email, result, tt.expected)
            }
        })
    }
}
```

### 基准测试

```go
// benchmark_test.go
package main

import (
    "strings"
    "testing"
)

func BenchmarkStringsJoin(b *testing.B) {
    data := []string{"hello", "world", "go", "benchmark"}
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        _ = strings.Join(data, " ")
    }
}

func BenchmarkStringConcat(b *testing.B) {
    data := []string{"hello", "world", "go", "benchmark"}
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        var result string
        for _, s := range data {
            result += s + " "
        }
    }
}

func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Fibonacci(20)
    }
}

func Fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}

// 运行基准测试
// go test -bench=.
// go test -bench=BenchmarkStringsJoin -benchmem
```

### 示例测试

```go
// example_test.go
package main

import (
    "fmt"
)

func ExampleAdd() {
    result := Add(2, 3)
    fmt.Println(result)
    // Output: 5
}

func ExampleValidateEmail() {
    valid := ValidateEmail("test@example.com")
    fmt.Println(valid)
    // Output: true
}

func ExampleFibonacci() {
    result := Fibonacci(10)
    fmt.Println(result)
    // Output: 55
}
```

### 测试覆盖率

```bash
# 运行测试并生成覆盖率报告
go test -cover
go test -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
go tool cover -func=coverage.out

# 设置覆盖率阈值
go test -cover -coverprofile=coverage.out
go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//'
```

```go
// coverage_test.go
package main

import (
    "testing"
)

func TestWithCoverage(t *testing.T) {
    // 确保所有分支都被测试
    result, err := Divide(10, 2)
    if err != nil || result != 5 {
        t.Error("Normal division failed")
    }

    _, err = Divide(10, 0)
    if err == nil {
        t.Error("Division by zero should fail")
    }
}
```

### Mock测试

```go
// repository/user_repository.go
package repository

type User struct {
    ID   int
    Name string
}

type UserRepository interface {
    FindByID(id int) (*User, error)
    Save(user *User) error
}

type userRepository struct {
    // 数据库连接
}

func NewUserRepository() UserRepository {
    return &userRepository{}
}

func (r *userRepository) FindByID(id int) (*User, error) {
    // 实际数据库查询逻辑
    return &User{ID: id, Name: "Test User"}, nil
}

func (r *userRepository) Save(user *User) error {
    // 实际保存逻辑
    return nil
}

// mock/user_repository_mock.go
package mock

import (
    "errors"
    "myproject/repository"
)

type MockUserRepository struct {
    users map[int]*repository.User
    error error
}

func NewMockUserRepository() *MockUserRepository {
    return &MockUserRepository{
        users: make(map[int]*repository.User),
    }
}

func (m *MockUserRepository) SetError(err error) {
    m.error = err
}

func (m *MockUserRepository) FindByID(id int) (*repository.User, error) {
    if m.error != nil {
        return nil, m.error
    }
    user, exists := m.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    return user, nil
}

func (m *MockUserRepository) Save(user *repository.User) error {
    if m.error != nil {
        return m.error
    }
    m.users[user.ID] = user
    return nil
}

// service/user_service_test.go
package service

import (
    "errors"
    "testing"
    "myproject/mock"
    "myproject/repository"
)

func TestUserService_GetUserByID(t *testing.T) {
    mockRepo := mock.NewMockUserRepository()
    service := NewUserService(mockRepo)

    // 测试正常情况
    mockRepo.users[1] = &repository.User{ID: 1, Name: "John"}
    user, err := service.GetUserByID(1)
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }
    if user.Name != "John" {
        t.Errorf("Expected John, got %s", user.Name)
    }

    // 测试错误情况
    mockRepo.SetError(errors.New("database error"))
    _, err = service.GetUserByID(2)
    if err == nil {
        t.Error("Expected error, got nil")
    }
}
```

### 集成测试

```go
// integration/user_integration_test.go
package integration

import (
    "database/sql"
    "testing"
    "myproject/repository"
    _ "github.com/lib/pq"
)

func TestUserRepositoryIntegration(t *testing.T) {
    // 设置测试数据库
    db, err := sql.Open("postgres", "test_db_connection_string")
    if err != nil {
        t.Fatalf("Failed to connect to database: %v", err)
    }
    defer db.Close()

    repo := repository.NewUserRepository(db)

    // 测试保存用户
    user := &repository.User{Name: "Integration Test User"}
    err = repo.Save(user)
    if err != nil {
        t.Fatalf("Failed to save user: %v", err)
    }

    // 测试查找用户
    foundUser, err := repo.FindByID(user.ID)
    if err != nil {
        t.Fatalf("Failed to find user: %v", err)
    }
    if foundUser.Name != user.Name {
        t.Errorf("Expected %s, got %s", user.Name, foundUser.Name)
    }
}
```

### 压力测试

```go
// stress/stress_test.go
package stress

import (
    "net/http"
    "testing"
    "time"
)

func BenchmarkHTTPServer(b *testing.B) {
    // 启动测试服务器
    server := startTestServer()
    defer server.Close()

    client := &http.Client{
        Timeout: 10 * time.Second,
    }

    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            resp, err := client.Get(server.URL + "/api/users")
            if err != nil {
                b.Errorf("Request failed: %v", err)
                continue
            }
            resp.Body.Close()
        }
    })
}

func startTestServer() *http.Server {
    // 启动测试HTTP服务器
    server := &http.Server{
        Addr: ":8080",
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte("OK"))
        }),
    }
    go server.ListenAndServe()
    time.Sleep(100 * time.Millisecond) // 等待服务器启动
    return server
}
```

### 测试工具链

#### 常用测试命令
```bash
# 基本测试
go test ./...

# 详细输出
go test -v ./...

# 并行测试
go test -parallel 4 ./...

# 竞态检测
go test -race ./...

# 覆盖率分析
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 性能分析
go test -bench=. -cpuprofile=cpu.prof
go tool pprof cpu.prof
```

#### 测试工具配置
```go
// go.mod 中的测试依赖
require (
    github.com/stretchr/testify v1.8.0
    github.com/golang/mock v1.6.0
    golang.org/x/tools v0.1.0 // indirect
)

// testdata 目录结构
testdata/
├── fixtures/
│   ├── users.json
│   └── orders.json
├── config/
│   └── test.yaml
└── scripts/
    └── setup.sh
```