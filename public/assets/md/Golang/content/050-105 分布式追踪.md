## 10.5 分布式追踪

### OpenTelemetry

```go
// OpenTelemetry分布式追踪实现
package opentelemetry

import (
    "context"
    "fmt"
    "log"
    "time"

    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/exporters/zipkin"
    "go.opentelemetry.io/otel/propagation"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
    "go.opentelemetry.io/otel/trace"
)

// 追踪器配置
type TracerConfig struct {
    ServiceName    string
    ServiceVersion string
    Environment    string
    ExporterType   string // "jaeger", "zipkin", "stdout"
    Endpoint       string
    SamplerRatio   float64
}

// OpenTelemetry追踪器
type OpenTelemetryTracer struct {
    tracerProvider *trace.TracerProvider
    tracer         trace.Tracer
    propagator     propagation.TextMapPropagator
}

func NewOpenTelemetryTracer(config *TracerConfig) (*OpenTelemetryTracer, error) {
    // 创建资源
    res, err := resource.New(context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String(config.ServiceName),
            semconv.ServiceVersionKey.String(config.ServiceVersion),
            semconv.DeploymentEnvironmentKey.String(config.Environment),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create resource: %v", err)
    }
    
    // 创建导出器
    var exporter trace.SpanExporter
    switch config.ExporterType {
    case "jaeger":
        exporter, err = jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(config.Endpoint)))
    case "zipkin":
        exporter, err = zipkin.New(config.Endpoint)
    case "stdout":
        exporter = stdouttrace.New(stdouttrace.WithPrettyPrint())
    default:
        return nil, fmt.Errorf("unsupported exporter type: %s", config.ExporterType)
    }
    
    if err != nil {
        return nil, fmt.Errorf("failed to create exporter: %v", err)
    }
    
    // 创建采样器
    sampler := trace.ParentBased(trace.TraceIDRatioBased(config.SamplerRatio))
    
    // 创建追踪器提供者
    tracerProvider := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(res),
        trace.WithSampler(sampler),
    )
    
    // 设置全局追踪器提供者
    otel.SetTracerProvider(tracerProvider)
    
    // 设置全局传播器
    propagator := propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})
    otel.SetTextMapPropagator(propagator)
    
    tracer := tracerProvider.Tracer(
        config.ServiceName,
        trace.WithInstrumentationVersion("1.0.0"),
    )
    
    return &OpenTelemetryTracer{
        tracerProvider: tracerProvider,
        tracer:         tracer,
        propagator:     propagator,
    }, nil
}

func (ott *OpenTelemetryTracer) StartSpan(ctx context.Context, name string, opts ...trace.SpanStartOption) (context.Context, trace.Span) {
    return ott.tracer.Start(ctx, name, opts...)
}

func (ott *OpenTelemetryTracer) StartSpanWithAttributes(ctx context.Context, name string, attrs map[string]interface{}) (context.Context, trace.Span) {
    var spanOpts []trace.SpanStartOption
    var attributes []attribute.KeyValue
    
    for key, value := range attrs {
        switch v := value.(type) {
        case string:
            attributes = append(attributes, attribute.String(key, v))
        case int:
            attributes = append(attributes, attribute.Int(key, v))
        case int64:
            attributes = append(attributes, attribute.Int64(key, v))
        case float64:
            attributes = append(attributes, attribute.Float64(key, v))
        case bool:
            attributes = append(attributes, attribute.Bool(key, v))
        }
    }
    
    if len(attributes) > 0 {
        spanOpts = append(spanOpts, trace.WithAttributes(attributes...))
    }
    
    return ott.tracer.Start(ctx, name, spanOpts...)
}

func (ott *OpenTelemetryTracer) AddEvent(span trace.Span, name string, attrs map[string]interface{}) {
    var attributes []attribute.KeyValue
    
    for key, value := range attrs {
        switch v := value.(type) {
        case string:
            attributes = append(attributes, attribute.String(key, v))
        case int:
            attributes = append(attributes, attribute.Int(key, v))
        case int64:
            attributes = append(attributes, attribute.Int64(key, v))
        case float64:
            attributes = append(attributes, attribute.Float64(key, v))
        case bool:
            attributes = append(attributes, attribute.Bool(key, v))
        }
    }
    
    span.AddEvent(name, trace.WithAttributes(attributes...))
}

func (ott *OpenTelemetryTracer) RecordError(span trace.Span, err error) {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
}

func (ott *OpenTelemetryTracer) Shutdown(ctx context.Context) error {
    return ott.tracerProvider.Shutdown(ctx)
}

// HTTP中间件
type HTTPMiddleware struct {
    tracer *OpenTelemetryTracer
}

func NewHTTPMiddleware(tracer *OpenTelemetryTracer) *HTTPMiddleware {
    return &HTTPMiddleware{tracer: tracer}
}

func (hm *HTTPMiddleware) Trace(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从请求头中提取追踪上下文
        ctx := hm.tracer.propagator.Extract(r.Context(), propagation.HeaderCarrier(r.Header))
        
        // 创建HTTP请求span
        attrs := map[string]interface{}{
            "http.method": r.Method,
            "http.url":    r.URL.String(),
            "http.host":   r.Host,
            "http.scheme": r.URL.Scheme,
        }
        
        ctx, span := hm.tracer.StartSpanWithAttributes(ctx, "HTTP "+r.Method, attrs)
        defer span.End()
        
        // 添加请求信息到span
        span.SetAttributes(
            attribute.String("http.user_agent", r.UserAgent()),
            attribute.String("http.client_ip", getClientIP(r)),
        )
        
        // 将追踪上下文注入响应头（用于调试）
        hm.tracer.propagator.Inject(ctx, propagation.HeaderCarrier(w.Header()))
        
        // 创建包装的ResponseWriter来捕获状态码
        wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // 处理请求
        next.ServeHTTP(wrapped, r.WithContext(ctx))
        
        // 记录响应状态码
        span.SetAttributes(attribute.Int("http.status_code", wrapped.statusCode))
        
        // 根据状态码设置span状态
        if wrapped.statusCode >= 500 {
            span.SetStatus(codes.Error, "Server Error")
        } else if wrapped.statusCode >= 400 {
            span.SetStatus(codes.Error, "Client Error")
        }
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

func getClientIP(r *http.Request) string {
    ip := r.Header.Get("X-Forwarded-For")
    if ip == "" {
        ip = r.Header.Get("X-Real-IP")
    }
    if ip == "" {
        ip = r.RemoteAddr
    }
    return ip
}

// gRPC拦截器
type GRPCInterceptor struct {
    tracer *OpenTelemetryTracer
}

func NewGRPCInterceptor(tracer *OpenTelemetryTracer) *GRPCInterceptor {
    return &GRPCInterceptor{tracer: tracer}
}

func (gi *GRPCInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 创建gRPC span
        attrs := map[string]interface{}{
            "rpc.system":    "grpc",
            "rpc.service":   info.FullMethod,
            "rpc.method":    getMethodName(info.FullMethod),
            "net.peer.ip":   getPeerIP(ctx),
        }
        
        ctx, span := gi.tracer.StartSpanWithAttributes(ctx, "gRPC "+info.FullMethod, attrs)
        defer span.End()
        
        // 处理请求
        resp, err := handler(ctx, req)
        
        // 记录结果
        if err != nil {
            gi.tracer.RecordError(span, err)
            span.SetAttributes(attribute.String("rpc.error", err.Error()))
        }
        
        return resp, err
    }
}

func (gi *GRPCInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // 创建客户端gRPC span
        attrs := map[string]interface{}{
            "rpc.system":  "grpc",
            "rpc.service": method,
            "rpc.method":  getMethodName(method),
        }
        
        ctx, span := gi.tracer.StartSpanWithAttributes(ctx, "gRPC client "+method, attrs)
        defer span.End()
        
        // 注入追踪上下文到请求元数据
        ctx = gi.tracer.propagator.Inject(ctx, metadata.NewOutgoingContext(ctx, metadata.MD{}))
        
        // 调用gRPC方法
        err := invoker(ctx, method, req, reply, cc, opts...)
        
        // 记录结果
        if err != nil {
            gi.tracer.RecordError(span, err)
            span.SetAttributes(attribute.String("rpc.error", err.Error()))
        }
        
        return err
    }
}

func getMethodName(fullMethod string) string {
    parts := strings.Split(fullMethod, "/")
    if len(parts) > 0 {
        return parts[len(parts)-1]
    }
    return fullMethod
}

func getPeerIP(ctx context.Context) string {
    if peer, ok := peer.FromContext(ctx); ok {
        return peer.Addr.String()
    }
    return ""
}

// 数据库追踪
type DatabaseTracer struct {
    tracer *OpenTelemetryTracer
}

func NewDatabaseTracer(tracer *OpenTelemetryTracer) *DatabaseTracer {
    return &DatabaseTracer{tracer: tracer}
}

func (dt *DatabaseTracer) TraceQuery(ctx context.Context, query string, args ...interface{}) (context.Context, trace.Span) {
    attrs := map[string]interface{}{
        "db.system":      "postgresql", // 或其他数据库类型
        "db.statement":   query,
        "db.operation":   getOperationFromQuery(query),
    }
    
    // 添加参数信息（注意不要记录敏感信息）
    if len(args) > 0 {
        attrs["db.args_count"] = len(args)
    }
    
    return dt.tracer.StartSpanWithAttributes(ctx, "DB Query", attrs)
}

func getOperationFromQuery(query string) string {
    query = strings.TrimSpace(query)
    if len(query) == 0 {
        return "unknown"
    }
    
    parts := strings.Fields(strings.ToUpper(query))
    if len(parts) > 0 {
        return parts[0]
    }
    
    return "unknown"
}

// 缓存追踪
type CacheTracer struct {
    tracer *OpenTelemetryTracer
}

func NewCacheTracer(tracer *OpenTelemetryTracer) *CacheTracer {
    return &CacheTracer{tracer: tracer}
}

func (ct *CacheTracer) TraceGet(ctx context.Context, key string) (context.Context, trace.Span) {
    attrs := map[string]interface{}{
        "cache.system": "redis",
        "cache.key":    key,
        "cache.operation": "get",
    }
    
    return ct.tracer.StartSpanWithAttributes(ctx, "Cache Get", attrs)
}

func (ct *CacheTracer) TraceSet(ctx context.Context, key string, value interface{}) (context.Context, trace.Span) {
    attrs := map[string]interface{}{
        "cache.system": "redis",
        "cache.key":    key,
        "cache.operation": "set",
        "cache.value_size": getValueSize(value),
    }
    
    return ct.tracer.StartSpanWithAttributes(ctx, "Cache Set", attrs)
}

func getValueSize(value interface{}) int {
    // 计算值的大小（简化实现）
    switch v := value.(type) {
    case string:
        return len(v)
    case []byte:
        return len(v)
    default:
        return len(fmt.Sprintf("%v", v))
    }
}

// 消息队列追踪
type MessageTracer struct {
    tracer *OpenTelemetryTracer
}

func NewMessageTracer(tracer *OpenTelemetryTracer) *MessageTracer {
    return &MessageTracer{tracer: tracer}
}

func (mt *MessageTracer) TracePublish(ctx context.Context, topic string, message []byte) (context.Context, trace.Span) {
    attrs := map[string]interface{}{
        "messaging.system": "rabbitmq", // 或其他消息系统
        "messaging.destination": topic,
        "messaging.operation": "publish",
        "messaging.message_size": len(message),
    }
    
    return mt.tracer.StartSpanWithAttributes(ctx, "Message Publish", attrs)
}

func (mt *MessageTracer) TraceConsume(ctx context.Context, topic string, message []byte) (context.Context, trace.Span) {
    attrs := map[string]interface{}{
        "messaging.system": "rabbitmq",
        "messaging.destination": topic,
        "messaging.operation": "consume",
        "messaging.message_size": len(message),
    }
    
    return mt.tracer.StartSpanWithAttributes(ctx, "Message Consume", attrs)
}

// 追踪上下文工具
type TraceContext struct {
    TraceID string
    SpanID  string
    Sampled bool
}

func GetCurrentTraceContext(ctx context.Context) *TraceContext {
    span := trace.SpanFromContext(ctx)
    if !span.IsRecording() {
        return nil
    }
    
    spanContext := span.SpanContext()
    if !spanContext.IsValid() {
        return nil
    }
    
    return &TraceContext{
        TraceID: spanContext.TraceID().String(),
        SpanID:  spanContext.SpanID().String(),
        Sampled: spanContext.IsSampled(),
    }
}

// 使用示例
func main() {
    // 配置追踪器
    config := &TracerConfig{
        ServiceName:    "user-service",
        ServiceVersion: "1.0.0",
        Environment:    "production",
        ExporterType:   "jaeger",
        Endpoint:       "http://localhost:14268/api/traces",
        SamplerRatio:   1.0, // 采样率100%
    }
    
    // 创建OpenTelemetry追踪器
    tracer, err := NewOpenTelemetryTracer(config)
    if err != nil {
        log.Fatalf("Failed to create tracer: %v", err)
    }
    defer tracer.Shutdown(context.Background())
    
    // 创建HTTP中间件
    httpMiddleware := NewHTTPMiddleware(tracer)
    
    // 创建gRPC拦截器
    grpcInterceptor := NewGRPCInterceptor(tracer)
    
    // 创建数据库追踪器
    dbTracer := NewDatabaseTracer(tracer)
    
    // 创建缓存追踪器
    cacheTracer := NewCacheTracer(tracer)
    
    // HTTP服务器示例
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        // 模拟业务逻辑
        ctx := r.Context()
        
        // 数据库查询追踪
        dbCtx, dbSpan := dbTracer.TraceQuery(ctx, "SELECT * FROM users WHERE id = $1", 123)
        time.Sleep(50 * time.Millisecond) // 模拟数据库查询时间
        dbSpan.End()
        
        // 缓存操作追踪
        cacheCtx, cacheSpan := cacheTracer.TraceGet(ctx, "user:123")
        time.Sleep(10 * time.Millisecond) // 模拟缓存查询时间
        cacheSpan.End()
        
        // 返回响应
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"id": 123, "name": "John Doe"}`))
    })
    
    // 包装HTTP处理程序
    wrappedHandler := httpMiddleware.Trace(http.DefaultServeMux)
    
    log.Println("Starting HTTP server on :8080")
    if err := http.ListenAndServe(":8080", wrappedHandler); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}
```

### Jaeger

```go
// Jaeger分布式追踪实现
package jaeger

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/uber/jaeger-client-go"
    "github.com/uber/jaeger-client-go/config"
    "github.com/uber/jaeger-client-go/zipkin"
    "github.com/uber/jaeger-lib/metrics"
    "github.com/opentracing/opentracing-go"
    "github.com/opentracing/opentracing-go/ext"
)

// Jaeger配置
type JaegerConfig struct {
    ServiceName     string
    CollectorHost   string
    CollectorPort   int
    AgentHost       string
    AgentPort       int
    SamplerType     string
    SamplerParam    float64
    ReporterLogSpans bool
    ReporterBufferFlushInterval time.Duration
}

// Jaeger追踪器
type JaegerTracer struct {
    tracer opentracing.Tracer
    closer io.Closer
}

func NewJaegerTracer(config *JaegerConfig) (*JaegerTracer, error) {
    cfg := config.Configuration{
        ServiceName: config.ServiceName,
        Sampler: &config.SamplerConfig{
            Type:  config.SamplerType,
            Param: config.SamplerParam,
        },
        Reporter: &config.ReporterConfig{
            LogSpans:            config.ReporterLogSpans,
            BufferFlushInterval: config.ReporterBufferFlushInterval,
            LocalAgentHostPort:  fmt.Sprintf("%s:%d", config.AgentHost, config.AgentPort),
        },
    }
    
    // 如果配置了收集器，则使用收集器
    if config.CollectorHost != "" {
        cfg.Reporter.CollectorEndpoint = fmt.Sprintf("http://%s:%d/api/traces", 
            config.CollectorHost, config.CollectorPort)
    }
    
    tracer, closer, err := cfg.NewTracer(
        config.Logger(jaeger.StdLogger),
        config.Metrics(metrics.NullFactory),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create Jaeger tracer: %v", err)
    }
    
    opentracing.SetGlobalTracer(tracer)
    
    return &JaegerTracer{
        tracer: tracer,
        closer: closer,
    }, nil
}

func (jt *JaegerTracer) StartSpan(operationName string, opts ...opentracing.StartSpanOption) opentracing.Span {
    return jt.tracer.StartSpan(operationName, opts...)
}

func (jt *JaegerTracer) StartSpanFromContext(ctx context.Context, operationName string, opts ...opentracing.StartSpanOption) (opentracing.Span, context.Context) {
    return opentracing.StartSpanFromContextWithTracer(ctx, jt.tracer, operationName, opts...)
}

func (jt *JaegerTracer) Inject(span opentracing.Span, format interface{}, carrier interface{}) error {
    return jt.tracer.Inject(span.Context(), format, carrier)
}

func (jt *JaegerTracer) Extract(format interface{}, carrier interface{}) (opentracing.SpanContext, error) {
    return jt.tracer.Extract(format, carrier)
}

func (jt *JaegerTracer) Close() error {
    if jt.closer != nil {
        return jt.closer.Close()
    }
    return nil
}

// HTTP中间件
type HTTPMiddleware struct {
    tracer *JaegerTracer
}

func NewHTTPMiddleware(tracer *JaegerTracer) *HTTPMiddleware {
    return &HTTPMiddleware{tracer: tracer}
}

func (hm *HTTPMiddleware) Trace(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从请求头中提取追踪上下文
        spanCtx, _ := hm.tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))
        
        // 创建HTTP请求span
        span := hm.tracer.StartSpan("HTTP "+r.Method, ext.RPCServerOption(spanCtx))
        defer span.Finish()
        
        // 添加HTTP标签
        ext.HTTPMethod.Set(span, r.Method)
        ext.HTTPUrl.Set(span, r.URL.String())
        ext.Component.Set(span, "HTTP")
        span.SetTag("http.host", r.Host)
        span.SetTag("http.user_agent", r.UserAgent())
        span.SetTag("http.client_ip", getClientIP(r))
        
        // 将span注入到上下文
        ctx := opentracing.ContextWithSpan(r.Context(), span)
        
        // 创建包装的ResponseWriter来捕获状态码
        wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // 处理请求
        next.ServeHTTP(wrapped, r.WithContext(ctx))
        
        // 记录响应状态码
        ext.HTTPStatusCode.Set(span, uint16(wrapped.statusCode))
        
        // 根据状态码设置span状态
        if wrapped.statusCode >= 500 {
            ext.Error.Set(span, true)
        } else if wrapped.statusCode >= 400 {
            ext.Error.Set(span, true)
        }
    })
}

// gRPC拦截器
type GRPCInterceptor struct {
    tracer *JaegerTracer
}

func NewGRPCInterceptor(tracer *JaegerTracer) *GRPCInterceptor {
    return &GRPCInterceptor{tracer: tracer}
}

func (gi *GRPCInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // 从gRPC元数据中提取追踪上下文
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok {
            md = metadata.MD{}
        }
        
        spanCtx, _ := gi.tracer.Extract(opentracing.HTTPHeaders, metadataReaderWriter{md: md})
        
        // 创建gRPC span
        span := gi.tracer.StartSpan("gRPC "+info.FullMethod, ext.RPCServerOption(spanCtx))
        defer span.Finish()
        
        // 添加gRPC标签
        ext.Component.Set(span, "gRPC")
        span.SetTag("grpc.service", info.FullMethod)
        span.SetTag("grpc.method", getMethodName(info.FullMethod))
        
        // 将span注入到上下文
        ctx = opentracing.ContextWithSpan(ctx, span)
        
        // 处理请求
        resp, err := handler(ctx, req)
        
        // 记录结果
        if err != nil {
            ext.Error.Set(span, true)
            span.SetTag("grpc.error", err.Error())
        }
        
        return resp, err
    }
}

func (gi *GRPCInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // 创建客户端gRPC span
        span, ctx := gi.tracer.StartSpanFromContext(ctx, "gRPC client "+method)
        defer span.Finish()
        
        // 添加gRPC标签
        ext.Component.Set(span, "gRPC-client")
        span.SetTag("grpc.service", method)
        span.SetTag("grpc.method", getMethodName(method))
        
        // 将追踪上下文注入到gRPC元数据
        md, ok := metadata.FromOutgoingContext(ctx)
        if !ok {
            md = metadata.MD{}
        } else {
            md = md.Copy()
        }
        
        err := gi.tracer.Inject(span.Context(), opentracing.HTTPHeaders, metadataReaderWriter{md: md})
        if err != nil {
            log.Printf("Failed to inject span context: %v", err)
        }
        
        ctx = metadata.NewOutgoingContext(ctx, md)
        
        // 调用gRPC方法
        err = invoker(ctx, method, req, reply, cc, opts...)
        
        // 记录结果
        if err != nil {
            ext.Error.Set(span, true)
            span.SetTag("grpc.error", err.Error())
        }
        
        return err
    }
}

// 数据库追踪
type DatabaseTracer struct {
    tracer *JaegerTracer
}

func NewDatabaseTracer(tracer *JaegerTracer) *DatabaseTracer {
    return &DatabaseTracer{tracer: tracer}
}

func (dt *DatabaseTracer) TraceQuery(ctx context.Context, query string, args ...interface{}) (opentracing.Span, context.Context) {
    span, ctx := opentracing.StartSpanFromContext(ctx, "DB Query")
    
    // 添加数据库标签
    span.SetTag("db.system", "postgresql") // 或其他数据库类型
    span.SetTag("db.statement", query)
    span.SetTag("db.operation", getOperationFromQuery(query))
    
    // 添加参数信息（注意不要记录敏感信息）
    if len(args) > 0 {
        span.SetTag("db.args_count", len(args))
    }
    
    return span, ctx
}

// 缓存追踪
type CacheTracer struct {
    tracer *JaegerTracer
}

func NewCacheTracer(tracer *JaegerTracer) *CacheTracer {
    return &CacheTracer{tracer: tracer}
}

func (ct *CacheTracer) TraceGet(ctx context.Context, key string) (opentracing.Span, context.Context) {
    span, ctx := opentracing.StartSpanFromContext(ctx, "Cache Get")
    
    span.SetTag("cache.system", "redis")
    span.SetTag("cache.key", key)
    span.SetTag("cache.operation", "get")
    
    return span, ctx
}

func (ct *CacheTracer) TraceSet(ctx context.Context, key string, value interface{}) (opentracing.Span, context.Context) {
    span, ctx := opentracing.StartSpanFromContext(ctx, "Cache Set")
    
    span.SetTag("cache.system", "redis")
    span.SetTag("cache.key", key)
    span.SetTag("cache.operation", "set")
    span.SetTag("cache.value_size", getValueSize(value))
    
    return span, ctx
}

// 辅助函数
func getClientIP(r *http.Request) string {
    ip := r.Header.Get("X-Forwarded-For")
    if ip == "" {
        ip = r.Header.Get("X-Real-IP")
    }
    if ip == "" {
        ip = r.RemoteAddr
    }
    return ip
}

func getMethodName(fullMethod string) string {
    parts := strings.Split(fullMethod, "/")
    if len(parts) > 0 {
        return parts[len(parts)-1]
    }
    return fullMethod
}

func getOperationFromQuery(query string) string {
    query = strings.TrimSpace(query)
    if len(query) == 0 {
        return "unknown"
    }
    
    parts := strings.Fields(strings.ToUpper(query))
    if len(parts) > 0 {
        return parts[0]
    }
    
    return "unknown"
}

func getValueSize(value interface{}) int {
    switch v := value.(type) {
    case string:
        return len(v)
    case []byte:
        return len(v)
    default:
        return len(fmt.Sprintf("%v", v))
    }
}

// gRPC元数据读写器
type metadataReaderWriter struct {
    md metadata.MD
}

func (w metadataReaderWriter) Set(key, val string) {
    key = strings.ToLower(key)
    w.md[key] = append(w.md[key], val)
}

func (w metadataReaderWriter) ForeachKey(handler func(key, val string) error) error {
    for k, vals := range w.md {
        for _, v := range vals {
            if err := handler(k, v); err != nil {
                return err
            }
        }
    }
    return nil
}

// 使用示例
func main() {
    // 配置Jaeger
    config := &JaegerConfig{
        ServiceName:     "user-service",
        AgentHost:       "localhost",
        AgentPort:       6831,
        SamplerType:     "const",
        SamplerParam:    1,
        ReporterLogSpans: true,
        ReporterBufferFlushInterval: 1 * time.Second,
    }
    
    // 创建Jaeger追踪器
    tracer, err := NewJaegerTracer(config)
    if err != nil {
        log.Fatalf("Failed to create Jaeger tracer: %v", err)
    }
    defer tracer.Close()
    
    // 创建HTTP中间件
    httpMiddleware := NewHTTPMiddleware(tracer)
    
    // 创建gRPC拦截器
    grpcInterceptor := NewGRPCInterceptor(tracer)
    
    // 创建数据库追踪器
    dbTracer := NewDatabaseTracer(tracer)
    
    // HTTP服务器示例
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        // 模拟业务逻辑
        ctx := r.Context()
        
        // 数据库查询追踪
        dbSpan, _ := dbTracer.TraceQuery(ctx, "SELECT * FROM users WHERE id = $1", 123)
        time.Sleep(50 * time.Millisecond) // 模拟数据库查询时间
        dbSpan.Finish()
        
        // 返回响应
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"id": 123, "name": "John Doe"}`))
    })
    
    // 包装HTTP处理程序
    wrappedHandler := httpMiddleware.Trace(http.DefaultServeMux)
    
    log.Println("Starting HTTP server on :8080")
    if err := http.ListenAndServe(":8080", wrappedHandler); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}
```

### Zipkin

```go
// Zipkin分布式追踪实现
package zipkin

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"

    zipkin "github.com/openzipkin/zipkin-go"
    zipkinhttp "github.com/openzipkin/zipkin-go/middleware/http"
    zipkingrpc "github.com/openzipkin/zipkin-go/middleware/grpc"
    "github.com/openzipkin/zipkin-go/reporter"
    httpreporter "github.com/openzipkin/zipkin-go/reporter/http"
    "google.golang.org/grpc"
)

// Zipkin配置
type ZipkinConfig struct {
    ServiceName     string
    Endpoint        string
    SampleRate      float64
    ReporterTimeout time.Duration
    LocalEndpoint   string
}

// Zipkin追踪器
type ZipkinTracer struct {
    tracer   *zipkin.Tracer
    reporter reporter.Reporter
}

func NewZipkinTracer(config *ZipkinConfig) (*ZipkinTracer, error) {
    // 创建报告器
    reporter := httpreporter.NewReporter(
        config.Endpoint,
        httpreporter.Timeout(config.ReporterTimeout),
    )
    
    // 创建本地端点
    endpoint, err := zipkin.NewEndpoint(config.ServiceName, config.LocalEndpoint)
    if err != nil {
        return nil, fmt.Errorf("failed to create endpoint: %v", err)
    }
    
    // 创建追踪器
    tracer, err := zipkin.NewTracer(
        reporter,
        zipkin.WithLocalEndpoint(endpoint),
        zipkin.WithSampler(zipkin.NewModuloSampler(config.SampleRate)),
        zipkin.WithTraceID128Bit(true),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create tracer: %v", err)
    }
    
    return &ZipkinTracer{
        tracer:   tracer,
        reporter: reporter,
    }, nil
}

func (zt *ZipkinTracer) StartSpan(name string, opts ...zipkin.SpanOption) zipkin.Span {
    return zt.tracer.StartSpan(name, opts...)
}

func (zt *ZipkinTracer) StartSpanFromContext(ctx context.Context, name string, opts ...zipkin.SpanOption) (zipkin.Span, context.Context) {
    span := zt.tracer.StartSpanFromContext(ctx, name, opts...)
    return span, zipkin.NewContext(ctx, span)
}

func (zt *ZipkinTracer) Close() error {
    if zt.reporter != nil {
        return zt.reporter.Close()
    }
    return nil
}

// HTTP中间件
type HTTPMiddleware struct {
    tracer *ZipkinTracer
}

func NewHTTPMiddleware(tracer *ZipkinTracer) *HTTPMiddleware {
    return &HTTPMiddleware{tracer: tracer}
}

func (hm *HTTPMiddleware) Trace(next http.Handler) http.Handler {
    return zipkinhttp.NewServerMiddleware(
        hm.tracer.tracer,
        zipkinhttp.SpanName("HTTP"),
        zipkinhttp.TagResponseSize(true),
        zipkinhttp.ServerTags(map[string]string{
            "component": "HTTP",
        }),
    )(next)
}

func (hm *HTTPMiddleware) Client() *zipkinhttp.Client {
    return zipkinhttp.NewClient(hm.tracer.tracer)
}

// gRPC拦截器
type GRPCInterceptor struct {
    tracer *ZipkinTracer
}

func NewGRPCInterceptor(tracer *ZipkinTracer) *GRPCInterceptor {
    return &GRPCInterceptor{tracer: tracer}
}

func (gi *GRPCInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor {
    return zipkingrpc.NewUnaryServerInterceptor(gi.tracer.tracer)
}

func (gi *GRPCInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor {
    return zipkingrpc.NewStreamServerInterceptor(gi.tracer.tracer)
}

func (gi *GRPCInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor {
    return zipkingrpc.NewUnaryClientInterceptor(gi.tracer.tracer)
}

func (gi *GRPCInterceptor) StreamClientInterceptor() grpc.StreamClientInterceptor {
    return zipkingrpc.NewStreamClientInterceptor(gi.tracer.tracer)
}

// 数据库追踪
type DatabaseTracer struct {
    tracer *ZipkinTracer
}

func NewDatabaseTracer(tracer *ZipkinTracer) *DatabaseTracer {
    return &DatabaseTracer{tracer: tracer}
}

func (dt *DatabaseTracer) TraceQuery(ctx context.Context, query string, args ...interface{}) (zipkin.Span, context.Context) {
    span := dt.tracer.tracer.StartSpanFromContext(ctx, "DB Query")
    
    // 添加数据库标签
    span.Tag("db.system", "postgresql")
    span.Tag("db.statement", query)
    span.Tag("db.operation", getOperationFromQuery(query))
    
    if len(args) > 0 {
        span.Tag("db.args_count", fmt.Sprintf("%d", len(args)))
    }
    
    return span, zipkin.NewContext(ctx, span)
}

// 缓存追踪
type CacheTracer struct {
    tracer *ZipkinTracer
}

func NewCacheTracer(tracer *ZipkinTracer) *CacheTracer {
    return &CacheTracer{tracer: tracer}
}

func (ct *CacheTracer) TraceGet(ctx context.Context, key string) (zipkin.Span, context.Context) {
    span := ct.tracer.tracer.StartSpanFromContext(ctx, "Cache Get")
    
    span.Tag("cache.system", "redis")
    span.Tag("cache.key", key)
    span.Tag("cache.operation", "get")
    
    return span, zipkin.NewContext(ctx, span)
}

func (ct *CacheTracer) TraceSet(ctx context.Context, key string, value interface{}) (zipkin.Span, context.Context) {
    span := ct.tracer.tracer.StartSpanFromContext(ctx, "Cache Set")
    
    span.Tag("cache.system", "redis")
    span.Tag("cache.key", key)
    span.Tag("cache.operation", "set")
    span.Tag("cache.value_size", fmt.Sprintf("%d", getValueSize(value)))
    
    return span, zipkin.NewContext(ctx, span)
}

// HTTP客户端追踪
type HTTPClientTracer struct {
    tracer *ZipkinTracer
    client *zipkinhttp.Client
}

func NewHTTPClientTracer(tracer *ZipkinTracer) *HTTPClientTracer {
    return &HTTPClientTracer{
        tracer: tracer,
        client: zipkinhttp.NewClient(tracer.tracer),
    }
}

func (hct *HTTPClientTracer) Do(req *http.Request) (*http.Response, error) {
    return hct.client.DoWithAppSpan(req, "HTTP Client")
}

func (hct *HTTPClientTracer) Get(url string) (*http.Response, error) {
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        return nil, err
    }
    return hct.Do(req)
}

func (hct *HTTPClientTracer) Post(url, contentType string, body io.Reader) (*http.Response, error) {
    req, err := http.NewRequest("POST", url, body)
    if err != nil {
        return nil, err
    }
    req.Header.Set("Content-Type", contentType)
    return hct.Do(req)
}

// 辅助函数
func getOperationFromQuery(query string) string {
    query = strings.TrimSpace(query)
    if len(query) == 0 {
        return "unknown"
    }
    
    parts := strings.Fields(strings.ToUpper(query))
    if len(parts) > 0 {
        return parts[0]
    }
    
    return "unknown"
}

func getValueSize(value interface{}) int {
    switch v := value.(type) {
    case string:
        return len(v)
    case []byte:
        return len(v)
    default:
        return len(fmt.Sprintf("%v", v))
    }
}

// 使用示例
func main() {
    // 配置Zipkin
    config := &ZipkinConfig{
        ServiceName:     "user-service",
        Endpoint:        "http://localhost:9411/api/v2/spans",
        SampleRate:      1.0,
        ReporterTimeout: 1 * time.Second,
        LocalEndpoint:   "localhost:8080",
    }
    
    // 创建Zipkin追踪器
    tracer, err := NewZipkinTracer(config)
    if err != nil {
        log.Fatalf("Failed to create Zipkin tracer: %v", err)
    }
    defer tracer.Close()
    
    // 创建HTTP中间件
    httpMiddleware := NewHTTPMiddleware(tracer)
    
    // 创建gRPC拦截器
    grpcInterceptor := NewGRPCInterceptor(tracer)
    
    // 创建数据库追踪器
    dbTracer := NewDatabaseTracer(tracer)
    
    // 创建HTTP客户端追踪器
    httpClientTracer := NewHTTPClientTracer(tracer)
    
    // HTTP服务器示例
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        // 模拟业务逻辑
        ctx := r.Context()
        
        // 数据库查询追踪
        dbSpan, _ := dbTracer.TraceQuery(ctx, "SELECT * FROM users WHERE id = $1", 123)
        time.Sleep(50 * time.Millisecond) // 模拟数据库查询时间
        dbSpan.Finish()
        
        // 调用外部API
        resp, err := httpClientTracer.Get("http://api.example.com/data")
        if err != nil {
            log.Printf("Failed to call external API: %v", err)
        } else {
            resp.Body.Close()
        }
        
        // 返回响应
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"id": 123, "name": "John Doe"}`))
    })
    
    // 包装HTTP处理程序
    wrappedHandler := httpMiddleware.Trace(http.DefaultServeMux)
    
    log.Println("Starting HTTP server on :8080")
    if err := http.ListenAndServe(":8080", wrappedHandler); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}
```

### 链路追踪实现

```go
// 链路追踪通用实现
package tracing

import (
    "context"
    "fmt"
    "log"
    "sync"
    "time"
)

// 追踪接口
type Tracer interface {
    StartSpan(ctx context.Context, name string, opts ...SpanOption) (Span, context.Context)
    Inject(spanContext SpanContext, carrier TextMapCarrier) error
    Extract(carrier TextMapCarrier) (SpanContext, error)
}

// Span接口
type Span interface {
    SpanContext() SpanContext
    SetName(name string)
    SetTag(key string, value interface{})
    LogKV(alternatingKeyValues ...interface{})
    LogFields(fields ...Field)
    Finish()
    FinishWithOptions(opts FinishOptions)
}

// Span上下文
type SpanContext interface {
    TraceID() string
    SpanID() string
    ParentSpanID() string
    IsValid() bool
    IsSampled() bool
}

// 追踪选项
type TracerOption func(*tracerOptions)

type tracerOptions struct {
    serviceName    string
    serviceVersion string
    environment    string
    sampleRate     float64
    reporter       Reporter
    propagator     Propagator
}

func WithServiceName(name string) TracerOption {
    return func(opts *tracerOptions) {
        opts.serviceName = name
    }
}

func WithServiceVersion(version string) TracerOption {
    return func(opts *tracerOptions) {
        opts.serviceVersion = version
    }
}

func WithEnvironment(env string) TracerOption {
    return func(opts *tracerOptions) {
        opts.environment = env
    }
}

func WithSampleRate(rate float64) TracerOption {
    return func(opts *tracerOptions) {
        opts.sampleRate = rate
    }
}

func WithReporter(reporter Reporter) TracerOption {
    return func(opts *tracerOptions) {
        opts.reporter = reporter
    }
}

func WithPropagator(propagator Propagator) TracerOption {
    return func(opts *tracerOptions) {
        opts.propagator = propagator
    }
}

// Span选项
type SpanOption func(*spanOptions)

type spanOptions struct {
    startTime time.Time
    tags      map[string]interface{}
    parent    SpanContext
}

func SpanWithStartTime(t time.Time) SpanOption {
    return func(opts *spanOptions) {
        opts.startTime = t
    }
}

func SpanWithTags(tags map[string]interface{}) SpanOption {
    return func(opts *spanOptions) {
        opts.tags = tags
    }
}

func SpanWithParent(parent SpanContext) SpanOption {
    return func(opts *spanOptions) {
        opts.parent = parent
    }
}

// 日志字段
type Field struct {
    Key   string
    Value interface{}
}

// 完成选项
type FinishOptions struct {
    FinishTime time.Time
    LogRecords []LogRecord
}

type LogRecord struct {
    Timestamp time.Time
    Fields    []Field
}

// 文本映射载体
type TextMapCarrier interface {
    Set(key, val string)
    Get(key string) string
    ForeachKey(handler func(key, val string) error) error
}

// 报告器接口
type Reporter interface {
    Report(span *SpanData)
    Close() error
}

// 传播器接口
type Propagator interface {
    Inject(spanContext SpanContext, carrier TextMapCarrier) error
    Extract(carrier TextMapCarrier) (SpanContext, error)
}

// Span数据
type SpanData struct {
    TraceID       string                 `json:"trace_id"`
    SpanID        string                 `json:"span_id"`
    ParentSpanID  string                 `json:"parent_span_id"`
    OperationName string                 `json:"operation_name"`
    StartTime     time.Time              `json:"start_time"`
    FinishTime    time.Time              `json:"finish_time"`
    Duration      time.Duration          `json:"duration"`
    Tags          map[string]interface{} `json:"tags"`
    Logs          []LogRecord            `json:"logs"`
    ServiceName   string                 `json:"service_name"`
    Resource      map[string]string      `json:"resource"`
    StatusCode    int                    `json:"status_code"`
    StatusMessage string                 `json:"status_message"`
}

// 自定义追踪器实现
type CustomTracer struct {
    options   tracerOptions
    reporter  Reporter
    propagator Propagator
    sampler   Sampler
    mutex     sync.RWMutex
}

func NewCustomTracer(opts ...TracerOption) *CustomTracer {
    options := tracerOptions{
        serviceName:    "unknown-service",
        serviceVersion: "0.0.0",
        environment:    "development",
        sampleRate:     1.0,
        reporter:       &ConsoleReporter{},
        propagator:     &B3Propagator{},
    }
    
    for _, opt := range opts {
        opt(&options)
    }
    
    return &CustomTracer{
        options:    options,
        reporter:   options.reporter,
        propagator: options.propagator,
        sampler:    NewSampler(options.sampleRate),
    }
}

func (ct *CustomTracer) StartSpan(ctx context.Context, name string, opts ...SpanOption) (Span, context.Context) {
    options := spanOptions{
        startTime: time.Now(),
        tags:      make(map[string]interface{}),
    }
    
    for _, opt := range opts {
        opt(&options)
    }
    
    // 决定是否采样
    var parentContext SpanContext
    if options.parent != nil {
        parentContext = options.parent
    } else {
        if span := SpanFromContext(ctx); span != nil {
            parentContext = span.SpanContext()
        }
    }
    
    sampled := ct.sampler.IsSampled(parentContext)
    if !sampled {
        span := &noopSpan{}
        return span, ContextWithSpan(ctx, span)
    }
    
    // 创建新的span
    span := &customSpan{
        tracer:        ct,
        operationName: name,
        startTime:     options.startTime,
        tags:          options.tags,
        logs:          make([]LogRecord, 0),
        serviceName:   ct.options.serviceName,
        resource: map[string]string{
            "service.version": ct.options.serviceVersion,
            "deployment.environment": ct.options.environment,
        },
    }
    
    // 设置span ID和trace ID
    span.spanID = generateSpanID()
    if parentContext != nil && parentContext.IsValid() {
        span.traceID = parentContext.TraceID()
        span.parentSpanID = parentContext.SpanID()
    } else {
        span.traceID = generateTraceID()
    }
    
    return span, ContextWithSpan(ctx, span)
}

func (ct *CustomTracer) Inject(spanContext SpanContext, carrier TextMapCarrier) error {
    return ct.propagator.Inject(spanContext, carrier)
}

func (ct *CustomTracer) Extract(carrier TextMapCarrier) (SpanContext, error) {
    return ct.propagator.Extract(carrier)
}

// 自定义Span实现
type customSpan struct {
    tracer        *CustomTracer
    traceID       string
    spanID        string
    parentSpanID  string
    operationName string
    startTime     time.Time
    finishTime    time.Time
    tags          map[string]interface{}
    logs          []LogRecord
    serviceName   string
    resource      map[string]string
    finished      bool
    mutex         sync.RWMutex
}

func (cs *customSpan) SpanContext() SpanContext {
    return &customSpanContext{
        traceID:      cs.traceID,
        spanID:       cs.spanID,
        parentSpanID: cs.parentSpanID,
        sampled:      true,
    }
}

func (cs *customSpan) SetName(name string) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    cs.operationName = name
}

func (cs *customSpan) SetTag(key string, value interface{}) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    if cs.tags == nil {
        cs.tags = make(map[string]interface{})
    }
    cs.tags[key] = value
}

func (cs *customSpan) LogKV(alternatingKeyValues ...interface{}) {
    if len(alternatingKeyValues)%2 != 0 {
        return
    }
    
    fields := make([]Field, 0, len(alternatingKeyValues)/2)
    for i := 0; i < len(alternatingKeyValues); i += 2 {
        key, ok := alternatingKeyValues[i].(string)
        if !ok {
            continue
        }
        fields = append(fields, Field{Key: key, Value: alternatingKeyValues[i+1]})
    }
    
    cs.LogFields(fields...)
}

func (cs *customSpan) LogFields(fields ...Field) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    logRecord := LogRecord{
        Timestamp: time.Now(),
        Fields:    fields,
    }
    
    cs.logs = append(cs.logs, logRecord)
}

func (cs *customSpan) Finish() {
    cs.FinishWithOptions(FinishOptions{})
}

func (cs *customSpan) FinishWithOptions(opts FinishOptions) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    if cs.finished {
        return
    }
    
    cs.finished = true
    cs.finishTime = opts.FinishTime
    if cs.finishTime.IsZero() {
        cs.finishTime = time.Now()
    }
    
    // 添加日志记录
    if len(opts.LogRecords) > 0 {
        cs.logs = append(cs.logs, opts.LogRecords...)
    }
    
    // 报告span数据
    spanData := &SpanData{
        TraceID:       cs.traceID,
        SpanID:        cs.spanID,
        ParentSpanID:  cs.parentSpanID,
        OperationName: cs.operationName,
        StartTime:     cs.startTime,
        FinishTime:    cs.finishTime,
        Duration:      cs.finishTime.Sub(cs.startTime),
        Tags:          cs.tags,
        Logs:          cs.logs,
        ServiceName:   cs.serviceName,
        Resource:      cs.resource,
    }
    
    if cs.tracer.reporter != nil {
        cs.tracer.reporter.Report(spanData)
    }
}

// Span上下文实现
type customSpanContext struct {
    traceID      string
    spanID       string
    parentSpanID string
    sampled      bool
}

func (csc *customSpanContext) TraceID() string {
    return csc.traceID
}

func (csc *customSpanContext) SpanID() string {
    return csc.spanID
}

func (csc *customSpanContext) ParentSpanID() string {
    return csc.parentSpanID
}

func (csc *customSpanContext) IsValid() bool {
    return csc.traceID != "" && csc.spanID != ""
}

func (csc *customSpanContext) IsSampled() bool {
    return csc.sampled
}

// 采样器
type Sampler interface {
    IsSampled(parentContext SpanContext) bool
}

type sampler struct {
    sampleRate float64
}

func NewSampler(rate float64) Sampler {
    return &sampler{sampleRate: rate}
}

func (s *sampler) IsSampled(parentContext SpanContext) bool {
    if parentContext != nil && parentContext.IsValid() {
        return parentContext.IsSampled()
    }
    
    return s.sampleRate >= 1.0 || rand.Float64() < s.sampleRate
}

// 空span（用于不采样的情况）
type noopSpan struct{}

func (ns *noopSpan) SpanContext() SpanContext { return nil }
func (ns *noopSpan) SetName(name string)      {}
func (ns *noopSpan) SetTag(key string, value interface{}) {}
func (ns *noopSpan) LogKV(alternatingKeyValues ...interface{}) {}
func (ns *noopSpan) LogFields(fields ...Field) {}
func (ns *noopSpan) Finish()                   {}
func (ns *noopSpan) FinishWithOptions(opts FinishOptions) {}

// 控制台报告器
type ConsoleReporter struct{}

func (cr *ConsoleReporter) Report(span *SpanData) {
    log.Printf("Span Reported: %s - %s (%v)", 
        span.TraceID, span.OperationName, span.Duration)
}

func (cr *ConsoleReporter) Close() error {
    return nil
}

// B3传播器
type B3Propagator struct{}

func (bp *B3Propagator) Inject(spanContext SpanContext, carrier TextMapCarrier) error {
    carrier.Set("X-B3-TraceId", spanContext.TraceID())
    carrier.Set("X-B3-SpanId", spanContext.SpanID())
    if spanContext.ParentSpanID() != "" {
        carrier.Set("X-B3-ParentSpanId", spanContext.ParentSpanID())
    }
    if spanContext.IsSampled() {
        carrier.Set("X-B3-Sampled", "1")
    } else {
        carrier.Set("X-B3-Sampled", "0")
    }
    return nil
}

func (bp *B3Propagator) Extract(carrier TextMapCarrier) (SpanContext, error) {
    traceID := carrier.Get("X-B3-TraceId")
    spanID := carrier.Get("X-B3-SpanId")
    parentSpanID := carrier.Get("X-B3-ParentSpanId")
    sampledStr := carrier.Get("X-B3-Sampled")
    
    if traceID == "" || spanID == "" {
        return nil, fmt.Errorf("missing required trace context")
    }
    
    sampled := sampledStr == "1" || sampledStr == "true"
    
    return &customSpanContext{
        traceID:      traceID,
        spanID:       spanID,
        parentSpanID: parentSpanID,
        sampled:      sampled,
    }, nil
}

// 上下文工具
type spanKey struct{}

func ContextWithSpan(ctx context.Context, span Span) context.Context {
    return context.WithValue(ctx, spanKey{}, span)
}

func SpanFromContext(ctx context.Context) Span {
    if span, ok := ctx.Value(spanKey{}).(Span); ok {
        return span
    }
    return nil
}

// ID生成器
func generateTraceID() string {
    return fmt.Sprintf("%016x%016x", rand.Uint64(), rand.Uint64())
}

func generateSpanID() string {
    return fmt.Sprintf("%016x", rand.Uint64())
}

// 使用示例
func main() {
    // 创建自定义追踪器
    tracer := NewCustomTracer(
        WithServiceName("user-service"),
        WithServiceVersion("1.0.0"),
        WithEnvironment("production"),
        WithSampleRate(1.0),
    )
    
    // 创建根span
    rootSpan, ctx := tracer.StartSpan(context.Background(), "main")
    defer rootSpan.Finish()
    
    // 模拟业务逻辑
    businessLogic(ctx, tracer)
    
    // 等待一段时间让报告器处理
    time.Sleep(1 * time.Second)
}

func businessLogic(ctx context.Context, tracer Tracer) {
    // 创建子span
    span, ctx := tracer.StartSpan(ctx, "businessLogic")
    defer span.Finish()
    
    // 添加标签
    span.SetTag("user.id", 123)
    span.SetTag("operation", "user-query")
    
    // 记录日志
    span.LogKV("event", "start", "user_id", 123)
    
    // 模拟数据库查询
    dbQuery(ctx, tracer)
    
    // 记录完成日志
    span.LogKV("event", "end", "result", "success")
}

func dbQuery(ctx context.Context, tracer Tracer) {
    span, ctx := tracer.StartSpan(ctx, "db.query")
    defer span.Finish()
    
    span.SetTag("db.system", "postgresql")
    span.SetTag("db.statement", "SELECT * FROM users WHERE id = $1")
    
    // 模拟查询时间
    time.Sleep(100 * time.Millisecond)
    
    span.LogKV("rows_affected", 1)
}
```

### 指标监控

```go
// 指标监控实现
package metrics

import (
    "context"
    "fmt"
    "log"
    "math"
    "sort"
    "sync"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

// 指标类型
type MetricType string

const (
    CounterType   MetricType = "counter"
    GaugeType     MetricType = "gauge"
    HistogramType MetricType = "histogram"
    SummaryType   MetricType = "summary"
)

// 指标标签
type Labels map[string]string

// 指标收集器接口
type Collector interface {
    Describe(ch chan<- *prometheus.Desc)
    Collect(ch chan<- prometheus.Metric)
}

// 指标管理器
type MetricsManager struct {
    registry *prometheus.Registry
    metrics  map[string]prometheus.Collector
    mutex    sync.RWMutex
}

func NewMetricsManager() *MetricsManager {
    registry := prometheus.NewRegistry()
    registry.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))
    registry.MustRegister(prometheus.NewGoCollector())
    
    return &MetricsManager{
        registry: registry,
        metrics:  make(map[string]prometheus.Collector),
    }
}

func (mm *MetricsManager) RegisterCounter(name, help string, labels []string) *prometheus.CounterVec {
    counter := prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: name,
            Help: help,
        },
        labels,
    )
    
    mm.mutex.Lock()
    mm.metrics[name] = counter
    mm.mutex.Unlock()
    
    mm.registry.MustRegister(counter)
    return counter
}

func (mm *MetricsManager) RegisterGauge(name, help string, labels []string) *prometheus.GaugeVec {
    gauge := prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: name,
            Help: help,
        },
        labels,
    )
    
    mm.mutex.Lock()
    mm.metrics[name] = gauge
    mm.mutex.Unlock()
    
    mm.registry.MustRegister(gauge)
    return gauge
}

func (mm *MetricsManager) RegisterHistogram(name, help string, labels []string, buckets []float64) *prometheus.HistogramVec {
    histogram := prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    name,
            Help:    help,
            Buckets: buckets,
        },
        labels,
    )
    
    mm.mutex.Lock()
    mm.metrics[name] = histogram
    mm.mutex.Unlock()
    
    mm.registry.MustRegister(histogram)
    return histogram
}

func (mm *MetricsManager) RegisterSummary(name, help string, labels []string, objectives map[float64]float64) *prometheus.SummaryVec {
    summary := prometheus.NewSummaryVec(
        prometheus.SummaryOpts{
            Name:       name,
            Help:       help,
            Objectives: objectives,
        },
        labels,
    )
    
    mm.mutex.Lock()
    mm.metrics[name] = summary
    mm.mutex.Unlock()
    
    mm.registry.MustRegister(summary)
    return summary
}

func (mm *MetricsManager) GetCounter(name string) *prometheus.CounterVec {
    mm.mutex.RLock()
    defer mm.mutex.RUnlock()
    
    if collector, exists := mm.metrics[name]; exists {
        if counter, ok := collector.(*prometheus.CounterVec); ok {
            return counter
        }
    }
    return nil
}

func (mm *MetricsManager) GetGauge(name string) *prometheus.GaugeVec {
    mm.mutex.RLock()
    defer mm.mutex.RUnlock()
    
    if collector, exists := mm.metrics[name]; exists {
        if gauge, ok := collector.(*prometheus.GaugeVec); ok {
            return gauge
        }
    }
    return nil
}

func (mm *MetricsManager) GetHistogram(name string) *prometheus.HistogramVec {
    mm.mutex.RLock()
    defer mm.mutex.RUnlock()
    
    if collector, exists := mm.metrics[name]; exists {
        if histogram, ok := collector.(*prometheus.HistogramVec); ok {
            return histogram
        }
    }
    return nil
}

func (mm *MetricsManager) GetSummary(name string) *prometheus.SummaryVec {
    mm.mutex.RLock()
    defer mm.mutex.RUnlock()
    
    if collector, exists := mm.metrics[name]; exists {
        if summary, ok := collector.(*prometheus.SummaryVec); ok {
            return summary
        }
    }
    return nil
}

func (mm *MetricsManager) HTTPHandler() http.Handler {
    return promhttp.HandlerFor(mm.registry, promhttp.HandlerOpts{})
}

// 应用指标
type ApplicationMetrics struct {
    manager *MetricsManager
    
    // HTTP指标
    httpRequestTotal    *prometheus.CounterVec
    httpRequestDuration *prometheus.HistogramVec
    httpResponseSize    *prometheus.HistogramVec
    httpRequestInFlight *prometheus.GaugeVec
    
    // 数据库指标
    dbQueryTotal    *prometheus.CounterVec
    dbQueryDuration *prometheus.HistogramVec
    dbConnectionPool *prometheus.GaugeVec
    
    // 缓存指标
    cacheHitTotal   *prometheus.CounterVec
    cacheMissTotal  *prometheus.CounterVec
    cacheOperationDuration *prometheus.HistogramVec
    
    // gRPC指标
    grpcRequestTotal    *prometheus.CounterVec
    grpcRequestDuration *prometheus.HistogramVec
    grpcResponseSize    *prometheus.HistogramVec
    
    // 自定义业务指标
    businessOperationTotal    *prometheus.CounterVec
    businessOperationDuration *prometheus.HistogramVec
}

func NewApplicationMetrics(manager *MetricsManager) *ApplicationMetrics {
    am := &ApplicationMetrics{manager: manager}
    am.initMetrics()
    return am
}

func (am *ApplicationMetrics) initMetrics() {
    // HTTP指标
    am.httpRequestTotal = am.manager.RegisterCounter(
        "http_requests_total",
        "Total number of HTTP requests",
        []string{"method", "endpoint", "status_code"},
    )
    
    am.httpRequestDuration = am.manager.RegisterHistogram(
        "http_request_duration_seconds",
        "HTTP request duration in seconds",
        []string{"method", "endpoint", "status_code"},
        prometheus.DefBuckets,
    )
    
    am.httpResponseSize = am.manager.RegisterHistogram(
        "http_response_size_bytes",
        "HTTP response size in bytes",
        []string{"method", "endpoint", "status_code"},
        []float64{100, 500, 1000, 5000, 10000, 100000, 1000000},
    )
    
    am.httpRequestInFlight = am.manager.RegisterGauge(
        "http_requests_in_flight",
        "Number of HTTP requests currently in flight",
        []string{"method", "endpoint"},
    )
    
    // 数据库指标
    am.dbQueryTotal = am.manager.RegisterCounter(
        "db_queries_total",
        "Total number of database queries",
        []string{"operation", "table", "error"},
    )
    
    am.dbQueryDuration = am.manager.RegisterHistogram(
        "db_query_duration_seconds",
        "Database query duration in seconds",
        []string{"operation", "table", "error"},
        prometheus.DefBuckets,
    )
    
    am.dbConnectionPool = am.manager.RegisterGauge(
        "db_connection_pool_connections",
        "Number of connections in the database connection pool",
        []string{"state"}, // active, idle, in_use
    )
    
    // 缓存指标
    am.cacheHitTotal = am.manager.RegisterCounter(
        "cache_hits_total",
        "Total number of cache hits",
        []string{"cache_type", "operation"},
    )
    
    am.cacheMissTotal = am.manager.RegisterCounter(
        "cache_misses_total",
        "Total number of cache misses",
        []string{"cache_type", "operation"},
    )
    
    am.cacheOperationDuration = am.manager.RegisterHistogram(
        "cache_operation_duration_seconds",
        "Cache operation duration in seconds",
        []string{"cache_type", "operation", "result"},
        prometheus.DefBuckets,
    )
    
    // gRPC指标
    am.grpcRequestTotal = am.manager.RegisterCounter(
        "grpc_requests_total",
        "Total number of gRPC requests",
        []string{"method", "service", "status_code"},
    )
    
    am.grpcRequestDuration = am.manager.RegisterHistogram(
        "grpc_request_duration_seconds",
        "gRPC request duration in seconds",
        []string{"method", "service", "status_code"},
        prometheus.DefBuckets,
    )
    
    am.grpcResponseSize = am.manager.RegisterHistogram(
        "grpc_response_size_bytes",
        "gRPC response size in bytes",
        []string{"method", "service", "status_code"},
        []float64{100, 500, 1000, 5000, 10000, 100000, 1000000},
    )
    
    // 业务指标
    am.businessOperationTotal = am.manager.RegisterCounter(
        "business_operations_total",
        "Total number of business operations",
        []string{"operation", "result", "error_type"},
    )
    
    am.businessOperationDuration = am.manager.RegisterHistogram(
        "business_operation_duration_seconds",
        "Business operation duration in seconds",
        []string{"operation", "result", "error_type"},
        prometheus.DefBuckets,
    )
}

// HTTP中间件指标
func (am *ApplicationMetrics) HTTPMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 增加进行中的请求数
        am.httpRequestInFlight.WithLabelValues(r.Method, r.URL.Path).Inc()
        defer am.httpRequestInFlight.WithLabelValues(r.Method, r.URL.Path).Dec()
        
        // 创建包装的ResponseWriter来捕获状态码和响应大小
        wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // 处理请求
        next.ServeHTTP(wrapped, r)
        
        duration := time.Since(start)
        
        // 记录指标
        am.httpRequestTotal.WithLabelValues(
            r.Method,
            r.URL.Path,
            fmt.Sprintf("%d", wrapped.statusCode),
        ).Inc()
        
        am.httpRequestDuration.WithLabelValues(
            r.Method,
            r.URL.Path,
            fmt.Sprintf("%d", wrapped.statusCode),
        ).Observe(duration.Seconds())
        
        am.httpResponseSize.WithLabelValues(
            r.Method,
            r.URL.Path,
            fmt.Sprintf("%d", wrapped.statusCode),
        ).Observe(float64(wrapped.bytesWritten))
    })
}

// 数据库指标
func (am *ApplicationMetrics) RecordDBQuery(operation, table string, duration time.Duration, err error) {
    errorLabel := "false"
    if err != nil {
        errorLabel = "true"
    }
    
    am.dbQueryTotal.WithLabelValues(operation, table, errorLabel).Inc()
    am.dbQueryDuration.WithLabelValues(operation, table, errorLabel).Observe(duration.Seconds())
}

func (am *ApplicationMetrics) SetDBConnectionPool(active, idle, inUse int) {
    am.dbConnectionPool.WithLabelValues("active").Set(float64(active))
    am.dbConnectionPool.WithLabelValues("idle").Set(float64(idle))
    am.dbConnectionPool.WithLabelValues("in_use").Set(float64(inUse))
}

// 缓存指标
func (am *ApplicationMetrics) RecordCacheHit(cacheType, operation string) {
    am.cacheHitTotal.WithLabelValues(cacheType, operation).Inc()
}

func (am *ApplicationMetrics) RecordCacheMiss(cacheType, operation string) {
    am.cacheMissTotal.WithLabelValues(cacheType, operation).Inc()
}

func (am *ApplicationMetrics) RecordCacheOperation(cacheType, operation, result string, duration time.Duration) {
    am.cacheOperationDuration.WithLabelValues(cacheType, operation, result).Observe(duration.Seconds())
}

// gRPC指标
func (am *ApplicationMetrics) RecordGRPCRequest(method, service, statusCode string, duration time.Duration, responseSize int) {
    am.grpcRequestTotal.WithLabelValues(method, service, statusCode).Inc()
    am.grpcRequestDuration.WithLabelValues(method, service, statusCode).Observe(duration.Seconds())
    am.grpcResponseSize.WithLabelValues(method, service, statusCode).Observe(float64(responseSize))
}

// 业务指标
func (am *ApplicationMetrics) RecordBusinessOperation(operation, result, errorType string, duration time.Duration) {
    am.businessOperationTotal.WithLabelValues(operation, result, errorType).Inc()
    am.businessOperationDuration.WithLabelValues(operation, result, errorType).Observe(duration.Seconds())
}

// 包装的ResponseWriter
type responseWriter struct {
    http.ResponseWriter
    statusCode    int
    bytesWritten  int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    n, err := rw.ResponseWriter.Write(b)
    rw.bytesWritten += n
    return n, err
}

// 系统指标收集器
type SystemMetricsCollector struct {
    manager *MetricsManager
    mutex   sync.RWMutex
}

func NewSystemMetricsCollector(manager *MetricsManager) *SystemMetricsCollector {
    collector := &SystemMetricsCollector{manager: manager}
    collector.registerSystemMetrics()
    return collector
}

func (smc *SystemMetricsCollector) registerSystemMetrics() {
    // 内存使用指标
    memoryUsage := smc.manager.RegisterGauge(
        "process_memory_usage_bytes",
        "Process memory usage in bytes",
        []string{"type"}, // rss, vms, swap
    )
    
    // CPU使用指标
    cpuUsage := smc.manager.RegisterGauge(
        "process_cpu_usage_percent",
        "Process CPU usage percentage",
        []string{"type"}, // user, system, total
    )
    
    // 垃圾回收指标
    gcDuration := smc.manager.RegisterHistogram(
        "go_gc_duration_seconds",
        "Go garbage collection duration in seconds",
        []string{"phase"}, // scavenging, marking, sweeping
        prometheus.DefBuckets,
    )
    
    // 协程指标
    goroutines := smc.manager.RegisterGauge(
        "go_goroutines",
        "Number of goroutines that currently exist",
        []string{},
    )
    
    // 启动定期收集
    go smc.collectSystemMetrics(memoryUsage, cpuUsage, gcDuration, goroutines)
}

func (smc *SystemMetricsCollector) collectSystemMetrics(
    memoryUsage, cpuUsage *prometheus.GaugeVec,
    gcDuration *prometheus.HistogramVec,
    goroutines *prometheus.GaugeVec,
) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            smc.collectMemoryMetrics(memoryUsage)
            smc.collectCPUMetrics(cpuUsage)
            smc.collectGCMetrics(gcDuration)
            smc.collectGoroutineMetrics(goroutines)
        }
    }
}

func (smc *SystemMetricsCollector) collectMemoryMetrics(gauge *prometheus.GaugeVec) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    gauge.WithLabelValues("alloc").Set(float64(m.Alloc))
    gauge.WithLabelValues("sys").Set(float64(m.Sys))
    gauge.WithLabelValues("heap_alloc").Set(float64(m.HeapAlloc))
    gauge.WithLabelValues("heap_sys").Set(float64(m.HeapSys))
    gauge.WithLabelValues("heap_idle").Set(float64(m.HeapIdle))
    gauge.WithLabelValues("heap_inuse").Set(float64(m.HeapInuse))
}

func (smc *SystemMetricsCollector) collectCPUMetrics(gauge *prometheus.GaugeVec) {
    // 简化实现，实际应用中需要更精确的CPU使用率计算
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    gauge.WithLabelValues("gc_cpu_fraction").Set(m.GCCPUFraction * 100)
}

func (smc *SystemMetricsCollector) collectGCMetrics(histogram *prometheus.HistogramVec) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    histogram.WithLabelValues("pause").Observe(time.Duration(m.PauseTotalNs).Seconds())
}

func (smc *SystemMetricsCollector) collectGoroutineMetrics(gauge *prometheus.GaugeVec) {
    gauge.WithLabelValues().Set(float64(runtime.NumGoroutine()))
}

// 使用示例
func main() {
    // 创建指标管理器
    manager := NewMetricsManager()
    
    // 创建应用指标
    appMetrics := NewApplicationMetrics(manager)
    
    // 创建系统指标收集器
    systemMetrics := NewSystemMetricsCollector(manager)
    
    // HTTP服务器示例
    http.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
        manager.HTTPHandler().ServeHTTP(w, r)
    })
    
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        // 模拟业务逻辑
        start := time.Now()
        
        // 模拟数据库查询
        time.Sleep(50 * time.Millisecond)
        appMetrics.RecordDBQuery("SELECT", "users", 50*time.Millisecond, nil)
        
        // 模拟缓存操作
        appMetrics.RecordCacheHit("redis", "get")
        
        // 模拟业务操作
        appMetrics.RecordBusinessOperation("user_query", "success", "", time.Since(start))
        
        // 返回响应
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"id": 123, "name": "John Doe"}`))
    })
    
    // 包装HTTP处理程序
    wrappedHandler := appMetrics.HTTPMiddleware(http.DefaultServeMux)
    
    log.Println("Starting HTTP server on :8080")
    if err := http.ListenAndServe(":8080", wrappedHandler); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}
```

### 日志聚合

```go
// 日志聚合实现
package logging

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "os"
    "runtime"
    "sync"
    "time"
    
    "github.com/sirupsen/logrus"
    "gopkg.in/natefinch/lumberjack.v2"
)

// 日志级别
type Level string

const (
    DebugLevel Level = "debug"
    InfoLevel  Level = "info"
    WarnLevel  Level = "warn"
    ErrorLevel Level = "error"
    FatalLevel Level = "fatal"
    PanicLevel Level = "panic"
)

// 日志字段
type Fields map[string]interface{}

// 日志条目
type Entry struct {
    Timestamp time.Time   `json:"timestamp"`
    Level     Level       `json:"level"`
    Message   string      `json:"message"`
    Fields    Fields      `json:"fields,omitempty"`
    Caller    *CallerInfo `json:"caller,omitempty"`
    TraceID   string      `json:"trace_id,omitempty"`
    SpanID    string      `json:"span_id,omitempty"`
}

type CallerInfo struct {
    File     string `json:"file"`
    Line     int    `json:"line"`
    Function string `json:"function"`
}

// 日志配置
type Config struct {
    Level          Level  `json:"level"`
    Format         string `json:"format"` // json, text
    Output         string `json:"output"` // stdout, file, both
    FilePath       string `json:"file_path"`
    MaxSize        int    `json:"max_size"`        // MB
    MaxBackups     int    `json:"max_backups"`
    MaxAge         int    `json:"max_age"`         // days
    Compress       bool   `json:"compress"`
    EnableCaller   bool   `json:"enable_caller"`
    EnableTracing  bool   `json:"enable_tracing"`
    ServiceName    string `json:"service_name"`
    Environment    string `json:"environment"`
}

// 日志聚合器
type Logger struct {
    config    *Config
    logger    *logrus.Logger
    fields    Fields
    mutex     sync.RWMutex
    formatter logrus.Formatter
}

func NewLogger(config *Config) *Logger {
    logger := logrus.New()
    
    // 设置日志级别
    level, err := logrus.ParseLevel(string(config.Level))
    if err != nil {
        level = logrus.InfoLevel
    }
    logger.SetLevel(level)
    
    // 设置输出
    switch config.Output {
    case "file":
        logger.SetOutput(&lumberjack.Logger{
            Filename:   config.FilePath,
            MaxSize:    config.MaxSize,
            MaxBackups: config.MaxBackups,
            MaxAge:     config.MaxAge,
            Compress:   config.Compress,
        })
    case "both":
        logger.SetOutput(io.MultiWriter(os.Stdout, &lumberjack.Logger{
            Filename:   config.FilePath,
            MaxSize:    config.MaxSize,
            MaxBackups: config.MaxBackups,
            MaxAge:     config.MaxAge,
            Compress:   config.Compress,
        }))
    default:
        logger.SetOutput(os.Stdout)
    }
    
    // 设置格式化器
    var formatter logrus.Formatter
    if config.Format == "json" {
        formatter = &JSONFormatter{
            ServiceName:   config.ServiceName,
            Environment:   config.Environment,
            EnableCaller:  config.EnableCaller,
            EnableTracing: config.EnableTracing,
        }
    } else {
        formatter = &TextFormatter{
            ServiceName:   config.ServiceName,
            Environment:   config.Environment,
            EnableCaller:  config.EnableCaller,
            EnableTracing: config.EnableTracing,
        }
    }
    logger.SetFormatter(formatter)
    
    return &Logger{
        config:    config,
        logger:    logger,
        fields:    make(Fields),
        formatter: formatter,
    }
}

func (l *Logger) WithFields(fields Fields) *Logger {
    l.mutex.Lock()
    defer l.mutex.Unlock()
    
    // 合并字段
    mergedFields := make(Fields)
    for k, v := range l.fields {
        mergedFields[k] = v
    }
    for k, v := range fields {
        mergedFields[k] = v
    }
    
    newLogger := *l
    newLogger.fields = mergedFields
    return &newLogger
}

func (l *Logger) WithField(key string, value interface{}) *Logger {
    return l.WithFields(Fields{key: value})
}

func (l *Logger) Debug(args ...interface{}) {
    l.log(DebugLevel, fmt.Sprint(args...))
}

func (l *Logger) Debugf(format string, args ...interface{}) {
    l.log(DebugLevel, fmt.Sprintf(format, args...))
}

func (l *Logger) Info(args ...interface{}) {
    l.log(InfoLevel, fmt.Sprint(args...))
}

func (l *Logger) Infof(format string, args ...interface{}) {
    l.log(InfoLevel, fmt.Sprintf(format, args...))
}

func (l *Logger) Warn(args ...interface{}) {
    l.log(WarnLevel, fmt.Sprint(args...))
}

func (l *Logger) Warnf(format string, args ...interface{}) {
    l.log(WarnLevel, fmt.Sprintf(format, args...))
}

func (l *Logger) Error(args ...interface{}) {
    l.log(ErrorLevel, fmt.Sprint(args...))
}

func (l *Logger) Errorf(format string, args ...interface{}) {
    l.log(ErrorLevel, fmt.Sprintf(format, args...))
}

func (l *Logger) Fatal(args ...interface{}) {
    l.log(FatalLevel, fmt.Sprint(args...))
    os.Exit(1)
}

func (l *Logger) Fatalf(format string, args ...interface{}) {
    l.log(FatalLevel, fmt.Sprintf(format, args...))
    os.Exit(1)
}

func (l *Logger) Panic(args ...interface{}) {
    msg := fmt.Sprint(args...)
    l.log(PanicLevel, msg)
    panic(msg)
}

func (l *Logger) Panicf(format string, args ...interface{}) {
    msg := fmt.Sprintf(format, args...)
    l.log(PanicLevel, msg)
    panic(msg)
}

func (l *Logger) log(level Level, msg string) {
    l.mutex.RLock()
    defer l.mutex.RUnlock()
    
    fields := make(logrus.Fields)
    for k, v := range l.fields {
        fields[k] = v
    }
    
    // 添加调用者信息
    if l.config.EnableCaller {
        if pc, file, line, ok := runtime.Caller(2); ok {
            funcName := runtime.FuncForPC(pc).Name()
            fields["caller"] = fmt.Sprintf("%s:%d", file, line)
            fields["function"] = funcName
        }
    }
    
    // 添加追踪信息
    if l.config.EnableTracing {
        if traceContext := getTraceContext(); traceContext != nil {
            fields["trace_id"] = traceContext.TraceID
            fields["span_id"] = traceContext.SpanID
        }
    }
    
    switch level {
    case DebugLevel:
        l.logger.WithFields(fields).Debug(msg)
    case InfoLevel:
        l.logger.WithFields(fields).Info(msg)
    case WarnLevel:
        l.logger.WithFields(fields).Warn(msg)
    case ErrorLevel:
        l.logger.WithFields(fields).Error(msg)
    case FatalLevel:
        l.logger.WithFields(fields).Fatal(msg)
    case PanicLevel:
        l.logger.WithFields(fields).Panic(msg)
    }
}

// JSON格式化器
type JSONFormatter struct {
    ServiceName   string
    Environment   string
    EnableCaller  bool
    EnableTracing bool
}

func (jf *JSONFormatter) Format(entry *logrus.Entry) ([]byte, error) {
    logEntry := Entry{
        Timestamp: entry.Time,
        Level:     Level(entry.Level.String()),
        Message:   entry.Message,
        Fields:    make(Fields),
    }
    
    // 添加服务信息
    logEntry.Fields["service"] = jf.ServiceName
    logEntry.Fields["environment"] = jf.Environment
    
    // 添加其他字段
    for k, v := range entry.Data {
        logEntry.Fields[k] = v
    }
    
    // 添加调用者信息
    if jf.EnableCaller {
        if caller, ok := entry.Data["caller"]; ok {
            if file, ok := caller.(string); ok {
                logEntry.Caller = &CallerInfo{
                    File: file,
                }
            }
        }
        if function, ok := entry.Data["function"]; ok {
            if funcName, ok := function.(string); ok && logEntry.Caller != nil {
                logEntry.Caller.Function = funcName
            }
        }
    }
    
    // 添加追踪信息
    if jf.EnableTracing {
        if traceID, ok := entry.Data["trace_id"]; ok {
            if id, ok := traceID.(string); ok {
                logEntry.TraceID = id
            }
        }
        if spanID, ok := entry.Data["span_id"]; ok {
            if id, ok := spanID.(string); ok {
                logEntry.SpanID = id
            }
        }
    }
    
    return json.Marshal(logEntry)
}

// 文本格式化器
type TextFormatter struct {
    ServiceName   string
    Environment   string
    EnableCaller  bool
    EnableTracing bool
}

func (tf *TextFormatter) Format(entry *logrus.Entry) ([]byte, error) {
    timestamp := entry.Time.Format("2006-01-02T15:04:05.000Z07:00")
    level := entry.Level.String()
    
    // 构建基础日志行
    logLine := fmt.Sprintf("%s [%s] [%s] [%s] %s",
        timestamp,
        tf.Environment,
        tf.ServiceName,
        level,
        entry.Message,
    )
    
    // 添加字段
    if len(entry.Data) > 0 {
        logLine += " {"
        first := true
        for k, v := range entry.Data {
            if !first {
                logLine += ", "
            }
            logLine += fmt.Sprintf("%s=%v", k, v)
            first = false
        }
        logLine += "}"
    }
    
    logLine += "\n"
    return []byte(logLine), nil
}

// 追踪上下文
type TraceContext struct {
    TraceID string
    SpanID  string
}

// 追踪上下文管理器
type TraceContextManager struct {
    contexts map[string]*TraceContext
    mutex    sync.RWMutex
}

func NewTraceContextManager() *TraceContextManager {
    return &TraceContextManager{
        contexts: make(map[string]*TraceContext),
    }
}

func (tcm *TraceContextManager) SetContext(ctx context.Context, traceID, spanID string) context.Context {
    traceCtx := &TraceContext{
        TraceID: traceID,
        SpanID:  spanID,
    }
    
    return context.WithValue(ctx, "trace_context", traceCtx)
}

func (tcm *TraceContextManager) GetContext(ctx context.Context) *TraceContext {
    if traceCtx, ok := ctx.Value("trace_context").(*TraceContext); ok {
        return traceCtx
    }
    return nil
}

// 全局追踪上下文管理器
var globalTraceContextManager = NewTraceContextManager()

func SetTraceContext(ctx context.Context, traceID, spanID string) context.Context {
    return globalTraceContextManager.SetContext(ctx, traceID, spanID)
}

func getTraceContext() *TraceContext {
    // 这里应该从上下文中获取追踪信息
    // 简化实现
    return nil
}

// 结构化日志记录器
type StructuredLogger struct {
    logger *Logger
}

func NewStructuredLogger(config *Config) *StructuredLogger {
    return &StructuredLogger{
        logger: NewLogger(config),
    }
}

func (sl *StructuredLogger) HTTPRequest(ctx context.Context, method, url string, statusCode int, duration time.Duration) {
    sl.logger.WithFields(Fields{
        "event":       "http_request",
        "method":      method,
        "url":         url,
        "status_code": statusCode,
        "duration_ms": duration.Milliseconds(),
    }).Info("HTTP request processed")
}

func (sl *StructuredLogger) DatabaseQuery(ctx context.Context, query string, duration time.Duration, err error) {
    fields := Fields{
        "event":       "db_query",
        "query":       query,
        "duration_ms": duration.Milliseconds(),
    }
    
    if err != nil {
        fields["error"] = err.Error()
        sl.logger.WithFields(fields).Error("Database query failed")
    } else {
        sl.logger.WithFields(fields).Info("Database query executed")
    }
}

func (sl *StructuredLogger) CacheOperation(ctx context.Context, operation, key string, duration time.Duration, hit bool) {
    sl.logger.WithFields(Fields{
        "event":       "cache_operation",
        "operation":   operation,
        "key":         key,
        "duration_ms": duration.Milliseconds(),
        "hit":         hit,
    }).Info("Cache operation completed")
}

func (sl *StructuredLogger) BusinessOperation(ctx context.Context, operation string, duration time.Duration, err error) {
    fields := Fields{
        "event":       "business_operation",
        "operation":   operation,
        "duration_ms": duration.Milliseconds(),
    }
    
    if err != nil {
        fields["error"] = err.Error()
        sl.logger.WithFields(fields).Error("Business operation failed")
    } else {
        sl.logger.WithFields(fields).Info("Business operation completed")
    }
}

// 日志聚合客户端
type LogAggregatorClient struct {
    endpoint string
    apiKey   string
    buffer   chan *Entry
    stopCh   chan struct{}
}

func NewLogAggregatorClient(endpoint, apiKey string, bufferSize int) *LogAggregatorClient {
    client := &LogAggregatorClient{
        endpoint: endpoint,
        apiKey:   apiKey,
        buffer:   make(chan *Entry, bufferSize),
        stopCh:   make(chan struct{}),
    }
    
    // 启动批量发送
    go client.batchSend()
    
    return client
}

func (lac *LogAggregatorClient) Log(entry *Entry) {
    select {
    case lac.buffer <- entry:
    default:
        // 缓冲区满时丢弃日志
        log.Printf("Log buffer full, dropping entry: %s", entry.Message)
    }
}

func (lac *LogAggregatorClient) batchSend() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    batch := make([]*Entry, 0, 100)
    
    for {
        select {
        case entry := <-lac.buffer:
            batch = append(batch, entry)
            if len(batch) >= 100 {
                lac.sendBatch(batch)
                batch = batch[:0]
            }
        case <-ticker.C:
            if len(batch) > 0 {
                lac.sendBatch(batch)
                batch = batch[:0]
            }
        case <-lac.stopCh:
            if len(batch) > 0 {
                lac.sendBatch(batch)
            }
            return
        }
    }
}

func (lac *LogAggregatorClient) sendBatch(batch []*Entry) {
    // 发送到日志聚合服务
    // 这里简化实现，实际应用中需要HTTP客户端发送
    log.Printf("Sending batch of %d logs to %s", len(batch), lac.endpoint)
}

func (lac *LogAggregatorClient) Close() {
    close(lac.stopCh)
}

// 使用示例
func main() {
    // 配置日志
    config := &Config{
        Level:         InfoLevel,
        Format:        "json",
        Output:        "both",
        FilePath:      "/var/log/myapp/app.log",
        MaxSize:       100,
        MaxBackups:    3,
        MaxAge:        30,
        Compress:      true,
        EnableCaller:  true,
        EnableTracing: true,
        ServiceName:   "user-service",
        Environment:   "production",
    }
    
    // 创建日志记录器
    logger := NewLogger(config)
    
    // 创建结构化日志记录器
    structuredLogger := NewStructuredLogger(config)
    
    // 使用示例
    logger.Info("Application started")
    logger.WithField("user_id", 123).Info("User logged in")
    
    // 结构化日志
    ctx := context.Background()
    structuredLogger.HTTPRequest(ctx, "GET", "/users/123", 200, 50*time.Millisecond)
    structuredLogger.DatabaseQuery(ctx, "SELECT * FROM users WHERE id = ?", 10*time.Millisecond, nil)
    structuredLogger.CacheOperation(ctx, "GET", "user:123", 1*time.Millisecond, true)
    
    // 错误日志
    logger.WithFields(Fields{
        "error_code": "DB_CONNECTION_FAILED",
        "database":   "postgresql",
    }).Error("Failed to connect to database")
    
    // 保持程序运行
    select {}
}
```