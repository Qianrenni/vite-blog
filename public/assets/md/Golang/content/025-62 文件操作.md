## 6.2 文件操作

### 文件读写操作

```go
package main

import (
    "bufio"
    "fmt"
    "io"
    "io/ioutil"
    "os"
    "strings"
)

func demonstrateFileOperations() {
    filename := "test.txt"
    
    // 写入文件
    content := "Hello, World!\nThis is a test file.\nLine 3: 12345"
    
    // 方法1：使用ioutil.WriteFile（简单但已弃用）
    // err := ioutil.WriteFile(filename, []byte(content), 0644)
    
    // 方法2：使用os.Create和Write
    file, err := os.Create(filename)
    if err != nil {
        fmt.Printf("Create file error: %v\n", err)
        return
    }
    defer file.Close()
    
    _, err = file.WriteString(content)
    if err != nil {
        fmt.Printf("Write file error: %v\n", err)
        return
    }
    fmt.Printf("File %s created and written\n", filename)
    
    // 读取整个文件
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        fmt.Printf("Read file error: %v\n", err)
        return
    }
    fmt.Printf("File content:\n%s\n", string(data))
    
    // 按行读取文件
    fmt.Println("Reading line by line:")
    file, err = os.Open(filename)
    if err != nil {
        fmt.Printf("Open file error: %v\n", err)
        return
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    lineNum := 1
    for scanner.Scan() {
        fmt.Printf("Line %d: %s\n", lineNum, scanner.Text())
        lineNum++
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Printf("Scanner error: %v\n", err)
    }
    
    // 使用bufio.Reader进行更灵活的读取
    fmt.Println("\nUsing bufio.Reader:")
    file, err = os.Open(filename)
    if err != nil {
        fmt.Printf("Open file error: %v\n", err)
        return
    }
    defer file.Close()
    
    reader := bufio.NewReader(file)
    for {
        line, err := reader.ReadString('\n')
        if err != nil {
            if err == io.EOF {
                if len(line) > 0 {
                    fmt.Printf("Last line: %s", line)
                }
                break
            }
            fmt.Printf("Read error: %v\n", err)
            break
        }
        fmt.Print(line)
    }
    
    // 追加写入文件
    file, err = os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Printf("Open file for append error: %v\n", err)
        return
    }
    defer file.Close()
    
    _, err = file.WriteString("\nAppended line")
    if err != nil {
        fmt.Printf("Append error: %v\n", err)
        return
    }
    fmt.Println("\nLine appended to file")
    
    // 检查文件是否存在
    if _, err := os.Stat(filename); os.IsNotExist(err) {
        fmt.Printf("File %s does not exist\n", filename)
    } else {
        fmt.Printf("File %s exists\n", filename)
    }
    
    // 获取文件信息
    fileInfo, err := os.Stat(filename)
    if err != nil {
        fmt.Printf("Stat error: %v\n", err)
        return
    }
    
    fmt.Printf("File info:\n")
    fmt.Printf("  Name: %s\n", fileInfo.Name())
    fmt.Printf("  Size: %d bytes\n", fileInfo.Size())
    fmt.Printf("  Mode: %s\n", fileInfo.Mode())
    fmt.Printf("  ModTime: %v\n", fileInfo.ModTime())
    fmt.Printf("  IsDir: %t\n", fileInfo.IsDir())
}

// 高效的大文件处理
func processLargeFile() {
    filename := "large_test.txt"
    
    // 创建大文件用于测试
    file, err := os.Create(filename)
    if err != nil {
        fmt.Printf("Create large file error: %v\n", err)
        return
    }
    
    // 写入大量数据
    writer := bufio.NewWriter(file)
    for i := 0; i < 100000; i++ {
        fmt.Fprintf(writer, "Line %d: This is test data for large file processing\n", i)
    }
    writer.Flush()
    file.Close()
    
    fmt.Printf("Large file %s created\n", filename)
    
    // 高效读取大文件
    file, err = os.Open(filename)
    if err != nil {
        fmt.Printf("Open large file error: %v\n", err)
        return
    }
    defer file.Close()
    
    // 使用缓冲读取器
    reader := bufio.NewReader(file)
    lineCount := 0
    wordCount := 0
    
    for {
        line, err := reader.ReadString('\n')
        if err != nil {
            if err == io.EOF {
                if len(line) > 0 {
                    lineCount++
                    wordCount += len(strings.Fields(line))
                }
                break
            }
            fmt.Printf("Read error: %v\n", err)
            break
        }
        
        lineCount++
        wordCount += len(strings.Fields(line))
        
        // 每处理10000行显示进度
        if lineCount%10000 == 0 {
            fmt.Printf("Processed %d lines\n", lineCount)
        }
    }
    
    fmt.Printf("Total lines: %d, Total words: %d\n", lineCount, wordCount)
    
    // 清理测试文件
    os.Remove(filename)
}

// 二进制文件操作
func binaryFileOperations() {
    filename := "binary_test.dat"
    
    // 写入二进制数据
    file, err := os.Create(filename)
    if err != nil {
        fmt.Printf("Create binary file error: %v\n", err)
        return
    }
    defer file.Close()
    
    // 写入不同类型的数据
    data := []interface{}{
        int32(12345),
        float64(3.14159),
        "Hello, Binary World!",
        []byte{0xFF, 0x00, 0xAA, 0x55},
    }
    
    for _, item := range data {
        switch v := item.(type) {
        case int32:
            binary.Write(file, binary.LittleEndian, v)
        case float64:
            binary.Write(file, binary.LittleEndian, v)
        case string:
            binary.Write(file, binary.LittleEndian, int32(len(v)))
            binary.Write(file, binary.LittleEndian, []byte(v))
        case []byte:
            binary.Write(file, binary.LittleEndian, int32(len(v)))
            binary.Write(file, binary.LittleEndian, v)
        }
    }
    
    fmt.Printf("Binary data written to %s\n", filename)
    
    // 读取二进制数据
    file, err = os.Open(filename)
    if err != nil {
        fmt.Printf("Open binary file error: %v\n", err)
        return
    }
    defer file.Close()
    
    // 读取数据（需要知道数据结构）
    var intVal int32
    var floatVal float64
    
    binary.Read(file, binary.LittleEndian, &intVal)
    fmt.Printf("Read int32: %d\n", intVal)
    
    binary.Read(file, binary.LittleEndian, &floatVal)
    fmt.Printf("Read float64: %f\n", floatVal)
    
    // 读取字符串
    var strLen int32
    binary.Read(file, binary.LittleEndian, &strLen)
    strData := make([]byte, strLen)
    binary.Read(file, binary.LittleEndian, &strData)
    fmt.Printf("Read string: %s\n", string(strData))
    
    // 读取字节数组
    var byteLen int32
    binary.Read(file, binary.LittleEndian, &byteLen)
    byteData := make([]byte, byteLen)
    binary.Read(file, binary.LittleEndian, &byteData)
    fmt.Printf("Read bytes: %v\n", byteData)
    
    // 清理
    os.Remove(filename)
}

// 文件复制和移动
func fileCopyMove() {
    sourceFile := "source.txt"
    destFile := "destination.txt"
    
    // 创建源文件
    content := "This is the content to be copied.\nLine 2\nLine 3"
    err := ioutil.WriteFile(sourceFile, []byte(content), 0644)
    if err != nil {
        fmt.Printf("Create source file error: %v\n", err)
        return
    }
    fmt.Printf("Source file %s created\n", sourceFile)
    
    // 方法1：使用io.Copy
    source, err := os.Open(sourceFile)
    if err != nil {
        fmt.Printf("Open source error: %v\n", err)
        return
    }
    defer source.Close()
    
    dest, err := os.Create(destFile)
    if err != nil {
        fmt.Printf("Create dest error: %v\n", err)
        return
    }
    defer dest.Close()
    
    _, err = io.Copy(dest, source)
    if err != nil {
        fmt.Printf("Copy error: %v\n", err)
        return
    }
    fmt.Printf("File copied from %s to %s\n", sourceFile, destFile)
    
    // 方法2：使用ioutil.ReadFile和WriteFile
    data, err := ioutil.ReadFile(sourceFile)
    if err != nil {
        fmt.Printf("Read source error: %v\n", err)
        return
    }
    
    err = ioutil.WriteFile(destFile+".2", data, 0644)
    if err != nil {
        fmt.Printf("Write dest error: %v\n", err)
        return
    }
    fmt.Printf("File copied using Read/Write methods\n")
    
    // 文件移动（重命名）
    movedFile := "moved.txt"
    err = os.Rename(destFile, movedFile)
    if err != nil {
        fmt.Printf("Rename error: %v\n", err)
        return
    }
    fmt.Printf("File moved from %s to %s\n", destFile, movedFile)
    
    // 清理文件
    os.Remove(sourceFile)
    os.Remove(movedFile)
    os.Remove(destFile + ".2")
}

// 临时文件操作
func temporaryFiles() {
    // 创建临时文件
    tmpFile, err := ioutil.TempFile("", "example_*.txt")
    if err != nil {
        fmt.Printf("Create temp file error: %v\n", err)
        return
    }
    defer os.Remove(tmpFile.Name()) // 清理临时文件
    defer tmpFile.Close()
    
    fmt.Printf("Temporary file created: %s\n", tmpFile.Name())
    
    // 写入临时文件
    content := "This is temporary content"
    _, err = tmpFile.WriteString(content)
    if err != nil {
        fmt.Printf("Write temp file error: %v\n", err)
        return
    }
    
    // 读取临时文件
    tmpFile.Seek(0, 0) // 回到文件开头
    data, err := ioutil.ReadAll(tmpFile)
    if err != nil {
        fmt.Printf("Read temp file error: %v\n", err)
        return
    }
    fmt.Printf("Temporary file content: %s\n", string(data))
    
    // 创建临时目录
    tmpDir, err := ioutil.TempDir("", "example_dir_")
    if err != nil {
        fmt.Printf("Create temp dir error: %v\n", err)
        return
    }
    defer os.RemoveAll(tmpDir) // 清理临时目录
    
    fmt.Printf("Temporary directory created: %s\n", tmpDir)
    
    // 在临时目录中创建文件
    tmpFilePath := filepath.Join(tmpDir, "temp_file.txt")
    err = ioutil.WriteFile(tmpFilePath, []byte("Content in temp dir"), 0644)
    if err != nil {
        fmt.Printf("Write file in temp dir error: %v\n", err)
        return
    }
    
    fmt.Printf("File created in temp directory: %s\n", tmpFilePath)
}
```

### 目录操作

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
    "strings"
)

func demonstrateDirectoryOperations() {
    // 创建测试目录结构
    testDir := "test_directory"
    subDir1 := filepath.Join(testDir, "subdir1")
    subDir2 := filepath.Join(testDir, "subdir2")
    
    // 创建目录
    err := os.MkdirAll(subDir1, 0755)
    if err != nil {
        fmt.Printf("Create dir error: %v\n", err)
        return
    }
    
    err = os.MkdirAll(subDir2, 0755)
    if err != nil {
        fmt.Printf("Create dir error: %v\n", err)
        return
    }
    
    fmt.Printf("Directory structure created: %s\n", testDir)
    
    // 在目录中创建文件
    files := []string{
        filepath.Join(testDir, "file1.txt"),
        filepath.Join(testDir, "file2.txt"),
        filepath.Join(subDir1, "subfile1.txt"),
        filepath.Join(subDir1, "subfile2.txt"),
        filepath.Join(subDir2, "subfile3.txt"),
    }
    
    for _, file := range files {
        err := ioutil.WriteFile(file, []byte("Content of "+file), 0644)
        if err != nil {
            fmt.Printf("Create file error: %v\n", err)
            return
        }
    }
    
    fmt.Println("Files created in directory structure")
    
    // 读取目录内容
    entries, err := ioutil.ReadDir(testDir)
    if err != nil {
        fmt.Printf("Read dir error: %v\n", err)
        return
    }
    
    fmt.Printf("Contents of %s:\n", testDir)
    for _, entry := range entries {
        if entry.IsDir() {
            fmt.Printf("  [DIR]  %s\n", entry.Name())
        } else {
            fmt.Printf("  [FILE] %s (%d bytes)\n", entry.Name(), entry.Size())
        }
    }
    
    // 递归遍历目录
    fmt.Println("\nRecursive directory traversal:")
    err = filepath.Walk(testDir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        indent := strings.Repeat("  ", strings.Count(path, string(os.PathSeparator))-1)
        if info.IsDir() {
            fmt.Printf("%s[DIR]  %s/\n", indent, filepath.Base(path))
        } else {
            fmt.Printf("%s[FILE] %s (%d bytes)\n", indent, filepath.Base(path), info.Size())
        }
        return nil
    })
    
    if err != nil {
        fmt.Printf("Walk error: %v\n", err)
    }
    
    // 查找特定类型的文件
    fmt.Println("\nFinding .txt files:")
    var txtFiles []string
    err = filepath.Walk(testDir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        if !info.IsDir() && strings.HasSuffix(info.Name(), ".txt") {
            txtFiles = append(txtFiles, path)
        }
        return nil
    })
    
    for _, file := range txtFiles {
        fmt.Printf("  Found: %s\n", file)
    }
    
    // 目录信息
    dirInfo, err := os.Stat(testDir)
    if err != nil {
        fmt.Printf("Stat dir error: %v\n", err)
        return
    }
    
    fmt.Printf("\nDirectory info for %s:\n", testDir)
    fmt.Printf("  Name: %s\n", dirInfo.Name())
    fmt.Printf("  Size: %d bytes\n", dirInfo.Size())
    fmt.Printf("  Mode: %s\n", dirInfo.Mode())
    fmt.Printf("  ModTime: %v\n", dirInfo.ModTime())
    fmt.Printf("  IsDir: %t\n", dirInfo.IsDir())
    
    // 删除目录（需要为空）
    emptyDir := filepath.Join(testDir, "empty_dir")
    err = os.Mkdir(emptyDir, 0755)
    if err != nil {
        fmt.Printf("Create empty dir error: %v\n", err)
        return
    }
    
    err = os.Remove(emptyDir)
    if err != nil {
        fmt.Printf("Remove empty dir error: %v\n", err)
        return
    }
    fmt.Printf("Empty directory removed: %s\n", emptyDir)
    
    // 递归删除目录
    err = os.RemoveAll(testDir)
    if err != nil {
        fmt.Printf("Remove all error: %v\n", err)
        return
    }
    fmt.Printf("Directory tree removed: %s\n", testDir)
}

// 目录操作工具函数
func directoryUtils() {
    // 获取当前工作目录
    wd, err := os.Getwd()
    if err != nil {
        fmt.Printf("Get working dir error: %v\n", err)
        return
    }
    fmt.Printf("Current working directory: %s\n", wd)
    
    // 改变工作目录
    homeDir, err := os.UserHomeDir()
    if err != nil {
        fmt.Printf("Get home dir error: %v\n", err)
        return
    }
    
    err = os.Chdir(homeDir)
    if err != nil {
        fmt.Printf("Change dir error: %v\n", err)
        return
    }
    
    newWd, _ := os.Getwd()
    fmt.Printf("Changed to home directory: %s\n", newWd)
    
    // 恢复原工作目录
    err = os.Chdir(wd)
    if err != nil {
        fmt.Printf("Restore dir error: %v\n", err)
        return
    }
    
    // 创建多级目录
    nestedDir := "level1/level2/level3"
    err = os.MkdirAll(nestedDir, 0755)
    if err != nil {
        fmt.Printf("Create nested dir error: %v\n", err)
        return
    }
    fmt.Printf("Nested directory created: %s\n", nestedDir)
    
    // 检查目录是否存在
    if _, err := os.Stat(nestedDir); os.IsNotExist(err) {
        fmt.Printf("Directory %s does not exist\n", nestedDir)
    } else {
        fmt.Printf("Directory %s exists\n", nestedDir)
    }
    
    // 清理
    os.RemoveAll("level1")
}

// 目录大小计算
func calculateDirectorySize(path string) (int64, error) {
    var size int64
    err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if !info.IsDir() {
            size += info.Size()
        }
        return nil
    })
    return size, err
}

func demonstrateDirectorySize() {
    // 创建测试目录
    testDir := "size_test"
    err := os.MkdirAll(filepath.Join(testDir, "sub1", "sub2"), 0755)
    if err != nil {
        fmt.Printf("Create test dir error: %v\n", err)
        return
    }
    
    // 创建不同大小的文件
    files := map[string]int{
        filepath.Join(testDir, "small.txt"):        100,
        filepath.Join(testDir, "medium.txt"):       1000,
        filepath.Join(testDir, "sub1", "large.txt"): 10000,
        filepath.Join(testDir, "sub1", "sub2", "huge.txt"): 100000,
    }
    
    for filename, size := range files {
        data := make([]byte, size)
        for i := range data {
            data[i] = byte(i % 256)
        }
        err := ioutil.WriteFile(filename, data, 0644)
        if err != nil {
            fmt.Printf("Create file error: %v\n", err)
            return
        }
    }
    
    // 计算目录大小
    size, err := calculateDirectorySize(testDir)
    if err != nil {
        fmt.Printf("Calculate size error: %v\n", err)
        return
    }
    
    fmt.Printf("Directory %s size: %d bytes (%.2f KB)\n", 
        testDir, size, float64(size)/1024)
    
    // 清理
    os.RemoveAll(testDir)
}
```

### 文件系统操作

```go
package main

import (
    "fmt"
    "os"
    "path/filepath"
    "syscall"
    "time"
)

func demonstrateFileSystemOperations() {
    // 文件系统信息
    wd, _ := os.Getwd()
    
    // 获取文件系统统计信息
    var stat syscall.Statfs_t
    err := syscall.Statfs(wd, &stat)
    if err != nil {
        fmt.Printf("Statfs error: %v\n", err)
        return
    }
    
    fmt.Printf("File system info for %s:\n", wd)
    fmt.Printf("  Block size: %d\n", stat.Bsize)
    fmt.Printf("  Total blocks: %d\n", stat.Blocks)
    fmt.Printf("  Free blocks: %d\n", stat.Bfree)
    fmt.Printf("  Available blocks: %d\n", stat.Bavail)
    fmt.Printf("  Total space: %.2f GB\n", 
        float64(stat.Blocks*uint64(stat.Bsize))/(1024*1024*1024))
    fmt.Printf("  Free space: %.2f GB\n", 
        float64(stat.Bfree*uint64(stat.Bsize))/(1024*1024*1024))
    fmt.Printf("  Available space: %.2f GB\n", 
        float64(stat.Bavail*uint64(stat.Bsize))/(1024*1024*1024))
    
    // 符号链接操作
    originalFile := "original.txt"
    symlinkFile := "symlink.txt"
    
    // 创建原始文件
    err = ioutil.WriteFile(originalFile, []byte("Original content"), 0644)
    if err != nil {
        fmt.Printf("Create original file error: %v\n", err)
        return
    }
    
    // 创建符号链接
    err = os.Symlink(originalFile, symlinkFile)
    if err != nil {
        fmt.Printf("Create symlink error: %v\n", err)
        return
    }
    fmt.Printf("Symbolic link created: %s -> %s\n", symlinkFile, originalFile)
    
    // 检查符号链接
    linkInfo, err := os.Lstat(symlinkFile)
    if err != nil {
        fmt.Printf("Lstat error: %v\n", err)
        return
    }
    
    fmt.Printf("Symlink info:\n")
    fmt.Printf("  Name: %s\n", linkInfo.Name())
    fmt.Printf("  Mode: %s\n", linkInfo.Mode())
    fmt.Printf("  Is symlink: %t\n", linkInfo.Mode()&os.ModeSymlink != 0)
    
    // 读取符号链接目标
    target, err := os.Readlink(symlinkFile)
    if err != nil {
        fmt.Printf("Readlink error: %v\n", err)
        return
    }
    fmt.Printf("Symlink target: %s\n", target)
    
    // 硬链接操作
    hardlinkFile := "hardlink.txt"
    err = os.Link(originalFile, hardlinkFile)
    if err != nil {
        fmt.Printf("Create hardlink error: %v\n", err)
        return
    }
    fmt.Printf("Hard link created: %s -> %s\n", hardlinkFile, originalFile)
    
    // 比较文件
    originalInfo, _ := os.Stat(originalFile)
    hardlinkInfo, _ := os.Stat(hardlinkFile)
    
    fmt.Printf("Original file inode: %d\n", getInode(originalInfo))
    fmt.Printf("Hard link file inode: %d\n", getInode(hardlinkInfo))
    fmt.Printf("Same inode: %t\n", getInode(originalInfo) == getInode(hardlinkInfo))
    
    // 清理
    os.Remove(originalFile)
    os.Remove(symlinkFile)
    os.Remove(hardlinkFile)
}

// 获取文件inode（Unix/Linux系统）
func getInode(info os.FileInfo) uint64 {
    if stat, ok := info.Sys().(*syscall.Stat_t); ok {
        return stat.Ino
    }
    return 0
}

// 磁盘空间监控
func monitorDiskSpace() {
    wd, _ := os.Getwd()
    
    // 持续监控磁盘空间
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    fmt.Println("Monitoring disk space (press Ctrl+C to stop):")
    
    for {
        select {
        case <-ticker.C:
            var stat syscall.Statfs_t
            err := syscall.Statfs(wd, &stat)
            if err != nil {
                fmt.Printf("Statfs error: %v\n", err)
                continue
            }
            
            total := float64(stat.Blocks * uint64(stat.Bsize))
            free := float64(stat.Bfree * uint64(stat.Bsize))
            used := total - free
            usage := (used / total) * 100
            
            fmt.Printf("Disk usage: %.1f%% (Used: %.2f GB / Total: %.2f GB)\n",
                usage, used/(1024*1024*1024), total/(1024*1024*1024))
            
            if usage > 90 {
                fmt.Println("WARNING: Disk usage is over 90%!")
            }
        }
    }
}

// 文件系统遍历和分析
func analyzeFileSystem() {
    wd, _ := os.Getwd()
    
    fmt.Printf("Analyzing file system starting from: %s\n", wd)
    
    type FileStats struct {
        Count int64
        Size  int64
    }
    
    stats := make(map[string]*FileStats)
    totalFiles := int64(0)
    totalSize := int64(0)
    
    err := filepath.Walk(wd, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return nil // 继续遍历，忽略错误
        }
        
        if !info.IsDir() {
            totalFiles++
            totalSize += info.Size()
            
            // 按扩展名统计
            ext := filepath.Ext(path)
            if ext == "" {
                ext = "no_extension"
            }
            
            if stats[ext] == nil {
                stats[ext] = &FileStats{}
            }
            stats[ext].Count++
            stats[ext].Size += info.Size()
        }
        
        return nil
    })
    
    if err != nil {
        fmt.Printf("Walk error: %v\n", err)
        return
    }
    
    fmt.Printf("Total files: %d\n", totalFiles)
    fmt.Printf("Total size: %.2f MB\n", float64(totalSize)/(1024*1024))
    
    fmt.Println("\nFile type statistics:")
    for ext, stat := range stats {
        fmt.Printf("  %s: %d files, %.2f MB\n", 
            ext, stat.Count, float64(stat.Size)/(1024*1024))
    }
}
```

### os包详解

```go
package main

import (
    "fmt"
    "os"
    "os/exec"
    "os/signal"
    "os/user"
    "syscall"
    "time"
)

func demonstrateOSPackage() {
    // 环境变量操作
    fmt.Println("=== Environment Variables ===")
    
    // 设置环境变量
    os.Setenv("MY_VAR", "Hello, Environment!")
    fmt.Printf("MY_VAR: %s\n", os.Getenv("MY_VAR"))
    
    // 获取所有环境变量
    env := os.Environ()
    fmt.Printf("Number of environment variables: %d\n", len(env))
    
    // 检查环境变量是否存在
    if value, exists := os.LookupEnv("PATH"); exists {
        fmt.Printf("PATH exists, length: %d characters\n", len(value))
    }
    
    // 进程相关操作
    fmt.Println("\n=== Process Information ===")
    fmt.Printf("Process ID: %d\n", os.Getpid())
    fmt.Printf("Parent Process ID: %d\n", os.Getppid())
    fmt.Printf("Process Group ID: %d\n", os.Getpgid(0))
    
    // 用户信息
    currentUser, err := user.Current()
    if err != nil {
        fmt.Printf("Get current user error: %v\n", err)
    } else {
        fmt.Printf("Current user: %s (UID: %s, GID: %s)\n", 
            currentUser.Username, currentUser.Uid, currentUser.Gid)
        fmt.Printf("Home directory: %s\n", currentUser.HomeDir)
    }
    
    // 主机信息
    hostname, err := os.Hostname()
    if err != nil {
        fmt.Printf("Get hostname error: %v\n", err)
    } else {
        fmt.Printf("Hostname: %s\n", hostname)
    }
    
    // 临时目录
    fmt.Printf("Temporary directory: %s\n", os.TempDir())
    
    // 工作目录
    wd, err := os.Getwd()
    if err != nil {
        fmt.Printf("Get working directory error: %v\n", err)
    } else {
        fmt.Printf("Working directory: %s\n", wd)
    }
    
    // 文件描述符操作
    fmt.Println("\n=== File Descriptors ===")
    // 标准输入、输出、错误
    fmt.Printf("Stdin: %v\n", os.Stdin)
    fmt.Printf("Stdout: %v\n", os.Stdout)
    fmt.Printf("Stderr: %v\n", os.Stderr)
    
    // 重定向输出
    file, err := os.Create("output.txt")
    if err != nil {
        fmt.Printf("Create output file error: %v\n", err)
        return
    }
    defer file.Close()
    defer os.Remove("output.txt")
    
    // 保存原始stdout
    originalStdout := os.Stdout
    // 重定向stdout到文件
    os.Stdout = file
    
    fmt.Println("This goes to the file")
    fmt.Printf("Process ID in file: %d\n", os.Getpid())
    
    // 恢复stdout
    os.Stdout = originalStdout
    fmt.Println("This goes to console")
    
    // 读取输出文件内容
    content, _ := ioutil.ReadFile("output.txt")
    fmt.Printf("File content:\n%s", string(content))
}

// 系统调用和进程管理
func demonstrateProcessManagement() {
    fmt.Println("=== Process Management ===")
    
    // 执行外部命令
    cmd := exec.Command("echo", "Hello from external command")
    output, err := cmd.Output()
    if err != nil {
        fmt.Printf("Command execution error: %v\n", err)
    } else {
        fmt.Printf("Command output: %s", output)
    }
    
    // 执行命令并获取错误输出
    cmd = exec.Command("ls", "/nonexistent")
    output, err = cmd.CombinedOutput()
    fmt.Printf("Combined output (including errors): %s", output)
    if err != nil {
        fmt.Printf("Command failed with: %v\n", err)
    }
    
    // 交互式命令执行
    fmt.Println("Starting interactive shell (type 'exit' to quit):")
    shell := exec.Command("sh")
    shell.Stdin = os.Stdin
    shell.Stdout = os.Stdout
    shell.Stderr = os.Stderr
    
    // 启动但不等待
    err = shell.Start()
    if err != nil {
        fmt.Printf("Start shell error: %v\n", err)
        return
    }
    
    // 等待命令完成
    err = shell.Wait()
    if err != nil {
        fmt.Printf("Shell execution error: %v\n", err)
    } else {
        fmt.Println("Shell completed successfully")
    }
}

// 信号处理
func demonstrateSignalHandling() {
    fmt.Println("=== Signal Handling ===")
    
    // 创建信号通道
    sigChan := make(chan os.Signal, 1)
    
    // 注册要捕获的信号
    signal.Notify(sigChan, 
        syscall.SIGINT,   // Ctrl+C
        syscall.SIGTERM,  // 终止信号
        syscall.SIGHUP)   // 挂起信号
    
    fmt.Println("Signal handler registered. Press Ctrl+C to test.")
    fmt.Println("This program will exit gracefully.")
    
    // 启动一个goroutine来处理信号
    go func() {
        sig := <-sigChan
        fmt.Printf("Received signal: %v\n", sig)
        fmt.Println("Cleaning up...")
        
        // 执行清理操作
        cleanup()
        
        // 退出程序
        os.Exit(0)
    }()
    
    // 模拟长时间运行的任务
    for i := 0; i < 100; i++ {
        fmt.Printf("Working... %d/100\n", i)
        time.Sleep(1 * time.Second)
    }
}

func cleanup() {
    fmt.Println("Performing cleanup operations...")
    // 这里可以添加实际的清理代码
    // 如关闭文件、断开连接、保存状态等
}

// 系统资源管理
func demonstrateSystemResources() {
    fmt.Println("=== System Resources ===")
    
    // 获取系统页面大小
    pageSize := os.Getpagesize()
    fmt.Printf("System page size: %d bytes\n", pageSize)
    
    // 进程优先级（需要权限）
    priority, err := syscall.Getpriority(syscall.PRIO_PROCESS, 0)
    if err != nil {
        fmt.Printf("Get priority error: %v\n", err)
    } else {
        fmt.Printf("Current process priority: %d\n", priority)
    }
    
    // 文件系统同步
    fmt.Println("Syncing file system...")
    syscall.Sync()
    fmt.Println("File system synced")
    
    // 获取系统限制
    var rLimit syscall.Rlimit
    err = syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rLimit)
    if err != nil {
        fmt.Printf("Get rlimit error: %v\n", err)
    } else {
        fmt.Printf("File descriptor limits: soft=%d, hard=%d\n", 
            rLimit.Cur, rLimit.Max)
    }
}

// 跨平台文件操作
func demonstrateCrossPlatform() {
    fmt.Println("=== Cross-Platform Operations ===")
    
    // 路径分隔符
    fmt.Printf("Path separator: %c\n", os.PathSeparator)
    fmt.Printf("Path list separator: %c\n", os.PathListSeparator)
    
    // 构建跨平台路径
    path := filepath.Join("dir1", "dir2", "file.txt")
    fmt.Printf("Cross-platform path: %s\n", path)
    
    // 检查路径分隔符
    fmt.Printf("Is path separator '/': %t\n", os.IsPathSeparator('/'))
    fmt.Printf("Is path separator '\\\\': %t\n", os.IsPathSeparator('\\'))
    
    // 路径操作
    absPath, err := filepath.Abs(".")
    if err != nil {
        fmt.Printf("Abs path error: %v\n", err)
    } else {
        fmt.Printf("Absolute path: %s\n", absPath)
    }
    
    // 路径清理
    messyPath := "dir1/../dir2/./file.txt"
    cleanPath := filepath.Clean(messyPath)
    fmt.Printf("Cleaned path: %s -> %s\n", messyPath, cleanPath)
}
```

### path/filepath包

```go
package main

import (
    "fmt"
    "os"
    "path"
    "path/filepath"
    "strings"
)

func demonstrateFilepath() {
    fmt.Println("=== filepath Package ===")
    
    // 基本路径操作
    paths := []string{
        "/home/user/documents/file.txt",
        "C:\\Users\\User\\Documents\\file.txt",
        "../parent/child/file.txt",
        "./current/file.txt",
        "file.txt",
    }
    
    for _, p := range paths {
        fmt.Printf("Path: %s\n", p)
        fmt.Printf("  Base: %s\n", filepath.Base(p))
        fmt.Printf("  Dir: %s\n", filepath.Dir(p))
        fmt.Printf("  Ext: %s\n", filepath.Ext(p))
        
        // 分割路径
        dir, file := filepath.Split(p)
        fmt.Printf("  Split - Dir: %s, File: %s\n", dir, file)
        
        fmt.Println()
    }
    
    // 路径连接
    joined := filepath.Join("dir1", "dir2", "file.txt")
    fmt.Printf("Joined path: %s\n", joined)
    
    // 跨平台路径连接
    pathsToJoin := []string{"home", "user", "documents", "file.txt"}
    crossPlatformPath := filepath.Join(pathsToJoin...)
    fmt.Printf("Cross-platform path: %s\n", crossPlatformPath)
    
    // 路径清理
    messyPaths := []string{
        "/home//user/./documents/../documents/file.txt",
        "dir1/../../dir2/file.txt",
        "./././file.txt",
    }
    
    for _, p := range messyPaths {
        cleaned := filepath.Clean(p)
        fmt.Printf("Clean: %s -> %s\n", p, cleaned)
    }
    
    // 绝对路径
    relPath := "relative/path/file.txt"
    absPath, err := filepath.Abs(relPath)
    if err != nil {
        fmt.Printf("Abs error: %v\n", err)
    } else {
        fmt.Printf("Absolute path: %s -> %s\n", relPath, absPath)
    }
    
    // 路径匹配
    patterns := []string{
        "*.txt",
        "file?.txt",
        "[a-z]*.go",
        "**/*.go",  // 不支持**，需要使用filepath.Walk
    }
    
    testFiles := []string{
        "file.txt",
        "file1.txt",
        "document.pdf",
        "main.go",
        "utils.go",
    }
    
    for _, pattern := range patterns {
        fmt.Printf("Pattern: %s\n", pattern)
        for _, file := range testFiles {
            matched, err := filepath.Match(pattern, file)
            if err != nil {
                fmt.Printf("  Match error for %s: %v\n", file, err)
            } else if matched {
                fmt.Printf("  Matched: %s\n", file)
            }
        }
        fmt.Println()
    }
    
    // 相对路径计算
    base := "/home/user"
    target := "/home/user/documents/file.txt"
    rel, err := filepath.Rel(base, target)
    if err != nil {
        fmt.Printf("Rel error: %v\n", err)
    } else {
        fmt.Printf("Relative path: %s -> %s = %s\n", base, target, rel)
    }
    
    // 路径分隔符处理
    fmt.Printf("Separator: %c\n", filepath.Separator)
    fmt.Printf("List separator: %c\n", filepath.ListSeparator)
    
    // 转换分隔符
    windowsPath := "C:\\Users\\User\\Documents\\file.txt"
    unixPath := filepath.ToSlash(windowsPath)
    fmt.Printf("To slash: %s -> %s\n", windowsPath, unixPath)
    
    fromSlash := filepath.FromSlash(unixPath)
    fmt.Printf("From slash: %s -> %s\n", unixPath, fromSlash)
}

// 路径遍历和搜索
func demonstratePathTraversal() {
    fmt.Println("=== Path Traversal ===")
    
    // 获取当前目录
    wd, err := os.Getwd()
    if err != nil {
        fmt.Printf("Getwd error: %v\n", err)
        return
    }
    
    fmt.Printf("Current directory: %s\n", wd)
    
    // 遍历目录树
    fmt.Println("Directory tree:")
    err = filepath.Walk(wd, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        // 只显示前几层
        rel, _ := filepath.Rel(wd, path)
        depth := strings.Count(rel, string(filepath.Separator))
        if depth > 3 {
            if info.IsDir() {
                return filepath.SkipDir  // 跳过这个目录
            }
            return nil
        }
        
        indent := strings.Repeat("  ", depth)
        if info.IsDir() {
            fmt.Printf("%s[DIR] %s/\n", indent, info.Name())
        } else {
            fmt.Printf("%s[FILE] %s (%d bytes)\n", indent, info.Name(), info.Size())
        }
        
        return nil
    })
    
    if err != nil {
        fmt.Printf("Walk error: %v\n", err)
    }
    
    // 查找特定文件
    fmt.Println("\nFinding Go files:")
    var goFiles []string
    err = filepath.Walk(wd, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
            relPath, _ := filepath.Rel(wd, path)
            goFiles = append(goFiles, relPath)
        }
        
        return nil
    })
    
    for _, file := range goFiles {
        fmt.Printf("  %s\n", file)
    }
    
    // 使用Glob模式匹配
    fmt.Println("\nUsing Glob patterns:")
    patterns := []string{
        "*.go",
        "*/*.go",
        "**/*.txt",  // 注意：Glob不支持**，需要使用Walk
    }
    
    for _, pattern := range patterns {
        matches, err := filepath.Glob(pattern)
        if err != nil {
            fmt.Printf("Glob error for %s: %v\n", pattern, err)
        } else {
            fmt.Printf("Pattern %s matches:\n", pattern)
            for _, match := range matches {
                fmt.Printf("  %s\n", match)
            }
        }
    }
}

// 路径安全检查
func demonstratePathSecurity() {
    fmt.Println("=== Path Security ===")
    
    // 检查路径是否在指定目录内（防止目录遍历攻击）
    allowedDir := "/safe/directory"
    testPaths := []string{
        "/safe/directory/file.txt",
        "/safe/directory/subdir/file.txt",
        "/safe/directory/../etc/passwd",
        "/etc/passwd",
        "/safe/directory/../../../etc/passwd",
    }
    
    for _, testPath := range testPaths {
        if isPathInDirectory(testPath, allowedDir) {
            fmt.Printf("ALLOWED: %s\n", testPath)
        } else {
            fmt.Printf("DENIED: %s\n", testPath)
        }
    }
    
    // 安全的路径连接
    fmt.Println("\nSafe path joining:")
    baseDirs := []string{"/home/user", "/var/data"}
    userInputs := []string{"file.txt", "../etc/passwd", "/absolute/path"}
    
    for _, base := range baseDirs {
        for _, input := range userInputs {
            safePath := safeJoin(base, input)
            fmt.Printf("Base: %s + Input: %s = %s\n", base, input, safePath)
        }
    }
}

// 检查路径是否在指定目录内
func isPathInDirectory(filePath, directory string) bool {
    // 转换为绝对路径
    absPath, err := filepath.Abs(filePath)
    if err != nil {
        return false
    }
    
    absDir, err := filepath.Abs(directory)
    if err != nil {
        return false
    }
    
    // 检查路径是否以目录路径开头
    rel, err := filepath.Rel(absDir, absPath)
    if err != nil {
        return false
    }
    
    // 如果相对路径以..开头，说明不在目录内
    return !strings.HasPrefix(rel, "..")
}

// 安全的路径连接
func safeJoin(base, userPath string) string {
    // 清理用户输入的路径
    cleanPath := filepath.Clean(userPath)
    
    // 移除开头的分隔符以避免绝对路径
    cleanPath = strings.TrimPrefix(cleanPath, string(filepath.Separator))
    
    // 连接路径
    result := filepath.Join(base, cleanPath)
    
    // 确保结果路径在基础目录内
    if !isPathInDirectory(result, base) {
        return base  // 返回基础目录作为安全默认值
    }
    
    return result
}

// 路径工具函数
func pathUtilities() {
    fmt.Println("=== Path Utilities ===")
    
    // 获取用户主目录
    homeDir, err := os.UserHomeDir()
    if err != nil {
        fmt.Printf("User home dir error: %v\n", err)
    } else {
        fmt.Printf("User home directory: %s\n", homeDir)
    }
    
    // 获取配置目录
    configDir, err := os.UserConfigDir()
    if err != nil {
        fmt.Printf("User config dir error: %v\n", err)
    } else {
        fmt.Printf("User config directory: %s\n", configDir)
    }
    
    // 获取缓存目录
    cacheDir, err := os.UserCacheDir()
    if err != nil {
        fmt.Printf("User cache dir error: %v\n", err)
    } else {
        fmt.Printf("User cache directory: %s\n", cacheDir)
    }
    
    // 路径标准化示例
    testPaths := []string{
        "/home/user/../user/documents/file.txt",
        "C:\\Users\\User\\..\\User\\Documents\\file.txt",
        "./dir/./subdir/../subdir/file.txt",
    }
    
    fmt.Println("Path normalization:")
    for _, p := range testPaths {
        normalized := filepath.Clean(p)
        abs, _ := filepath.Abs(normalized)
        fmt.Printf("  %s\n    -> %s\n    -> %s\n", p, normalized, abs)
    }
    
    // 路径组件分析
    fullPath := "/home/user/documents/project/main.go"
    fmt.Printf("\nPath components for %s:\n", fullPath)
    
    // 分割所有组件
    components := splitPath(fullPath)
    for i, component := range components {
        fmt.Printf("  [%d] %s\n", i, component)
    }
    
    // 重建路径
    rebuilt := filepath.Join(components...)
    fmt.Printf("  Rebuilt: %s\n", rebuilt)
}

// 分割路径为组件
func splitPath(path string) []string {
    var components []string
    dir := path
    
    for {
        dir, file := filepath.Split(dir)
        if file != "" {
            components = append([]string{file}, components...)
        }
        if dir == "" || dir == string(filepath.Separator) || 
           (len(dir) >= 2 && dir[1] == ':' && filepath.Separator == '\\') {  // Windows drive
            if dir != "" {
                components = append([]string{dir}, components...)
            }
            break
        }
        dir = filepath.Clean(dir)
    }
    
    return components
}
```

### 文件权限管理

```go
package main

import (
    "fmt"
    "os"
    "path/filepath"
    "syscall"
)

func demonstrateFilePermissions() {
    fmt.Println("=== File Permissions ===")
    
    // 创建测试文件
    filename := "permission_test.txt"
    content := "This file is for permission testing"
    
    // 创建文件并设置权限
    err := ioutil.WriteFile(filename, []byte(content), 0644)
    if err != nil {
        fmt.Printf("Create file error: %v\n", err)
        return
    }
    fmt.Printf("File %s created with 0644 permissions\n", filename)
    
    // 获取文件权限信息
    fileInfo, err := os.Stat(filename)
    if err != nil {
        fmt.Printf("Stat error: %v\n", err)
        return
    }
    
    fmt.Printf("File permissions: %s\n", fileInfo.Mode())
    fmt.Printf("Is regular file: %t\n", fileInfo.Mode().IsRegular())
    fmt.Printf("Is directory: %t\n", fileInfo.Mode().IsDir())
    fmt.Printf("Is executable: %t\n", fileInfo.Mode()&0111 != 0)
    
    // 详细权限检查
    mode := fileInfo.Mode()
    fmt.Printf("Owner permissions: %s\n", getPermissionString(mode.Perm()>>6))
    fmt.Printf("Group permissions: %s\n", getPermissionString((mode.Perm()>>3)&7))
    fmt.Printf("Other permissions: %s\n", getPermissionString(mode.Perm()&7))
    
    // 修改文件权限
    err = os.Chmod(filename, 0600)
    if err != nil {
        fmt.Printf("Chmod error: %v\n", err)
        return
    }
    
    fileInfo, _ = os.Stat(filename)
    fmt.Printf("Permissions after chmod 0600: %s\n", fileInfo.Mode())
    
    // 创建不同权限的文件
    testFiles := map[string]os.FileMode{
        "readonly.txt":    0444,
        "writeonly.txt":   0222,
        "executable.txt":  0755,
        "private.txt":     0600,
    }
    
    for name, perm := range testFiles {
        err := ioutil.WriteFile(name, []byte("Content of "+name), perm)
        if err != nil {
            fmt.Printf("Create %s error: %v\n", name, err)
            continue
        }
        fmt.Printf("Created %s with permissions %s\n", name, perm)
    }
    
    // 检查权限
    fmt.Println("\nPermission checks:")
    for name := range testFiles {
        if canRead(name) {
            fmt.Printf("  %s: readable\n", name)
        }
        if canWrite(name) {
            fmt.Printf("  %s: writable\n", name)
        }
        if canExecute(name) {
            fmt.Printf("  %s: executable\n", name)
        }
    }
    
    // 清理测试文件
    for name := range testFiles {
        os.Remove(name)
    }
    os.Remove(filename)
}

// 获取权限字符串表示
func getPermissionString(perm uint32) string {
    var result string
    if perm&4 != 0 {
        result += "r"
    } else {
        result += "-"
    }
    if perm&2 != 0 {
        result += "w"
    } else {
        result += "-"
    }
    if perm&1 != 0 {
        result += "x"
    } else {
        result += "-"
    }
    return result
}

// 权限检查函数
func canRead(filename string) bool {
    file, err := os.Open(filename)
    if err != nil {
        return false
    }
    file.Close()
    return true
}

func canWrite(filename string) bool {
    file, err := os.OpenFile(filename, os.O_WRONLY, 0)
    if err != nil {
        return false
    }
    file.Close()
    return true
}

func canExecute(filename string) bool {
    fileInfo, err := os.Stat(filename)
    if err != nil {
        return false
    }
    return fileInfo.Mode()&0111 != 0
}

// 目录权限管理
func demonstrateDirectoryPermissions() {
    fmt.Println("\n=== Directory Permissions ===")
    
    // 创建测试目录结构
    testDir := "perm_test_dir"
    subDir := filepath.Join(testDir, "subdir")
    
    err := os.MkdirAll(subDir, 0755)
    if err != nil {
        fmt.Printf("Create dir error: %v\n", err)
        return
    }
    fmt.Printf("Directory structure created: %s\n", testDir)
    
    // 创建不同权限的文件
    files := []struct {
        path string
        perm os.FileMode
    }{
        {filepath.Join(testDir, "public.txt"), 0644},
        {filepath.Join(testDir, "private.txt"), 0600},
        {filepath.Join(subDir, "subfile.txt"), 0644},
    }
    
    for _, f := range files {
        err := ioutil.WriteFile(f.path, []byte("Content"), f.perm)
        if err != nil {
            fmt.Printf("Create file error: %v\n", err)
            continue
        }
        fmt.Printf("Created %s with permissions %s\n", f.path, f.perm)
    }
    
    // 递归修改目录权限
    err = filepath.Walk(testDir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        // 只修改文件权限，保持目录权限
        if !info.IsDir() {
            err = os.Chmod(path, 0600)
            if err != nil {
                return err
            }
            fmt.Printf("Changed %s to 0600\n", path)
        }
        
        return nil
    })
    
    if err != nil {
        fmt.Printf("Walk error: %v\n", err)
    }
    
    // 清理
    os.RemoveAll(testDir)
}

// 用户和组权限
func demonstrateUserGroupPermissions() {
    fmt.Println("\n=== User and Group Permissions ===")
    
    filename := "user_group_test.txt"
    err := ioutil.WriteFile(filename, []byte("Test content"), 0644)
    if err != nil {
        fmt.Printf("Create file error: %v\n", err)
        return
    }
    
    // 获取文件的详细信息（Unix/Linux系统）
    fileInfo, err := os.Stat(filename)
    if err != nil {
        fmt.Printf("Stat error: %v\n", err)
        os.Remove(filename)
        return
    }
    
    // 在Unix系统上获取用户和组信息
    if stat, ok := fileInfo.Sys().(*syscall.Stat_t); ok {
        fmt.Printf("File owner UID: %d\n", stat.Uid)
        fmt.Printf("File group GID: %d\n", stat.Gid)
    }
    
    // 获取当前用户信息
    currentUser, err := user.Current()
    if err != nil {
        fmt.Printf("Get current user error: %v\n", err)
    } else {
        fmt.Printf("Current user: %s (UID: %s)\n", currentUser.Username, currentUser.Uid)
    }
    
    // 权限检查的最佳实践
    fmt.Println("\nPermission checking best practices:")
    
    // 方法1：使用os.IsPermission
    _, err = os.Open("/root/secret.txt")
    if os.IsPermission(err) {
        fmt.Println("Permission denied (using os.IsPermission)")
    }
    
    // 方法2：使用os.IsNotExist
    _, err = os.Open("/nonexistent/file.txt")
    if os.IsNotExist(err) {
        fmt.Printf("File does not exist (using os.IsNotExist)\n")
    }
    
    // 方法3：检查具体权限
    if canRead(filename) {
        fmt.Printf("%s is readable\n", filename)
    }
    
    os.Remove(filename)
}

// 安全的文件操作
func secureFileOperations() {
    fmt.Println("\n=== Secure File Operations ===")
    
    // 创建临时文件进行安全操作
    tmpFile, err := ioutil.TempFile("", "secure_*")
    if err != nil {
        fmt.Printf("Create temp file error: %v\n", err)
        return
    }
    defer os.Remove(tmpFile.Name())
    defer tmpFile.Close()
    
    fmt.Printf("Created secure temporary file: %s\n", tmpFile.Name())
    
    // 设置安全权限
    err = os.Chmod(tmpFile.Name(), 0600)
    if err != nil {
        fmt.Printf("Chmod error: %v\n", err)
        return
    }
    
    // 写入敏感数据
    sensitiveData := "This is sensitive information"
    _, err = tmpFile.WriteString(sensitiveData)
    if err != nil {
        fmt.Printf("Write error: %v\n", err)
        return
    }
    
    // 验证权限
    fileInfo, _ := os.Stat(tmpFile.Name())
    fmt.Printf("Secure file permissions: %s\n", fileInfo.Mode())
    
    // 原子文件写入（避免数据损坏）
    atomicWrite("atomic_test.txt", "Atomic write content")
}

// 原子文件写入
func atomicWrite(filename, content string) error {
    // 创建临时文件
    tmpFile, err := ioutil.TempFile(filepath.Dir(filename), filepath.Base(filename)+".tmp*")
    if err != nil {
        return err
    }
    
    // 确保临时文件被清理
    defer os.Remove(tmpFile.Name())
    defer tmpFile.Close()
    
    // 写入内容
    _, err = tmpFile.WriteString(content)
    if err != nil {
        return err
    }
    
    // 同步到磁盘
    err = tmpFile.Sync()
    if err != nil {
        return err
    }
    
    // 原子重命名
    err = os.Rename(tmpFile.Name(), filename)
    if err != nil {
        return err
    }
    
    fmt.Printf("Atomic write completed: %s\n", filename)
    return nil
}
```

### 文件锁机制

```go
package main

import (
    "fmt"
    "os"
    "sync"
    "syscall"
    "time"
)

// 文件锁结构
type FileLock struct {
    file *os.File
    mu   sync.Mutex
}

// 创建文件锁
func NewFileLock(filename string) (*FileLock, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0644)
    if err != nil {
        return nil, err
    }
    
    return &FileLock{
        file: file,
    }, nil
}

// 获取排他锁
func (fl *FileLock) Lock() error {
    fl.mu.Lock()
    defer fl.mu.Unlock()
    
    return syscall.Flock(int(fl.file.Fd()), syscall.LOCK_EX)
}

// 获取共享锁
func (fl *FileLock) RLock() error {
    fl.mu.Lock()
    defer fl.mu.Unlock()
    
    return syscall.Flock(int(fl.file.Fd()), syscall.LOCK_SH)
}

// 释放锁
func (fl *FileLock) Unlock() error {
    fl.mu.Lock()
    defer fl.mu.Unlock()
    
    return syscall.Flock(int(fl.file.Fd()), syscall.LOCK_UN)
}

// 尝试获取锁（非阻塞）
func (fl *FileLock) TryLock() bool {
    fl.mu.Lock()
    defer fl.mu.Unlock()
    
    err := syscall.Flock(int(fl.file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)
    return err == nil
}

// 关闭文件锁
func (fl *FileLock) Close() error {
    fl.Unlock()
    return fl.file.Close()
}

func demonstrateFileLocking() {
    fmt.Println("=== File Locking ===")
    
    lockFile := "lock_test.lock"
    
    // 创建文件锁
    lock, err := NewFileLock(lockFile)
    if err != nil {
        fmt.Printf("Create lock error: %v\n", err)
        return
    }
    defer lock.Close()
    defer os.Remove(lockFile)
    
    fmt.Println("File lock created")
    
    // 获取排他锁
    err = lock.Lock()
    if err != nil {
        fmt.Printf("Lock error: %v\n", err)
        return
    }
    fmt.Println("Exclusive lock acquired")
    
    // 模拟工作
    time.Sleep(2 * time.Second)
    
    // 释放锁
    err = lock.Unlock()
    if err != nil {
        fmt.Printf("Unlock error: %v\n", err)
        return
    }
    fmt.Println("Lock released")
    
    // 共享锁演示
    err = lock.RLock()
    if err != nil {
        fmt.Printf("RLock error: %v\n", err)
        return
    }
    fmt.Println("Shared lock acquired")
    
    // 释放共享锁
    lock.Unlock()
    fmt.Println("Shared lock released")
}

// 并发文件锁测试
func concurrentFileLocking() {
    fmt.Println("\n=== Concurrent File Locking ===")
    
    lockFile := "concurrent_lock_test.lock"
    lock, err := NewFileLock(lockFile)
    if err != nil {
        fmt.Printf("Create lock error: %v\n", err)
        return
    }
    defer lock.Close()
    defer os.Remove(lockFile)
    
    // 启动多个goroutine竞争锁
    var wg sync.WaitGroup
    results := make(chan string, 10)
    
    // 第一个goroutine获取锁并保持一段时间
    wg.Add(1)
    go func() {
        defer wg.Done()
        err := lock.Lock()
        if err != nil {
            results <- fmt.Sprintf("Goroutine 1 lock error: %v", err)
            return
        }
        
        results <- "Goroutine 1 acquired lock"
        time.Sleep(3 * time.Second)  // 保持锁3秒
        lock.Unlock()
        results <- "Goroutine 1 released lock"
    }()
    
    // 其他goroutine尝试获取锁
    for i := 2; i <= 5; i++ {
        id := i
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            // 尝试立即获取锁
            if lock.TryLock() {
                results <- fmt.Sprintf("Goroutine %d got lock immediately", id)
                lock.Unlock()
                return
            }
            
            results <- fmt.Sprintf("Goroutine %d waiting for lock", id)
            
            // 等待获取锁
            err := lock.Lock()
            if err != nil {
                results <- fmt.Sprintf("Goroutine %d lock error: %v", id, err)
                return
            }
            
            results <- fmt.Sprintf("Goroutine %d acquired lock", id)
            time.Sleep(500 * time.Millisecond)  // 短暂持有
            lock.Unlock()
            results <- fmt.Sprintf("Goroutine %d released lock", id)
        }()
    }
    
    // 收集结果
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // 打印结果
    for result := range results {
        fmt.Println(result)
    }
}

// 高级文件锁功能
type AdvancedFileLock struct {
    file     *os.File
    filename string
    locked   bool
    mu       sync.Mutex
}

func NewAdvancedFileLock(filename string) (*AdvancedFileLock, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0644)
    if err != nil {
        return nil, err
    }
    
    return &AdvancedFileLock{
        file:     file,
        filename: filename,
        locked:   false,
    }, nil
}

func (afl *AdvancedFileLock) Lock() error {
    afl.mu.Lock()
    defer afl.mu.Unlock()
    
    if afl.locked {
        return fmt.Errorf("already locked")
    }
    
    err := syscall.Flock(int(afl.file.Fd()), syscall.LOCK_EX)
    if err != nil {
        return err
    }
    
    afl.locked = true
    return nil
}

func (afl *AdvancedFileLock) Unlock() error {
    afl.mu.Lock()
    defer afl.mu.Unlock()
    
    if !afl.locked {
        return fmt.Errorf("not locked")
    }
    
    err := syscall.Flock(int(afl.file.Fd()), syscall.LOCK_UN)
    if err != nil {
        return err
    }
    
    afl.locked = false
    return nil
}

func (afl *AdvancedFileLock) IsLocked() bool {
    afl.mu.Lock()
    defer afl.mu.Unlock()
    return afl.locked
}

func (afl *AdvancedFileLock) Close() error {
    if afl.locked {
        afl.Unlock()
    }
    return afl.file.Close()
}

func demonstrateAdvancedFileLocking() {
    fmt.Println("\n=== Advanced File Locking ===")
    
    lockFile := "advanced_lock_test.lock"
    lock, err := NewAdvancedFileLock(lockFile)
    if err != nil {
        fmt.Printf("Create advanced lock error: %v\n", err)
        return
    }
    defer lock.Close()
    defer os.Remove(lockFile)
    
    fmt.Printf("Lock status: %t\n", lock.IsLocked())
    
    // 获取锁
    err = lock.Lock()
    if err != nil {
        fmt.Printf("Lock error: %v\n", err)
        return
    }
    fmt.Printf("Lock acquired, status: %t\n", lock.IsLocked())
    
    // 尝试再次获取锁（应该失败）
    err = lock.Lock()
    if err != nil {
        fmt.Printf("Second lock attempt failed as expected: %v\n", err)
    }
    
    // 释放锁
    err = lock.Unlock()
    if err != nil {
        fmt.Printf("Unlock error: %v\n", err)
        return
    }
    fmt.Printf("Lock released, status: %t\n", lock.IsLocked())
}

// 文件锁在实际应用中的使用
func fileLockInPractice() {
    fmt.Println("\n=== File Lock in Practice ===")
    
    // 日志文件写入示例
    logFile := "application.log"
    
    // 多个goroutine同时写入日志
    var wg sync.WaitGroup
    
    for i := 1; i <= 5; i++ {
        id := i
        wg.Add(1)
        go func() {
            defer wg.Done()
            writeLogEntry(logFile, fmt.Sprintf("Log entry from goroutine %d", id))
        }()
    }
    
    wg.Wait()
    
    // 读取日志文件
    content, err := ioutil.ReadFile(logFile)
    if err != nil {
        fmt.Printf("Read log error: %v\n", err)
        return
    }
    
    fmt.Printf("Log file content:\n%s", string(content))
    
    // 清理
    os.Remove(logFile)
}

// 带锁的日志写入函数
func writeLogEntry(filename, message string) {
    lockFile := filename + ".lock"
    
    lock, err := NewFileLock(lockFile)
    if err != nil {
        fmt.Printf("Create log lock error: %v\n", err)
        return
    }
    defer lock.Close()
    
    // 获取锁
    err = lock.Lock()
    if err != nil {
        fmt.Printf("Log lock error: %v\n", err)
        return
    }
    
    // 追加写入日志
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Printf("Open log file error: %v\n", err)
        return
    }
    defer file.Close()
    
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    logEntry := fmt.Sprintf("[%s] %s\n", timestamp, message)
    
    _, err = file.WriteString(logEntry)
    if err != nil {
        fmt.Printf("Write log error: %v\n", err)
        return
    }
    
    // 模拟处理时间
    time.Sleep(100 * time.Millisecond)
}

// 文件锁性能测试
func fileLockPerformance() {
    fmt.Println("\n=== File Lock Performance ===")
    
    lockFile := "performance_test.lock"
    lock, err := NewFileLock(lockFile)
    if err != nil {
        fmt.Printf("Create performance lock error: %v\n", err)
        return
    }
    defer lock.Close()
    defer os.Remove(lockFile)
    
    // 测试锁获取和释放的性能
    iterations := 1000
    start := time.Now()
    
    for i := 0; i < iterations; i++ {
        err := lock.Lock()
        if err != nil {
            fmt.Printf("Lock error on iteration %d: %v\n", i, err)
            return
        }
        
        // 模拟短时间持有锁
        time.Sleep(10 * time.Microsecond)
        
        err = lock.Unlock()
        if err != nil {
            fmt.Printf("Unlock error on iteration %d: %v\n", i, err)
            return
        }
    }
    
    duration := time.Since(start)
    fmt.Printf("Performed %d lock/unlock operations in %v\n", iterations, duration)
    fmt.Printf("Average time per operation: %v\n", duration/time.Duration(iterations))
    
    // 测试并发性能
    fmt.Println("Testing concurrent performance...")
    start = time.Now()
    
    var wg sync.WaitGroup
    numGoroutines := 10
    opsPerGoroutine := 100
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(goroutineID int) {
            defer wg.Done()
            
            for j := 0; j < opsPerGoroutine; j++ {
                err := lock.Lock()
                if err != nil {
                    fmt.Printf("Goroutine %d lock error: %v\n", goroutineID, err)
                    return
                }
                
                time.Sleep(1 * time.Microsecond)
                
                err = lock.Unlock()
                if err != nil {
                    fmt.Printf("Goroutine %d unlock error: %v\n", goroutineID, err)
                    return
                }
            }
        }(i)
    }
    
    wg.Wait()
    duration = time.Since(start)
    totalOps := numGoroutines * opsPerGoroutine
    fmt.Printf("Performed %d concurrent lock/unlock operations in %v\n", totalOps, duration)
    fmt.Printf("Average time per operation: %v\n", duration/time.Duration(totalOps))
}

func main() {
    demonstrateFileOperations()
    processLargeFile()
    binaryFileOperations()
    fileCopyMove()
    temporaryFiles()
    
    demonstrateDirectoryOperations()
    directoryUtils()
    demonstrateDirectorySize()
    
    demonstrateFileSystemOperations()
    analyzeFileSystem()
    
    demonstrateOSPackage()
    demonstrateProcessManagement()
    demonstrateSystemResources()
    demonstrateCrossPlatform()
    
    demonstrateFilepath()
    demonstratePathTraversal()
    demonstratePathSecurity()
    pathUtilities()
    
    demonstrateFilePermissions()
    demonstrateDirectoryPermissions()
    demonstrateUserGroupPermissions()
    secureFileOperations()
    
    demonstrateFileLocking()
    concurrentFileLocking()
    demonstrateAdvancedFileLocking()
    fileLockInPractice()
    fileLockPerformance()
    
    // 注意：信号处理函数会阻塞程序，所以放在最后
    // demonstrateSignalHandling()
}
```