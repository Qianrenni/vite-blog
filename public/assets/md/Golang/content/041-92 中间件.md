## 9.2 中间件

### 中间件概念

```go
package middleware

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

// 中间件类型定义
type Middleware func(http.HandlerFunc) http.HandlerFunc

// 基础中间件示例
func LoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        // 调用下一个处理器
        next(w, r)
        
        log.Printf("Completed %s %s in %v", r.Method, r.URL.Path, time.Since(start))
    }
}

// 认证中间件
func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 检查认证头
        auth := r.Header.Get("Authorization")
        if auth == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        // 简单的认证检查（实际应用中应该更复杂）
        if auth != "Bearer secret-token" {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // 认证通过，继续处理
        next(w, r)
    }
}

// CORS中间件
func CORSMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        // 处理预检请求
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next(w, r)
    }
}

// 限流中间件
type RateLimiter struct {
    requests map[string][]time.Time
    limit    int
    window   time.Duration
}

func NewRateLimiter(limit int, window time.Duration) *RateLimiter {
    return &RateLimiter{
        requests: make(map[string][]time.Time),
        limit:    limit,
        window:   window,
    }
}

func (rl *RateLimiter) Middleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        clientIP := r.RemoteAddr
        
        now := time.Now()
        requests := rl.requests[clientIP]
        
        // 清理过期的请求记录
        validRequests := make([]time.Time, 0)
        for _, reqTime := range requests {
            if now.Sub(reqTime) < rl.window {
                validRequests = append(validRequests, reqTime)
            }
        }
        
        // 检查是否超过限制
        if len(validRequests) >= rl.limit {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }
        
        // 记录当前请求
        validRequests = append(validRequests, now)
        rl.requests[clientIP] = validRequests
        
        next(w, r)
    }
}

// 压缩中间件
func CompressionMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 检查客户端是否支持压缩
        acceptEncoding := r.Header.Get("Accept-Encoding")
        if acceptEncoding == "" {
            next(w, r)
            return
        }
        
        // 这里简化处理，实际应用中需要更复杂的压缩逻辑
        w.Header().Set("Content-Encoding", "gzip")
        next(w, r)
    }
}

// 错误恢复中间件
func RecoveryMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic recovered: %v", err)
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        
        next(w, r)
    }
}
```

### 自定义中间件

```go
// 高级中间件示例
package middleware

import (
    "context"
    "crypto/subtle"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strings"
    "time"
)

// 请求上下文
type ContextKey string
const UserContextKey ContextKey = "user"

// 用户信息
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
    Role  string `json:"role"`
}

// JWT认证中间件
func JWTAuthMiddleware(secret string) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            authHeader := r.Header.Get("Authorization")
            if authHeader == "" {
                http.Error(w, "Authorization header required", http.StatusUnauthorized)
                return
            }
            
            // 检查Bearer前缀
            if !strings.HasPrefix(authHeader, "Bearer ") {
                http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
                return
            }
            
            token := strings.TrimPrefix(authHeader, "Bearer ")
            
            // 这里应该验证JWT token
            // 简化示例，假设token是有效的
            if token != "valid-jwt-token" {
                http.Error(w, "Invalid token", http.StatusUnauthorized)
                return
            }
            
            // 设置用户信息到上下文
            user := &User{ID: 1, Name: "Test User", Email: "test@example.com", Role: "user"}
            ctx := context.WithValue(r.Context(), UserContextKey, user)
            r = r.WithContext(ctx)
            
            next(w, r)
        }
    }
}

// 角色认证中间件
func RoleAuthMiddleware(allowedRoles ...string) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            user, ok := r.Context().Value(UserContextKey).(*User)
            if !ok {
                http.Error(w, "User not authenticated", http.StatusUnauthorized)
                return
            }
            
            allowed := false
            for _, role := range allowedRoles {
                if user.Role == role {
                    allowed = true
                    break
                }
            }
            
            if !allowed {
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
            }
            
            next(w, r)
        }
    }
}

// 请求ID中间件
func RequestIDMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        requestID := generateRequestID()
        
        // 设置响应头
        w.Header().Set("X-Request-ID", requestID)
        
        // 设置到上下文
        ctx := context.WithValue(r.Context(), "request_id", requestID)
        r = r.WithContext(ctx)
        
        next(w, r)
    }
}

func generateRequestID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

// 请求日志中间件
type LoggingResponseWriter struct {
    http.ResponseWriter
    statusCode int
    size       int
}

func (lrw *LoggingResponseWriter) WriteHeader(code int) {
    lrw.statusCode = code
    lrw.ResponseWriter.WriteHeader(code)
}

func (lrw *LoggingResponseWriter) Write(b []byte) (int, error) {
    size, err := lrw.ResponseWriter.Write(b)
    lrw.size += size
    return size, err
}

func DetailedLoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 包装ResponseWriter以捕获状态码和响应大小
        lrw := &LoggingResponseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // 记录请求信息
        log.Printf("Request: %s %s from %s", r.Method, r.URL.Path, r.RemoteAddr)
        
        next(lrw, r)
        
        // 记录响应信息
        duration := time.Since(start)
        log.Printf("Response: %d %s (%d bytes) in %v", 
            lrw.statusCode, http.StatusText(lrw.statusCode), lrw.size, duration)
    }
}

// 基本身份验证中间件
func BasicAuthMiddleware(username, password string) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            user, pass, ok := r.BasicAuth()
            if !ok {
                w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            
            // 使用constant time comparison防止时序攻击
            if subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 ||
               subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {
                w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            
            next(w, r)
        }
    }
}

// API密钥认证中间件
func APIKeyAuthMiddleware(apiKeys map[string]string) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            apiKey := r.Header.Get("X-API-Key")
            if apiKey == "" {
                http.Error(w, "API key required", http.StatusUnauthorized)
                return
            }
            
            clientName, exists := apiKeys[apiKey]
            if !exists {
                http.Error(w, "Invalid API key", http.StatusUnauthorized)
                return
            }
            
            // 设置客户端信息到上下文
            ctx := context.WithValue(r.Context(), "client_name", clientName)
            r = r.WithContext(ctx)
            
            next(w, r)
        }
    }
}

// 请求大小限制中间件
func MaxSizeMiddleware(maxSize int64) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // 限制请求体大小
            r.Body = http.MaxBytesReader(w, r.Body, maxSize)
            
            next(w, r)
        }
    }
}
```

### 常用中间件（日志、认证、限流等）

```go
// 完整的中间件集合
package middleware

import (
    "golang.org/x/time/rate"
    "sync"
    "time"
)

// 令牌桶限流器
type TokenBucketLimiter struct {
    visitors map[string]*Visitor
    mutex    sync.Mutex
    r        rate.Limit // 每秒生成的令牌数
    b        int        // 桶的容量
}

type Visitor struct {
    limiter  *rate.Limiter
    lastSeen time.Time
}

func NewTokenBucketLimiter(r rate.Limit, b int) *TokenBucketLimiter {
    return &TokenBucketLimiter{
        visitors: make(map[string]*Visitor),
        r:        r,
        b:        b,
    }
}

func (t *TokenBucketLimiter) Middleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        t.mutex.Lock()
        defer t.mutex.Unlock()
        
        // 清理过期的访问者
        now := time.Now()
        for ip, visitor := range t.visitors {
            if now.Sub(visitor.lastSeen) > 3*time.Minute {
                delete(t.visitors, ip)
            }
        }
        
        // 获取客户端IP
        ip := r.RemoteAddr
        
        // 获取或创建访问者
        visitor, exists := t.visitors[ip]
        if !exists {
            limiter := rate.NewLimiter(t.r, t.b)
            t.visitors[ip] = &Visitor{limiter, now}
            visitor = &Visitor{limiter, now}
        } else {
            visitor.lastSeen = now
        }
        
        // 尝试获取令牌
        if !visitor.limiter.Allow() {
            http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
            return
        }
        
        next(w, r)
    }
}

// 缓存中间件
type CacheMiddleware struct {
    cache    map[string]*CacheItem
    mutex    sync.RWMutex
    duration time.Duration
}

type CacheItem struct {
    data      []byte
    timestamp time.Time
    headers   map[string]string
}

func NewCacheMiddleware(duration time.Duration) *CacheMiddleware {
    return &CacheMiddleware{
        cache:    make(map[string]*CacheItem),
        duration: duration,
    }
}

func (c *CacheMiddleware) Middleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 只缓存GET请求
        if r.Method != http.MethodGet {
            next(w, r)
            return
        }
        
        key := r.URL.String()
        
        // 尝试从缓存获取
        c.mutex.RLock()
        item, exists := c.cache[key]
        c.mutex.RUnlock()
        
        if exists && time.Since(item.timestamp) < c.duration {
            // 从缓存返回
            for k, v := range item.headers {
                w.Header().Set(k, v)
            }
            w.Header().Set("X-Cache", "HIT")
            w.Write(item.data)
            return
        }
        
        // 包装ResponseWriter以捕获响应
        crw := &CacheResponseWriter{ResponseWriter: w, headers: make(map[string]string)}
        
        next(crw, r)
        
        // 缓存响应
        if crw.statusCode == http.StatusOK {
            c.mutex.Lock()
            c.cache[key] = &CacheItem{
                data:      crw.body.Bytes(),
                timestamp: time.Now(),
                headers:   crw.headers,
            }
            c.mutex.Unlock()
        }
    }
}

// 缓存响应写入器
type CacheResponseWriter struct {
    http.ResponseWriter
    statusCode int
    body       bytes.Buffer
    headers    map[string]string
}

func (crw *CacheResponseWriter) WriteHeader(code int) {
    crw.statusCode = code
    crw.ResponseWriter.WriteHeader(code)
}

func (crw *CacheResponseWriter) Write(b []byte) (int, error) {
    // 捕获响应体
    crw.body.Write(b)
    // 写入原始响应
    return crw.ResponseWriter.Write(b)
}

func (crw *CacheResponseWriter) Header() http.Header {
    return crw.ResponseWriter.Header()
}

// 安全中间件
func SecurityMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 设置安全头
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.Header().Set("X-Frame-Options", "DENY")
        w.Header().Set("X-XSS-Protection", "1; mode=block")
        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
        w.Header().Set("Content-Security-Policy", "default-src 'self'")
        
        next(w, r)
    }
}

// 请求超时中间件
func TimeoutMiddleware(timeout time.Duration) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            ctx, cancel := context.WithTimeout(r.Context(), timeout)
            defer cancel()
            
            // 创建带超时的请求
            r = r.WithContext(ctx)
            
            done := make(chan bool)
            go func() {
                next(w, r)
                done <- true
            }()
            
            select {
            case <-done:
                // 正常完成
            case <-ctx.Done():
                // 超时
                http.Error(w, "Request timeout", http.StatusGatewayTimeout)
            }
        }
    }
}
```

### 中间件链

```go
// 中间件链管理
package middleware

import (
    "net/http"
)

// 中间件链
type MiddlewareChain struct {
    middlewares []Middleware
}

func NewMiddlewareChain(middlewares ...Middleware) *MiddlewareChain {
    return &MiddlewareChain{
        middlewares: middlewares,
    }
}

// 添加中间件
func (mc *MiddlewareChain) Use(middleware Middleware) *MiddlewareChain {
    mc.middlewares = append(mc.middlewares, middleware)
    return mc
}

// 应用中间件链到处理器
func (mc *MiddlewareChain) Apply(handler http.HandlerFunc) http.HandlerFunc {
    // 从右到左应用中间件（最右边的最先执行）
    for i := len(mc.middlewares) - 1; i >= 0; i-- {
        handler = mc.middlewares[i](handler)
    }
    return handler
}

// 条件中间件
func ConditionalMiddleware(condition func(*http.Request) bool, middleware Middleware) Middleware {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            if condition(r) {
                middleware(next)(w, r)
            } else {
                next(w, r)
            }
        }
    }
}

// 路由特定中间件
func RouteSpecificMiddleware(routes map[string]Middleware, defaultMiddleware Middleware) Middleware {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            if middleware, exists := routes[r.URL.Path]; exists {
                middleware(next)(w, r)
            } else if defaultMiddleware != nil {
                defaultMiddleware(next)(w, r)
            } else {
                next(w, r)
            }
        }
    }
}

// 中间件组合示例
func ExampleMiddlewareChain() {
    // 创建中间件链
    chain := NewMiddlewareChain(
        RecoveryMiddleware,
        LoggingMiddleware,
        CORSMiddleware,
    )
    
    // 添加更多中间件
    chain.Use(SecurityMiddleware)
    
    // 条件中间件
    authMiddleware := ConditionalMiddleware(
        func(r *http.Request) bool {
            return strings.HasPrefix(r.URL.Path, "/api/")
        },
        AuthMiddleware,
    )
    chain.Use(authMiddleware)
    
    // 应用到处理器
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello World"))
    }
    
    finalHandler := chain.Apply(handler)
    
    // 使用最终处理器
    http.HandleFunc("/", finalHandler)
    http.ListenAndServe(":8080", nil)
}
```

### 中间件性能优化

```go
// 高性能中间件实现
package middleware

import (
    "sync"
    "time"
)

// 对象池优化中间件
type PooledMiddleware struct {
    pool sync.Pool
}

func NewPooledMiddleware() *PooledMiddleware {
    return &PooledMiddleware{
        pool: sync.Pool{
            New: func() interface{} {
                return &LoggingData{}
            },
        },
    }
}

type LoggingData struct {
    start time.Time
    path  string
    ip    string
}

func (pm *PooledMiddleware) LoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 从池中获取对象
        data := pm.pool.Get().(*LoggingData)
        defer pm.pool.Put(data) // 使用后放回池中
        
        data.start = time.Now()
        data.path = r.URL.Path
        data.ip = r.RemoteAddr
        
        next(w, r)
        
        // 异步记录日志
        go func(d *LoggingData) {
            log.Printf("Request: %s %s from %s took %v", 
                r.Method, d.path, d.ip, time.Since(d.start))
        }(data)
    }
}

// 预编译正则表达式优化
import (
    "regexp"
    "sync"
)

var (
    userAgentRegex *regexp.Regexp
    regexOnce      sync.Once
)

func init() {
    regexOnce.Do(func() {
        userAgentRegex = regexp.MustCompile(`(?i)(bot|crawler|spider|scraper)`)
    })
}

// 爬虫检测中间件
func BotDetectionMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        userAgent := r.Header.Get("User-Agent")
        if userAgentRegex.MatchString(userAgent) {
            // 可以对爬虫应用不同的中间件或限制
            log.Printf("Bot detected: %s", userAgent)
        }
        
        next(w, r)
    }
}

// 零分配中间件
func ZeroAllocationMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 避免字符串拼接和分配
        start := time.Now()
        
        next(w, r)
        
        // 使用预分配的缓冲区记录日志
        logBuf := make([]byte, 0, 256)
        logBuf = append(logBuf, "Request completed in "...)
        logBuf = append(logBuf, time.Since(start).String()...)
        log.Println(string(logBuf))
    }
}
```

### 中间件测试

```go
// 中间件测试
package middleware

import (
    "net/http"
    "net/http/httptest"
    "testing"
)

// 测试基础中间件
func TestLoggingMiddleware(t *testing.T) {
    // 创建测试处理器
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("Hello World"))
    }
    
    // 应用中间件
    wrappedHandler := LoggingMiddleware(handler)
    
    // 创建测试请求和响应记录器
    req := httptest.NewRequest("GET", "/test", nil)
    w := httptest.NewRecorder()
    
    // 执行处理器
    wrappedHandler(w, req)
    
    // 验证结果
    if w.Code != http.StatusOK {
        t.Errorf("Expected status code %d, got %d", http.StatusOK, w.Code)
    }
    
    if w.Body.String() != "Hello World" {
        t.Errorf("Expected body 'Hello World', got '%s'", w.Body.String())
    }
}

// 测试认证中间件
func TestAuthMiddleware(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }
    
    wrappedHandler := AuthMiddleware(handler)
    
    // 测试无认证头的情况
    req := httptest.NewRequest("GET", "/test", nil)
    w := httptest.NewRecorder()
    wrappedHandler(w, req)
    
    if w.Code != http.StatusUnauthorized {
        t.Errorf("Expected status code %d, got %d", http.StatusUnauthorized, w.Code)
    }
    
    // 测试有效认证头的情况
    req = httptest.NewRequest("GET", "/test", nil)
    req.Header.Set("Authorization", "Bearer secret-token")
    w = httptest.NewRecorder()
    wrappedHandler(w, req)
    
    if w.Code != http.StatusOK {
        t.Errorf("Expected status code %d, got %d", http.StatusOK, w.Code)
    }
}

// 测试CORS中间件
func TestCORSMiddleware(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }
    
    wrappedHandler := CORSMiddleware(handler)
    
    // 测试OPTIONS请求
    req := httptest.NewRequest("OPTIONS", "/test", nil)
    w := httptest.NewRecorder()
    wrappedHandler(w, req)
    
    if w.Code != http.StatusOK {
        t.Errorf("Expected status code %d, got %d", http.StatusOK, w.Code)
    }
    
    // 验证CORS头
    if w.Header().Get("Access-Control-Allow-Origin") != "*" {
        t.Errorf("Expected CORS header, got %s", w.Header().Get("Access-Control-Allow-Origin"))
    }
}

// 测试限流中间件
func TestRateLimiter(t *testing.T) {
    limiter := NewRateLimiter(2, time.Minute) // 每分钟最多2个请求
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }
    
    wrappedHandler := limiter.Middleware(handler)
    
    // 创建测试请求
    req := httptest.NewRequest("GET", "/test", nil)
    req.RemoteAddr = "127.0.0.1:12345"
    
    // 测试前两个请求应该成功
    for i := 0; i < 2; i++ {
        w := httptest.NewRecorder()
        wrappedHandler(w, req)
        if w.Code != http.StatusOK {
            t.Errorf("Request %d should succeed, got status %d", i+1, w.Code)
        }
    }
    
    // 第三个请求应该被限流
    w := httptest.NewRecorder()
    wrappedHandler(w, req)
    if w.Code != http.StatusTooManyRequests {
        t.Errorf("Third request should be rate limited, got status %d", w.Code)
    }
}

// 基准测试中间件性能
func BenchmarkLoggingMiddleware(b *testing.B) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }
    
    wrappedHandler := LoggingMiddleware(handler)
    req := httptest.NewRequest("GET", "/test", nil)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        w := httptest.NewRecorder()
        wrappedHandler(w, req)
    }
}

func BenchmarkNoMiddleware(b *testing.B) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }
    
    req := httptest.NewRequest("GET", "/test", nil)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        w := httptest.NewRecorder()
        handler(w, req)
    }
}

// 并发测试
func TestMiddlewareConcurrency(t *testing.T) {
    handler := func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(10 * time.Millisecond) // 模拟处理时间
        w.WriteHeader(http.StatusOK)
    }
    
    wrappedHandler := LoggingMiddleware(handler)
    
    // 并发测试
    const numGoroutines = 100
    done := make(chan bool, numGoroutines)
    
    for i := 0; i < numGoroutines; i++ {
        go func() {
            req := httptest.NewRequest("GET", "/test", nil)
            w := httptest.NewRecorder()
            wrappedHandler(w, req)
            done <- true
        }()
    }
    
    // 等待所有goroutine完成
    for i := 0; i < numGoroutines; i++ {
        <-done
    }
}
```