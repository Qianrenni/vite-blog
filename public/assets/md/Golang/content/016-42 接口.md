## 4.2 接口

### 接口定义和实现

```go
// 定义接口
type Shape interface {
    Area() float64
    Perimeter() float64
}

// 实现接口的结构体
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * 3.14159 * c.Radius
}

func main() {
    var s Shape
    
    s = Rectangle{Width: 10, Height: 5}
    fmt.Printf("Rectangle Area: %.2f\n", s.Area())
    fmt.Printf("Rectangle Perimeter: %.2f\n", s.Perimeter())
    
    s = Circle{Radius: 3}
    fmt.Printf("Circle Area: %.2f\n", s.Area())
    fmt.Printf("Circle Perimeter: %.2f\n", s.Perimeter())
}
```

### 接口的隐式实现

```go
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}

type ReadWriter interface {
    Reader
    Writer
}

// 文件类型隐式实现Reader和Writer接口
type File struct {
    name string
}

func (f *File) Read(data []byte) (int, error) {
    // 实现读取逻辑
    copy(data, []byte("Hello, World!"))
    return len("Hello, World!"), nil
}

func (f *File) Write(data []byte) (int, error) {
    // 实现写入逻辑
    fmt.Printf("Writing to file %s: %s\n", f.name, string(data))
    return len(data), nil
}

func main() {
    file := &File{name: "test.txt"}
    
    // 隐式实现，无需显式声明
    var reader Reader = file
    var writer Writer = file
    var readWriter ReadWriter = file
    
    data := make([]byte, 13)
    reader.Read(data)
    fmt.Println(string(data))
    
    writer.Write([]byte("Hello, Go!"))
    
    readWriter.Write([]byte("Combined interface"))
}
```

### 空接口interface{}

```go
func main() {
    // 空接口可以存储任何类型的值
    var i interface{}
    
    i = 42
    fmt.Println(i)  // 42
    
    i = "Hello"
    fmt.Println(i)  // Hello
    
    i = []int{1, 2, 3}
    fmt.Println(i)  // [1 2 3]
    
    // 类型断言
    if str, ok := i.(string); ok {
        fmt.Printf("String value: %s\n", str)
    }
    
    // 使用空接口的函数
    printAny(42)
    printAny("Hello")
    printAny([]int{1, 2, 3})
}

func printAny(value interface{}) {
    fmt.Printf("Value: %v, Type: %T\n", value, value)
}
```

### 类型断言

```go
func processValue(v interface{}) {
    switch value := v.(type) {
    case int:
        fmt.Printf("Integer: %d\n", value)
    case string:
        fmt.Printf("String: %s\n", value)
    case bool:
        fmt.Printf("Boolean: %t\n", value)
    case []int:
        fmt.Printf("Slice of integers: %v\n", value)
    default:
        fmt.Printf("Unknown type: %T\n", value)
    }
}

func main() {
    values := []interface{}{42, "Hello", true, []int{1, 2, 3}, 3.14}
    
    for _, v := range values {
        processValue(v)
        
        // 安全的类型断言
        if str, ok := v.(string); ok {
            fmt.Printf("Length of string: %d\n", len(str))
        }
        
        // 不安全的类型断言（如果类型不匹配会panic）
        // str := v.(string)  // 如果v不是string类型会panic
    }
}
```

### 接口组合

```go
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// 实现组合接口
type File struct {
    name string
}

func (f *File) Read(data []byte) (int, error) {
    copy(data, []byte("Hello, World!"))
    return len("Hello, World!"), nil
}

func (f *File) Write(data []byte) (int, error) {
    fmt.Printf("Writing to %s: %s\n", f.name, string(data))
    return len(data), nil
}

func (f *File) Close() error {
    fmt.Printf("Closing file %s\n", f.name)
    return nil
}

func main() {
    file := &File{name: "test.txt"}
    
    var rwc ReadWriteCloser = file
    rwc.Read(make([]byte, 13))
    rwc.Write([]byte("Hello"))
    rwc.Close()
}
```

### 接口内嵌

```go
type Stringer interface {
    String() string
}

type Error interface {
    Error() string
}

type StringError interface {
    Stringer
    Error
}

type MyError struct {
    message string
}

func (e MyError) String() string {
    return fmt.Sprintf("Error: %s", e.message)
}

func (e MyError) Error() string {
    return e.message
}

func main() {
    err := MyError{message: "Something went wrong"}
    
    var se StringError = err
    fmt.Println(se.String())  // Error: Something went wrong
    fmt.Println(se.Error())   // Something went wrong
}
```

### 接口值和nil

```go
type Speaker interface {
    Speak() string
}

type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}

func main() {
    // nil接口值
    var s Speaker
    fmt.Println(s == nil)  // true
    
    // 接口值包含nil指针
    var dogPtr *Dog
    s = dogPtr
    fmt.Println(s == nil)  // false!
    fmt.Println(dogPtr == nil)  // true
    
    // 这会panic，因为接口值不为nil，但底层值为nil
    // fmt.Println(s.Speak())  // panic: runtime error
    
    // 正确的实现
    var dog *Dog
    if dog != nil {
        s = dog
        fmt.Println(s.Speak())
    } else {
        fmt.Println("Dog is nil")
    }
}
```

### 接口性能考虑

```go
import (
    "testing"
)

type Interface interface {
    Method()
}

type Concrete struct {
    value int
}

func (c Concrete) Method() {}

// 直接调用
func directCall(c Concrete) {
    c.Method()
}

// 接口调用
func interfaceCall(i Interface) {
    i.Method()
}

// 性能测试示例
func BenchmarkDirectCall(b *testing.B) {
    c := Concrete{value: 42}
    for i := 0; i < b.N; i++ {
        directCall(c)
    }
}

func BenchmarkInterfaceCall(b *testing.B) {
    c := Concrete{value: 42}
    var i Interface = c
    for i := 0; i < b.N; i++ {
        interfaceCall(i)
    }
}
```