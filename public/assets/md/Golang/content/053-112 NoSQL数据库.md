## 11.2 NoSQL数据库

### Redis客户端使用

#### 基本操作
```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
)

var ctx = context.Background()
var rdb *redis.Client

func initRedis() {
    rdb = redis.NewClient(&redis.Options{
        Addr:     "localhost:6379",
        Password: "", // no password set
        DB:       0,  // use default DB
    })
    
    // 测试连接
    pong, err := rdb.Ping(ctx).Result()
    if err != nil {
        panic(err)
    }
    fmt.Println("Redis连接成功:", pong)
}

// 字符串操作
func stringOperations() {
    // 设置键值
    err := rdb.Set(ctx, "name", "张三", 0).Err()
    if err != nil {
        panic(err)
    }
    
    // 获取值
    val, err := rdb.Get(ctx, "name").Result()
    if err != nil {
        panic(err)
    }
    fmt.Println("name:", val)
    
    // 设置过期时间
    rdb.Set(ctx, "temp", "临时数据", time.Hour)
    
    // 自增
    rdb.Incr(ctx, "counter")
    rdb.IncrBy(ctx, "counter", 10)
    
    // 批量操作
    rdb.MSet(ctx, "key1", "value1", "key2", "value2")
    vals, _ := rdb.MGet(ctx, "key1", "key2").Result()
    fmt.Println("批量获取:", vals)
}

// 哈希操作
func hashOperations() {
    // 设置哈希字段
    rdb.HSet(ctx, "user:1", "name", "张三")
    rdb.HSet(ctx, "user:1", "email", "zhangsan@example.com")
    rdb.HSet(ctx, "user:1", "age", 25)
    
    // 获取哈希字段
    name, _ := rdb.HGet(ctx, "user:1", "name").Result()
    fmt.Println("用户名:", name)
    
    // 获取所有字段
    userMap, _ := rdb.HGetAll(ctx, "user:1").Result()
    fmt.Println("用户信息:", userMap)
    
    // 批量设置
    rdb.HMSet(ctx, "user:2", map[string]interface{}{
        "name":  "李四",
        "email": "lisi@example.com",
        "age":   30,
    })
}

// 列表操作
func listOperations() {
    // 从左侧推入
    rdb.LPush(ctx, "tasks", "task1", "task2", "task3")
    
    // 从右侧推入
    rdb.RPush(ctx, "tasks", "task4")
    
    // 弹出元素
    task, _ := rdb.LPop(ctx, "tasks").Result()
    fmt.Println("弹出任务:", task)
    
    // 获取列表长度
    length, _ := rdb.LLen(ctx, "tasks").Result()
    fmt.Println("任务数量:", length)
    
    // 获取范围
    tasks, _ := rdb.LRange(ctx, "tasks", 0, -1).Result()
    fmt.Println("所有任务:", tasks)
}

// 集合操作
func setOperations() {
    // 添加元素
    rdb.SAdd(ctx, "tags", "go", "redis", "database", "nosql")
    
    // 检查元素是否存在
    exists, _ := rdb.SIsMember(ctx, "tags", "go").Result()
    fmt.Println("go标签存在:", exists)
    
    // 获取所有元素
    tags, _ := rdb.SMembers(ctx, "tags").Result()
    fmt.Println("所有标签:", tags)
    
    // 交集、并集、差集
    rdb.SAdd(ctx, "backend", "go", "java", "python")
    rdb.SAdd(ctx, "frontend", "javascript", "go", "typescript")
    
    // 交集
    intersection, _ := rdb.SInter(ctx, "backend", "frontend").Result()
    fmt.Println("交集:", intersection)
    
    // 并集
    union, _ := rdb.SUnion(ctx, "backend", "frontend").Result()
    fmt.Println("并集:", union)
}

// 有序集合操作
func zsetOperations() {
    // 添加元素
    rdb.ZAdd(ctx, "scores", &redis.Z{Score: 90, Member: "张三"})
    rdb.ZAdd(ctx, "scores", &redis.Z{Score: 85, Member: "李四"})
    rdb.ZAdd(ctx, "scores", &redis.Z{Score: 95, Member: "王五"})
    
    // 获取排名
    rank, _ := rdb.ZRank(ctx, "scores", "张三").Result()
    fmt.Println("张三排名:", rank)
    
    // 获取分数
    score, _ := rdb.ZScore(ctx, "scores", "张三").Result()
    fmt.Println("张三分数:", score)
    
    // 获取范围
    members, _ := rdb.ZRangeWithScores(ctx, "scores", 0, -1).Result()
    fmt.Println("所有成员:", members)
    
    // 获取分数范围内的成员
    rangeMembers, _ := rdb.ZRangeByScoreWithScores(ctx, "scores", 
        &redis.ZRangeBy{Min: "80", Max: "100"}).Result()
    fmt.Println("高分成员:", rangeMembers)
}
```

#### Redis在业务中的应用
```go
// 缓存实现
type CacheService struct {
    client *redis.Client
}

func NewCacheService(client *redis.Client) *CacheService {
    return &CacheService{client: client}
}

// 获取缓存
func (c *CacheService) Get(key string) (string, error) {
    return c.client.Get(ctx, key).Result()
}

// 设置缓存
func (c *CacheService) Set(key, value string, expiration time.Duration) error {
    return c.client.Set(ctx, key, value, expiration).Err()
}

// 删除缓存
func (c *CacheService) Delete(key string) error {
    return c.client.Del(ctx, key).Err()
}

// 分布式锁
func (c *CacheService) AcquireLock(key string, expiration time.Duration) (string, error) {
    lockKey := "lock:" + key
    lockValue := fmt.Sprintf("%d", time.Now().UnixNano())
    
    ok, err := c.client.SetNX(ctx, lockKey, lockValue, expiration).Result()
    if err != nil {
        return "", err
    }
    
    if !ok {
        return "", fmt.Errorf("获取锁失败")
    }
    
    return lockValue, nil
}

func (c *CacheService) ReleaseLock(key, value string) error {
    lockKey := "lock:" + key
    
    // 使用Lua脚本确保原子性
    script := redis.NewScript(`
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
    `)
    
    result, err := script.Run(ctx, c.client, []string{lockKey}, value).Result()
    if err != nil {
        return err
    }
    
    if result.(int64) == 0 {
        return fmt.Errorf("释放锁失败")
    }
    
    return nil
}

// 计数器
func (c *CacheService) IncrementCounter(key string) (int64, error) {
    return c.client.Incr(ctx, key).Result()
}

func (c *CacheService) GetCounter(key string) (int64, error) {
    return c.client.Get(ctx, key).Int64()
}

// 限流器
func (c *CacheService) AllowRequest(key string, limit int64, window time.Duration) bool {
    now := time.Now().Unix()
    windowStart := now - int64(window.Seconds())
    
    pipe := c.client.TxPipeline()
    pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart))
    pipe.ZCard(ctx, key)
    pipe.ZAdd(ctx, key, &redis.Z{Score: float64(now), Member: fmt.Sprintf("%d", now)})
    pipe.Expire(ctx, key, window)
    
    results, err := pipe.Exec(ctx)
    if err != nil {
        return false
    }
    
    count, _ := results[1].(*redis.IntCmd).Result()
    return count < limit
}
```

### MongoDB驱动使用

#### 基本操作
```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"
    
    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/bson/primitive"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

var mongoClient *mongo.Client
var userCollection *mongo.Collection

type User struct {
    ID        primitive.ObjectID `bson:"_id,omitempty" json:"id"`
    Name      string             `bson:"name" json:"name"`
    Email     string             `bson:"email" json:"email"`
    Age       int                `bson:"age" json:"age"`
    CreatedAt time.Time          `bson:"created_at" json:"created_at"`
    Tags      []string           `bson:"tags,omitempty" json:"tags,omitempty"`
    Address   Address            `bson:"address,omitempty" json:"address,omitempty"`
}

type Address struct {
    City  string `bson:"city" json:"city"`
    State string `bson:"state" json:"state"`
}

func initMongoDB() {
    // 连接MongoDB
    client, err := mongo.NewClient(options.Client().ApplyURI("mongodb://localhost:27017"))
    if err != nil {
        log.Fatal(err)
    }
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    
    mongoClient = client
    userCollection = client.Database("testdb").Collection("users")
    
    fmt.Println("MongoDB连接成功")
}

// 插入文档
func insertDocuments() {
    // 插入单个文档
    user := User{
        Name:      "张三",
        Email:     "zhangsan@example.com",
        Age:       25,
        CreatedAt: time.Now(),
        Tags:      []string{"go", "developer"},
        Address:   Address{City: "北京", State: "北京市"},
    }
    
    result, err := userCollection.InsertOne(context.TODO(), user)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("插入文档ID: %v\n", result.InsertedID)
    
    // 批量插入
    users := []interface{}{
        User{Name: "李四", Email: "lisi@example.com", Age: 30, CreatedAt: time.Now()},
        User{Name: "王五", Email: "wangwu@example.com", Age: 28, CreatedAt: time.Now()},
    }
    
    insertManyResult, err := userCollection.InsertMany(context.TODO(), users)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("批量插入文档数: %d\n", len(insertManyResult.InsertedIDs))
}

// 查询文档
func queryDocuments() {
    // 查询单个文档
    var user User
    err := userCollection.FindOne(context.TODO(), bson.M{"name": "张三"}).Decode(&user)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("找到用户: %+v\n", user)
    
    // 查询多个文档
    cursor, err := userCollection.Find(context.TODO(), bson.M{"age": bson.M{"$gte": 25}})
    if err != nil {
        log.Fatal(err)
    }
    defer cursor.Close(context.TODO())
    
    var users []User
    if err = cursor.All(context.TODO(), &users); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("找到用户数: %d\n", len(users))
    
    // 条件查询
    filter := bson.M{
        "age": bson.M{"$gte": 18, "$lte": 65},
        "tags": bson.M{"$in": []string{"go", "python"}},
    }
    
    cursor, err = userCollection.Find(context.TODO(), filter)
    if err != nil {
        log.Fatal(err)
    }
    defer cursor.Close(context.TODO())
    
    // 排序和限制
    findOptions := options.Find()
    findOptions.SetSort(bson.D{{"created_at", -1}}) // 按创建时间降序
    findOptions.SetLimit(10)
    
    cursor, err = userCollection.Find(context.TODO(), bson.M{}, findOptions)
    if err != nil {
        log.Fatal(err)
    }
    defer cursor.Close(context.TODO())
}

// 更新文档
func updateDocuments() {
    // 更新单个文档
    filter := bson.M{"name": "张三"}
    update := bson.M{"$set": bson.M{"age": 26}}
    
    result, err := userCollection.UpdateOne(context.TODO(), filter, update)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("匹配文档数: %d, 修改文档数: %d\n", result.MatchedCount, result.ModifiedCount)
    
    // 批量更新
    filter = bson.M{"age": bson.M{"$lt": 30}}
    update = bson.M{"$set": bson.M{"tags": []string{"young"}}}
    
    updateResult, err := userCollection.UpdateMany(context.TODO(), filter, update)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("批量更新匹配数: %d, 修改数: %d\n", updateResult.MatchedCount, updateResult.ModifiedCount)
    
    // 数组操作
    arrayFilter := bson.M{"name": "张三"}
    arrayUpdate := bson.M{"$push": bson.M{"tags": "mongodb"}}
    
    userCollection.UpdateOne(context.TODO(), arrayFilter, arrayUpdate)
}

// 删除文档
func deleteDocuments() {
    // 删除单个文档
    filter := bson.M{"name": "张三"}
    deleteResult, err := userCollection.DeleteOne(context.TODO(), filter)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("删除文档数: %d\n", deleteResult.DeletedCount)
    
    // 批量删除
    filter = bson.M{"age": bson.M{"$lt": 18}}
    deleteResult, err = userCollection.DeleteMany(context.TODO(), filter)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("批量删除文档数: %d\n", deleteResult.DeletedCount)
}

// 聚合操作
func aggregationOperations() {
    // 聚合管道
    pipeline := []bson.M{
        // 匹配条件
        {"$match": bson.M{"age": bson.M{"$gte": 18}}},
        
        // 分组统计
        {"$group": bson.M{
            "_id":   "$tags",
            "count": bson.M{"$sum": 1},
            "avgAge": bson.M{"$avg": "$age"},
        }},
        
        // 排序
        {"$sort": bson.M{"count": -1}},
        
        // 限制结果
        {"$limit": 10},
    }
    
    cursor, err := userCollection.Aggregate(context.TODO(), pipeline)
    if err != nil {
        log.Fatal(err)
    }
    defer cursor.Close(context.TODO())
    
    var results []bson.M
    if err = cursor.All(context.TODO(), &results); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("聚合结果: %+v\n", results)
}
```

### 数据库选型指南

#### 选型考虑因素
```go
// 数据库选型评估框架
type DatabaseEvaluation struct {
    Type           string // SQL, NoSQL
    UseCase        string // OLTP, OLAP, Cache, etc.
    DataModel      string // Relational, Document, Key-Value, etc.
    Consistency    string // Strong, Eventual, etc.
    Scalability    string // Vertical, Horizontal
    Performance    string // Latency, Throughput
    Complexity     string // Simple, Complex
    Cost           string // OpenSource, Commercial
}

// 不同场景的数据库选择
func databaseSelectionGuide() {
    scenarios := map[string]DatabaseEvaluation{
        "用户信息管理": {
            Type:        "SQL",
            UseCase:     "OLTP",
            DataModel:   "Relational",
            Consistency: "Strong",
            Scalability: "Vertical",
            Performance: "LowLatency",
            Complexity:  "Moderate",
            Cost:        "OpenSource",
        },
        "实时推荐系统": {
            Type:        "NoSQL",
            UseCase:     "Analytics",
            DataModel:   "Document",
            Consistency: "Eventual",
            Scalability: "Horizontal",
            Performance: "HighThroughput",
            Complexity:  "High",
            Cost:        "Commercial",
        },
        "会话缓存": {
            Type:        "NoSQL",
            UseCase:     "Cache",
            DataModel:   "Key-Value",
            Consistency: "Eventual",
            Scalability: "Horizontal",
            Performance: "LowLatency",
            Complexity:  "Simple",
            Cost:        "OpenSource",
        },
    }
    
    fmt.Printf("数据库选型指南: %+v\n", scenarios)
}
```

### 缓存策略

#### 缓存模式实现
```go
// 缓存服务接口
type CacheStrategy interface {
    Get(key string) (interface{}, error)
    Set(key string, value interface{}, expiration time.Duration) error
    Delete(key string) error
}

// LRU缓存实现
type LRUCache struct {
    cache *lru.Cache
    mutex sync.RWMutex
}

func NewLRUCache(maxEntries int) *LRUCache {
    cache, _ := lru.New(maxEntries)
    return &LRUCache{cache: cache}
}

func (c *LRUCache) Get(key string) (interface{}, error) {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    
    if value, ok := c.cache.Get(key); ok {
        return value, nil
    }
    return nil, fmt.Errorf("key not found")
}

func (c *LRUCache) Set(key string, value interface{}, expiration time.Duration) error {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    c.cache.Add(key, value)
    return nil
}

func (c *LRUCache) Delete(key string) error {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    c.cache.Remove(key)
    return nil
}

// 多级缓存
type MultiLevelCache struct {
    l1Cache CacheStrategy // 本地缓存
    l2Cache CacheStrategy // Redis缓存
    db      *gorm.DB      // 数据库
}

func NewMultiLevelCache(l1, l2 CacheStrategy, db *gorm.DB) *MultiLevelCache {
    return &MultiLevelCache{
        l1Cache: l1,
        l2Cache: l2,
        db:      db,
    }
}

func (c *MultiLevelCache) GetUser(id uint) (*User, error) {
    // 1. 查找L1缓存
    if user, err := c.l1Cache.Get(fmt.Sprintf("user:%d", id)); err == nil {
        return user.(*User), nil
    }
    
    // 2. 查找L2缓存
    if user, err := c.l2Cache.Get(fmt.Sprintf("user:%d", id)); err == nil {
        // 写入L1缓存
        c.l1Cache.Set(fmt.Sprintf("user:%d", id), user, time.Minute*5)
        return user.(*User), nil
    }
    
    // 3. 查询数据库
    var user User
    if err := c.db.First(&user, id).Error; err != nil {
        return nil, err
    }
    
    // 写入缓存
    c.l2Cache.Set(fmt.Sprintf("user:%d", id), &user, time.Hour)
    c.l1Cache.Set(fmt.Sprintf("user:%d", id), &user, time.Minute*5)
    
    return &user, nil
}

// 缓存失效策略
type CacheInvalidation struct {
    redisClient *redis.Client
}

func (ci *CacheInvalidation) InvalidateUserCache(userID uint) {
    // 删除用户相关缓存
    keys := []string{
        fmt.Sprintf("user:%d", userID),
        fmt.Sprintf("user_orders:%d", userID),
        fmt.Sprintf("user_profile:%d", userID),
    }
    
    ci.redisClient.Del(ctx, keys...)
}

func (ci *CacheInvalidation) InvalidatePattern(pattern string) {
    // 使用SCAN删除匹配的键
    iter := ci.redisClient.Scan(ctx, 0, pattern, 0).Iterator()
    for iter.Next(ctx) {
        ci.redisClient.Del(ctx, iter.Val())
    }
}
```

### 数据一致性

#### 分布式事务实现
```go
// 两阶段提交(Two-Phase Commit)简化实现
type TwoPhaseCommit struct {
    participants []TransactionParticipant
}

type TransactionParticipant interface {
    Prepare(transactionID string) error
    Commit(transactionID string) error
    Rollback(transactionID string) error
}

func (tpc *TwoPhaseCommit) Execute(transactionID string) error {
    // 第一阶段：准备阶段
    for _, participant := range tpc.participants {
        if err := participant.Prepare(transactionID); err != nil {
            // 准备失败，回滚所有参与者
            tpc.rollbackAll(transactionID)
            return err
        }
    }
    
    // 第二阶段：提交阶段
    for _, participant := range tpc.participants {
        if err := participant.Commit(transactionID); err != nil {
            // 提交失败，记录错误但继续提交其他参与者
            log.Printf("提交失败: %v", err)
        }
    }
    
    return nil
}

func (tpc *TwoPhaseCommit) rollbackAll(transactionID string) {
    for _, participant := range tpc.participants {
        participant.Rollback(transactionID)
    }
}

// 最终一致性实现
type EventualConsistency struct {
    messageQueue MessageQueue
    retryLimit   int
}

type MessageQueue interface {
    Publish(topic string, message interface{}) error
    Subscribe(topic string, handler func(message interface{}) error) error
}

func (ec *EventualConsistency) PublishEvent(event interface{}) error {
    return ec.messageQueue.Publish("data_sync", event)
}

func (ec *EventualConsistency) HandleEvent(event interface{}) error {
    // 处理事件并更新数据
    // 如果失败，重新入队或记录到死信队列
    err := ec.processEvent(event)
    if err != nil {
        // 重试机制
        return ec.retryEvent(event)
    }
    return nil
}

func (ec *EventualConsistency) processEvent(event interface{}) error {
    // 具体的事件处理逻辑
    return nil
}

func (ec *EventualConsistency) retryEvent(event interface{}) error {
    // 实现重试逻辑
    return nil
}
```

### 分布式缓存

#### Redis集群操作
```go
// Redis集群客户端
type RedisClusterClient struct {
    client *redis.ClusterClient
}

func NewRedisClusterClient(addrs []string) *RedisClusterClient {
    client := redis.NewClusterClient(&redis.ClusterOptions{
        Addrs: addrs,
        // 其他配置选项
    })
    
    return &RedisClusterClient{client: client}
}

// 分布式锁实现
type DistributedLock struct {
    client *redis.ClusterClient
    key    string
    value  string
    expiry time.Duration
}

func NewDistributedLock(client *redis.ClusterClient, key string, expiry time.Duration) *DistributedLock {
    return &DistributedLock{
        client: client,
        key:    key,
        value:  generateLockValue(),
        expiry: expiry,
    }
}

func (dl *DistributedLock) Acquire() (bool, error) {
    return dl.client.SetNX(ctx, dl.key, dl.value, dl.expiry).Result()
}

func (dl *DistributedLock) Release() (bool, error) {
    script := redis.NewScript(`
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
    `)
    
    result, err := script.Run(ctx, dl.client, []string{dl.key}, dl.value).Result()
    if err != nil {
        return false, err
    }
    
    return result.(int64) == 1, nil
}

func generateLockValue() string {
    return fmt.Sprintf("%d_%s", time.Now().UnixNano(), randomString(8))
}

func randomString(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, length)
    for i := range b {
        b[i] = charset[rand.Intn(len(charset))]
    }
    return string(b)
}

// 缓存分片
type ShardedCache struct {
    clients []*redis.Client
    shards  int
}

func NewShardedCache(shardAddrs []string) *ShardedCache {
    var clients []*redis.Client
    for _, addr := range shardAddrs {
        client := redis.NewClient(&redis.Options{Addr: addr})
        clients = append(clients, client)
    }
    
    return &ShardedCache{
        clients: clients,
        shards:  len(clients),
    }
}

func (sc *ShardedCache) getShard(key string) *redis.Client {
    hash := fnv.New32a()
    hash.Write([]byte(key))
    shardIndex := int(hash.Sum32()) % sc.shards
    return sc.clients[shardIndex]
}

func (sc *ShardedCache) Set(key string, value interface{}, expiration time.Duration) error {
    shard := sc.getShard(key)
    return shard.Set(ctx, key, value, expiration).Err()
}

func (sc *ShardedCache) Get(key string) (interface{}, error) {
    shard := sc.getShard(key)
    return shard.Get(ctx, key).Result()
}
```