## 6.1 常用标准库

### fmt包（格式化输入输出）

```go
package main

import (
    "fmt"
    "io"
    "os"
    "strings"
)

// 自定义类型实现fmt接口
type Person struct {
    Name string
    Age  int
}

// 实现Stringer接口
func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
}

// 实现GoStringer接口
func (p Person) GoString() string {
    return fmt.Sprintf("Person{Name: %q, Age: %d}", p.Name, p.Age)
}

// 实现Formatter接口
func (p Person) Format(f fmt.State, c rune) {
    switch c {
    case 'v':
        if f.Flag('#') {
            fmt.Fprintf(f, "Person{Name: %q, Age: %d}", p.Name, p.Age)
        } else {
            fmt.Fprintf(f, "%s (%d)", p.Name, p.Age)
        }
    case 's':
        fmt.Fprintf(f, "%s", p.Name)
    case 'd':
        fmt.Fprintf(f, "%d", p.Age)
    }
}

func demonstrateFmt() {
    // 基本格式化
    name := "Alice"
    age := 30
    
    // Printf - 格式化输出到标准输出
    fmt.Printf("Name: %s, Age: %d\n", name, age)
    
    // Sprintf - 格式化字符串
    formatted := fmt.Sprintf("Hello %s, you are %d years old", name, age)
    fmt.Println(formatted)
    
    // Fprintf - 格式化输出到Writer
    fmt.Fprintf(os.Stdout, "Direct to stdout: %s\n", name)
    
    // Print系列
    fmt.Print("Print: ", name, " ", age, "\n")
    fmt.Println("Println:", name, age)
    
    // Scan系列
    var inputName string
    var inputAge int
    // fmt.Scanf("%s %d", &inputName, &inputAge)  // 从标准输入读取
    
    // 字符串扫描
    input := "Bob 25"
    n, err := fmt.Sscanf(input, "%s %d", &inputName, &inputAge)
    if err != nil {
        fmt.Printf("Scan error: %v\n", err)
    } else {
        fmt.Printf("Scanned %d items: %s %d\n", n, inputName, inputAge)
    }
    
    // 使用自定义类型
    person := Person{Name: "Charlie", Age: 35}
    fmt.Println(person)           // 调用String()方法
    fmt.Printf("%#v\n", person)   // 调用GoString()方法
    fmt.Printf("%v\n", person)    // 调用Format()方法
    
    // 格式化标志
    num := 42
    fmt.Printf("Default: %d\n", num)
    fmt.Printf("Width: %6d\n", num)
    fmt.Printf("Zero-padded: %06d\n", num)
    fmt.Printf("Left-aligned: %-6d\n", num)
    fmt.Printf("Hex: %x\n", num)
    fmt.Printf("Hex with 0x: %#x\n", num)
    fmt.Printf("Binary: %b\n", num)
    
    // 浮点数格式化
    pi := 3.14159265359
    fmt.Printf("Default: %f\n", pi)
    fmt.Printf("Precision 2: %.2f\n", pi)
    fmt.Printf("Scientific: %e\n", pi)
    fmt.Printf("Scientific upper: %E\n", pi)
    fmt.Printf("General: %g\n", pi)
    
    // 动态宽度和精度
    width := 10
    precision := 3
    fmt.Printf("%*.*f\n", width, precision, pi)
    
    // 错误处理
    _, err = fmt.Println("Hello")
    if err != nil {
        fmt.Printf("Print error: %v\n", err)
    }
    
    // Writer和Reader接口
    var buf strings.Builder
    fmt.Fprint(&buf, "Hello")
    fmt.Fprintf(&buf, " %s", "World")
    fmt.Fprintf(&buf, "! Number: %d", 42)
    fmt.Println(buf.String())
}

// 自定义Writer示例
type CustomWriter struct {
    prefix string
}

func (cw *CustomWriter) Write(p []byte) (n int, err error) {
    output := cw.prefix + string(p)
    return fmt.Print(output)
}

func demonstrateCustomWriter() {
    cw := &CustomWriter{prefix: "[LOG] "}
    fmt.Fprintln(cw, "This is a custom log message")
}
```

### strconv包（字符串转换）

```go
package main

import (
    "fmt"
    "strconv"
)

func demonstrateStrconv() {
    // 字符串到整数转换
    str := "123"
    if num, err := strconv.Atoi(str); err == nil {
        fmt.Printf("Atoi: %d\n", num)
    } else {
        fmt.Printf("Atoi error: %v\n", err)
    }
    
    // 指定进制转换
    if num, err := strconv.ParseInt("1010", 2, 64); err == nil {
        fmt.Printf("Binary ParseInt: %d\n", num)
    }
    
    if num, err := strconv.ParseInt("FF", 16, 64); err == nil {
        fmt.Printf("Hex ParseInt: %d\n", num)
    }
    
    // 无符号整数
    if num, err := strconv.ParseUint("255", 10, 64); err == nil {
        fmt.Printf("ParseUint: %d\n", num)
    }
    
    // 浮点数转换
    if f, err := strconv.ParseFloat("3.14159", 64); err == nil {
        fmt.Printf("ParseFloat: %f\n", f)
    }
    
    // 布尔值转换
    if b, err := strconv.ParseBool("true"); err == nil {
        fmt.Printf("ParseBool: %t\n", b)
    }
    
    // 整数到字符串
    fmt.Printf("Itoa: %s\n", strconv.Itoa(456))
    fmt.Printf("FormatInt (binary): %s\n", strconv.FormatInt(42, 2))
    fmt.Printf("FormatInt (hex): %s\n", strconv.FormatInt(255, 16))
    fmt.Printf("FormatUint: %s\n", strconv.FormatUint(255, 10))
    
    // 浮点数到字符串
    pi := 3.14159265359
    fmt.Printf("FormatFloat (default): %s\n", strconv.FormatFloat(pi, 'f', -1, 64))
    fmt.Printf("FormatFloat (precision 3): %s\n", strconv.FormatFloat(pi, 'f', 3, 64))
    fmt.Printf("FormatFloat (scientific): %s\n", strconv.FormatFloat(pi, 'e', -1, 64))
    
    // 引用和转义
    text := `Hello "World" & <script>`
    quoted := strconv.Quote(text)
    fmt.Printf("Quoted: %s\n", quoted)
    
    if unquoted, err := strconv.Unquote(quoted); err == nil {
        fmt.Printf("Unquoted: %s\n", unquoted)
    }
    
    // 错误处理示例
    invalidStr := "not a number"
    if _, err := strconv.Atoi(invalidStr); err != nil {
        fmt.Printf("Conversion error: %v\n", err)
        // 可以使用错误类型断言获取更详细信息
        if numError, ok := err.(*strconv.NumError); ok {
            fmt.Printf("NumError: %v, Func: %s, Num: %s\n", 
                numError.Err, numError.Func, numError.Num)
        }
    }
    
    // 特殊值处理
    fmt.Printf("MaxInt64: %s\n", strconv.FormatInt(int64(^uint64(0)>>1), 10))
    fmt.Printf("MinInt64: %s\n", strconv.FormatInt(int64(-1<<63), 10))
    
    // 大整数处理
    bigNum := "123456789012345678901234567890"
    if num, err := strconv.ParseInt(bigNum, 10, 64); err != nil {
        fmt.Printf("Big number error: %v\n", err)
    } else {
        fmt.Printf("Big number parsed: %d\n", num)
    }
}
```

### strings包（字符串操作）

```go
package main

import (
    "fmt"
    "strings"
    "unicode"
)

func demonstrateStrings() {
    text := "Hello, World! Welcome to Go programming."
    
    // 基本操作
    fmt.Printf("Length: %d\n", len(text))
    fmt.Printf("To upper: %s\n", strings.ToUpper(text))
    fmt.Printf("To lower: %s\n", strings.ToLower(text))
    fmt.Printf("Title case: %s\n", strings.Title(strings.ToLower(text)))
    
    // 查找操作
    fmt.Printf("Contains 'World': %t\n", strings.Contains(text, "World"))
    fmt.Printf("Index of 'World': %d\n", strings.Index(text, "World"))
    fmt.Printf("Last index of 'o': %d\n", strings.LastIndex(text, "o"))
    fmt.Printf("Count of 'o': %d\n", strings.Count(text, "o"))
    
    // 分割和连接
    words := strings.Fields(text)  // 按空白字符分割
    fmt.Printf("Fields: %v\n", words)
    
    parts := strings.Split(text, " ")  // 按指定分隔符分割
    fmt.Printf("Split by space: %v\n", parts)
    
    joined := strings.Join(words, "-")
    fmt.Printf("Joined with '-': %s\n", joined)
    
    // 修剪操作
    spacedText := "  Hello, World!  "
    fmt.Printf("Trim space: '%s'\n", strings.TrimSpace(spacedText))
    fmt.Printf("Trim left: '%s'\n", strings.TrimLeft(spacedText, " "))
    fmt.Printf("Trim right: '%s'\n", strings.TrimRight(spacedText, " "))
    fmt.Printf("Trim custom: '%s'\n", strings.Trim("!!!Hello!!!", "!"))
    
    // 替换操作
    replaced := strings.Replace(text, "World", "Go", -1)  // -1表示替换所有
    fmt.Printf("Replace: %s\n", replaced)
    
    replacer := strings.NewReplacer("Hello", "Hi", "World", "Go")
    fmt.Printf("Replacer: %s\n", replacer.Replace(text))
    
    // 前缀和后缀
    fmt.Printf("Has prefix 'Hello': %t\n", strings.HasPrefix(text, "Hello"))
    fmt.Printf("Has suffix 'programming.': %t\n", strings.HasSuffix(text, "programming."))
    
    // 重复和填充
    fmt.Printf("Repeat: %s\n", strings.Repeat("Go ", 3))
    
    // Builder的使用（高效字符串构建）
    var builder strings.Builder
    builder.Grow(100)  // 预分配容量
    builder.WriteString("Hello")
    builder.WriteByte(' ')
    builder.WriteString("World")
    builder.WriteRune('!')
    fmt.Printf("Builder result: %s\n", builder.String())
    fmt.Printf("Builder length: %d\n", builder.Len())
    fmt.Printf("Builder capacity: %d\n", builder.Cap())
    
    // Reader的使用
    reader := strings.NewReader(text)
    fmt.Printf("Reader length: %d\n", reader.Len())
    fmt.Printf("Reader size: %d\n", reader.Size())
    
    // 高级操作
    // Repeat with custom function
    mapper := func(r rune) rune {
        if r >= 'a' && r <= 'z' {
            return r - 'a' + 'A'  // 转换为大写
        }
        return r
    }
    fmt.Printf("Map function: %s\n", strings.Map(mapper, "hello world"))
    
    // 比较操作
    fmt.Printf("Compare 'abc' and 'def': %d\n", strings.Compare("abc", "def"))
    fmt.Printf("Equal fold 'Hello' and 'HELLO': %t\n", strings.EqualFold("Hello", "HELLO"))
    
    // Unicode相关操作
    unicodeText := "Hello 世界 123"
    fmt.Printf("Index of any: %d\n", strings.IndexAny(unicodeText, "界3"))
    fmt.Printf("Index of rune: %d\n", strings.IndexRune(unicodeText, '界'))
    
    // Builder重置示例
    builder.Reset()
    builder.WriteString("New content")
    fmt.Printf("Reset builder: %s\n", builder.String())
}

// 自定义字符串处理函数
func reverseWords(s string) string {
    words := strings.Fields(s)
    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
        words[i], words[j] = words[j], words[i]
    }
    return strings.Join(words, " ")
}

// 字符串验证函数
func isValidEmail(email string) bool {
    if !strings.Contains(email, "@") {
        return false
    }
    
    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return false
    }
    
    local, domain := parts[0], parts[1]
    if len(local) == 0 || len(domain) == 0 {
        return false
    }
    
    // 简单的域名验证
    if !strings.Contains(domain, ".") {
        return false
    }
    
    return true
}

func advancedStringOperations() {
    // 反转单词示例
    sentence := "Hello World Go Programming"
    fmt.Printf("Original: %s\n", sentence)
    fmt.Printf("Reversed words: %s\n", reverseWords(sentence))
    
    // 邮箱验证示例
    emails := []string{
        "user@example.com",
        "invalid.email",
        "@domain.com",
        "user@",
        "valid@domain.org",
    }
    
    for _, email := range emails {
        fmt.Printf("Email %s is valid: %t\n", email, isValidEmail(email))
    }
    
    // 字符串统计
    text := "The quick brown fox jumps over the lazy dog"
    charCount := make(map[rune]int)
    for _, char := range strings.ToLower(text) {
        if unicode.IsLetter(char) {
            charCount[char]++
        }
    }
    
    fmt.Println("Character frequency:")
    for char, count := range charCount {
        fmt.Printf("'%c': %d\n", char, count)
    }
}
```

### bytes包（字节操作）

```go
package main

import (
    "bytes"
    "fmt"
    "unicode"
)

func demonstrateBytes() {
    // 创建字节切片
    data := []byte("Hello, World!")
    fmt.Printf("Original: %s\n", data)
    
    // 基本操作
    fmt.Printf("Length: %d\n", len(data))
    fmt.Printf("Capacity: %d\n", cap(data))
    
    // 比较操作
    data1 := []byte("Hello")
    data2 := []byte("Hello")
    data3 := []byte("World")
    
    fmt.Printf("Equal: %t\n", bytes.Equal(data1, data2))
    fmt.Printf("Compare: %d\n", bytes.Compare(data1, data3))  // -1 if data1 < data3
    
    // 查找操作
    fmt.Printf("Contains 'World': %t\n", bytes.Contains(data, []byte("World")))
    fmt.Printf("Index of 'World': %d\n", bytes.Index(data, []byte("World")))
    fmt.Printf("Count of 'l': %d\n", bytes.Count(data, []byte("l")))
    
    // 分割和连接
    parts := bytes.Split(data, []byte(" "))
    fmt.Printf("Split: %s\n", parts)
    
    joined := bytes.Join(parts, []byte("-"))
    fmt.Printf("Joined: %s\n", joined)
    
    // 修剪操作
    spacedData := []byte("  Hello, World!  ")
    fmt.Printf("Trim space: %s\n", bytes.TrimSpace(spacedData))
    fmt.Printf("Trim: %s\n", bytes.Trim(spacedData, " "))
    
    // 替换操作
    replaced := bytes.Replace(data, []byte("World"), []byte("Go"), -1)
    fmt.Printf("Replace: %s\n", replaced)
    
    // 大小写转换
    fmt.Printf("To upper: %s\n", bytes.ToUpper(data))
    fmt.Printf("To lower: %s\n", bytes.ToLower(data))
    
    // Buffer的使用（类似strings.Builder但用于字节）
    var buffer bytes.Buffer
    buffer.Grow(100)  // 预分配容量
    buffer.Write([]byte("Hello"))
    buffer.WriteByte(' ')
    buffer.WriteString("World")  // Buffer也实现了WriteString
    buffer.WriteRune('!')
    
    fmt.Printf("Buffer content: %s\n", buffer.Bytes())
    fmt.Printf("Buffer string: %s\n", buffer.String())
    fmt.Printf("Buffer length: %d\n", buffer.Len())
    
    // Reader的使用
    reader := bytes.NewReader(data)
    fmt.Printf("Reader length: %d\n", reader.Len())
    
    // 从Reader读取
    buf := make([]byte, 5)
    n, err := reader.Read(buf)
    if err != nil {
        fmt.Printf("Read error: %v\n", err)
    } else {
        fmt.Printf("Read %d bytes: %s\n", n, buf[:n])
    }
    
    // Writer的使用
    var output bytes.Buffer
    output.Write([]byte("Written to buffer\n"))
    fmt.Printf("Output: %s", output.String())
}

// 高效的字节处理示例
func efficientByteProcessing() {
    // 使用Buffer进行高效字符串构建
    var buf bytes.Buffer
    
    // 模拟处理大量数据
    for i := 0; i < 1000; i++ {
        buf.WriteString(fmt.Sprintf("Line %d\n", i))
    }
    
    result := buf.String()
    fmt.Printf("Generated %d characters\n", len(result))
    
    // 字节切片操作
    data := []byte("The quick brown fox jumps over the lazy dog")
    
    // 查找并替换多个实例
    search := []byte("the")
    replace := []byte("THE")
    
    // 不区分大小写的替换
    lowerData := bytes.ToLower(data)
    indices := findAllIndices(lowerData, search)
    
    fmt.Printf("Found %d occurrences of '%s'\n", len(indices), search)
    
    // 使用bytes.Buffer进行替换
    var resultBuf bytes.Buffer
    lastIdx := 0
    
    for _, idx := range indices {
        resultBuf.Write(data[lastIdx:idx])
        resultBuf.Write(replace)
        lastIdx = idx + len(search)
    }
    resultBuf.Write(data[lastIdx:])
    
    fmt.Printf("Result: %s\n", resultBuf.String())
}

// 辅助函数：查找所有匹配的索引
func findAllIndices(data, pattern []byte) []int {
    var indices []int
    start := 0
    
    for {
        idx := bytes.Index(data[start:], pattern)
        if idx == -1 {
            break
        }
        indices = append(indices, start+idx)
        start += idx + 1
    }
    
    return indices
}

// 字节切片分析函数
func analyzeBytes(data []byte) {
    fmt.Printf("Byte analysis of: %s\n", data)
    
    var letterCount, digitCount, spaceCount, punctCount int
    
    for _, b := range data {
        switch {
        case unicode.IsLetter(rune(b)):
            letterCount++
        case unicode.IsDigit(rune(b)):
            digitCount++
        case unicode.IsSpace(rune(b)):
            spaceCount++
        case unicode.IsPunct(rune(b)):
            punctCount++
        }
    }
    
    fmt.Printf("Letters: %d, Digits: %d, Spaces: %d, Punctuation: %d\n",
        letterCount, digitCount, spaceCount, punctCount)
}
```

### time包（时间处理）

```go
package main

import (
    "fmt"
    "time"
)

func demonstrateTime() {
    // 当前时间
    now := time.Now()
    fmt.Printf("Current time: %v\n", now)
    fmt.Printf("Unix timestamp: %d\n", now.Unix())
    fmt.Printf("Unix nano: %d\n", now.UnixNano())
    
    // 时间格式化
    fmt.Printf("RFC3339: %s\n", now.Format(time.RFC3339))
    fmt.Printf("Custom format: %s\n", now.Format("2006-01-02 15:04:05"))
    fmt.Printf("Date only: %s\n", now.Format("2006-01-02"))
    fmt.Printf("Time only: %s\n", now.Format("15:04:05"))
    
    // 解析时间字符串
    timeStr := "2023-12-25 15:30:45"
    layout := "2006-01-02 15:04:05"
    
    if parsedTime, err := time.Parse(layout, timeStr); err == nil {
        fmt.Printf("Parsed time: %v\n", parsedTime)
    } else {
        fmt.Printf("Parse error: %v\n", err)
    }
    
    // 时间计算
    // 加减时间
    future := now.Add(24 * time.Hour)  // 24小时后
    past := now.Add(-7 * 24 * time.Hour)  // 7天前
    
    fmt.Printf("24 hours later: %v\n", future)
    fmt.Printf("7 days ago: %v\n", past)
    
    // 时间差
    duration := future.Sub(now)
    fmt.Printf("Duration: %v\n", duration)
    
    // 时间比较
    fmt.Printf("Future after now: %t\n", future.After(now))
    fmt.Printf("Past before now: %t\n", past.Before(now))
    fmt.Printf("Now equal to now: %t\n", now.Equal(now))
    
    // Duration操作
    d1 := 2*time.Hour + 30*time.Minute
    d2 := 90 * time.Minute
    
    fmt.Printf("Duration 1: %v\n", d1)
    fmt.Printf("Duration 2: %v\n", d2)
    fmt.Printf("Sum: %v\n", d1+d2)
    fmt.Printf("Difference: %v\n", d1-d2)
    
    // Timer和Ticker
    fmt.Println("Timer example:")
    timer := time.NewTimer(2 * time.Second)
    go func() {
        <-timer.C
        fmt.Println("Timer fired!")
    }()
    
    // Ticker示例
    fmt.Println("Ticker example:")
    ticker := time.NewTicker(500 * time.Millisecond)
    go func() {
        count := 0
        for t := range ticker.C {
            fmt.Printf("Tick at %v\n", t)
            count++
            if count >= 5 {
                ticker.Stop()
                fmt.Println("Ticker stopped")
                break
            }
        }
    }()
    
    // Sleep示例
    fmt.Println("Sleeping for 1 second...")
    time.Sleep(1 * time.Second)
    fmt.Println("Awake!")
    
    // 时间戳转换
    timestamp := int64(1672531199)  // Unix timestamp
    unixTime := time.Unix(timestamp, 0)
    fmt.Printf("Unix timestamp %d -> %v\n", timestamp, unixTime)
    
    // 时区处理
    loc, err := time.LoadLocation("Asia/Shanghai")
    if err != nil {
        fmt.Printf("Load location error: %v\n", err)
    } else {
        shanghaiTime := now.In(loc)
        fmt.Printf("Shanghai time: %v\n", shanghaiTime)
    }
    
    // UTC时间
    utcTime := now.UTC()
    fmt.Printf("UTC time: %v\n", utcTime)
    
    // 时间轮询示例
    fmt.Println("Time polling example:")
    timeout := time.After(3 * time.Second)
    tick := time.Tick(500 * time.Millisecond)
    
    count := 0
    for {
        select {
        case <-tick:
            count++
            fmt.Printf("Tick #%d\n", count)
        case <-timeout:
            fmt.Println("Timeout reached")
            return
        }
    }
}

// 定时任务调度示例
func scheduleTask() {
    // 每天特定时间执行任务
    go func() {
        for {
            now := time.Now()
            // 计算到明天9点的时间
            nextRun := time.Date(now.Year(), now.Month(), now.Day()+1, 9, 0, 0, 0, now.Location())
            duration := nextRun.Sub(now)
            
            fmt.Printf("Next run in: %v\n", duration)
            time.Sleep(duration)
            
            // 执行任务
            fmt.Printf("Task executed at: %v\n", time.Now())
        }
    }()
}

// 性能测试时间测量
func measurePerformance() {
    start := time.Now()
    
    // 模拟一些工作
    time.Sleep(100 * time.Millisecond)
    
    duration := time.Since(start)
    fmt.Printf("Operation took: %v\n", duration)
    
    // 高精度时间测量
    startNano := time.Now()
    for i := 0; i < 1000000; i++ {
        _ = i * i
    }
    durationNano := time.Since(startNano)
    fmt.Printf("High precision measurement: %v\n", durationNano)
}
```

### math包（数学运算）

```go
package main

import (
    "fmt"
    "math"
    "math/rand"
    "time"
)

func demonstrateMath() {
    // 基本数学常数
    fmt.Printf("Pi: %.10f\n", math.Pi)
    fmt.Printf("E: %.10f\n", math.E)
    fmt.Printf("Phi (Golden ratio): %.10f\n", math.Phi)
    
    // 基本运算
    x, y := 3.0, 4.0
    fmt.Printf("x=%.2f, y=%.2f\n", x, y)
    fmt.Printf("Add: %.2f\n", x+y)
    fmt.Printf("Subtract: %.2f\n", x-y)
    fmt.Printf("Multiply: %.2f\n", x*y)
    fmt.Printf("Divide: %.2f\n", x/y)
    fmt.Printf("Power: %.2f\n", math.Pow(x, y))
    fmt.Printf("Square root: %.2f\n", math.Sqrt(x))
    
    // 三角函数
    angle := math.Pi / 4  // 45度
    fmt.Printf("Angle: %.2f radians (%.2f degrees)\n", angle, angle*180/math.Pi)
    fmt.Printf("Sin: %.4f\n", math.Sin(angle))
    fmt.Printf("Cos: %.4f\n", math.Cos(angle))
    fmt.Printf("Tan: %.4f\n", math.Tan(angle))
    
    // 反三角函数
    fmt.Printf("Asin(0.5): %.4f radians (%.2f degrees)\n", 
        math.Asin(0.5), math.Asin(0.5)*180/math.Pi)
    
    // 指数和对数
    fmt.Printf("Exp(1): %.4f\n", math.Exp(1))
    fmt.Printf("Ln(10): %.4f\n", math.Log(10))
    fmt.Printf("Log10(100): %.4f\n", math.Log10(100))
    fmt.Printf("Log2(8): %.4f\n", math.Log2(8))
    
    // 舍入函数
    num := 3.75
    fmt.Printf("Number: %.2f\n", num)
    fmt.Printf("Floor: %.2f\n", math.Floor(num))
    fmt.Printf("Ceil: %.2f\n", math.Ceil(num))
    fmt.Printf("Round: %.2f\n", math.Round(num))
    fmt.Printf("Trunc: %.2f\n", math.Trunc(num))
    
    // 绝对值和符号
    negative := -15.5
    fmt.Printf("Negative: %.2f\n", negative)
    fmt.Printf("Absolute: %.2f\n", math.Abs(negative))
    fmt.Printf("Sign: %.2f\n", math.Signbit(negative))
    
    // 最大值和最小值
    a, b := 10.5, 20.3
    fmt.Printf("Max(%.2f, %.2f): %.2f\n", a, b, math.Max(a, b))
    fmt.Printf("Min(%.2f, %.2f): %.2f\n", a, b, math.Min(a, b))
    
    // 特殊值检查
    nan := math.NaN()
    inf := math.Inf(1)
    negInf := math.Inf(-1)
    
    fmt.Printf("NaN check: %t\n", math.IsNaN(nan))
    fmt.Printf("Positive infinity check: %t\n", math.IsInf(inf, 1))
    fmt.Printf("Negative infinity check: %t\n", math.IsInf(negInf, -1))
    fmt.Printf("Any infinity check: %t\n", math.IsInf(inf, 0))
    
    // 位运算相关
    fmt.Printf("Next after 1.0 towards 2.0: %.20f\n", math.Nextafter(1.0, 2.0))
    fmt.Printf("Remainder of 10/3: %.2f\n", math.Remainder(10, 3))
    
    // 双曲函数
    fmt.Printf("Sinh(1): %.4f\n", math.Sinh(1))
    fmt.Printf("Cosh(1): %.4f\n", math.Cosh(1))
    fmt.Printf("Tanh(1): %.4f\n", math.Tanh(1))
    
    // 伽马函数
    fmt.Printf("Gamma(5): %.2f (should be 4! = 24)\n", math.Gamma(5))
    
    // 误差函数
    fmt.Printf("Erf(1): %.4f\n", math.Erf(1))
}

// 随机数生成
func demonstrateRandom() {
    // 使用时间作为种子
    rand.Seed(time.Now().UnixNano())
    
    // 基本随机数生成
    fmt.Println("Random numbers:")
    for i := 0; i < 5; i++ {
        fmt.Printf("Int: %d, Float: %.4f\n", rand.Int(), rand.Float64())
    }
    
    // 范围内的随机数
    fmt.Println("Random in ranges:")
    for i := 0; i < 5; i++ {
        fmt.Printf("Int [1,10]: %d, Float [0,10]: %.2f\n", 
            rand.Intn(10)+1, rand.Float64()*10)
    }
    
    // 随机排列
    slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Printf("Original: %v\n", slice)
    rand.Shuffle(len(slice), func(i, j int) {
        slice[i], slice[j] = slice[j], slice[i]
    })
    fmt.Printf("Shuffled: %v\n", slice)
    
    // 随机选择
    choices := []string{"apple", "banana", "cherry", "date", "elderberry"}
    fmt.Printf("Random choice: %s\n", choices[rand.Intn(len(choices))])
    
    // 正态分布随机数
    fmt.Println("Normal distribution samples:")
    for i := 0; i < 5; i++ {
        sample := rand.NormFloat64()  // 均值0，标准差1
        fmt.Printf("Sample %d: %.4f\n", i+1, sample)
    }
}

// 数学计算示例
func mathematicalCalculations() {
    // 质数检查
    fmt.Println("Prime numbers up to 30:")
    for i := 2; i <= 30; i++ {
        if isPrime(i) {
            fmt.Printf("%d ", i)
        }
    }
    fmt.Println()
    
    // 最大公约数和最小公倍数
    a, b := 48, 18
    gcd := greatestCommonDivisor(a, b)
    lcm := leastCommonMultiple(a, b)
    fmt.Printf("GCD(%d, %d) = %d\n", a, b, gcd)
    fmt.Printf("LCM(%d, %d) = %d\n", a, b, lcm)
    
    // 斐波那契数列
    fmt.Println("Fibonacci sequence:")
    for i := 0; i < 15; i++ {
        fmt.Printf("%d ", fibonacci(i))
    }
    fmt.Println()
    
    // 阶乘计算
    fmt.Println("Factorials:")
    for i := 0; i <= 10; i++ {
        fmt.Printf("%d! = %d\n", i, factorial(i))
    }
}

// 辅助函数
func isPrime(n int) bool {
    if n < 2 {
        return false
    }
    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func greatestCommonDivisor(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func leastCommonMultiple(a, b int) int {
    return a * b / greatestCommonDivisor(a, b)
}

func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}

func factorial(n int) int64 {
    if n <= 1 {
        return 1
    }
    return int64(n) * factorial(n-1)
}
```

### sort包（排序算法）

```go
package main

import (
    "fmt"
    "sort"
)

// 自定义类型实现排序接口
type Person struct {
    Name string
    Age  int
    City string
}

type ByAge []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

type ByName []Person

func (a ByName) Len() int           { return len(a) }
func (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }

func demonstrateSort() {
    // 基本排序
    numbers := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Printf("Original: %v\n", numbers)
    
    sort.Ints(numbers)
    fmt.Printf("Sorted: %v\n", numbers)
    
    // 字符串排序
    strings := []string{"banana", "apple", "cherry", "date"}
    fmt.Printf("Original strings: %v\n", strings)
    
    sort.Strings(strings)
    fmt.Printf("Sorted strings: %v\n", strings)
    
    // 浮点数排序
    floats := []float64{3.14, 2.71, 1.41, 1.73}
    fmt.Printf("Original floats: %v\n", floats)
    
    sort.Float64s(floats)
    fmt.Printf("Sorted floats: %v\n", floats)
    
    // 自定义排序 - 使用sort.Interface
    people := []Person{
        {"Alice", 30, "New York"},
        {"Bob", 25, "Los Angeles"},
        {"Charlie", 35, "Chicago"},
        {"Diana", 28, "Houston"},
    }
    
    fmt.Println("Original people:")
    for _, p := range people {
        fmt.Printf("  %s (%d) - %s\n", p.Name, p.Age, p.City)
    }
    
    // 按年龄排序
    sort.Sort(ByAge(people))
    fmt.Println("Sorted by age:")
    for _, p := range people {
        fmt.Printf("  %s (%d) - %s\n", p.Name, p.Age, p.City)
    }
    
    // 按姓名排序
    sort.Sort(ByName(people))
    fmt.Println("Sorted by name:")
    for _, p := range people {
        fmt.Printf("  %s (%d) - %s\n", p.Name, p.Age, p.City)
    }
    
    // 使用sort.Slice进行自定义排序（Go 1.8+）
    sort.Slice(people, func(i, j int) bool {
        return people[i].City < people[j].City
    })
    fmt.Println("Sorted by city:")
    for _, p := range people {
        fmt.Printf("  %s (%d) - %s\n", p.Name, p.Age, p.City)
    }
    
    // 逆序排序
    sort.Slice(people, func(i, j int) bool {
        return people[i].Age > people[j].Age  // 注意这里是大于号
    })
    fmt.Println("Sorted by age (descending):")
    for _, p := range people {
        fmt.Printf("  %s (%d) - %s\n", p.Name, p.Age, p.City)
    }
    
    // 稳定排序
    type Record struct {
        Name  string
        Score int
        ID    int
    }
    
    records := []Record{
        {"Alice", 85, 1},
        {"Bob", 85, 2},
        {"Charlie", 90, 3},
        {"Diana", 85, 4},
    }
    
    // 稳定排序保持相等元素的原始顺序
    sort.SliceStable(records, func(i, j int) bool {
        return records[i].Score > records[j].Score
    })
    fmt.Println("Stable sorted by score:")
    for _, r := range records {
        fmt.Printf("  %s (%d) - ID: %d\n", r.Name, r.Score, r.ID)
    }
    
    // 搜索操作
    sortedNumbers := []int{1, 3, 5, 7, 9, 11, 13, 15}
    target := 7
    
    index := sort.SearchInts(sortedNumbers, target)
    if index < len(sortedNumbers) && sortedNumbers[index] == target {
        fmt.Printf("Found %d at index %d\n", target, index)
    } else {
        fmt.Printf("%d not found\n", target)
    }
    
    // 检查是否已排序
    fmt.Printf("Is numbers sorted? %t\n", sort.IntsAreSorted(numbers))
    fmt.Printf("Is strings sorted? %t\n", sort.StringsAreSorted(strings))
    
    // 二分查找自定义条件
    index = sort.Search(len(sortedNumbers), func(i int) bool {
        return sortedNumbers[i] >= 10
    })
    fmt.Printf("First number >= 10 is at index %d: %d\n", index, sortedNumbers[index])
}

// 复杂排序示例
func complexSorting() {
    // 多级排序
    type Student struct {
        Name    string
        Grade   string
        Score   float64
        Age     int
    }
    
    students := []Student{
        {"Alice", "A", 95.5, 20},
        {"Bob", "B", 87.2, 19},
        {"Charlie", "A", 95.5, 21},
        {"Diana", "A", 92.0, 20},
        {"Eve", "B", 87.2, 18},
    }
    
    // 先按成绩降序，再按年龄升序，最后按姓名升序
    sort.Slice(students, func(i, j int) bool {
        if students[i].Score != students[j].Score {
            return students[i].Score > students[j].Score  // 降序
        }
        if students[i].Age != students[j].Age {
            return students[i].Age < students[j].Age      // 升序
        }
        return students[i].Name < students[j].Name        // 升序
    })
    
    fmt.Println("Multi-level sorted students:")
    for _, s := range students {
        fmt.Printf("  %s (%s) - Score: %.1f, Age: %d\n", 
            s.Name, s.Grade, s.Score, s.Age)
    }
    
    // 部分排序
    data := []int{64, 34, 25, 12, 22, 11, 90, 5}
    fmt.Printf("Original data: %v\n", data)
    
    // 只排序前4个元素
    sort.Ints(data[:4])
    fmt.Printf("First 4 sorted: %v\n", data)
    
    // 排序后4个元素
    sort.Ints(data[4:])
    fmt.Printf("Last 4 sorted: %v\n", data)
}

// 排序性能测试
func sortingPerformance() {
    // 生成大量随机数据进行排序测试
    const size = 10000
    data := make([]int, size)
    for i := 0; i < size; i++ {
        data[i] = i
    }
    
    // 打乱数据
    for i := range data {
        j := rand.Intn(i + 1)
        data[i], data[j] = data[j], data[i]
    }
    
    fmt.Printf("Sorting %d elements...\n", size)
    
    // 测试不同排序算法的性能
    // 快速排序（默认）
    data1 := make([]int, size)
    copy(data1, data)
    
    start := time.Now()
    sort.Ints(data1)
    duration := time.Since(start)
    fmt.Printf("Built-in sort: %v\n", duration)
    
    // 检查排序正确性
    fmt.Printf("Is sorted: %t\n", sort.IntsAreSorted(data1))
}
```

### regexp包（正则表达式）

```go
package main

import (
    "fmt"
    "regexp"
    "strings"
)

func demonstrateRegexp() {
    // 基本正则表达式编译
    re, err := regexp.Compile(`\b\w+@\w+\.\w+\b`)
    if err != nil {
        fmt.Printf("Regex compile error: %v\n", err)
        return
    }
    
    text := "Contact us at support@example.com or sales@company.org for more info."
    
    // 查找匹配
    matches := re.FindAllString(text, -1)  // -1表示查找所有
    fmt.Printf("Email matches: %v\n", matches)
    
    // 查找匹配的位置
    indices := re.FindAllStringIndex(text, -1)
    fmt.Printf("Email indices: %v\n", indices)
    
    // 子匹配
    emailRe, _ := regexp.Compile(`(\w+)@(\w+)\.(\w+)`)
    submatches := emailRe.FindStringSubmatch("support@example.com")
    if len(submatches) > 0 {
        fmt.Printf("Full match: %s\n", submatches[0])
        fmt.Printf("Username: %s\n", submatches[1])
        fmt.Printf("Domain: %s\n", submatches[2])
        fmt.Printf("TLD: %s\n", submatches[3])
    }
    
    // 替换操作
    phoneText := "Call me at 123-456-7890 or 987-654-3210"
    phoneRe, _ := regexp.Compile(`\d{3}-\d{3}-\d{4}`)
    
    // 简单替换
    replaced := phoneRe.ReplaceAllString(phoneText, "XXX-XXX-XXXX")
    fmt.Printf("Replaced: %s\n", replaced)
    
    // 使用函数进行替换
    masked := phoneRe.ReplaceAllStringFunc(phoneText, func(s string) string {
        parts := strings.Split(s, "-")
        return fmt.Sprintf("(%s) %s-XXXX", parts[0], parts[1])
    })
    fmt.Printf("Function replaced: %s\n", masked)
    
    // 字节切片操作
    byteText := []byte("The price is $29.99 and the discount is 15%")
    priceRe, _ := regexp.Compile(`\$\d+\.\d+`)
    priceMatches := priceRe.FindAll(byteText, -1)
    fmt.Printf("Price matches: %s\n", priceMatches)
    
    // 分割字符串
    sentence := "apple,banana;cherry:grape|orange"
    separators := regexp.MustCompile(`[,;:|]`)
    parts := separators.Split(sentence, -1)
    fmt.Printf("Split parts: %v\n", parts)
    
    // 常用正则表达式模式
    patterns := map[string]string{
        "email":     `\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b`,
        "phone":     `\b\d{3}-\d{3}-\d{4}\b`,
        "url":       `https?://[^\s]+`,
        "ip":        `\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b`,
        "date":      `\b\d{4}-\d{2}-\d{2}\b`,
        "time":      `\b\d{2}:\d{2}:\d{2}\b`,
        "number":    `\b\d+(\.\d+)?\b`,
        "word":      `\b\w+\b`,
        "uppercase": `\b[A-Z][a-z]*\b`,
    }
    
    testText := `Contact john@example.com or call 555-123-4567. 
    Visit https://www.example.com on 2023-12-25 at 14:30:00. 
    IP: 192.168.1.1, Price: $99.99, Version: 2.1.0`
    
    fmt.Println("Pattern matching results:")
    for name, pattern := range patterns {
        re, _ := regexp.Compile(pattern)
        matches := re.FindAllString(testText, -1)
        if len(matches) > 0 {
            fmt.Printf("  %s: %v\n", name, matches)
        }
    }
    
    // 正则表达式选项
    // 不区分大小写
    caseInsensitive, _ := regexp.Compile(`(?i)hello`)
    fmt.Printf("Case insensitive match: %v\n", 
        caseInsensitive.MatchString("HELLO world"))
    
    // 多行模式
    multiline, _ := regexp.Compile(`(?m)^.*$`)
    multilineText := "Line 1\nLine 2\nLine 3"
    lines := multiline.FindAllString(multilineText, -1)
    fmt.Printf("Multiline matches: %v\n", lines)
    
    // 贪婪vs非贪婪匹配
    html := `<div>Content 1</div><div>Content 2</div>`
    
    // 贪婪匹配（默认）
    greedy, _ := regexp.Compile(`<div>.*</div>`)
    fmt.Printf("Greedy match: %s\n", greedy.FindString(html))
    
    // 非贪婪匹配
    nonGreedy, _ := regexp.Compile(`<div>.*?</div>`)
    nonGreedyMatches := nonGreedy.FindAllString(html, -1)
    fmt.Printf("Non-greedy matches: %v\n", nonGreedyMatches)
    
    // 前瞻和后顾断言
    // 正向前瞻：匹配后面跟着特定内容的模式
    lookahead, _ := regexp.Compile(`\w+(?=\s*:)`)  // 匹配后面跟着冒号的单词
    lookaheadText := "name: John, age: 30, city: New York"
    lookaheadMatches := lookahead.FindAllString(lookaheadText, -1)
    fmt.Printf("Lookahead matches: %v\n", lookaheadMatches)
    
    // 错误处理
    _, err = regexp.Compile(`[invalid regex`)
    if err != nil {
        fmt.Printf("Invalid regex error: %v\n", err)
    }
    
    // 预编译常用正则表达式以提高性能
    var (
        emailRegex    = regexp.MustCompile(`\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b`)
        phoneRegex    = regexp.MustCompile(`\b\d{3}-\d{3}-\d{4}\b`)
        urlRegex      = regexp.MustCompile(`https?://[^\s]+`)
    )
    
    // 在实际应用中使用预编译的正则表达式
    content := "Email: user@example.com, Phone: 123-456-7890, URL: https://example.com"
    
    fmt.Printf("Precompiled email: %v\n", emailRegex.FindAllString(content, -1))
    fmt.Printf("Precompiled phone: %v\n", phoneRegex.FindAllString(content, -1))
    fmt.Printf("Precompiled URL: %v\n", urlRegex.FindAllString(content, -1))
}

// 实用的正则表达式工具函数
func validateInput() {
    // 邮箱验证
    emailValidator := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    
    emails := []string{
        "valid@example.com",
        "invalid.email",
        "@domain.com",
        "user@",
        "good@domain.org",
    }
    
    fmt.Println("Email validation:")
    for _, email := range emails {
        valid := emailValidator.MatchString(email)
        fmt.Printf("  %s: %t\n", email, valid)
    }
    
    // 密码强度验证
    passwordValidator := regexp.MustCompile(`^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$`)
    
    passwords := []string{
        "password",           // 弱密码
        "Password123",        // 中等密码
        "StrongPass123!",     // 强密码
        "weak",               // 太短
    }
    
    fmt.Println("Password validation:")
    for _, password := range passwords {
        valid := passwordValidator.MatchString(password)
        fmt.Printf("  %s: %t\n", password, valid)
    }
    
    // 手机号验证（中国格式）
    phoneValidator := regexp.MustCompile(`^1[3-9]\d{9}$`)
    
    phones := []string{
        "13812345678",
        "12345678901",
        "138123456789",  // 太长
        "12812345678",   // 不是13-19开头
    }
    
    fmt.Println("Phone validation:")
    for _, phone := range phones {
        valid := phoneValidator.MatchString(phone)
        fmt.Printf("  %s: %t\n", phone, valid)
    }
}

// 文本清理和格式化
func textProcessing() {
    // 移除HTML标签
    htmlText := `<p>Hello <b>World</b>! This is <i>important</i>.</p>`
    tagRemover := regexp.MustCompile(`<[^>]*>`)
    cleanText := tagRemover.ReplaceAllString(htmlText, "")
    fmt.Printf("Cleaned HTML: %s\n", cleanText)
    
    // 标准化空白字符
    messyText := "Too   many\t\tspaces    and\n\n\nnewlines"
    whitespaceNormalizer := regexp.MustCompile(`\s+`)
    normalizedText := whitespaceNormalizer.ReplaceAllString(messyText, " ")
    fmt.Printf("Normalized: %s\n", strings.TrimSpace(normalizedText))
    
    // 提取和清理数字
    textWithNumbers := "The price is $29.99 and the quantity is 5 items."
    numberExtractor := regexp.MustCompile(`\d+\.?\d*`)
    numbers := numberExtractor.FindAllString(textWithNumbers, -1)
    fmt.Printf("Extracted numbers: %v\n", numbers)
}
```

### encoding包（编码解码）

```go
package main

import (
    "bytes"
    "encoding/base64"
    "encoding/hex"
    "encoding/json"
    "encoding/xml"
    "fmt"
    "io"
)

// JSON示例结构体
type Person struct {
    Name    string `json:"name"`
    Age     int    `json:"age"`
    Email   string `json:"email,omitempty"`
    Address string `json:"address"`
}

type Company struct {
    Name     string   `json:"name"`
    Employees []Person `json:"employees"`
}

func demonstrateJSON() {
    // 基本JSON编码
    person := Person{
        Name:    "Alice",
        Age:     30,
        Email:   "alice@example.com",
        Address: "123 Main St",
    }
    
    // 编码为JSON
    jsonData, err := json.Marshal(person)
    if err != nil {
        fmt.Printf("JSON marshal error: %v\n", err)
        return
    }
    fmt.Printf("JSON encoded: %s\n", jsonData)
    
    // 美化输出
    prettyJSON, err := json.MarshalIndent(person, "", "  ")
    if err != nil {
        fmt.Printf("JSON marshal indent error: %v\n", err)
        return
    }
    fmt.Printf("Pretty JSON:\n%s\n", prettyJSON)
    
    // JSON解码
    var decodedPerson Person
    err = json.Unmarshal(jsonData, &decodedPerson)
    if err != nil {
        fmt.Printf("JSON unmarshal error: %v\n", err)
        return
    }
    fmt.Printf("Decoded person: %+v\n", decodedPerson)
    
    // 处理省略的字段
    personWithoutEmail := Person{
        Name:    "Bob",
        Age:     25,
        Address: "456 Oak Ave",
        // Email字段为空，会被omitempty忽略
    }
    
    jsonData2, _ := json.Marshal(personWithoutEmail)
    fmt.Printf("Person without email: %s\n", jsonData2)
    
    // 数组和切片
    people := []Person{
        {Name: "Charlie", Age: 35, Email: "charlie@example.com", Address: "789 Pine St"},
        {Name: "Diana", Age: 28, Address: "321 Elm St"},
    }
    
    jsonArray, _ := json.Marshal(people)
    fmt.Printf("JSON array: %s\n", jsonArray)
    
    var decodedPeople []Person
    json.Unmarshal(jsonArray, &decodedPeople)
    fmt.Printf("Decoded people: %+v\n", decodedPeople)
    
    // 嵌套结构体
    company := Company{
        Name: "Tech Corp",
        Employees: people,
    }
    
    companyJSON, _ := json.Marshal(company)
    fmt.Printf("Company JSON: %s\n", companyJSON)
    
    // 使用流式编码器
    var buf bytes.Buffer
    encoder := json.NewEncoder(&buf)
    encoder.SetIndent("", "  ")
    
    company2 := Company{
        Name: "Innovation Inc",
        Employees: []Person{
            {Name: "Eve", Age: 32, Email: "eve@innovation.com", Address: "555 Tech Blvd"},
        },
    }
    
    encoder.Encode(company2)
    fmt.Printf("Stream encoded:\n%s\n", buf.String())
    
    // 流式解码器
    decoder := json.NewDecoder(&buf)
    var decodedCompany Company
    decoder.Decode(&decodedCompany)
    fmt.Printf("Stream decoded company: %+v\n", decodedCompany)
    
    // 处理JSON数字
    jsonNumbers := `{"integer": 42, "float": 3.14, "string_number": "123"}`
    
    var numberData map[string]interface{}
    json.Unmarshal([]byte(jsonNumbers), &numberData)
    
    fmt.Printf("Number data: %+v\n", numberData)
    fmt.Printf("Integer type: %T\n", numberData["integer"])
    fmt.Printf("Float type: %T\n", numberData["float"])
    fmt.Printf("String number type: %T\n", numberData["string_number"])
    
    // 自定义JSON处理
    customJSON := `{"name": "Frank", "tags": ["developer", "golang", "backend"]}`
    
    var customData struct {
        Name string   `json:"name"`
        Tags []string `json:"tags"`
    }
    
    json.Unmarshal([]byte(customJSON), &customData)
    fmt.Printf("Custom data: %+v\n", customData)
    
    // 错误处理
    invalidJSON := `{"name": "Invalid", "age": }`  // 语法错误
    var invalidPerson Person
    err = json.Unmarshal([]byte(invalidJSON), &invalidPerson)
    if err != nil {
        fmt.Printf("JSON parse error: %v\n", err)
        // 可以获取更详细的错误信息
        if syntaxErr, ok := err.(*json.SyntaxError); ok {
            fmt.Printf("Syntax error at offset %d\n", syntaxErr.Offset)
        }
    }
}

// XML示例结构体
type XMLPerson struct {
    XMLName xml.Name `xml:"person"`
    Name    string   `xml:"name"`
    Age     int      `xml:"age"`
    Email   string   `xml:"email,omitempty"`
}

type XMLCompany struct {
    XMLName   xml.Name    `xml:"company"`
    Name      string      `xml:"name"`
    Employees []XMLPerson `xml:"employee"`
}

func demonstrateXML() {
    // 基本XML编码
    person := XMLPerson{
        Name:  "Alice",
        Age:   30,
        Email: "alice@example.com",
    }
    
    xmlData, err := xml.Marshal(person)
    if err != nil {
        fmt.Printf("XML marshal error: %v\n", err)
        return
    }
    fmt.Printf("XML encoded: %s\n", xmlData)
    
    // 美化输出
    prettyXML, err := xml.MarshalIndent(person, "", "  ")
    if err != nil {
        fmt.Printf("XML marshal indent error: %v\n", err)
        return
    }
    fmt.Printf("Pretty XML:\n%s\n", prettyXML)
    
    // 添加XML声明
    var buf bytes.Buffer
    buf.WriteString(xml.Header)
    xml.NewEncoder(&buf).Encode(person)
    fmt.Printf("XML with header:\n%s", buf.String())
    
    // XML解码
    var decodedPerson XMLPerson
    err = xml.Unmarshal(xmlData, &decodedPerson)
    if err != nil {
        fmt.Printf("XML unmarshal error: %v\n", err)
        return
    }
    fmt.Printf("Decoded person: %+v\n", decodedPerson)
    
    // 复杂XML结构
    company := XMLCompany{
        Name: "Tech Corp",
        Employees: []XMLPerson{
            {Name: "Bob", Age: 25},
            {Name: "Charlie", Age: 35, Email: "charlie@example.com"},
        },
    }
    
    companyXML, _ := xml.MarshalIndent(company, "", "  ")
    fmt.Printf("Company XML:\n%s\n", companyXML)
    
    // 属性处理
    type Product struct {
        XMLName xml.Name `xml:"product"`
        ID      string   `xml:"id,attr"`
        Name    string   `xml:"name"`
        Price   float64  `xml:"price"`
    }
    
    product := Product{
        ID:    "P001",
        Name:  "Laptop",
        Price: 999.99,
    }
    
    productXML, _ := xml.Marshal(product)
    fmt.Printf("Product with attributes: %s\n", productXML)
}

func demonstrateBase64() {
    // 基本Base64编码
    data := "Hello, World! This is a test message."
    encoded := base64.StdEncoding.EncodeToString([]byte(data))
    fmt.Printf("Base64 encoded: %s\n", encoded)
    
    // Base64解码
    decoded, err := base64.StdEncoding.DecodeString(encoded)
    if err != nil {
        fmt.Printf("Base64 decode error: %v\n", err)
        return
    }
    fmt.Printf("Base64 decoded: %s\n", string(decoded))
    
    // URL安全的Base64编码
    urlSafeEncoded := base64.URLEncoding.EncodeToString([]byte(data))
    fmt.Printf("URL-safe encoded: %s\n", urlSafeEncoded)
    
    urlSafeDecoded, _ := base64.URLEncoding.DecodeString(urlSafeEncoded)
    fmt.Printf("URL-safe decoded: %s\n", string(urlSafeDecoded))
    
    // Raw编码（不使用填充字符）
    rawEncoded := base64.RawStdEncoding.EncodeToString([]byte(data))
    fmt.Printf("Raw encoded: %s\n", rawEncoded)
    
    // 处理二进制数据
    binaryData := []byte{0xFF, 0x00, 0xAA, 0x55, 0x12, 0x34}
    binaryEncoded := base64.StdEncoding.EncodeToString(binaryData)
    fmt.Printf("Binary encoded: %s\n", binaryEncoded)
    
    binaryDecoded, _ := base64.StdEncoding.DecodeString(binaryEncoded)
    fmt.Printf("Binary decoded: %v\n", binaryDecoded)
    
    // 流式编码
    var buf bytes.Buffer
    encoder := base64.NewEncoder(base64.StdEncoding, &buf)
    encoder.Write([]byte("Streaming base64 encoding"))
    encoder.Close()  // 必须调用Close来刷新缓冲区
    fmt.Printf("Stream encoded: %s\n", buf.String())
    
    // 流式解码
    decoder := base64.NewDecoder(base64.StdEncoding, &buf)
    decodedStream := make([]byte, 100)
    n, _ := decoder.Read(decodedStream)
    fmt.Printf("Stream decoded: %s\n", string(decodedStream[:n]))
}

func demonstrateHex() {
    // 基本十六进制编码
    data := "Hello, Hex World!"
    encoded := hex.EncodeToString([]byte(data))
    fmt.Printf("Hex encoded: %s\n", encoded)
    
    // 十六进制解码
    decoded, err := hex.DecodeString(encoded)
    if err != nil {
        fmt.Printf("Hex decode error: %v\n", err)
        return
    }
    fmt.Printf("Hex decoded: %s\n", string(decoded))
    
    // 大写十六进制
    encodedUpper := fmt.Sprintf("%X", []byte(data))
    fmt.Printf("Hex uppercase: %s\n", encodedUpper)
    
    // 处理字节切片
    bytesData := []byte{0xDE, 0xAD, 0xBE, 0xEF}
    hexString := hex.EncodeToString(bytesData)
    fmt.Printf("Bytes to hex: %s\n", hexString)
    
    decodedBytes, _ := hex.DecodeString(hexString)
    fmt.Printf("Hex to bytes: %v\n", decodedBytes)
    
    // 格式化输出
    for i, b := range bytesData {
        fmt.Printf("Byte %d: 0x%02X\n", i, b)
    }
}

// 自定义编码器示例
type CustomEncoder struct {
    data []byte
}

func (ce *CustomEncoder) Encode() string {
    // 简单的自定义编码：每个字节加1
    encoded := make([]byte, len(ce.data))
    for i, b := range ce.data {
        encoded[i] = b + 1
    }
    return base64.StdEncoding.EncodeToString(encoded)
}

func (ce *CustomEncoder) Decode(encoded string) ([]byte, error) {
    decoded, err := base64.StdEncoding.DecodeString(encoded)
    if err != nil {
        return nil, err
    }
    
    // 解码：每个字节减1
    original := make([]byte, len(decoded))
    for i, b := range decoded {
        original[i] = b - 1
    }
    return original, nil
}

func demonstrateCustomEncoding() {
    original := "Custom encoding test"
    encoder := &CustomEncoder{data: []byte(original)}
    
    encoded := encoder.Encode()
    fmt.Printf("Custom encoded: %s\n", encoded)
    
    decoded, err := encoder.Decode(encoded)
    if err != nil {
        fmt.Printf("Custom decode error: %v\n", err)
        return
    }
    fmt.Printf("Custom decoded: %s\n", string(decoded))
}

// 编码性能测试
func encodingPerformance() {
    // 生成测试数据
    testData := make([]byte, 10000)
    for i := range testData {
        testData[i] = byte(i % 256)
    }
    
    fmt.Println("Encoding performance test:")
    
    // Base64编码性能
    start := time.Now()
    for i := 0; i < 1000; i++ {
        base64.StdEncoding.EncodeToString(testData)
    }
    duration := time.Since(start)
    fmt.Printf("Base64 encoding: %v\n", duration)
    
    // Hex编码性能
    start = time.Now()
    for i := 0; i < 1000; i++ {
        hex.EncodeToString(testData)
    }
    duration = time.Since(start)
    fmt.Printf("Hex encoding: %v\n", duration)
    
    // JSON编码性能
    person := Person{
        Name:    "Performance Test",
        Age:     25,
        Email:   "test@example.com",
        Address: "Performance Testing Address",
    }
    
    start = time.Now()
    for i := 0; i < 1000; i++ {
        json.Marshal(person)
    }
    duration = time.Since(start)
    fmt.Printf("JSON encoding: %v\n", duration)
}
```

### crypto包（加密解密）

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/hmac"
    "crypto/md5"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "fmt"
    "io"
)

func demonstrateHashing() {
    // MD5哈希
    data := "Hello, World!"
    md5Hash := md5.Sum([]byte(data))
    fmt.Printf("MD5: %x\n", md5Hash)
    
    // SHA256哈希
    sha256Hash := sha256.Sum256([]byte(data))
    fmt.Printf("SHA256: %x\n", sha256Hash)
    
    // 使用hash包进行流式哈希计算
    hasher := sha256.New()
    hasher.Write([]byte("Hello, "))
    hasher.Write([]byte("World!"))
    hashBytes := hasher.Sum(nil)
    fmt.Printf("Stream SHA256: %x\n", hashBytes)
    
    // HMAC（基于哈希的消息认证码）
    key := []byte("secret-key")
    message := []byte("important message")
    
    // HMAC-SHA256
    h := hmac.New(sha256.New, key)
    h.Write(message)
    mac := h.Sum(nil)
    fmt.Printf("HMAC-SHA256: %x\n", mac)
    
    // 验证HMAC
    expectedMAC := mac
    hVerify := hmac.New(sha256.New, key)
    hVerify.Write(message)
    actualMAC := hVerify.Sum(nil)
    
    if hmac.Equal(expectedMAC, actualMAC) {
        fmt.Println("HMAC verification successful")
    } else {
        fmt.Println("HMAC verification failed")
    }
}

func demonstrateAES() {
    // AES加密示例
    key := []byte("thisis32bytekeyforaes256crypto")
    plaintext := []byte("This is a secret message")
    
    // 创建AES cipher
    block, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf("AES cipher error: %v\n", err)
        return
    }
    
    // 生成随机IV
    iv := make([]byte, aes.BlockSize)
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        fmt.Printf("IV generation error: %v\n", err)
        return
    }
    
    // 填充明文到块大小的倍数
    paddedPlaintext := pkcs7Pad(plaintext, aes.BlockSize)
    
    // CBC模式加密
    mode := cipher.NewCBCEncrypter(block, iv)
    ciphertext := make([]byte, len(paddedPlaintext))
    mode.CryptBlocks(ciphertext, paddedPlaintext)
    
    // 组合IV和密文以便解密
    encryptedData := append(iv, ciphertext...)
    encodedData := base64.StdEncoding.EncodeToString(encryptedData)
    fmt.Printf("AES encrypted: %s\n", encodedData)
    
    // 解密
    decodedData, _ := base64.StdEncoding.DecodeString(encodedData)
    iv = decodedData[:aes.BlockSize]
    ciphertext = decodedData[aes.BlockSize:]
    
    modeDecrypt := cipher.NewCBCDecrypter(block, iv)
    paddedPlaintextDecrypted := make([]byte, len(ciphertext))
    modeDecrypt.CryptBlocks(paddedPlaintextDecrypted, ciphertext)
    
    // 去除填充
    plaintextDecrypted, err := pkcs7Unpad(paddedPlaintextDecrypted)
    if err != nil {
        fmt.Printf("Unpad error: %v\n", err)
        return
    }
    
    fmt.Printf("AES decrypted: %s\n", string(plaintextDecrypted))
}

// PKCS#7填充
func pkcs7Pad(data []byte, blockSize int) []byte {
    padding := blockSize - len(data)%blockSize
    padtext := bytes.Repeat([]byte{byte(padding)}, padding)
    return append(data, padtext...)
}

// PKCS#7去填充
func pkcs7Unpad(data []byte) ([]byte, error) {
    length := len(data)
    if length == 0 {
        return nil, fmt.Errorf("pkcs7Unpad: invalid padding size")
    }
    unpadding := int(data[length-1])
    if unpadding > length {
        return nil, fmt.Errorf("pkcs7Unpad: invalid padding")
    }
    return data[:(length - unpadding)], nil
}

// GCM模式加密（推荐用于现代应用）
func demonstrateAESGCM() {
    // 生成密钥
    key := make([]byte, 32) // 256位密钥
    if _, err := rand.Read(key); err != nil {
        fmt.Printf("Key generation error: %v\n", err)
        return
    }
    
    plaintext := []byte("Secret message for GCM encryption")
    
    // 创建cipher
    block, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf("Cipher creation error: %v\n", err)
        return
    }
    
    // 创建GCM
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        fmt.Printf("GCM creation error: %v\n", err)
        return
    }
    
    // 生成nonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        fmt.Printf("Nonce generation error: %v\n", err)
        return
    }
    
    // 加密
    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    encodedCiphertext := base64.StdEncoding.EncodeToString(ciphertext)
    fmt.Printf("GCM encrypted: %s\n", encodedCiphertext)
    
    // 解密
    decodedCiphertext, _ := base64.StdEncoding.DecodeString(encodedCiphertext)
    
    nonce, ciphertext = decodedCiphertext[:gcm.NonceSize()], decodedCiphertext[gcm.NonceSize():]
    
    plaintextDecrypted, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        fmt.Printf("Decryption error: %v\n", err)
        return
    }
    
    fmt.Printf("GCM decrypted: %s\n", string(plaintextDecrypted))
}

// 密码学安全的随机数生成
func demonstrateCryptoRand() {
    // 生成随机字节
    randomBytes := make([]byte, 32)
    if _, err := rand.Read(randomBytes); err != nil {
        fmt.Printf("Random read error: %v\n", err)
        return
    }
    fmt.Printf("Random bytes: %x\n", randomBytes)
    
    // 生成随机整数
    var randomInt int64
    if err := binary.Read(rand.Reader, binary.LittleEndian, &randomInt); err != nil {
        fmt.Printf("Random int error: %v\n", err)
        return
    }
    fmt.Printf("Random int: %d\n", randomInt)
    
    // 生成范围内的随机数
    max := int64(100)
    randomInRange := randomInt % max
    if randomInRange < 0 {
        randomInRange = -randomInRange
    }
    fmt.Printf("Random in range [0,%d): %d\n", max, randomInRange)
}

// 数字签名示例（使用RSA）
import (
    "crypto"
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha256"
)

func demonstrateDigitalSignature() {
    // 生成RSA密钥对
    privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
    if err != nil {
        fmt.Printf("Key generation error: %v\n", err)
        return
    }
    publicKey := &privateKey.PublicKey
    
    message := []byte("This is a signed message")
    
    // 创建消息摘要
    hash := sha256.Sum256(message)
    
    // 签名
    signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hash[:])
    if err != nil {
        fmt.Printf("Signature error: %v\n", err)
        return
    }
    
    fmt.Printf("Signature: %x\n", signature)
    
    // 验证签名
    err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hash[:], signature)
    if err != nil {
        fmt.Printf("Signature verification failed: %v\n", err)
    } else {
        fmt.Println("Signature verification successful")
    }
}

// 密码学最佳实践示例
func cryptoBestPractices() {
    // 1. 使用足够强度的密钥
    strongKey := make([]byte, 32) // 256位
    if _, err := rand.Read(strongKey); err != nil {
        fmt.Printf("Key generation error: %v\n", err)
        return
    }
    
    // 2. 使用安全的随机数
    nonce := make([]byte, 12) // GCM推荐的nonce大小
    if _, err := rand.Read(nonce); err != nil {
        fmt.Printf("Nonce generation error: %v\n", err)
        return
    }
    
    // 3. 使用认证加密（如GCM）
    // 参见前面的AES-GCM示例
    
    // 4. 密钥派生函数示例（简化版）
    password := "user_password"
    salt := make([]byte, 16)
    rand.Read(salt)
    
    // 实际应用中应该使用bcrypt、scrypt或argon2
    // 这里仅作演示
    derivedKey := sha256.Sum256(append([]byte(password), salt...))
    fmt.Printf("Derived key: %x\n", derivedKey)
    
    // 5. 安全的字符串比较（防止时序攻击）
    func secureCompare(a, b []byte) bool {
        if len(a) != len(b) {
            return false
        }
        var result byte
        for i := 0; i < len(a); i++ {
            result |= a[i] ^ b[i]
        }
        return result == 0
    }
    
    // 6. 密码哈希（实际应用中使用bcrypt等）
    passwordToHash := "my_secure_password"
    passwordHash := sha256.Sum256([]byte(passwordToHash))
    fmt.Printf("Password hash: %x\n", passwordHash)
}

// 性能测试和基准测试
func cryptoPerformance() {
    // 测试不同哈希算法的性能
    testData := make([]byte, 1000)
    rand.Read(testData)
    
    fmt.Println("Crypto performance test:")
    
    // SHA256性能
    start := time.Now()
    for i := 0; i < 10000; i++ {
        sha256.Sum256(testData)
    }
    duration := time.Since(start)
    fmt.Printf("SHA256 hashing: %v\n", duration)
    
    // HMAC性能
    key := make([]byte, 32)
    rand.Read(key)
    
    start = time.Now()
    for i := 0; i < 10000; i++ {
        h := hmac.New(sha256.New, key)
        h.Write(testData)
        h.Sum(nil)
    }
    duration = time.Since(start)
    fmt.Printf("HMAC-SHA256: %v\n", duration)
}

func main() {
    fmt.Println("=== fmt包演示 ===")
    demonstrateFmt()
    
    fmt.Println("\n=== strconv包演示 ===")
    demonstrateStrconv()
    
    fmt.Println("\n=== strings包演示 ===")
    demonstrateStrings()
    advancedStringOperations()
    
    fmt.Println("\n=== bytes包演示 ===")
    demonstrateBytes()
    efficientByteProcessing()
    
    fmt.Println("\n=== time包演示 ===")
    demonstrateTime()
    measurePerformance()
    
    fmt.Println("\n=== math包演示 ===")
    demonstrateMath()
    demonstrateRandom()
    mathematicalCalculations()
    
    fmt.Println("\n=== sort包演示 ===")
    demonstrateSort()
    complexSorting()
    
    fmt.Println("\n=== regexp包演示 ===")
    demonstrateRegexp()
    validateInput()
    textProcessing()
    
    fmt.Println("\n=== encoding包演示 ===")
    demonstrateJSON()
    demonstrateXML()
    demonstrateBase64()
    demonstrateHex()
    demonstrateCustomEncoding()
    encodingPerformance()
    
    fmt.Println("\n=== crypto包演示 ===")
    demonstrateHashing()
    demonstrateAES()
    demonstrateAESGCM()
    demonstrateCryptoRand()
    demonstrateDigitalSignature()
    cryptoBestPractices()
    cryptoPerformance()
}
```