## 2.1 变量和常量

### 变量声明方式

#### 1. 标准声明（var）
```go
// 声明并初始化
var name string = "Go"
var age int = 20

// 声明不初始化（使用零值）
var score int
var message string

// 批量声明
var (
    x int
    y float64 = 3.14
    z string = "hello"
)

// 类型推导
var count = 100
var pi = 3.14159
```

#### 2. 短声明（:=）
```go
// 只能在函数内部使用
func main() {
    name := "Go"        // 等价于 var name = "Go"
    age := 20          // 等价于 var age = 20
    x, y := 10, 20     // 同时声明多个变量
    
    // 短声明也可以重新赋值已存在的变量
    age, height := 21, 180  // age重新赋值，height是新变量
}
```

### 变量作用域

Go语言的作用域遵循词法作用域规则：

```go
package main

import "fmt"

var globalVar = "全局变量"  // 包级作用域

func main() {
    localVar := "局部变量"   // 函数级作用域
    
    if true {
        blockVar := "块级变量"  // 块级作用域
        fmt.Println(globalVar, localVar, blockVar)
    }
    
    // fmt.Println(blockVar)  // 错误：blockVar作用域已结束
    
    for i := 0; i < 3; i++ {
        loopVar := i        // 每次循环都有新的作用域
        fmt.Println(loopVar)
    }
    // fmt.Println(i)        // 错误：i作用域已结束
}
```

### 常量定义

常量在编译时确定，运行时不能修改：

```go
// 基本常量声明
const PI = 3.14159
const MaxSize int = 1024
const isActive = true

// 批量声明
const (
    StatusOK = 200
    StatusNotFound = 404
    StatusError = 500
)

// 常量组中的类型推导
const (
    a = iota    // 0
    b           // 1
    c           // 2
    d           // 3
)
```

### iota枚举

iota是Go语言的枚举生成器：

```go
const (
    Monday = iota   // 0
    Tuesday         // 1
    Wednesday       // 2
    Thursday        // 3
    Friday          // 4
    Saturday        // 5
    Sunday          // 6
)

// 跳过值
const (
    None = iota * 10  // 0
    _                 // 跳过10
    Low               // 20
    Medium            // 30
    High              // 40
)

// 位掩码
const (
    Readable = 1 << iota  // 1
    Writable              // 2
    Executable            // 4
)

// 自定义步长
const (
    A = iota * 2 + 1  // 1
    B                 // 3
    C                 // 5
    D                 // 7
)
```

### 变量命名规范

```go
// ✅ 正确的命名
var userName string
var userID int
var htmlParser string
var URL string
var HTTPStatus int

// ❌ 不推荐的命名
var user_name string  // 不要使用下划线
var User string       // 包级变量不要首字母大写（除非导出）
var u string          // 避免单字母变量（除非循环计数器）

// 函数内短变量名
for i := 0; i < 10; i++ {
    // i, j, k 通常用于循环计数器
}

// 多个变量声明
var (
    firstName, lastName string
    age                int
    email              string
)
```

### 零值概念

Go语言中未初始化的变量会获得其类型的零值：

```go
package main

import "fmt"

func main() {
    // 数值类型的零值是0
    var num int
    var fnum float64
    var cnum complex128
    
    // 布尔类型的零值是false
    var flag bool
    
    // 字符串类型的零值是空字符串
    var str string
    
    // 指针类型的零值是nil
    var ptr *int
    
    // 切片、映射、通道的零值是nil
    var slice []int
    var m map[string]int
    var ch chan int
    
    fmt.Printf("int: %d\n", num)           // 0
    fmt.Printf("float: %f\n", fnum)        // 0.000000
    fmt.Printf("complex: %v\n", cnum)      // (0+0i)
    fmt.Printf("bool: %t\n", flag)         // false
    fmt.Printf("string: '%s'\n", str)      // ''
    fmt.Printf("pointer: %v\n", ptr)       // <nil>
    fmt.Printf("slice: %v\n", slice)       // []
    fmt.Printf("map: %v\n", m)             // map[]
    fmt.Printf("channel: %v\n", ch)        // <nil>
}
```

### 变量生命周期

```go
package main

import "fmt"

var globalVar = "I'm global"  // 程序启动到结束

func createClosure() func() {
    localVar := "I'm local"   // 函数调用开始到返回值不再被引用
    
    return func() {
        fmt.Println(localVar) // 闭包延长了localVar的生命周期
    }
}

func main() {
    closure := createClosure()
    closure()  // 输出: I'm local
    
    // 栈上分配的变量
    stackVar := "stack"  // 函数结束时销毁
    
    // 堆上分配的变量（逃逸分析）
    heapVar := new(string)
    *heapVar = "heap"    // 当有指针引用时可能分配到堆上
    
    fmt.Println(stackVar, *heapVar)
    
    // 循环中的变量
    for i := 0; i < 3; i++ {
        loopVar := i  // 每次迭代创建新变量
        fmt.Println(loopVar)
    }
}
```