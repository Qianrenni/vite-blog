## 2.2 数据类型

### 基本数据类型

#### 数值类型

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // 整数类型
    var a int8 = 127        // -128 to 127
    var b int16 = 32767     // -32768 to 32767
    var c int32 = 2147483647 // -2147483648 to 2147483647
    var d int64 = 9223372036854775807 // 大范围
    
    // 无符号整数
    var ua uint8 = 255
    var ub uint16 = 65535
    var uc uint32 = 4294967295
    var ud uint64 = 18446744073709551615
    
    // 浮点数
    var f32 float32 = 3.14159
    var f64 float64 = math.Pi
    
    // 复数
    var c64 complex64 = 3 + 4i
    var c128 complex128 = complex(3.14, 2.71)
    
    fmt.Printf("整数: %d %d %d %d\n", a, b, c, d)
    fmt.Printf("无符号: %d %d %d %d\n", ua, ub, uc, ud)
    fmt.Printf("浮点: %f %f\n", f32, f64)
    fmt.Printf("复数: %v %v\n", c64, c128)
    fmt.Printf("复数实部: %f, 虚部: %f\n", real(c128), imag(c128))
}
```

#### 布尔类型

```go
package main

import "fmt"

func main() {
    var flag1 bool = true
    flag2 := false
    
    // 逻辑运算
    result1 := flag1 && flag2  // 逻辑与
    result2 := flag1 || flag2  // 逻辑或
    result3 := !flag1          // 逻辑非
    
    fmt.Printf("flag1: %t, flag2: %t\n", flag1, flag2)
    fmt.Printf("AND: %t, OR: %t, NOT: %t\n", result1, result2, result3)
    
    // 布尔表达式
    x, y := 10, 20
    fmt.Printf("x > y: %t\n", x > y)
    fmt.Printf("x == y: %t\n", x == y)
    fmt.Printf("x <= y: %t\n", x <= y)
}
```

#### 字符串类型

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    // 字符串声明
    var str1 string = "Hello"
    str2 := "World"
    str3 := `原始字符串
可以包含
换行符`
    
    // 字符串连接
    result := str1 + " " + str2
    fmt.Println(result)
    fmt.Println(str3)
    
    // 字符串长度
    fmt.Printf("Length of '%s': %d\n", result, len(result))
    
    // 字符串遍历
    for i, char := range result {
        fmt.Printf("Index: %d, Char: %c\n", i, char)
    }
    
    // 字符串比较
    fmt.Printf("Equal: %t\n", strings.Compare("abc", "abc") == 0)
    fmt.Printf("Contains: %t\n", strings.Contains("hello", "ell"))
    
    // 字符串修改（需要转换为字节切片）
    mutableStr := []byte("Hello")
    mutableStr[0] = 'h'
    fmt.Println(string(mutableStr))
}
```

#### 字符类型（rune）

```go
package main

import "fmt"

func main() {
    // rune是int32的别名，用于表示Unicode字符
    var ch1 rune = 'A'
    ch2 := '中'  // 中文字符
    ch3 := '\n'  // 转义字符
    ch4 := '\u6587' // Unicode码点
    
    fmt.Printf("ASCII字符: %c (值: %d)\n", ch1, ch1)
    fmt.Printf("中文字符: %c (值: %d)\n", ch2, ch2)
    fmt.Printf("转义字符: %c (值: %d)\n", ch3, ch3)
    fmt.Printf("Unicode字符: %c (值: %d)\n", ch4, ch4)
    
    // 遍历包含中文的字符串
    str := "Hello世界"
    for i, r := range str {
        fmt.Printf("Index: %d, Rune: %c\n", i, r)
    }
}
```

#### 字节类型（byte）

```go
package main

import "fmt"

func main() {
    // byte是uint8的别名
    var b1 byte = 'A'
    b2 := byte(65)
    
    fmt.Printf("Byte as char: %c\n", b1)
    fmt.Printf("Byte as number: %d\n", b2)
    
    // 字节切片
    data := []byte{'H', 'e', 'l', 'l', 'o'}
    fmt.Println(string(data))
    
    // 字符串转字节切片
    str := "Hello"
    bytes := []byte(str)
    fmt.Printf("Bytes: %v\n", bytes)
    
    // 字节切片转字符串
    newStr := string(bytes)
    fmt.Printf("String: %s\n", newStr)
}
```

### 复合数据类型

#### 数组

```go
package main

import "fmt"

func main() {
    // 数组声明
    var arr1 [5]int                    // 长度为5的整数数组
    arr2 := [5]int{1, 2, 3, 4, 5}      // 初始化
    arr3 := [...]int{1, 2, 3}          // 编译器推导长度
    arr4 := [5]int{1: 10, 4: 50}       // 指定索引初始化
    
    fmt.Printf("arr1: %v\n", arr1)
    fmt.Printf("arr2: %v\n", arr2)
    fmt.Printf("arr3: %v\n", arr3)
    fmt.Printf("arr4: %v\n", arr4)
    
    // 数组长度
    fmt.Printf("Length of arr2: %d\n", len(arr2))
    
    // 数组遍历
    for i := 0; i < len(arr2); i++ {
        fmt.Printf("arr2[%d] = %d\n", i, arr2[i])
    }
    
    // range遍历
    for index, value := range arr2 {
        fmt.Printf("Index: %d, Value: %d\n", index, value)
    }
    
    // 数组是值类型（复制）
    arr5 := arr2
    arr5[0] = 100
    fmt.Printf("Original: %v, Copy: %v\n", arr2, arr5)
    
    // 多维数组
    var matrix [3][3]int
    matrix[0][0] = 1
    fmt.Printf("Matrix: %v\n", matrix)
}
```

#### 切片（slice）

```go
package main

import "fmt"

func main() {
    // 创建切片
    var slice1 []int                    // nil切片
    slice2 := make([]int, 5)            // 长度为5的切片
    slice3 := make([]int, 3, 10)        // 长度3，容量10
    slice4 := []int{1, 2, 3, 4, 5}      // 字面量创建
    
    fmt.Printf("slice1: %v, len: %d, cap: %d\n", slice1, len(slice1), cap(slice1))
    fmt.Printf("slice2: %v, len: %d, cap: %d\n", slice2, len(slice2), cap(slice2))
    fmt.Printf("slice3: %v, len: %d, cap: %d\n", slice3, len(slice3), cap(slice3))
    fmt.Printf("slice4: %v, len: %d, cap: %d\n", slice4, len(slice4), cap(slice4))
    
    // 从数组创建切片
    arr := [5]int{1, 2, 3, 4, 5}
    slice5 := arr[1:4]        // [2, 3, 4]
    slice6 := arr[:3]         // [1, 2, 3]
    slice7 := arr[2:]         // [3, 4, 5]
    
    fmt.Printf("slice5: %v\n", slice5)
    fmt.Printf("slice6: %v\n", slice6)
    fmt.Printf("slice7: %v\n", slice7)
    
    // 切片操作
    slice8 := append(slice4, 6, 7, 8)  // 添加元素
    fmt.Printf("After append: %v\n", slice8)
    
    // 切片复制
    slice9 := make([]int, len(slice8))
    copy(slice9, slice8)
    fmt.Printf("Copy: %v\n", slice9)
    
    // 切片是引用类型
    modifySlice(slice8)
    fmt.Printf("After modify: %v\n", slice8)
    
    // 切片扩容
    slice10 := make([]int, 0, 2)
    for i := 0; i < 10; i++ {
        slice10 = append(slice10, i)
        fmt.Printf("len: %d, cap: %d\n", len(slice10), cap(slice10))
    }
}

func modifySlice(s []int) {
    if len(s) > 0 {
        s[0] = 999
    }
}
```

#### 映射（map）

```go
package main

import "fmt"

func main() {
    // 创建map
    var map1 map[string]int              // nil map
    map2 := make(map[string]int)         // 空map
    map3 := map[string]int{              // 字面量初始化
        "apple":  5,
        "banana": 3,
        "orange": 8,
    }
    
    fmt.Printf("map1: %v\n", map1)
    fmt.Printf("map2: %v\n", map2)
    fmt.Printf("map3: %v\n", map3)
    
    // map操作
    map2["key1"] = 100
    map2["key2"] = 200
    
    // 访问元素
    value, exists := map2["key1"]
    if exists {
        fmt.Printf("key1 exists, value: %d\n", value)
    }
    
    // 删除元素
    delete(map2, "key1")
    fmt.Printf("After delete: %v\n", map2)
    
    // 遍历map
    for key, value := range map3 {
        fmt.Printf("Key: %s, Value: %d\n", key, value)
    }
    
    // 获取map长度
    fmt.Printf("Length of map3: %d\n", len(map3))
    
    // map是引用类型
    modifyMap(map3)
    fmt.Printf("After modify: %v\n", map3)
    
    // 检查key是否存在
    if val, ok := map3["grape"]; ok {
        fmt.Printf("grape: %d\n", val)
    } else {
        fmt.Println("grape not found")
    }
}

func modifyMap(m map[string]int) {
    m["apple"] = 999
}
```

#### 结构体（struct）

```go
package main

import "fmt"

// 定义结构体
type Person struct {
    Name    string
    Age     int
    Email   string
    Address string
}

// 嵌套结构体
type Company struct {
    Name    string
    Address string
    CEO     Person
}

// 匿名字段（嵌入）
type Employee struct {
    Person   // 嵌入Person结构体
    Salary   float64
    Position string
}

func main() {
    // 创建结构体实例
    var p1 Person
    p1.Name = "Alice"
    p1.Age = 30
    p1.Email = "alice@example.com"
    
    // 字面量初始化
    p2 := Person{
        Name:  "Bob",
        Age:   25,
        Email: "bob@example.com",
    }
    
    // 顺序初始化（必须指定所有字段）
    p3 := Person{"Charlie", 35, "charlie@example.com", "New York"}
    
    // 部分初始化
    p4 := Person{
        Name: "David",
        Age:  28,
    }
    
    fmt.Printf("p1: %+v\n", p1)
    fmt.Printf("p2: %+v\n", p2)
    fmt.Printf("p3: %+v\n", p3)
    fmt.Printf("p4: %+v\n", p4)
    
    // 访问字段
    fmt.Printf("Name: %s, Age: %d\n", p2.Name, p2.Age)
    
    // 指针结构体
    p5 := &Person{
        Name: "Eve",
        Age:  32,
    }
    fmt.Printf("p5: %+v\n", *p5)
    fmt.Printf("Name via pointer: %s\n", p5.Name) // 自动解引用
    
    // 嵌套结构体
    company := Company{
        Name:    "Tech Corp",
        Address: "Silicon Valley",
        CEO: Person{
            Name:  "John CEO",
            Age:   45,
            Email: "john@techcorp.com",
        },
    }
    fmt.Printf("Company: %+v\n", company)
    fmt.Printf("CEO Name: %s\n", company.CEO.Name)
    
    // 匿名字段
    emp := Employee{
        Person: Person{
            Name:  "Frank",
            Age:   29,
            Email: "frank@company.com",
        },
        Salary:   50000,
        Position: "Developer",
    }
    fmt.Printf("Employee: %+v\n", emp)
    fmt.Printf("Employee Name: %s\n", emp.Name) // 直接访问嵌入字段
}

// 结构体方法
func (p Person) String() string {
    return fmt.Sprintf("Person{Name: %s, Age: %d, Email: %s}", p.Name, p.Age, p.Email)
}
```

#### 指针

```go
package main

import "fmt"

func main() {
    // 声明指针
    var ptr *int
    var num int = 42
    
    // 获取地址
    ptr = &num
    fmt.Printf("num: %d, address: %p\n", num, &num)
    fmt.Printf("ptr: %p, value: %d\n", ptr, *ptr)
    
    // 修改指针指向的值
    *ptr = 100
    fmt.Printf("After modify: num = %d\n", num)
    
    // 创建指针的指针
    ptr2 := &ptr
    fmt.Printf("ptr2: %p, ptr it points to: %p, value: %d\n", ptr2, *ptr2, **ptr2)
    
    // 指针与函数
    increment(&num)
    fmt.Printf("After increment: num = %d\n", num)
    
    // new函数创建指针
    ptr3 := new(int)  // 创建指向int的指针，值为0
    fmt.Printf("new int pointer: %p, value: %d\n", ptr3, *ptr3)
    *ptr3 = 200
    fmt.Printf("After assignment: value: %d\n", *ptr3)
    
    // 指针与结构体
    type Point struct {
        X, Y int
    }
    
    point := Point{10, 20}
    pointPtr := &point
    pointPtr.X = 30  // 自动解引用
    fmt.Printf("Point: %+v\n", point)
    
    // 指针比较
    ptr4 := &num
    fmt.Printf("ptr == ptr4: %t\n", ptr == ptr4)
    fmt.Printf("ptr == nil: %t\n", ptr == nil)
}

func increment(n *int) {
    *n++
}
```

### 类型转换和类型断言

```go
package main

import "fmt"

func main() {
    // 基本类型转换
    var a int = 42
    var b float64 = float64(a)
    var c int32 = int32(b)
    
    fmt.Printf("a: %d, b: %f, c: %d\n", a, b, c)
    
    // 字符串转换
    str := "123"
    num, err := strconv.Atoi(str)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Printf("String to int: %d\n", num)
    }
    
    // int转字符串
    str2 := strconv.Itoa(456)
    fmt.Printf("Int to string: %s\n", str2)
    
    // 安全的类型转换
    var x interface{} = 100
    if num, ok := x.(int); ok {
        fmt.Printf("x is int: %d\n", num)
    }
    
    // 类型断言
    var y interface{} = "hello"
    str3 := y.(string)  // 直接断言（如果失败会panic）
    fmt.Printf("String: %s\n", str3)
    
    // 安全的类型断言
    if str4, ok := y.(string); ok {
        fmt.Printf("Safe assertion: %s\n", str4)
    }
    
    // switch类型断言
    var z interface{} = 3.14
    switch v := z.(type) {
    case int:
        fmt.Printf("int: %d\n", v)
    case float64:
        fmt.Printf("float64: %f\n", v)
    case string:
        fmt.Printf("string: %s\n", v)
    default:
        fmt.Printf("unknown type: %T\n", v)
    }
}
```

### 类型别名和类型定义

```go
package main

import "fmt"

// 类型定义（创建新类型）
type Celsius float64
type Fahrenheit float64

// 类型别名（Go 1.9+）
type MyInt = int
type MyString = string

// 方法定义
func (c Celsius) String() string {
    return fmt.Sprintf("%g°C", c)
}

func (f Fahrenheit) String() string {
    return fmt.Sprintf("%g°F", f)
}

// 类型转换函数
func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
    return Celsius((f - 32) * 5 / 9)
}

func main() {
    // 使用自定义类型
    var tempC Celsius = 25.0
    var tempF Fahrenheit = 77.0
    
    fmt.Printf("Temperature: %s\n", tempC)
    fmt.Printf("Converted: %s\n", CToF(tempC))
    fmt.Printf("Back to C: %s\n", FToC(tempF))
    
    // 类型别名
    var myNum MyInt = 42
    var regularNum int = myNum  // 可以直接赋值，因为是别名
    fmt.Printf("MyInt: %d, int: %d\n", myNum, regularNum)
    
    // 类型定义需要显式转换
    // regularNum = tempC  // 错误：不能直接赋值
    regularNum = int(tempC)   // 需要转换
    fmt.Printf("Converted: %d\n", regularNum)
}
```

### 自定义类型

```go
package main

import (
    "fmt"
    "time"
)

// 自定义类型示例
type Duration time.Duration

// 为自定义类型添加方法
func (d Duration) Seconds() float64 {
    return time.Duration(d).Seconds()
}

func (d Duration) String() string {
    return time.Duration(d).String()
}

// 枚举类型
type Status int

const (
    StatusPending Status = iota
    StatusProcessing
    StatusCompleted
    StatusFailed
)

func (s Status) String() string {
    switch s {
    case StatusPending:
        return "Pending"
    case StatusProcessing:
        return "Processing"
    case StatusCompleted:
        return "Completed"
    case StatusFailed:
        return "Failed"
    default:
        return "Unknown"
    }
}

// 复杂的自定义类型
type User struct {
    ID        int
    Username  string
    Email     string
    CreatedAt time.Time
    Status    Status
}

// 构造函数
func NewUser(username, email string) *User {
    return &User{
        Username:  username,
        Email:     email,
        CreatedAt: time.Now(),
        Status:    StatusPending,
    }
}

// 方法
func (u *User) Activate() {
    u.Status = StatusProcessing
}

func (u *User) Complete() {
    u.Status = StatusCompleted
}

func (u *User) Fail() {
    u.Status = StatusFailed
}

func main() {
    // 使用自定义Duration类型
    var d Duration = Duration(time.Hour + 30*time.Minute)
    fmt.Printf("Duration: %s (%.0f seconds)\n", d, d.Seconds())
    
    // 使用枚举
    fmt.Printf("Status values: %s, %s, %s, %s\n",
        StatusPending, StatusProcessing, StatusCompleted, StatusFailed)
    
    // 使用User类型
    user := NewUser("john_doe", "john@example.com")
    fmt.Printf("New user: %+v\n", user)
    
    user.Activate()
    fmt.Printf("After activation: %s\n", user.Status)
    
    user.Complete()
    fmt.Printf("After completion: %s\n", user.Status)
}
```