## 4.3 面向对象特性

### 封装性

```go
// 包级封装
package bank

import "fmt"

// 私有字段（小写开头）
type account struct {
    owner   string
    balance float64
}

// 公有方法（大写开头）
func NewAccount(owner string, initialBalance float64) *account {
    if initialBalance < 0 {
        panic("Initial balance cannot be negative")
    }
    return &account{
        owner:   owner,
        balance: initialBalance,
    }
}

func (a *account) Deposit(amount float64) {
    if amount <= 0 {
        panic("Deposit amount must be positive")
    }
    a.balance += amount
    fmt.Printf("Deposited %.2f. New balance: %.2f\n", amount, a.balance)
}

func (a *account) Withdraw(amount float64) bool {
    if amount <= 0 {
        panic("Withdrawal amount must be positive")
    }
    if amount > a.balance {
        fmt.Println("Insufficient funds")
        return false
    }
    a.balance -= amount
    fmt.Printf("Withdrew %.2f. New balance: %.2f\n", amount, a.balance)
    return true
}

func (a *account) GetBalance() float64 {
    return a.balance
}

// 使用示例
func main() {
    acc := bank.NewAccount("Alice", 1000)
    acc.Deposit(500)
    acc.Withdraw(200)
    fmt.Printf("Final balance: %.2f\n", acc.GetBalance())
    
    // 无法直接访问私有字段
    // fmt.Println(acc.balance)  // 编译错误
}
```

### 组合优于继承

```go
// 错误的继承方式（Go不支持）
// type Animal struct { name string }
// type Dog extends Animal {}  // Go不支持

// 正确的组合方式
type Animal struct {
    Name string
    Age  int
}

func (a Animal) Info() string {
    return fmt.Sprintf("%s is %d years old", a.Name, a.Age)
}

type Mover interface {
    Move() string
}

type Barker interface {
    Bark() string
}

type Dog struct {
    Animal  // 组合
}

func (d Dog) Move() string {
    return "Dog is running"
}

func (d Dog) Bark() string {
    return "Woof!"
}

type Bird struct {
    Animal
    WingSpan float64
}

func (b Bird) Move() string {
    return "Bird is flying"
}

func (b Bird) Chirp() string {
    return "Tweet!"
}

func MakeMove(m Mover) {
    fmt.Println(m.Move())
}

func MakeSound(b Barker) {
    fmt.Println(b.Bark())
}

func main() {
    dog := Dog{Animal: Animal{Name: "Buddy", Age: 3}}
    bird := Bird{Animal: Animal{Name: "Robin", Age: 1}, WingSpan: 12.5}
    
    fmt.Println(dog.Info())  // Buddy is 3 years old
    fmt.Println(dog.Move())  // Dog is running
    fmt.Println(dog.Bark())  // Woof!
    
    MakeMove(dog)   // Dog is running
    MakeMove(bird)  // Bird is flying
}
```

### 多态性实现

```go
type Shape interface {
    Area() float64
    String() string
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) String() string {
    return fmt.Sprintf("Rectangle(%.2f x %.2f)", r.Width, r.Height)
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

func (c Circle) String() string {
    return fmt.Sprintf("Circle(radius: %.2f)", c.Radius)
}

type Triangle struct {
    Base, Height float64
}

func (t Triangle) Area() float64 {
    return 0.5 * t.Base * t.Height
}

func (t Triangle) String() string {
    return fmt.Sprintf("Triangle(base: %.2f, height: %.2f)", t.Base, t.Height)
}

// 多态函数
func PrintArea(s Shape) {
    fmt.Printf("%s has area %.2f\n", s.String(), s.Area())
}

func TotalArea(shapes []Shape) float64 {
    total := 0.0
    for _, shape := range shapes {
        total += shape.Area()
    }
    return total
}

func main() {
    shapes := []Shape{
        Rectangle{Width: 10, Height: 5},
        Circle{Radius: 3},
        Triangle{Base: 6, Height: 4},
    }
    
    // 多态调用
    for _, shape := range shapes {
        PrintArea(shape)
    }
    
    fmt.Printf("Total area: %.2f\n", TotalArea(shapes))
}
```

### 接口设计原则

```go
// 好的接口设计：小而专注
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// 组合使用
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// 避免过大的接口
// 不好的设计
type BadInterface interface {
    Read() []byte
    Write([]byte)
    Close() error
    Flush() error
    Seek(int64, int) (int64, error)
    // ... 更多方法
}

// 好的设计：按功能分离
type Flusher interface {
    Flush() error
}

type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}
```

### SOLID原则在Go中的应用

```go
// 1. 单一职责原则 (SRP)
type EmailSender struct{}

func (e EmailSender) SendEmail(to, subject, body string) error {
    // 发送邮件逻辑
    return nil
}

type SMSSender struct{}

func (s SMSSender) SendSMS(to, message string) error {
    // 发送短信逻辑
    return nil
}

// 2. 开闭原则 (OCP) - 对扩展开放，对修改关闭
type Notifier interface {
    Notify(message string) error
}

type EmailNotifier struct {
    sender EmailSender
}

func (e EmailNotifier) Notify(message string) error {
    return e.sender.SendEmail("user@example.com", "Notification", message)
}

type SMSNotifier struct {
    sender SMSSender
}

func (s SMSNotifier) Notify(message string) error {
    return s.sender.SendSMS("+1234567890", message)
}

// 3. 里氏替换原则 (LSP)
func SendNotification(n Notifier, message string) {
    n.Notify(message)  // 任何Notifier实现都可以替换
}

// 4. 接口隔离原则 (ISP)
type PaymentProcessor interface {
    ProcessPayment(amount float64) error
}

type RefundProcessor interface {
    ProcessRefund(amount float64) error
}

type CreditCardProcessor struct{}

func (c CreditCardProcessor) ProcessPayment(amount float64) error {
    // 处理信用卡支付
    return nil
}

func (c CreditCardProcessor) ProcessRefund(amount float64) error {
    // 处理信用卡退款
    return nil
}

// 5. 依赖倒置原则 (DIP)
type OrderService struct {
    paymentProcessor PaymentProcessor  // 依赖接口，不是具体实现
}

func (o OrderService) PlaceOrder(amount float64) error {
    return o.paymentProcessor.ProcessPayment(amount)
}

func main() {
    // 可以轻松切换不同的支付处理器
    var processor PaymentProcessor = CreditCardProcessor{}
    service := OrderService{paymentProcessor: processor}
    service.PlaceOrder(100.0)
}
```

### 设计模式实现

```go
// 1. 工厂模式
type Vehicle interface {
    Start() string
}

type Car struct{}

func (c Car) Start() string {
    return "Car started"
}

type Truck struct{}

func (t Truck) Start() string {
    return "Truck started"
}

func NewVehicle(vehicleType string) Vehicle {
    switch vehicleType {
    case "car":
        return Car{}
    case "truck":
        return Truck{}
    default:
        panic("Unknown vehicle type")
    }
}

// 2. 单例模式
type Database struct {
    connectionString string
}

var (
    dbInstance *Database
    once       sync.Once
)

func GetDatabase() *Database {
    once.Do(func() {
        dbInstance = &Database{connectionString: "localhost:5432"}
    })
    return dbInstance
}

// 3. 装饰器模式
type Coffee interface {
    Cost() float64
    Description() string
}

type SimpleCoffee struct{}

func (s SimpleCoffee) Cost() float64 {
    return 2.0
}

func (s SimpleCoffee) Description() string {
    return "Simple coffee"
}

type MilkDecorator struct {
    coffee Coffee
}

func (m MilkDecorator) Cost() float64 {
    return m.coffee.Cost() + 0.5
}

func (m MilkDecorator) Description() string {
    return m.coffee.Description() + ", milk"
}

// 4. 观察者模式
type Observer interface {
    Update(message string)
}

type Subject interface {
    Register(observer Observer)
    Unregister(observer Observer)
    NotifyAll(message string)
}

type NewsAgency struct {
    observers []Observer
    news      string
}

func (n *NewsAgency) Register(observer Observer) {
    n.observers = append(n.observers, observer)
}

func (n *NewsAgency) Unregister(observer Observer) {
    for i, obs := range n.observers {
        if obs == observer {
            n.observers = append(n.observers[:i], n.observers[i+1:]...)
            break
        }
    }
}

func (n *NewsAgency) NotifyAll(message string) {
    for _, observer := range n.observers {
        observer.Update(message)
    }
}

type NewsChannel struct {
    name string
}

func (n NewsChannel) Update(message string) {
    fmt.Printf("[%s] Received news: %s\n", n.name, message)
}

func main() {
    // 工厂模式
    car := NewVehicle("car")
    fmt.Println(car.Start())
    
    // 单例模式
    db1 := GetDatabase()
    db2 := GetDatabase()
    fmt.Println(db1 == db2)  // true
    
    // 装饰器模式
    coffee := SimpleCoffee{}
    coffeeWithMilk := MilkDecorator{coffee: coffee}
    fmt.Printf("%s: $%.2f\n", coffeeWithMilk.Description(), coffeeWithMilk.Cost())
    
    // 观察者模式
    agency := &NewsAgency{}
    channel1 := NewsChannel{name: "Channel 1"}
    channel2 := NewsChannel{name: "Channel 2"}
    
    agency.Register(channel1)
    agency.Register(channel2)
    agency.NotifyAll("Breaking news!")
}
```