## 3.3 错误处理

### error接口

```go
package main

import (
    "errors"
    "fmt"
    "io"
    "os"
    "strconv"
)

// error接口基本概念
func errorInterfaceBasics() {
    fmt.Println("=== error接口基本概念 ===")
    
    // error接口定义
    // type error interface {
    //     Error() string
    // }
    
    // 创建error的几种方式
    
    // 1. 使用errors.New
    err1 := errors.New("这是一个错误")
    fmt.Printf("errors.New: %v\n", err1)
    
    // 2. 使用fmt.Errorf
    err2 := fmt.Errorf("格式化错误: %s", "参数无效")
    fmt.Printf("fmt.Errorf: %v\n", err2)
    
    // 3. 自定义error类型
    type CustomError struct {
        Code    int
        Message string
    }
    
    func (ce CustomError) Error() string {
        return fmt.Sprintf("错误代码 %d: %s", ce.Code, ce.Message)
    }
    
    err3 := CustomError{Code: 404, Message: "未找到"}
    fmt.Printf("自定义error: %v\n", err3)
    
    // 4. 使用系统预定义的error
    err4 := io.EOF
    fmt.Printf("系统预定义error: %v\n", err4)
}

// error处理模式
func errorHandlingPatterns() {
    fmt.Println("\n=== error处理模式 ===")
    
    // 基本错误检查
    value, err := strconv.Atoi("abc")
    if err != nil {
        fmt.Printf("转换错误: %v\n", err)
    } else {
        fmt.Printf("转换结果: %d\n", value)
    }
    
    // 成功的转换
    value, err = strconv.Atoi("123")
    if err != nil {
        fmt.Printf("转换错误: %v\n", err)
    } else {
        fmt.Printf("转换结果: %d\n", value)
    }
    
    // 多重错误检查
    processMultipleOperations()
}

func processMultipleOperations() {
    fmt.Println("多重错误检查:")
    
    operations := []func() error{
        func() error { return nil },                    // 成功
        func() error { return errors.New("操作2失败") }, // 失败
        func() error { return nil },                    // 成功
    }
    
    for i, op := range operations {
        if err := op(); err != nil {
            fmt.Printf("操作%d失败: %v\n", i+1, err)
            // 可以选择继续或返回
            // return err
        } else {
            fmt.Printf("操作%d成功\n", i+1)
        }
    }
}

// 自定义error类型
func customErrorTypes() {
    fmt.Println("\n=== 自定义error类型 ===")
    
    // 简单的自定义error
    type ValidationError struct {
        Field   string
        Message string
    }
    
    func (ve ValidationError) Error() string {
        return fmt.Sprintf("验证错误 - 字段 %s: %s", ve.Field, ve.Message)
    }
    
    // 复杂的自定义error
    type DatabaseError struct {
        Operation string
        Table     string
        Err       error
        Query     string
    }
    
    func (de DatabaseError) Error() string {
        return fmt.Sprintf("数据库错误 [%s %s]: %v", de.Operation, de.Table, de.Err)
    }
    
    func (de DatabaseError) Unwrap() error {
        return de.Err
    }
    
    // 使用自定义error
    validateUser := func(name string) error {
        if name == "" {
            return ValidationError{Field: "name", Message: "不能为空"}
        }
        if len(name) < 3 {
            return ValidationError{Field: "name", Message: "长度不能少于3个字符"}
        }
        return nil
    }
    
    // 测试验证
    testNames := []string{"", "ab", "alice"}
    
    for _, name := range testNames {
        if err := validateUser(name); err != nil {
            fmt.Printf("验证'%s'失败: %v\n", name, err)
            
            // 类型断言检查具体错误类型
            if validationErr, ok := err.(ValidationError); ok {
                fmt.Printf("  具体错误信息 - 字段: %s, 消息: %s\n",
                    validationErr.Field, validationErr.Message)
            }
        } else {
            fmt.Printf("验证'%s'成功\n", name)
        }
    }
    
    // 数据库错误示例
    dbError := DatabaseError{
        Operation: "SELECT",
        Table:     "users",
        Err:       errors.New("连接超时"),
        Query:     "SELECT * FROM users WHERE id = 1",
    }
    
    fmt.Printf("数据库错误: %v\n", dbError)
}

// error检查和比较
func errorCheckingAndComparison() {
    fmt.Println("\n=== error检查和比较 ===")
    
    // 直接比较
    err := errors.New("特定错误")
    if err == errors.New("特定错误") {
        fmt.Println("错误相等")
    } else {
        fmt.Println("错误不相等") // 每次errors.New都创建新实例
    }
    
    // 使用errors.Is进行语义比较
    if errors.Is(err, err) {
        fmt.Println("使用errors.Is: 错误相等")
    }
    
    // 预定义错误比较
    file, openErr := os.Open("nonexistent.txt")
    if openErr != nil {
        if errors.Is(openErr, os.ErrNotExist) {
            fmt.Printf("文件不存在错误: %v\n", openErr)
        } else {
            fmt.Printf("其他文件错误: %v\n", openErr)
        }
    } else {
        file.Close()
    }
    
    // 类型断言检查
    type NetworkError struct {
        Message string
    }
    
    func (ne NetworkError) Error() string {
        return fmt.Sprintf("网络错误: %s", ne.Message)
    }
    
    var networkErr error = NetworkError{Message: "连接失败"}
    
    if _, ok := networkErr.(NetworkError); ok {
        fmt.Println("检测到网络错误")
    }
    
    // 使用errors.As进行类型检查
    var target NetworkError
    if errors.As(networkErr, &target) {
        fmt.Printf("使用errors.As检测到网络错误: %s\n", target.Message)
    }
}

// error包装和解包装
func errorWrappingAndUnwrapping() {
    fmt.Println("\n=== error包装和解包装 ===")
    
    // 创建包装的错误
    originalErr := errors.New("原始错误")
    wrappedErr := fmt.Errorf("包装错误: %w", originalErr)
    
    fmt.Printf("原始错误: %v\n", originalErr)
    fmt.Printf("包装错误: %v\n", wrappedErr)
    
    // 解包装错误
    unwrapped := errors.Unwrap(wrappedErr)
    fmt.Printf("解包装后的错误: %v\n", unwrapped)
    fmt.Printf("解包装是否等于原始错误: %t\n", unwrapped == originalErr)
    
    // 多层包装
    err1 := errors.New("最内层错误")
    err2 := fmt.Errorf("第二层: %w", err1)
    err3 := fmt.Errorf("最外层: %w", err2)
    
    fmt.Printf("多层包装: %v\n", err3)
    
    // 检查错误链
    if errors.Is(err3, err1) {
        fmt.Println("在错误链中找到了最内层错误")
    }
    
    // 解包到具体类型
    type ConfigError struct {
        File string
        Line int
        Err  error
    }
    
    func (ce ConfigError) Error() string {
        return fmt.Sprintf("配置文件 %s 第%d行: %v", ce.File, ce.Line, ce.Err)
    }
    
    func (ce ConfigError) Unwrap() error {
        return ce.Err
    }
    
    configErr := ConfigError{
        File: "config.json",
        Line: 15,
        Err:  errors.New("无效的JSON格式"),
    }
    
    wrappedConfigErr := fmt.Errorf("加载配置失败: %w", configErr)
    
    fmt.Printf("配置错误: %v\n", wrappedConfigErr)
    
    // 检查错误链中的特定错误
    if errors.Is(wrappedConfigErr, configErr) {
        fmt.Println("找到配置错误")
    }
    
    var target ConfigError
    if errors.As(wrappedConfigErr, &target) {
        fmt.Printf("解包到配置错误: 文件=%s, 行=%d\n", target.File, target.Line)
    }
}

// error处理最佳实践
func errorHandlingBestPractices() {
    fmt.Println("\n=== error处理最佳实践 ===")
    
    // 1. 及时处理错误
    handleErrorsPromptly()
    
    // 2. 提供有意义的错误信息
    meaningfulErrorMessages()
    
    // 3. 不要忽略错误
    dontIgnoreErrors()
    
    // 4. 错误日志记录
    errorLogging()
}

func handleErrorsPromptly() {
    fmt.Println("1. 及时处理错误:")
    
    // 好的做法
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Printf("  打开文件失败: %v\n", err)
        return
    }
    defer file.Close()
    
    fmt.Println("  文件打开成功")
}

func meaningfulErrorMessages() {
    fmt.Println("2. 提供有意义的错误信息:")
    
    processData := func(id int, data string) error {
        if id <= 0 {
            return fmt.Errorf("处理数据失败: 无效的ID %d", id)
        }
        if data == "" {
            return fmt.Errorf("处理数据失败: ID %d 的数据为空", id)
        }
        return nil
    }
    
    // 测试
    testCases := []struct {
        id   int
        data string
    }{
        {0, "data"},
        {1, ""},
        {1, "valid"},
    }
    
    for _, tc := range testCases {
        if err := processData(tc.id, tc.data); err != nil {
            fmt.Printf("  %v\n", err)
        } else {
            fmt.Printf("  处理ID %d成功\n", tc.id)
        }
    }
}

func dontIgnoreErrors() {
    fmt.Println("3. 不要忽略错误:")
    
    // 不好的做法
    // file, _ := os.Open("example.txt") // 忽略错误
    
    // 好的做法
    file, err := os.Open("example.txt")
    if err != nil {
        // 至少要记录错误
        fmt.Printf("  警告: 无法打开文件: %v\n", err)
        // 或者返回错误给调用者
        // return err
    } else {
        defer file.Close()
        fmt.Println("  文件打开成功")
    }
}

func errorLogging() {
    fmt.Println("4. 错误日志记录:")
    
    logError := func(operation string, err error) {
        fmt.Printf("  [ERROR] %s 失败: %v\n", operation, err)
    }
    
    // 模拟操作
    if _, err := os.Open("nonexistent.txt"); err != nil {
        logError("打开文件", err)
    }
}

// error与panic的对比
func errorVsPanic() {
    fmt.Println("\n=== error与panic的对比 ===")
    
    // 使用error处理预期错误
    divideWithError := func(a, b float64) (float64, error) {
        if b == 0 {
            return 0, errors.New("除数不能为零")
        }
        return a / b, nil
    }
    
    // 使用panic处理程序错误
    divideWithPanic := func(a, b float64) float64 {
        if b == 0 {
            panic("除数不能为零")
        }
        return a / b
    }
    
    // 测试error处理
    fmt.Println("Error处理方式:")
    if result, err := divideWithError(10, 0); err != nil {
        fmt.Printf("  错误: %v\n", err)
    } else {
        fmt.Printf("  结果: %.2f\n", result)
    }
    
    // 测试panic处理
    fmt.Println("Panic处理方式:")
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("  恢复panic: %v\n", r)
        }
    }()
    
    result := divideWithPanic(10, 0)
    fmt.Printf("  结果: %.2f\n", result)
}

// error的实际应用
func errorRealWorldApplications() {
    fmt.Println("\n=== error的实际应用 ===")
    
    // 业务逻辑错误处理
    businessLogicErrorHandling()
    
    // 系统级错误处理
    systemLevelErrorHandling()
}

func businessLogicErrorHandling() {
    fmt.Println("业务逻辑错误处理:")
    
    // 用户服务错误定义
    type UserServiceError struct {
        Code    string
        Message string
    }
    
    func (use UserServiceError) Error() string {
        return fmt.Sprintf("用户服务错误 [%s]: %s", use.Code, use.Message)
    }
    
    // 常量错误
    var (
        ErrUserNotFound = UserServiceError{Code: "USER_NOT_FOUND", Message: "用户未找到"}
        ErrUserExists   = UserServiceError{Code: "USER_EXISTS", Message: "用户已存在"}
        ErrInvalidEmail = UserServiceError{Code: "INVALID_EMAIL", Message: "邮箱格式无效"}
    )
    
    // 用户服务模拟
    type User struct {
        ID    int
        Name  string
        Email string
    }
    
    users := map[int]User{
        1: {ID: 1, Name: "Alice", Email: "alice@example.com"},
    }
    
    getUser := func(id int) (User, error) {
        user, exists := users[id]
        if !exists {
            return User{}, ErrUserNotFound
        }
        return user, nil
    }
    
    createUser := func(user User) error {
        if user.Email == "" || !isValidEmail(user.Email) {
            return ErrInvalidEmail
        }
        if _, exists := users[user.ID]; exists {
            return ErrUserExists
        }
        users[user.ID] = user
        return nil
    }
    
    isValidEmail := func(email string) bool {
        return len(email) > 0 && len(email) < 255 && email != "invalid@example.com"
    }
    
    // 测试
    testCases := []struct {
        name string
        op   func() error
    }{
        {
            "获取存在的用户",
            func() error {
                user, err := getUser(1)
                if err != nil {
                    return err
                }
                fmt.Printf("  获取用户: %+v\n", user)
                return nil
            },
        },
        {
            "获取不存在的用户",
            func() error {
                _, err := getUser(999)
                return err
            },
        },
        {
            "创建有效用户",
            func() error {
                return createUser(User{ID: 2, Name: "Bob", Email: "bob@example.com"})
            },
        },
        {
            "创建无效邮箱用户",
            func() error {
                return createUser(User{ID: 3, Name: "Charlie", Email: "invalid@example.com"})
            },
        },
    }
    
    for _, tc := range testCases {
        fmt.Printf("测试: %s\n", tc.name)
        if err := tc.op(); err != nil {
            fmt.Printf("  错误: %v\n", err)
            
            // 错误类型检查
            switch err {
            case ErrUserNotFound:
                fmt.Println("  处理用户未找到错误")
            case ErrUserExists:
                fmt.Println("  处理用户已存在错误")
            case ErrInvalidEmail:
                fmt.Println("  处理无效邮箱错误")
            default:
                fmt.Println("  处理未知错误")
            }
        } else {
            fmt.Println("  操作成功")
        }
        fmt.Println()
    }
}

func systemLevelErrorHandling() {
    fmt.Println("系统级错误处理:")
    
    // 文件操作错误处理
    processFile := func(filename string) error {
        file, err := os.Open(filename)
        if err != nil {
            // 包装系统错误
            return fmt.Errorf("无法打开文件 %s: %w", filename, err)
        }
        defer file.Close()
        
        // 模拟文件处理
        fmt.Printf("  处理文件: %s\n", filename)
        return nil
    }
    
    // 网络操作错误处理
    type NetworkError struct {
        Op  string
        URL string
        Err error
    }
    
    func (ne NetworkError) Error() string {
        return fmt.Sprintf("网络操作 %s 失败 %s: %v", ne.Op, ne.URL, ne.Err)
    }
    
    func (ne NetworkError) Unwrap() error {
        return ne.Err
    }
    
    makeRequest := func(url string) error {
        // 模拟网络请求
        if url == "http://invalid.com" {
            return NetworkError{
                Op:  "GET",
                URL: url,
                Err: errors.New("DNS解析失败"),
            }
        }
        return nil
    }
    
    // 测试
    files := []string{"existing.txt", "nonexistent.txt"}
    for _, file := range files {
        if err := processFile(file); err != nil {
            fmt.Printf("  文件处理错误: %v\n", err)
        }
    }
    
    urls := []string{"http://example.com", "http://invalid.com"}
    for _, url := range urls {
        if err := makeRequest(url); err != nil {
            fmt.Printf("  网络请求错误: %v\n", err)
            
            var netErr NetworkError
            if errors.As(err, &netErr) {
                fmt.Printf("    网络错误详情 - 操作: %s, URL: %s\n", netErr.Op, netErr.URL)
            }
        }
    }
}

func main() {
    errorInterfaceBasics()
    errorHandlingPatterns()
    customErrorTypes()
    errorCheckingAndComparison()
    errorWrappingAndUnwrapping()
    errorHandlingBestPractices()
    errorVsPanic()
    errorRealWorldApplications()
    
    // 高级错误处理技术
    fmt.Println("\n=== 高级错误处理技术 ===")
    advancedErrorHandling()
}

func advancedErrorHandling() {
    // 错误链处理
    fmt.Println("错误链处理:")
    errorChaining()
    
    // 多错误处理
    fmt.Println("\n多错误处理:")
    multiErrorHandling()
}

func errorChaining() {
    fmt.Println("错误链处理示例:")
    
    // 创建复杂的错误链
    type ValidationError struct {
        Field   string
        Value   string
        Message string
    }
    
    func (ve ValidationError) Error() string {
        return fmt.Sprintf("验证错误: 字段 %s 值 %s - %s", ve.Field, ve.Value, ve.Message)
    }
    
    type BusinessError struct {
        Code    string
        Message string
        Cause   error
    }
    
    func (be BusinessError) Error() string {
        return fmt.Sprintf("业务错误 [%s]: %s", be.Code, be.Message)
    }
    
    func (be BusinessError) Unwrap() error {
        return be.Cause
    }
    
    // 模拟数据处理流程
    validateInput := func(data map[string]string) error {
        if email, exists := data["email"]; exists {
            if !isValidEmail(email) {
                return ValidationError{
                    Field:   "email",
                    Value:   email,
                    Message: "邮箱格式无效",
                }
            }
        }
        return nil
    }
    
    isValidEmail := func(email string) bool {
        return len(email) > 0 && len(email) < 255 && email != "invalid@example.com"
    }
    
    processBusinessLogic := func(data map[string]string) error {
        if err := validateInput(data); err != nil {
            return BusinessError{
                Code:    "VALIDATION_FAILED",
                Message: "输入验证失败",
                Cause:   err,
            }
        }
        
        // 模拟业务逻辑
        if data["action"] == "invalid" {
            return errors.New("无效的操作")
        }
        
        return nil
    }
    
    // 测试数据
    testData := []map[string]string{
        {"email": "invalid@example.com", "action": "create"}, // 验证错误
        {"email": "user@example.com", "action": "invalid"},   // 业务错误
        {"email": "user@example.com", "action": "create"},    // 成功
    }
    
    for i, data := range testData {
        fmt.Printf("测试数据 %d: %v\n", i+1, data)
        
        if err := processBusinessLogic(data); err != nil {
            fmt.Printf("  错误: %v\n", err)
            
            // 检查错误链
            var validationErr ValidationError
            if errors.As(err, &validationErr) {
                fmt.Printf("    找到验证错误: 字段=%s, 值=%s\n",
                    validationErr.Field, validationErr.Value)
            }
            
            var businessErr BusinessError
            if errors.As(err, &businessErr) {
                fmt.Printf("    找到业务错误: 代码=%s\n", businessErr.Code)
            }
            
            // 检查特定错误
            if errors.Is(err, ValidationError{}) {
                fmt.Println("    错误链中包含验证错误")
            }
        } else {
            fmt.Println("  处理成功")
        }
        fmt.Println()
    }
}

func multiErrorHandling() {
    fmt.Println("多错误处理示例:")
    
    // 多错误类型
    type MultiError struct {
        Errors []error
    }
    
    func (me MultiError) Error() string {
        if len(me.Errors) == 0 {
            return "无错误"
        }
        if len(me.Errors) == 1 {
            return me.Errors[0].Error()
        }
        
        result := fmt.Sprintf("多个错误 (%d):\n", len(me.Errors))
        for i, err := range me.Errors {
            result += fmt.Sprintf("  %d. %v\n", i+1, err)
        }
        return result
    }
    
    // 并行处理多个任务
    processTasks := func(tasks []func() error) error {
        var errors []error
        
        for i, task := range tasks {
            if err := task(); err != nil {
                errors = append(errors, fmt.Errorf("任务%d失败: %w", i+1, err))
            }
        }
        
        if len(errors) > 0 {
            return MultiError{Errors: errors}
        }
        return nil
    }
    
    // 测试任务
    tasks := []func() error{
        func() error { return nil },                           // 成功
        func() error { return errors.New("任务2失败") },         // 失败
        func() error { return nil },                           // 成功
        func() error { return fmt.Errorf("任务4失败: %w", errors.New("网络错误")) }, // 包装错误
    }
    
    if err := processTasks(tasks); err != nil {
        fmt.Printf("批量处理错误: %v\n", err)
        
        var multiErr MultiError
        if errors.As(err, &multiErr) {
            fmt.Printf("  总共%d个错误:\n", len(multiErr.Errors))
            for i, singleErr := range multiErr.Errors {
                fmt.Printf("    错误%d: %v\n", i+1, singleErr)
            }
        }
    } else {
        fmt.Println("所有任务处理成功")
    }
}
```

### 错误处理模式

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "log"
    "net/http"
    "sync"
    "time"
)

// 基本错误处理模式
func basicErrorHandlingPatterns() {
    fmt.Println("=== 基本错误处理模式 ===")
    
    // 1. 立即处理模式
    immediateHandlingPattern()
    
    // 2. 延迟处理模式
    deferredHandlingPattern()
    
    // 3. 错误传播模式
    errorPropagationPattern()
}

func immediateHandlingPattern() {
    fmt.Println("1. 立即处理模式:")
    
    processData := func(data string) error {
        if data == "" {
            return errors.New("数据不能为空")
        }
        fmt.Printf("  处理数据: %s\n", data)
        return nil
    }
    
    // 立即检查和处理错误
    if err := processData(""); err != nil {
        fmt.Printf("  错误处理: %v\n", err)
        // 可以选择记录日志、返回默认值等
        return
    }
    
    if err := processData("有效数据"); err != nil {
        fmt.Printf("  错误处理: %v\n", err)
    } else {
        fmt.Println("  数据处理成功")
    }
}

func deferredHandlingPattern() {
    fmt.Println("2. 延迟处理模式:")
    
    type Result struct {
        Data string
        Err  error
    }
    
    processData := func(data string) Result {
        if data == "" {
            return Result{Err: errors.New("数据不能为空")}
        }
        return Result{Data: "处理后的" + data}
    }
    
    // 延迟错误处理
    results := []Result{
        processData("数据1"),
        processData(""),
        processData("数据3"),
    }
    
    for i, result := range results {
        if result.Err != nil {
            fmt.Printf("  结果%d错误: %v\n", i+1, result.Err)
        } else {
            fmt.Printf("  结果%d: %s\n", i+1, result.Data)
        }
    }
}

func errorPropagationPattern() {
    fmt.Println("3. 错误传播模式:")
    
    // 底层函数
    lowLevelOperation := func(input string) (string, error) {
        if input == "error" {
            return "", errors.New("底层操作失败")
        }
        return "处理结果: " + input, nil
    }
    
    // 中层函数
    midLevelOperation := func(input string) (string, error) {
        result, err := lowLevelOperation(input)
        if err != nil {
            // 包装错误并传播
            return "", fmt.Errorf("中层操作失败: %w", err)
        }
        return result, nil
    }
    
    // 高层函数
    highLevelOperation := func(input string) error {
        result, err := midLevelOperation(input)
        if err != nil {
            // 记录日志并返回错误
            log.Printf("高层操作失败: %v", err)
            return fmt.Errorf("高层操作失败: %w", err)
        }
        fmt.Printf("  最终结果: %s\n", result)
        return nil
    }
    
    // 测试
    inputs := []string{"正常数据", "error"}
    
    for _, input := range inputs {
        fmt.Printf("  处理输入: %s\n", input)
        if err := highLevelOperation(input); err != nil {
            fmt.Printf("    错误: %v\n", err)
        }
    }
}

// 错误恢复模式
func errorRecoveryPatterns() {
    fmt.Println("\n=== 错误恢复模式 ===")
    
    // 1. 重试模式
    retryPattern()
    
    // 2. 降级模式
    fallbackPattern()
    
    // 3. 超时模式
    timeoutPattern()
}

func retryPattern() {
    fmt.Println("1. 重试模式:")
    
    // 模拟不稳定的操作
    attempt := 0
    unstableOperation := func() (string, error) {
        attempt++
        if attempt < 3 {
            return "", fmt.Errorf("操作失败，尝试次数: %d", attempt)
        }
        return "操作成功", nil
    }
    
    // 重试逻辑
    retry := func(operation func() (string, error), maxRetries int) (string, error) {
        var lastErr error
        
        for i := 0; i <= maxRetries; i++ {
            result, err := operation()
            if err == nil {
                return result, nil
            }
            
            lastErr = err
            if i < maxRetries {
                fmt.Printf("    第%d次尝试失败: %v，等待重试...\n", i+1, err)
                time.Sleep(time.Duration(i+1) * 100 * time.Millisecond) // 递增延迟
            }
        }
        
        return "", fmt.Errorf("重试%d次后仍然失败: %w", maxRetries, lastErr)
    }
    
    // 测试重试
    result, err := retry(unstableOperation, 5)
    if err != nil {
        fmt.Printf("    最终失败: %v\n", err)
    } else {
        fmt.Printf("    最终成功: %s\n", result)
    }
}

func fallbackPattern() {
    fmt.Println("2. 降级模式:")
    
    // 主要服务
    primaryService := func(request string) (string, error) {
        if request == "error" {
            return "", errors.New("主要服务不可用")
        }
        return "主要服务响应: " + request, nil
    }
    
    // 备用服务
    fallbackService := func(request string) (string, error) {
        return "备用服务响应: " + request, nil
    }
    
    // 降级处理
    serviceWithFallback := func(request string) string {
        if result, err := primaryService(request); err == nil {
            return result
        }
        
        fmt.Println("    主要服务失败，切换到备用服务")
        if result, err := fallbackService(request); err == nil {
            return result
        }
        
        return "所有服务都不可用"
    }
    
    // 测试
    requests := []string{"正常请求", "error"}
    
    for _, request := range requests {
        result := serviceWithFallback(request)
        fmt.Printf("    请求 '%s': %s\n", request, result)
    }
}

func timeoutPattern() {
    fmt.Println("3. 超时模式:")
    
    // 模拟长时间运行的操作
    longRunningOperation := func(duration time.Duration) (string, error) {
        time.Sleep(duration)
        return "操作完成", nil
    }
    
    // 带超时的操作
    operationWithTimeout := func(operation func() (string, error), timeout time.Duration) (string, error) {
        resultChan := make(chan string, 1)
        errorChan := make(chan error, 1)
        
        go func() {
            result, err := operation()
            if err != nil {
                errorChan <- err
            } else {
                resultChan <- result
            }
        }()
        
        select {
        case result := <-resultChan:
            return result, nil
        case err := <-errorChan:
            return "", err
        case <-time.After(timeout):
            return "", fmt.Errorf("操作超时 (%v)", timeout)
        }
    }
    
    // 测试
    durations := []time.Duration{100 * time.Millisecond, 500 * time.Millisecond}
    timeout := 300 * time.Millisecond
    
    for i, duration := range durations {
        fmt.Printf("    测试%d (耗时%v):\n", i+1, duration)
        result, err := operationWithTimeout(
            func() (string, error) { return longRunningOperation(duration) },
            timeout,
        )
        
        if err != nil {
            fmt.Printf("      错误: %v\n", err)
        } else {
            fmt.Printf("      结果: %s\n", result)
        }
    }
}

// 错误分类模式
func errorClassificationPatterns() {
    fmt.Println("\n=== 错误分类模式 ===")
    
    // 定义错误类型
    type ErrorCode string
    
    const (
        ValidationError ErrorCode = "VALIDATION_ERROR"
        BusinessError   ErrorCode = "BUSINESS_ERROR"
        SystemError     ErrorCode = "SYSTEM_ERROR"
        NetworkError    ErrorCode = "NETWORK_ERROR"
    )
    
    // 错误结构
    type AppError struct {
        Code    ErrorCode
        Message string
        Details map[string]interface{}
        Cause   error
    }
    
    func (ae AppError) Error() string {
        return fmt.Sprintf("[%s] %s", ae.Code, ae.Message)
    }
    
    func (ae AppError) Unwrap() error {
        return ae.Cause
    }
    
    // 错误工厂
    createValidationError := func(message string, details map[string]interface{}) error {
        return AppError{
            Code:    ValidationError,
            Message: message,
            Details: details,
        }
    }
    
    createBusinessError := func(message string, cause error) error {
        return AppError{
            Code:    BusinessError,
            Message: message,
            Cause:   cause,
        }
    }
    
    createSystemError := func(message string, cause error) error {
        return AppError{
            Code:    SystemError,
            Message: message,
            Cause:   cause,
        }
    }
    
    // 错误处理器
    handleError := func(err error) {
        var appErr AppError
        if errors.As(err, &appErr) {
            switch appErr.Code {
            case ValidationError:
                fmt.Printf("    验证错误: %s\n", appErr.Message)
                if len(appErr.Details) > 0 {
                    fmt.Printf("    详情: %v\n", appErr.Details)
                }
            case BusinessError:
                fmt.Printf("    业务错误: %s\n", appErr.Message)
            case SystemError:
                fmt.Printf("    系统错误: %s\n", appErr.Message)
                if appErr.Cause != nil {
                    fmt.Printf("    原因: %v\n", appErr.Cause)
                }
            default:
                fmt.Printf("    未知错误: %v\n", err)
            }
        } else {
            fmt.Printf("    未分类错误: %v\n", err)
        }
    }
    
    // 测试不同类型的错误
    errorsToTest := []error{
        createValidationError("邮箱格式无效", map[string]interface{}{
            "field": "email",
            "value": "invalid-email",
        }),
        createBusinessError("余额不足", errors.New("账户余额为0")),
        createSystemError("数据库连接失败", errors.New("连接超时")),
        errors.New("普通错误"),
    }
    
    for i, err := range errorsToTest {
        fmt.Printf("  错误%d: ", i+1)
        handleError(err)
    }
}

// 上下文感知错误处理
func contextAwareErrorHandling() {
    fmt.Println("\n=== 上下文感知错误处理 ===")
    
    // 带上下文的操作
    operationWithContext := func(ctx context.Context, duration time.Duration) (string, error) {
        select {
        case <-time.After(duration):
            return "操作完成", nil
        case <-ctx.Done():
            return "", ctx.Err()
        }
    }
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
    defer cancel()
    
    // 测试不同耗时的操作
    durations := []time.Duration{100 * time.Millisecond, 500 * time.Millisecond}
    
    for i, duration := range durations {
        fmt.Printf("  测试%d (耗时%v):\n", i+1, duration)
        result, err := operationWithContext(ctx, duration)
        
        if err != nil {
            if errors.Is(err, context.DeadlineExceeded) {
                fmt.Printf("    错误: 操作超时\n")
            } else if errors.Is(err, context.Canceled) {
                fmt.Printf("    错误: 操作被取消\n")
            } else {
                fmt.Printf("    错误: %v\n", err)
            }
        } else {
            fmt.Printf("    结果: %s\n", result)
        }
    }
}

// 并发错误处理模式
func concurrentErrorHandlingPatterns() {
    fmt.Println("\n=== 并发错误处理模式 ===")
    
    // 1. WaitGroup模式
    waitGroupPattern()
    
    // 2. Channel模式
    channelPattern()
    
    // 3. 错误收集模式
    errorCollectionPattern()
}

func waitGroupPattern() {
    fmt.Println("1. WaitGroup模式:")
    
    var wg sync.WaitGroup
    errors := make(chan error, 5)
    
    // 启动多个goroutine
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // 模拟工作
            time.Sleep(time.Duration(id*100) * time.Millisecond)
            
            // 模拟可能的错误
            if id == 2 {
                errors <- fmt.Errorf("goroutine %d 失败", id)
                return
            }
            
            fmt.Printf("    goroutine %d 完成\n", id)
        }(i)
    }
    
    // 等待所有goroutine完成
    go func() {
        wg.Wait()
        close(errors)
    }()
    
    // 收集错误
    for err := range errors {
        fmt.Printf("    收到错误: %v\n", err)
    }
    
    fmt.Println("    所有goroutine完成")
}

func channelPattern() {
    fmt.Println("2. Channel模式:")
    
    // 结果通道
    type Result struct {
        ID    int
        Value string
        Error error
    }
    
    results := make(chan Result, 5)
    
    // 启动工作者
    for i := 0; i < 5; i++ {
        go func(id int) {
            // 模拟工作
            time.Sleep(time.Duration(id*100) * time.Millisecond)
            
            // 模拟结果
            if id == 3 {
                results <- Result{ID: id, Error: fmt.Errorf("工作者 %d 失败", id)}
            } else {
                results <- Result{ID: id, Value: fmt.Sprintf("结果%d", id)}
            }
        }(i)
    }
    
    // 收集结果
    for i := 0; i < 5; i++ {
        result := <-results
        if result.Error != nil {
            fmt.Printf("    工作者%d错误: %v\n", result.ID, result.Error)
        } else {
            fmt.Printf("    工作者%d结果: %s\n", result.ID, result.Value)
        }
    }
}

func errorCollectionPattern() {
    fmt.Println("3. 错误收集模式:")
    
    // 错误收集器
    type ErrorCollector struct {
        mu     sync.Mutex
        errors []error
    }
    
    func (ec *ErrorCollector) Add(err error) {
        ec.mu.Lock()
        defer ec.mu.Unlock()
        ec.errors = append(ec.errors, err)
    }
    
    func (ec *ErrorCollector) GetErrors() []error {
        ec.mu.Lock()
        defer ec.mu.Unlock()
        return append([]error(nil), ec.errors...)
    }
    
    // 创建收集器
    collector := &ErrorCollector{}
    var wg sync.WaitGroup
    
    // 并发执行任务
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // 模拟任务
            time.Sleep(time.Duration(id*50) * time.Millisecond)
            
            if id%2 == 0 {
                collector.Add(fmt.Errorf("任务%d失败", id))
            } else {
                fmt.Printf("    任务%d成功\n", id)
            }
        }(i)
    }
    
    wg.Wait()
    
    // 处理收集到的错误
    errors := collector.GetErrors()
    if len(errors) > 0 {
        fmt.Printf("    收集到%d个错误:\n", len(errors))
        for _, err := range errors {
            fmt.Printf("      %v\n", err)
        }
    } else {
        fmt.Println("    所有任务成功完成")
    }
}

// 错误日志模式
func errorLoggingPatterns() {
    fmt.Println("\n=== 错误日志模式 ===")
    
    // 结构化错误日志
    type ErrorLog struct {
        Timestamp time.Time
        Level     string
        Message   string
        Error     error
        Context   map[string]interface{}
    }
    
    func (el ErrorLog) String() string {
        return fmt.Sprintf("[%s] %s: %s (上下文: %v)",
            el.Timestamp.Format("15:04:05"), el.Level, el.Message, el.Context)
    }
    
    // 日志记录器
    logError := func(level, message string, err error, context map[string]interface{}) {
        logEntry := ErrorLog{
            Timestamp: time.Now(),
            Level:     level,
            Message:   message,
            Error:     err,
            Context:   context,
        }
        fmt.Println("    " + logEntry.String())
    }
    
    // 模拟操作
    simulateOperation := func(operation string, shouldFail bool) error {
        if shouldFail {
            return fmt.Errorf("%s操作失败", operation)
        }
        return nil
    }
    
    // 测试日志记录
    operations := []struct {
        name       string
        shouldFail bool
        context    map[string]interface{}
    }{
        {"数据库查询", true, map[string]interface{}{"table": "users", "query": "SELECT *"}},
        {"文件读取", false, map[string]interface{}{"filename": "config.json"}},
        {"网络请求", true, map[string]interface{}{"url": "http://api.example.com", "method": "GET"}},
    }
    
    for _, op := range operations {
        if err := simulateOperation(op.name, op.shouldFail); err != nil {
            logError("ERROR", "操作失败", err, op.context)
        } else {
            logError("INFO", "操作成功", nil, op.context)
        }
    }
}

// 实际应用场景
func realWorldErrorHandling() {
    fmt.Println("\n=== 实际应用场景 ===")
    
    // Web服务错误处理
    fmt.Println("Web服务错误处理:")
    webServiceErrorHandling()
    
    // 数据库操作错误处理
    fmt.Println("\n数据库操作错误处理:")
    databaseErrorHandling()
}

func webServiceErrorHandling() {
    // HTTP错误类型
    type HTTPError struct {
        StatusCode int
        Message    string
        Details    map[string]interface{}
    }
    
    func (he HTTPError) Error() string {
        return fmt.Sprintf("HTTP %d: %s", he.StatusCode, he.Message)
    }
    
    // 错误响应生成器
    generateErrorResponse := func(err error) (int, map[string]interface{}) {
        var httpErr HTTPError
        
        if errors.As(err, &httpErr) {
            return httpErr.StatusCode, map[string]interface{}{
                "error":   httpErr.Message,
                "details": httpErr.Details,
            }
        }
        
        // 默认错误
        return http.StatusInternalServerError, map[string]interface{}{
            "error": "内部服务器错误",
        }
    }
    
    // 模拟API处理函数
    apiHandler := func(request map[string]interface{}) (int, map[string]interface{}) {
        // 验证输入
        if name, ok := request["name"].(string); !ok || name == "" {
            err := HTTPError{
                StatusCode: http.StatusBadRequest,
                Message:    "名称不能为空",
                Details:    map[string]interface{}{"field": "name"},
            }
            return generateErrorResponse(err)
        }
        
        // 模拟业务逻辑错误
        if action, ok := request["action"].(string); ok && action == "invalid" {
            err := HTTPError{
                StatusCode: http.StatusForbidden,
                Message:    "无效的操作",
                Details:    map[string]interface{}{"action": action},
            }
            return generateErrorResponse(err)
        }
        
        // 成功响应
        return http.StatusOK, map[string]interface{}{
            "message": "操作成功",
            "data":    request,
        }
    }
    
    // 测试请求
    testRequests := []map[string]interface{}{
        {},                                    // 缺少名称
        {"name": "Alice"},                     // 正常请求
        {"name": "Bob", "action": "invalid"},  // 无效操作
    }
    
    for i, request := range testRequests {
        fmt.Printf("  请求%d: %v\n", i+1, request)
        statusCode, response := apiHandler(request)
        fmt.Printf("    状态码: %d, 响应: %v\n", statusCode, response)
    }
}

func databaseErrorHandling() {
    // 数据库错误类型
    type DatabaseError struct {
        Operation string
        Table     string
        Query     string
        Err       error
        Retries   int
    }
    
    func (de DatabaseError) Error() string {
        return fmt.Sprintf("数据库错误 [%s %s]: %v", de.Operation, de.Table, de.Err)
    }
    
    func (de DatabaseError) Unwrap() error {
        return de.Err
    }
    
    // 数据库连接模拟
    type Database struct {
        connected bool
        retries   int
    }
    
    func (db *Database) Connect() error {
        db.retries++
        if db.retries < 2 {
            return fmt.Errorf("连接失败，重试次数: %d", db.retries)
        }
        db.connected = true
        return nil
    }
    
    func (db *Database) Query(query string) ([]map[string]interface{}, error) {
        if !db.connected {
            return nil, DatabaseError{
                Operation: "QUERY",
                Table:     "unknown",
                Query:     query,
                Err:       errors.New("数据库未连接"),
                Retries:   0,
            }
        }
        
        // 模拟查询结果
        return []map[string]interface{}{
            {"id": 1, "name": "Alice"},
            {"id": 2, "name": "Bob"},
        }, nil
    }
    
    // 数据库操作函数
    performDatabaseOperation := func(db *Database, query string) ([]map[string]interface{}, error) {
        // 尝试连接
        maxRetries := 3
        for i := 0; i < maxRetries; i++ {
            if err := db.Connect(); err == nil {
                break
            } else if i == maxRetries-1 {
                return nil, DatabaseError{
                    Operation: "CONNECT",
                    Table:     "connection",
                    Query:     "",
                    Err:       err,
                    Retries:   i + 1,
                }
            }
            time.Sleep(100 * time.Millisecond)
        }
        
        // 执行查询
        results, err := db.Query(query)
        if err != nil {
            return nil, DatabaseError{
                Operation: "QUERY",
                Table:     "users",
                Query:     query,
                Err:       err,
                Retries:   0,
            }
        }
        
        return results, nil
    }
    
    // 测试
    db := &Database{}
    
    queries := []string{
        "SELECT * FROM users",
        "SELECT * FROM products",
    }
    
    for i, query := range queries {
        fmt.Printf("  查询%d: %s\n", i+1, query)
        results, err := performDatabaseOperation(db, query)
        
        if err != nil {
            fmt.Printf("    错误: %v\n", err)
            
            var dbErr DatabaseError
            if errors.As(err, &dbErr) {
                fmt.Printf("    数据库错误详情 - 操作: %s, 表: %s, 重试: %d\n",
                    dbErr.Operation, dbErr.Table, dbErr.Retries)
            }
        } else {
            fmt.Printf("    结果数量: %d\n", len(results))
            for _, row := range results {
                fmt.Printf("      %v\n", row)
            }
        }
    }
}

func main() {
    basicErrorHandlingPatterns()
    errorRecoveryPatterns()
    errorClassificationPatterns()
    contextAwareErrorHandling()
    concurrentErrorHandlingPatterns()
    errorLoggingPatterns()
    realWorldErrorHandling()
    
    // 高级错误处理模式
    fmt.Println("\n=== 高级错误处理模式 ===")
    advancedErrorHandlingPatterns()
}

func advancedErrorHandlingPatterns() {
    // 错误恢复和补偿模式
    fmt.Println("错误恢复和补偿模式:")
    recoveryAndCompensationPattern()
    
    // 错误指标和监控模式
    fmt.Println("\n错误指标和监控模式:")
    errorMetricsAndMonitoringPattern()
}

func recoveryAndCompensationPattern() {
    fmt.Println("错误恢复和补偿模式示例:")
    
    // 事务管理器
    type TransactionManager struct {
        operations []func() error  // 正向操作
        compensations []func()     // 补偿操作
    }
    
    func (tm *TransactionManager) AddOperation(op func() error, comp func()) {
        tm.operations = append(tm.operations, op)
        tm.compensations = append(tm.compensations, comp)
    }
    
    func (tm *TransactionManager) Execute() error {
        executedOps := 0
        
        // 执行所有操作
        for i, op := range tm.operations {
            if err := op(); err != nil {
                fmt.Printf("    操作%d失败: %v\n", i+1, err)
                // 执行补偿操作
                tm.compensate(executedOps)
                return fmt.Errorf("事务失败在操作%d: %w", i+1, err)
            }
            executedOps++
        }
        
        fmt.Println("    所有操作执行成功")
        return nil
    }
    
    func (tm *TransactionManager) compensate(upTo int) {
        fmt.Printf("    执行补偿操作 (回滚到操作%d)\n", upTo)
        for i := upTo - 1; i >= 0; i-- {
            if i < len(tm.compensations) {
                tm.compensations[i]()
            }
        }
    }
    
    // 模拟服务
    type ServiceState struct {
        data map[string]string
    }
    
    service := &ServiceState{data: make(map[string]string)}
    
    // 模拟操作
    createRecord := func(key, value string) func() error {
        return func() error {
            if key == "error" {
                return errors.New("创建记录失败")
            }
            service.data[key] = value
            fmt.Printf("      创建记录: %s = %s\n", key, value)
            return nil
        }
    }
    
    deleteRecord := func(key string) func() {
        return func() {
            if _, exists := service.data[key]; exists {
                delete(service.data, key)
                fmt.Printf("      补偿删除记录: %s\n", key)
            }
        }
    }
    
    updateRecord := func(key, value string) func() error {
        return func() error {
            if key == "update_error" {
                return errors.New("更新记录失败")
            }
            oldValue := service.data[key]
            service.data[key] = value
            fmt.Printf("      更新记录: %s = %s (原值: %s)\n", key, value, oldValue)
            return nil
        }
    }
    
    restoreRecord := func(key, oldValue string) func() {
        return func() {
            if oldValue != "" {
                service.data[key] = oldValue
                fmt.Printf("      补偿恢复记录: %s = %s\n", key, oldValue)
            } else {
                delete(service.data, key)
                fmt.Printf("      补偿删除记录: %s\n", key)
            }
        }
    }
    
    // 测试成功事务
    fmt.Println("  测试成功事务:")
    tm1 := &TransactionManager{}
    tm1.AddOperation(createRecord("key1", "value1"), deleteRecord("key1"))
    tm1.AddOperation(updateRecord("key1", "value2"), restoreRecord("key1", "value1"))
    tm1.AddOperation(createRecord("key2", "value3"), deleteRecord("key2"))
    
    if err := tm1.Execute(); err != nil {
        fmt.Printf("    事务失败: %v\n", err)
    } else {
        fmt.Printf("    事务成功，当前数据: %v\n", service.data)
    }
    
    // 测试失败事务
    fmt.Println("\n  测试失败事务:")
    tm2 := &TransactionManager{}
    tm2.AddOperation(createRecord("key3", "value4"), deleteRecord("key3"))
    tm2.AddOperation(createRecord("error", "value5"), deleteRecord("error")) // 会失败
    tm2.AddOperation(createRecord("key4", "value6"), deleteRecord("key4"))
    
    if err := tm2.Execute(); err != nil {
        fmt.Printf("    事务失败: %v\n", err)
    }
    fmt.Printf("    失败后数据状态: %v\n", service.data)
}

func errorMetricsAndMonitoringPattern() {
    fmt.Println("错误指标和监控模式示例:")
    
    // 错误统计器
    type ErrorMetrics struct {
        mu           sync.RWMutex
        totalErrors  int64
        errorTypes   map[string]int64
        lastErrors   []string
        maxLastErrors int
    }
    
    func NewErrorMetrics(maxLastErrors int) *ErrorMetrics {
        return &ErrorMetrics{
            errorTypes:    make(map[string]int64),
            lastErrors:    make([]string, 0, maxLastErrors),
            maxLastErrors: maxLastErrors,
        }
    }
    
    func (em *ErrorMetrics) RecordError(err error) {
        em.mu.Lock()
        defer em.mu.Unlock()
        
        em.totalErrors++
        
        // 记录错误类型
        errorType := fmt.Sprintf("%T", err)
        em.errorTypes[errorType]++
        
        // 记录最近的错误
        errorStr := fmt.Sprintf("[%s] %v", time.Now().Format("15:04:05"), err)
        if len(em.lastErrors) >= em.maxLastErrors {
            em.lastErrors = em.lastErrors[1:]
        }
        em.lastErrors = append(em.lastErrors, errorStr)
    }
    
    func (em *ErrorMetrics) GetMetrics() (int64, map[string]int64, []string) {
        em.mu.RLock()
        defer em.mu.RUnlock()
        
        // 复制错误类型统计
        errorTypes := make(map[string]int64)
        for k, v := range em.errorTypes {
            errorTypes[k] = v
        }
        
        // 复制最近错误
        lastErrors := make([]string, len(em.lastErrors))
        copy(lastErrors, em.lastErrors)
        
        return em.totalErrors, errorTypes, lastErrors
    }
    
    // 创建指标收集器
    metrics := NewErrorMetrics(5)
    
    // 模拟操作和错误记录
    operations := []func() error{
        func() error { return nil },                    // 成功
        func() error { return errors.New("普通错误") },   // 普通错误
        func() error { return fmt.Errorf("格式化错误: %w", errors.New("原因")) }, // 包装错误
        func() error { return nil },                    // 成功
        func() error { return errors.New("另一个错误") }, // 另一个错误
    }
    
    for i, op := range operations {
        if err := op(); err != nil {
            fmt.Printf("    操作%d失败: %v\n", i+1, err)
            metrics.RecordError(err)
        } else {
            fmt.Printf("    操作%d成功\n", i+1)
        }
    }
    
    // 显示指标
    total, types, last := metrics.GetMetrics()
    fmt.Printf("    总错误数: %d\n", total)
    fmt.Println("    错误类型统计:")
    for errorType, count := range types {
        fmt.Printf("      %s: %d\n", errorType, count)
    }
    fmt.Println("    最近错误:")
    for _, err := range last {
        fmt.Printf("      %s\n", err)
    }
    
    // 错误率监控
    errorRate := float64(total) / float64(len(operations)) * 100
    fmt.Printf("    错误率: %.1f%%\n", errorRate)
    
    if errorRate > 50 {
        fmt.Println("    警告: 错误率过高!")
    }
}
```

### panic和recover机制

```go
package main

import (
    "fmt"
    "log"
    "runtime"
    "sync"
    "time"
)

// panic基本概念
func panicBasics() {
    fmt.Println("=== panic基本概念 ===")
    
    // panic的作用
    fmt.Println("1. panic的作用:")
    fmt.Println("   - 立即停止当前函数的执行")
    fmt.Println("   - 开始执行defer语句")
    fmt.Println("   - 向上冒泡直到程序崩溃或被recover捕获")
    
    // 简单的panic示例
    simplePanicExample()
    
    // panic的参数类型
    panicParameterTypes()
}

func simplePanicExample() {
    fmt.Println("2. 简单的panic示例:")
    
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("    恢复了panic: %v\n", r)
        }
    }()
    
    fmt.Println("    执行正常代码...")
    panic("这是一个测试panic")
    fmt.Println("    这行代码不会执行")
}

func panicParameterTypes() {
    fmt.Println("3. panic的参数类型:")
    
    testCases := []interface{}{
        "字符串panic",
        42,
        struct{ Message string }{Message: "结构体panic"},
        nil,
    }
    
    for i, param := range testCases {
        func() {
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("    测试%d - 恢复panic(%v): %v (类型: %T)\n", i+1, param, r, r)
                }
            }()
            
            panic(param)
        }()
    }
}

// recover机制
func recoverMechanism() {
    fmt.Println("\n=== recover机制 ===")
    
    // recover的基本用法
    basicRecover()
    
    // recover的限制
    recoverLimitations()
    
    // 嵌套panic和recover
    nestedPanicRecover()
}

func basicRecover() {
    fmt.Println("1. recover的基本用法:")
    
    divide := func(a, b int) int {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    捕获到panic: %v\n", r)
            }
        }()
        
        if b == 0 {
            panic("除数不能为零")
        }
        
        return a / b
    }
    
    // 测试正常情况
    result := divide(10, 2)
    fmt.Printf("    10 / 2 = %d\n", result)
    
    // 测试panic情况
    result = divide(10, 0)
    fmt.Printf("    10 / 0 的结果: %d\n", result) // 由于panic被恢复，返回int零值
}

func recoverLimitations() {
    fmt.Println("2. recover的限制:")
    
    // recover只能在defer函数中使用才有意义
    fmt.Println("    在普通函数中调用recover:")
    r := recover() // 返回nil，因为不在defer中
    fmt.Printf("    recover()返回: %v\n", r)
    
    // recover只能捕获同一goroutine中的panic
    fmt.Println("    跨goroutine的panic无法捕获:")
    go func() {
        defer func() {
            r := recover() // 这个recover无法捕获下面的panic
            if r != nil {
                fmt.Printf("    goroutine中的recover: %v\n", r)
            }
        }()
        panic("goroutine中的panic")
    }()
    
    // 主goroutine中的recover
    func() {
        defer func() {
            r := recover() // 这个recover也无法捕获其他goroutine的panic
            if r != nil {
                fmt.Printf("    主goroutine中的recover: %v\n", r)
            }
        }()
        time.Sleep(100 * time.Millisecond)
    }()
}

func nestedPanicRecover() {
    fmt.Println("3. 嵌套panic和recover:")
    
    outerFunction := func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    外层函数捕获到panic: %v\n", r)
            }
        }()
        
        fmt.Println("    外层函数开始")
        innerFunction()
        fmt.Println("    外层函数结束")
    }
    
    innerFunction := func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    内层函数捕获到panic: %v\n", r)
                // 可以重新panic
                panic(fmt.Sprintf("重新抛出: %v", r))
            }
        }()
        
        fmt.Println("    内层函数开始")
        panic("内层函数的panic")
        fmt.Println("    内层函数结束")
    }
    
    outerFunction()
}

// panic和error的对比
func panicVsError() {
    fmt.Println("\n=== panic和error的对比 ===")
    
    // 何时使用error
    whenToUseError()
    
    // 何时使用panic
    whenToUsePanic()
    
    // 错误处理策略对比
    errorHandlingStrategyComparison()
}

func whenToUseError() {
    fmt.Println("1. 何时使用error:")
    fmt.Println("   - 预期的错误情况")
    fmt.Println("   - 调用者可以合理处理的错误")
    fmt.Println("   - 业务逻辑的一部分")
    
    // 示例：文件操作错误
    fileOperationWithError := func(filename string) error {
        if filename == "" {
            return fmt.Errorf("文件名不能为空")
        }
        // 模拟文件操作
        fmt.Printf("    处理文件: %s\n", filename)
        return nil
    }
    
    // 测试
    filenames := []string{"", "valid.txt"}
    for _, filename := range filenames {
        if err := fileOperationWithError(filename); err != nil {
            fmt.Printf("    文件操作错误: %v\n", err)
        } else {
            fmt.Printf("    文件操作成功\n")
        }
    }
}

func whenToUsePanic() {
    fmt.Println("2. 何时使用panic:")
    fmt.Println("   - 程序员错误（如数组越界、空指针）")
    fmt.Println("   - 不可恢复的错误")
    fmt.Println("   - 违反了基本假设")
    
    // 示例：数组访问越界检查
    safeArrayAccess := func(arr []int, index int) int {
        if index < 0 || index >= len(arr) {
            panic(fmt.Sprintf("数组越界: 索引%d，长度%d", index, len(arr)))
        }
        return arr[index]
    }
    
    // 测试
    arr := []int{1, 2, 3}
    indices := []int{1, 5} // 5会导致panic
    
    for _, index := range indices {
        func() {
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("    捕获到panic: %v\n", r)
                }
            }()
            
            result := safeArrayAccess(arr, index)
            fmt.Printf("    arr[%d] = %d\n", index, result)
        }()
    }
}

func errorHandlingStrategyComparison() {
    fmt.Println("3. 错误处理策略对比:")
    
    // 使用error的策略
    fmt.Println("    使用error策略:")
    divideWithError := func(a, b float64) (float64, error) {
        if b == 0 {
            return 0, fmt.Errorf("除数不能为零")
        }
        return a / b, nil
    }
    
    if result, err := divideWithError(10, 0); err != nil {
        fmt.Printf("      错误处理: %v\n", err)
    } else {
        fmt.Printf("      结果: %.2f\n", result)
    }
    
    // 使用panic的策略
    fmt.Println("    使用panic策略:")
    divideWithPanic := func(a, b float64) float64 {
        if b == 0 {
            panic("除数不能为零")
        }
        return a / b
    }
    
    func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("      panic处理: %v\n", r)
            }
        }()
        
        result := divideWithPanic(10, 0)
        fmt.Printf("      结果: %.2f\n", result)
    }()
}

// panic的实际应用场景
func panicRealWorldApplications() {
    fmt.Println("\n=== panic的实际应用场景 ===")
    
    // 1. 库函数中的契约检查
    contractChecking()
    
    // 2. 初始化过程中的致命错误
    initializationPanic()
    
    // 3. 不可恢复的系统错误
    unrecoverableSystemError()
}

func contractChecking() {
    fmt.Println("1. 库函数中的契约检查:")
    
    // 模拟一个库函数，要求输入必须满足某些条件
    type Stack struct {
        items []int
        maxSize int
    }
    
    NewStack := func(maxSize int) *Stack {
        if maxSize <= 0 {
            panic(fmt.Sprintf("栈大小必须大于0，得到: %d", maxSize))
        }
        return &Stack{
            items: make([]int, 0, maxSize),
            maxSize: maxSize,
        }
    }
    
    (s *Stack) Push(item int) {
        if len(s.items) >= s.maxSize {
            panic(fmt.Sprintf("栈溢出: 最大大小%d", s.maxSize))
        }
        s.items = append(s.items, item)
    }
    
    (s *Stack) Pop() int {
        if len(s.items) == 0 {
            panic("栈下溢: 栈为空")
        }
        item := s.items[len(s.items)-1]
        s.items = s.items[:len(s.items)-1]
        return item
    }
    
    // 测试
    func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    捕获到panic: %v\n", r)
            }
        }()
        
        // 创建无效大小的栈
        stack := NewStack(-1)
        fmt.Printf("    创建栈成功: %+v\n", stack)
    }()
    
    func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    捕获到panic: %v\n", r)
            }
        }()
        
        // 正常创建栈并测试溢出
        stack := NewStack(2)
        stack.Push(1)
        stack.Push(2)
        stack.Push(3) // 这会触发panic
    }()
}

func initializationPanic() {
    fmt.Println("2. 初始化过程中的致命错误:")
    
    // 模拟配置加载
    loadConfiguration := func() map[string]string {
        // 模拟配置文件读取失败
        configData := ""
        if configData == "" {
            panic("配置文件为空或不存在")
        }
        
        // 解析配置...
        return map[string]string{"key": "value"}
    }
    
    // 应用初始化
    initializeApplication := func() {
        defer func() {
            if r := recover(); r != nil {
                log.Fatalf("应用初始化失败: %v", r)
            }
        }()
        
        fmt.Println("    开始初始化应用...")
        config := loadConfiguration()
        fmt.Printf("    配置加载成功: %v\n", config)
        fmt.Println("    应用初始化完成")
    }
    
    // 测试初始化
    initializeApplication()
}

func unrecoverableSystemError() {
    fmt.Println("3. 不可恢复的系统错误:")
    
    // 模拟关键系统组件失败
    criticalSystemComponent := func() {
        // 模拟硬件故障或关键资源不可用
        hardwareOK := false
        if !hardwareOK {
            panic("关键硬件组件故障，系统无法继续运行")
        }
    }
    
    // 系统主循环
    systemMainLoop := func() {
        defer func() {
            if r := recover(); r != nil {
                log.Fatalf("系统崩溃: %v", r)
            }
        }()
        
        fmt.Println("    系统启动...")
        criticalSystemComponent()
        fmt.Println("    系统正常运行")
    }
    
    // 测试系统运行
    systemMainLoop()
}

// panic和recover的高级用法
func advancedPanicRecover() {
    fmt.Println("\n=== panic和recover的高级用法 ===")
    
    // 1. 错误包装和重新抛出
    errorWrappingAndRepanic()
    
    // 2. 带上下文的panic处理
    contextualPanicHandling()
    
    // 3. panic信息的详细记录
    detailedPanicLogging()
}

func errorWrappingAndRepanic() {
    fmt.Println("1. 错误包装和重新抛出:")
    
    // 自定义panic类型
    type PanicInfo struct {
        Function string
        File     string
        Line     int
        Message  string
        Stack    string
    }
    
    func (pi PanicInfo) Error() string {
        return fmt.Sprintf("[%s:%d] %s: %s\nStack:\n%s",
            pi.File, pi.Line, pi.Function, pi.Message, pi.Stack)
    }
    
    // 获取调用栈信息
    getStackTrace := func() string {
        buf := make([]byte, 1024)
        n := runtime.Stack(buf, false)
        return string(buf[:n])
    }
    
    // 包装panic的函数
    wrappedFunction := func(message string) {
        defer func() {
            if r := recover(); r != nil {
                // 获取文件和行号信息
                _, file, line, _ := runtime.Caller(1)
                
                panicInfo := PanicInfo{
                    Function: "wrappedFunction",
                    File:     file,
                    Line:     line,
                    Message:  fmt.Sprintf("%v", r),
                    Stack:    getStackTrace(),
                }
                
                // 重新抛出包装后的panic
                panic(panicInfo)
            }
        }()
        
        if message == "error" {
            panic("原始错误信息")
        }
        
        fmt.Println("    函数执行正常")
    }
    
    // 测试包装函数
    func() {
        defer func() {
            if r := recover(); r != nil {
                if panicInfo, ok := r.(PanicInfo); ok {
                    fmt.Printf("    捕获到包装的panic:\n%v\n", panicInfo.Error())
                } else {
                    fmt.Printf("    捕获到普通panic: %v\n", r)
                }
            }
        }()
        
        wrappedFunction("error")
    }()
}

func contextualPanicHandling() {
    fmt.Println("2. 带上下文的panic处理:")
    
    // 上下文信息结构
    type ContextInfo struct {
        UserID    int
        RequestID string
        Operation string
        Timestamp time.Time
    }
    
    // 带上下文的panic处理
    processWithContext := func(ctx ContextInfo, data string) {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    上下文信息: %+v\n", ctx)
                fmt.Printf("    捕获到panic: %v\n", r)
                fmt.Printf("    时间: %v\n", time.Now())
            }
        }()
        
        fmt.Printf("    处理用户%d的请求%s\n", ctx.UserID, ctx.RequestID)
        
        if data == "panic" {
            panic("处理过程中发生错误")
        }
        
        fmt.Println("    处理完成")
    }
    
    // 测试不同上下文
    contexts := []ContextInfo{
        {UserID: 123, RequestID: "req-001", Operation: "create_user", Timestamp: time.Now()},
        {UserID: 456, RequestID: "req-002", Operation: "update_profile", Timestamp: time.Now()},
    }
    
    testData := []string{"normal", "panic"}
    
    for _, ctx := range contexts {
        for _, data := range testData {
            processWithContext(ctx, data)
        }
    }
}

func detailedPanicLogging() {
    fmt.Println("3. panic信息的详细记录:")
    
    // 详细的panic记录器
    type PanicLogger struct {
        mu sync.Mutex
        logs []string
    }
    
    func (pl *PanicLogger) LogPanic(r interface{}) {
        pl.mu.Lock()
        defer pl.mu.Unlock()
        
        logEntry := fmt.Sprintf("[%s] PANIC: %v\nStack:\n%s",
            time.Now().Format("2006-01-02 15:04:05"),
            r,
            getStackTrace())
        
        pl.logs = append(pl.logs, logEntry)
        fmt.Printf("    记录panic日志:\n%s\n", logEntry)
    }
    
    func (pl *PanicLogger) GetLogs() []string {
        pl.mu.Lock()
        defer pl.mu.Unlock()
        
        logs := make([]string, len(pl.logs))
        copy(logs, pl.logs)
        return logs
    }
    
    // 创建全局panic记录器
    logger := &PanicLogger{}
    
    // 带日志记录的函数
    riskyOperation := func(id int) {
        defer func() {
            if r := recover(); r != nil {
                logger.LogPanic(r)
            }
        }()
        
        fmt.Printf("    执行风险操作%d\n", id)
        
        if id == 2 {
            panic("操作2失败")
        }
        
        fmt.Printf("    操作%d完成\n", id)
    }
    
    // 执行多个操作
    for i := 1; i <= 3; i++ {
        riskyOperation(i)
    }
    
    // 显示日志
    logs := logger.GetLogs()
    fmt.Printf("    总共记录%d条panic日志\n", len(logs))
}

// 并发环境中的panic处理
func concurrentPanicHandling() {
    fmt.Println("\n=== 并发环境中的panic处理 ===")
    
    // 1. goroutine中的panic处理
    goroutinePanicHandling()
    
    // 2. panic传播和隔离
    panicPropagationAndIsolation()
    
    // 3. 并发安全的panic处理
    concurrentSafePanicHandling()
}

func goroutinePanicHandling() {
    fmt.Println("1. goroutine中的panic处理:")
    
    // 带panic处理的worker
    worker := func(id int, jobs <-chan int, results chan<- int, errors chan<- error) {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    Worker %d 捕获到panic: %v\n", id, r)
                errors <- fmt.Errorf("worker %d panic: %v", id, r)
            }
        }()
        
        for job := range jobs {
            fmt.Printf("    Worker %d 处理任务 %d\n", id, job)
            
            // 模拟某些任务会panic
            if job == 5 {
                panic(fmt.Sprintf("任务%d导致panic", job))
            }
            
            results <- job * 2
        }
    }
    
    // 创建通道
    jobs := make(chan int, 10)
    results := make(chan int, 10)
    errors := make(chan error, 10)
    
    // 启动workers
    for i := 1; i <= 3; i++ {
        go worker(i, jobs, results, errors)
    }
    
    // 发送任务
    for i := 1; i <= 8; i++ {
        jobs <- i
    }
    close(jobs)
    
    // 收集结果和错误
    go func() {
        for i := 0; i < 8; i++ {
            select {
            case result := <-results:
                fmt.Printf("    收到结果: %d\n", result)
            case err := <-errors:
                fmt.Printf("    收到错误: %v\n", err)
            }
        }
    }()
    
    time.Sleep(100 * time.Millisecond)
}

func panicPropagationAndIsolation() {
    fmt.Println("2. panic传播和隔离:")
    
    // 隔离的goroutine组
    type IsolatedGroup struct {
        wg sync.WaitGroup
        errors chan error
    }
    
    func NewIsolatedGroup() *IsolatedGroup {
        return &IsolatedGroup{
            errors: make(chan error, 10),
        }
    }
    
    func (ig *IsolatedGroup) Go(f func() error) {
        ig.wg.Add(1)
        go func() {
            defer ig.wg.Done()
            defer func() {
                if r := recover(); r != nil {
                    ig.errors <- fmt.Errorf("panic recovered: %v", r)
                }
            }()
            
            if err := f(); err != nil {
                ig.errors <- err
            }
        }()
    }
    
    func (ig *IsolatedGroup) Wait() []error {
        ig.wg.Wait()
        close(ig.errors)
        
        var errors []error
        for err := range ig.errors {
            errors = append(errors, err)
        }
        return errors
    }
    
    // 测试隔离组
    group := NewIsolatedGroup()
    
    // 添加一些会失败的任务
    tasks := []func() error{
        func() error { return nil },                    // 成功
        func() error { panic("任务2 panic") },          // panic
        func() error { return errors.New("任务3错误") },   // 错误
        func() error { return nil },                    // 成功
    }
    
    for i, task := range tasks {
        id := i + 1
        group.Go(func() error {
            fmt.Printf("    执行任务%d\n", id)
            return task()
        })
    }
    
    // 等待所有任务完成
    errors := group.Wait()
    fmt.Printf("    总共%d个错误:\n", len(errors))
    for _, err := range errors {
        fmt.Printf("      %v\n", err)
    }
}

func concurrentSafePanicHandling() {
    fmt.Println("3. 并发安全的panic处理:")
    
    // 线程安全的panic处理器
    type SafePanicHandler struct {
        mu sync.RWMutex
        panicCount int64
        lastPanic  string
        panicTimes []time.Time
    }
    
    func (sph *SafePanicHandler) HandlePanic(r interface{}) {
        sph.mu.Lock()
        defer sph.mu.Unlock()
        
        sph.panicCount++
        sph.lastPanic = fmt.Sprintf("%v", r)
        sph.panicTimes = append(sph.panicTimes, time.Now())
        
        if len(sph.panicTimes) > 100 {
            sph.panicTimes = sph.panicTimes[1:]
        }
        
        fmt.Printf("    [安全处理] 捕获panic #%d: %v\n", sph.panicCount, r)
    }
    
    func (sph *SafePanicHandler) GetStats() (int64, string, []time.Time) {
        sph.mu.RLock()
        defer sph.mu.RUnlock()
        
        times := make([]time.Time, len(sph.panicTimes))
        copy(times, sph.panicTimes)
        
        return sph.panicCount, sph.lastPanic, times
    }
    
    // 创建全局处理器
    handler := &SafePanicHandler{}
    
    // 并发执行可能panic的函数
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            defer func() {
                if r := recover(); r != nil {
                    handler.HandlePanic(r)
                }
            }()
            
            fmt.Printf("    Goroutine %d 开始\n", id)
            time.Sleep(time.Duration(id*100) * time.Millisecond)
            
            if id%2 == 0 {
                panic(fmt.Sprintf("Goroutine %d panic", id))
            }
            
            fmt.Printf("    Goroutine %d 完成\n", id)
        }(i)
    }
    
    wg.Wait()
    
    // 显示统计信息
    count, last, times := handler.GetStats()
    fmt.Printf("    总共处理%d个panic\n", count)
    fmt.Printf("    最后一个panic: %s\n", last)
    fmt.Printf("    panic时间点: %d个\n", len(times))
}

// panic最佳实践
func panicBestPractices() {
    fmt.Println("\n=== panic最佳实践 ===")
    
    // 1. panic使用原则
    panicUsagePrinciples()
    
    // 2. recover使用原则
    recoverUsagePrinciples()
    
    // 3. 错误处理策略选择
    errorHandlingStrategySelection()
}

func panicUsagePrinciples() {
    fmt.Println("1. panic使用原则:")
    fmt.Println("   ✅ 程序员错误（如数组越界、空指针）")
    fmt.Println("   ✅ 不可恢复的致命错误")
    fmt.Println("   ✅ 违反基本假设的情况")
    fmt.Println("   ❌ 预期的业务逻辑错误")
    fmt.Println("   ❌ 可以通过error处理的情况")
    fmt.Println("   ❌ 第三方API调用失败")
    
    // 示例：正确的panic使用
    correctPanicUsage()
}

func correctPanicUsage() {
    fmt.Println("   正确的panic使用示例:")
    
    // 断言检查
    assert := func(condition bool, message string) {
        if !condition {
            panic(fmt.Sprintf("断言失败: %s", message))
        }
    }
    
    // 不变式检查
    invariantCheck := func(value int) {
        if value < 0 {
            panic(fmt.Sprintf("不变式违反: 值%d不能为负数", value))
        }
    }
    
    // 测试断言
    func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    捕获到断言panic: %v\n", r)
            }
        }()
        
        assert(2+2 == 5, "数学计算错误") // 这会触发panic
    }()
    
    // 测试不变式
    func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    捕获到不变式panic: %v\n", r)
            }
        }()
        
        invariantCheck(-1) // 这会触发panic
    }()
}

func recoverUsagePrinciples() {
    fmt.Println("2. recover使用原则:")
    fmt.Println("   ✅ 在defer函数中使用")
    fmt.Println("   ✅ 记录panic信息用于调试")
    fmt.Println("   ✅ 适当的错误恢复和清理")
    fmt.Println("   ✅ 避免忽略panic信息")
    fmt.Println("   ❌ 在普通函数中使用（无效）")
    fmt.Println("   ❌ 跨goroutine使用（无效）")
    
    // 示例：正确的recover使用
    correctRecoverUsage()
}

func correctRecoverUsage() {
    fmt.Println("   正确的recover使用示例:")
    
    // 带详细信息记录的recover
    detailedRecover := func(operation string) {
        defer func() {
            if r := recover(); r != nil {
                // 记录详细信息
                fmt.Printf("    [详细恢复] 操作'%s'发生panic: %v\n", operation, r)
                
                // 记录调用栈
                buf := make([]byte, 1024)
                n := runtime.Stack(buf, false)
                fmt.Printf("    调用栈:\n%s\n", string(buf[:n]))
                
                // 执行清理工作
                fmt.Printf("    执行清理工作...\n")
            }
        }()
        
        fmt.Printf("    执行操作: %s\n", operation)
        
        if operation == "will_panic" {
            panic("操作失败")
        }
        
        fmt.Printf("    操作完成: %s\n", operation)
    }
    
    // 测试
    operations := []string{"normal", "will_panic"}
    for _, op := range operations {
        detailedRecover(op)
    }
}

func errorHandlingStrategySelection() {
    fmt.Println("3. 错误处理策略选择:")
    
    // 决策树示例
    fmt.Println("   错误处理决策树:")
    fmt.Println("   1. 是否是程序员错误？")
    fmt.Println("      - 是 → 使用panic")
    fmt.Println("      - 否 → 继续")
    fmt.Println("   2. 是否是预期的错误情况？")
    fmt.Println("      - 是 → 使用error")
    fmt.Println("      - 否 → 继续")
    fmt.Println("   3. 调用者能否合理处理？")
    fmt.Println("      - 是 → 使用error")
    fmt.Println("      - 否 → 可能使用panic")
    
    // 实际应用示例
    strategySelectionExample()
}

func strategySelectionExample() {
    fmt.Println("   策略选择示例:")
    
    // 业务逻辑错误 - 使用error
    validateUserInput := func(input string) error {
        if len(input) == 0 {
            return fmt.Errorf("输入不能为空")
        }
        if len(input) > 100 {
            return fmt.Errorf("输入过长")
        }
        return nil
    }
    
    // 程序员错误 - 使用panic
    createFixedSizeArray := func(size int) []int {
        if size <= 0 {
            panic(fmt.Sprintf("数组大小必须为正数，得到: %d", size))
        }
        if size > 1000000 {
            panic(fmt.Sprintf("数组大小过大: %d", size))
        }
        return make([]int, size)
    }
    
    // 测试业务逻辑错误
    inputs := []string{"", "valid input", "a very long input that exceeds the maximum allowed length"}
    for _, input := range inputs {
        if err := validateUserInput(input); err != nil {
            fmt.Printf("    输入验证错误: %v\n", err)
        } else {
            fmt.Printf("    输入验证通过: %s\n", input)
        }
    }
    
    // 测试程序员错误
    sizes := []int{-1, 10, 2000000}
    for _, size := range sizes {
        func() {
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("    捕获到数组创建panic: %v\n", r)
                }
            }()
            
            arr := createFixedSizeArray(size)
            fmt.Printf("    创建数组成功，大小: %d\n", len(arr))
        }()
    }
}

// 实际应用案例
func realWorldPanicApplications() {
    fmt.Println("\n=== 实际应用案例 ===")
    
    // 1. Web服务器panic处理
    webServerPanicHandling()
    
    // 2. 数据库连接池panic处理
    databasePoolPanicHandling()
    
    // 3. 微服务间panic传播处理
    microservicePanicHandling()
}

func webServerPanicHandling() {
    fmt.Println("1. Web服务器panic处理:")
    
    // HTTP处理器panic恢复中间件
    type HTTPHandler struct {
        handler func(http.ResponseWriter, *http.Request)
    }
    
    func (h *HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                // 记录panic信息
                log.Printf("HTTP处理panic [URL: %s]: %v", r.URL.Path, err)
                
                // 返回500错误
                http.Error(w, "内部服务器错误", http.StatusInternalServerError)
            }
        }()
        
        h.handler(w, r)
    }
    
    // 模拟HTTP处理器
    riskyHandler := func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "处理请求: %s\n", r.URL.Path)
        
        // 模拟某些路径会panic
        if r.URL.Path == "/panic" {
            panic("处理/painc路径时发生错误")
        }
        
        fmt.Fprintf(w, "请求处理完成\n")
    }
    
    // 创建处理器
    handler := &HTTPHandler{handler: riskyHandler}
    
    // 模拟请求处理
    testRequests := []string{"/normal", "/panic"}
    for _, path := range testRequests {
        fmt.Printf("    模拟处理请求: %s\n", path)
        
        // 模拟HTTP请求和响应
        req, _ := http.NewRequest("GET", path, nil)
        
        func() {
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("      捕获到处理panic: %v\n", r)
                }
            }()
            
            handler.ServeHTTP(nil, req)
        }()
    }
}

func databasePoolPanicHandling() {
    fmt.Println("2. 数据库连接池panic处理:")
    
    // 简化的连接池实现
    type ConnectionPool struct {
        connections chan *DBConnection
        maxSize     int
        mu          sync.Mutex
        activeCount int
    }
    
    type DBConnection struct {
        id       int
        isActive bool
    }
    
    func NewConnectionPool(maxSize int) *ConnectionPool {
        return &ConnectionPool{
            connections: make(chan *DBConnection, maxSize),
            maxSize:     maxSize,
        }
    }
    
    func (cp *ConnectionPool) GetConnection() (*DBConnection, error) {
        select {
        case conn := <-cp.connections:
            return conn, nil
        default:
            cp.mu.Lock()
            if cp.activeCount < cp.maxSize {
                cp.activeCount++
                id := cp.activeCount
                cp.mu.Unlock()
                return &DBConnection{id: id, isActive: true}, nil
            }
            cp.mu.Unlock()
            return nil, errors.New("连接池已满")
        }
    }
    
    func (cp *ConnectionPool) ReturnConnection(conn *DBConnection) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("返回连接时发生panic: %v", r)
                // 确保连接被正确清理
                conn.isActive = false
            }
        }()
        
        if conn == nil || !conn.isActive {
            panic("尝试返回无效连接")
        }
        
        select {
        case cp.connections <- conn:
            // 连接返回成功
        default:
            // 连接池已满，关闭连接
            conn.isActive = false
            fmt.Printf("    连接%d已关闭（连接池满）\n", conn.id)
        }
    }
    
    // 测试连接池
    pool := NewConnectionPool(2)
    
    // 获取连接
    conn1, err := pool.GetConnection()
    if err != nil {
        fmt.Printf("    获取连接1失败: %v\n", err)
    } else {
        fmt.Printf("    获取连接1成功: %d\n", conn1.id)
    }
    
    conn2, err := pool.GetConnection()
    if err != nil {
        fmt.Printf("    获取连接2失败: %v\n", err)
    } else {
        fmt.Printf("    获取连接2成功: %d\n", conn2.id)
    }
    
    // 测试panic情况
    func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("    捕获到返回连接panic: %v\n", r)
            }
        }()
        
        // 尝试返回nil连接（会触发panic）
        pool.ReturnConnection(nil)
    }()
    
    // 正常返回连接
    if conn1 != nil {
        pool.ReturnConnection(conn1)
        fmt.Printf("    连接1返回成功\n")
    }
}

func microservicePanicHandling() {
    fmt.Println("3. 微服务间panic传播处理:")
    
    // 服务间通信的panic处理
    type ServiceClient struct {
        serviceName string
        timeout     time.Duration
    }
    
    func (sc *ServiceClient) Call(method string, data interface{}) (interface{}, error) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("服务调用panic [服务: %s, 方法: %s]: %v", sc.serviceName, method, r)
                // 可以选择重试、降级或返回错误
            }
        }()
        
        fmt.Printf("    调用服务 %s 的方法 %s\n", sc.serviceName, method)
        
        // 模拟服务调用
        switch sc.serviceName {
        case "user-service":
            if method == "get-user" {
                return map[string]interface{}{"id": 1, "name": "Alice"}, nil
            }
        case "payment-service":
            if method == "process-payment" {
                // 模拟支付服务panic
                panic("支付处理失败：网络超时")
            }
        }
        
        return nil, fmt.Errorf("未知服务方法: %s.%s", sc.serviceName, method)
    }
    
    // 服务调用管理器
    type ServiceManager struct {
        clients map[string]*ServiceClient
    }
    
    func NewServiceManager() *ServiceManager {
        return &ServiceManager{
            clients: map[string]*ServiceClient{
                "user": &ServiceClient{serviceName: "user-service", timeout: time.Second * 5},
                "payment": &ServiceClient{serviceName: "payment-service", timeout: time.Second * 10},
            },
        }
    }
    
    func (sm *ServiceManager) CallService(serviceName, method string, data interface{}) (interface{}, error) {
        client, exists := sm.clients[serviceName]
        if !exists {
            return nil, fmt.Errorf("未知服务: %s", serviceName)
        }
        
        // 带超时的调用
        resultChan := make(chan interface{}, 1)
        errorChan := make(chan error, 1)
        
        go func() {
            defer func() {
                if r := recover(); r != nil {
                    errorChan <- fmt.Errorf("服务调用panic: %v", r)
                }
            }()
            
            result, err := client.Call(method, data)
            if err != nil {
                errorChan <- err
            } else {
                resultChan <- result
            }
        }()
        
        select {
        case result := <-resultChan:
            return result, nil
        case err := <-errorChan:
            return nil, err
        case <-time.After(client.timeout):
            return nil, fmt.Errorf("服务调用超时: %s.%s", serviceName, method)
        }
    }
    
    // 测试微服务调用
    manager := NewServiceManager()
    
    // 测试正常调用
    fmt.Println("    测试正常服务调用:")
    if result, err := manager.CallService("user", "get-user", nil); err != nil {
        fmt.Printf("      调用失败: %v\n", err)
    } else {
        fmt.Printf("      调用成功: %v\n", result)
    }
    
    // 测试panic服务调用
    fmt.Println("    测试panic服务调用:")
    if result, err := manager.CallService("payment", "process-payment", nil); err != nil {
        fmt.Printf("      调用失败: %v\n", err)
    } else {
        fmt.Printf("      调用成功: %v\n", result)
    }
}

func main() {
    panicBasics()
    recoverMechanism()
    panicVsError()
    panicRealWorldApplications()
    advancedPanicRecover()
    concurrentPanicHandling()
    panicBestPractices()
    realWorldPanicApplications()
    
    // 总结和最佳实践
    fmt.Println("\n=== 总结和最佳实践 ===")
    summaryAndBestPractices()
}

func summaryAndBestPractices() {
    fmt.Println("panic和recover总结:")
    fmt.Println("1. panic用于处理程序错误和不可恢复的致命错误")
    fmt.Println("2. recover用于捕获和处理panic，防止程序崩溃")
    fmt.Println("3. recover只能在defer函数中使用，且只能捕获同一goroutine的panic")
    fmt.Println("4. 合理使用panic和error，遵循错误处理最佳实践")
    fmt.Println("5. 在并发环境中特别注意panic的传播和处理")
    fmt.Println("6. 记录详细的panic信息用于调试和监控")
    
    // 最终演示：完整的错误处理流程
    fmt.Println("\n最终演示：完整的错误处理流程:")
    completeErrorHandlingFlow()
}

func completeErrorHandlingFlow() {
    // 模拟一个完整的应用错误处理流程
    type Application struct {
        name    string
        version string
        logger  *PanicLogger
    }
    
    func NewApplication(name, version string) *Application {
        return &Application{
            name:    name,
            version: version,
            logger:  &PanicLogger{},
        }
    }
    
    func (app *Application) Run() {
        fmt.Printf("应用 %s v%s 启动\n", app.name, app.version)
        
        defer func() {
            if r := recover(); r != nil {
                app.logger.LogPanic(r)
                fmt.Printf("应用因panic终止: %v\n", r)
                
                // 执行清理工作
                app.cleanup()
                
                // 记录最终状态
                logs := app.logger.GetLogs()
                fmt.Printf("总共记录%d个panic\n", len(logs))
            }
        }()
        
        // 初始化组件
        app.initialize()
        
        // 运行业务逻辑
        app.businessLogic()
        
        fmt.Println("应用正常结束")
    }
    
    func (app *Application) initialize() {
        fmt.Println("  初始化组件...")
        
        // 模拟初始化失败
        if app.version == "1.0.0-bad" {
            panic("初始化失败：配置文件损坏")
        }
        
        fmt.Println("  组件初始化成功")
    }
    
    func (app *Application) businessLogic() {
        fmt.Println("  执行业务逻辑...")
        
        // 模拟并发任务
        var wg sync.WaitGroup
        for i := 0; i < 3; i++ {
            wg.Add(1)
            go func(id int) {
                defer wg.Done()
                defer func() {
                    if r := recover(); r != nil {
                        app.logger.LogPanic(fmt.Sprintf("任务%d panic: %v", id, r))
                    }
                }()
                
                fmt.Printf("    执行任务%d\n", id)
                
                // 模拟某些任务失败
                if id == 1 {
                    panic(fmt.Sprintf("任务%d执行失败", id))
                }
                
                fmt.Printf("    任务%d完成\n", id)
            }(i)
        }
        
        wg.Wait()
    }
    
    func (app *Application) cleanup() {
        fmt.Println("  执行清理工作...")
        // 清理资源...
        fmt.Println("  清理完成")
    }
    
    // 测试正常应用
    fmt.Println("测试正常应用:")
    normalApp := NewApplication("MyApp", "1.0.0")
    normalApp.Run()
    
    fmt.Println()
    
    // 测试有问题的应用
    fmt.Println("测试有问题的应用:")
    badApp := NewApplication("BadApp", "1.0.0-bad")
    badApp.Run()
}
```