## 12.1 Web安全

### XSS防护

#### XSS攻击防护实现
```go
package main

import (
    "html"
    "html/template"
    "net/http"
    "regexp"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
)

// XSS防护中间件
type XSSProtection struct {
    // 预定义的危险标签和属性
    dangerousTags      []string
    dangerousAttributes []string
    scriptPattern      *regexp.Regexp
    eventPattern       *regexp.Regexp
}

func NewXSSProtection() *XSSProtection {
    return &XSSProtection{
        dangerousTags: []string{
            "script", "iframe", "object", "embed", "link", "meta", "style",
            "form", "input", "button", "select", "textarea", "frame", "frameset",
        },
        dangerousAttributes: []string{
            "onload", "onerror", "onclick", "onmouseover", "onmouseout",
            "onsubmit", "onreset", "onfocus", "onblur", "onchange",
            "onkeydown", "onkeypress", "onkeyup", "onabort", "oncanplay",
        },
        scriptPattern: regexp.MustCompile(`(?i)<script[^>]*>.*?</script>`),
        eventPattern:  regexp.MustCompile(`(?i)\s*on\w+\s*=\s*["'][^"']*["']`),
    }
}

// 清理HTML内容，防止XSS攻击
func (xss *XSSProtection) SanitizeHTML(input string) string {
    // 1. 移除危险的script标签
    clean := xss.scriptPattern.ReplaceAllString(input, "")
    
    // 2. 移除事件属性
    clean = xss.eventPattern.ReplaceAllString(clean, "")
    
    // 3. 移除危险标签
    for _, tag := range xss.dangerousTags {
        pattern := regexp.MustCompile(`(?i)<\s*` + tag + `[^>]*>`)
        clean = pattern.ReplaceAllString(clean, "")
        pattern = regexp.MustCompile(`(?i)</\s*` + tag + `\s*>`)
        clean = pattern.ReplaceAllString(clean, "")
    }
    
    // 4. 移除危险属性
    for _, attr := range xss.dangerousAttributes {
        pattern := regexp.MustCompile(`(?i)\s+` + attr + `\s*=\s*["'][^"']*["']`)
        clean = pattern.ReplaceAllString(clean, "")
    }
    
    // 5. HTML转义
    clean = html.EscapeString(clean)
    
    return clean
}

// 验证输入内容是否安全
func (xss *XSSProtection) IsSafeInput(input string) bool {
    // 检查是否包含危险内容
    if xss.scriptPattern.MatchString(input) {
        return false
    }
    
    if xss.eventPattern.MatchString(input) {
        return false
    }
    
    // 检查危险标签
    lowerInput := strings.ToLower(input)
    for _, tag := range xss.dangerousTags {
        if strings.Contains(lowerInput, "<"+tag) {
            return false
        }
    }
    
    return true
}

// XSS防护中间件
func (xss *XSSProtection) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 检查请求参数
        for key, values := range c.Request.URL.Query() {
            for _, value := range values {
                if !xss.IsSafeInput(value) {
                    c.JSON(http.StatusBadRequest, gin.H{
                        "error": "检测到潜在的XSS攻击",
                        "field": key,
                    })
                    c.Abort()
                    return
                }
            }
        }
        
        // 检查POST表单数据
        if c.Request.Method == "POST" || c.Request.Method == "PUT" {
            c.Request.ParseForm()
            for key, values := range c.Request.PostForm {
                for _, value := range values {
                    if !xss.IsSafeInput(value) {
                        c.JSON(http.StatusBadRequest, gin.H{
                            "error": "检测到潜在的XSS攻击",
                            "field": key,
                        })
                        c.Abort()
                        return
                    }
                }
            }
        }
        
        c.Next()
    }
}

// 安全的HTML渲染
type SafeHTMLRenderer struct {
    xss *XSSProtection
}

func NewSafeHTMLRenderer() *SafeHTMLRenderer {
    return &SafeHTMLRenderer{
        xss: NewXSSProtection(),
    }
}

// 安全地渲染用户输入的内容
func (shr *SafeHTMLRenderer) RenderSafeContent(content string) template.HTML {
    sanitized := shr.xss.SanitizeHTML(content)
    return template.HTML(sanitized)
}

// XSS防护示例应用
func XSSProtectionExample() {
    r := gin.Default()
    
    // 创建XSS防护实例
    xss := NewXSSProtection()
    
    // 使用XSS防护中间件
    r.Use(xss.Middleware())
    
    // 创建安全HTML渲染器
    renderer := NewSafeHTMLRenderer()
    
    // 处理用户评论提交
    r.POST("/comment", func(c *gin.Context) {
        comment := c.PostForm("comment")
        
        // 额外的输入验证
        if len(comment) > 1000 {
            c.JSON(http.StatusBadRequest, gin.H{"error": "评论内容过长"})
            return
        }
        
        // 清理输入内容
        safeComment := xss.SanitizeHTML(comment)
        
        // 保存到数据库（这里简化处理）
        c.JSON(http.StatusOK, gin.H{
            "message": "评论提交成功",
            "comment": safeComment,
        })
    })
    
    // 显示用户内容
    r.GET("/user/:id", func(c *gin.Context) {
        userID := c.Param("id")
        
        // 从数据库获取用户数据（模拟）
        userBio := "<p>这是一个安全的用户简介</p><script>alert('XSS')</script>"
        
        // 渲染安全内容
        safeBio := renderer.RenderSafeContent(userBio)
        
        c.HTML(http.StatusOK, "user.html", gin.H{
            "userID": userID,
            "bio":    safeBio,
        })
    })
    
    // 启动服务器
    r.Run(":8080")
}
```

#### CSP (Content Security Policy) 实现
```go
// CSP中间件
type CSPMiddleware struct {
    policy string
}

func NewCSPMiddleware() *CSPMiddleware {
    // 定义CSP策略
    policy := "default-src 'self'; " +
        "script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; " +
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " +
        "img-src 'self' data: https:; " +
        "font-src 'self' https://fonts.gstatic.com; " +
        "connect-src 'self'; " +
        "frame-ancestors 'none'; " +
        "form-action 'self'; " +
        "base-uri 'self';"
    
    return &CSPMiddleware{policy: policy}
}

func (csp *CSPMiddleware) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 设置CSP头
        c.Header("Content-Security-Policy", csp.policy)
        c.Header("X-Content-Security-Policy", csp.policy)
        c.Header("X-WebKit-CSP", csp.policy)
        
        c.Next()
    }
}

// 安全头设置中间件
func SecurityHeadersMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 设置各种安全头
        c.Header("X-Frame-Options", "DENY")                    // 防止点击劫持
        c.Header("X-XSS-Protection", "1; mode=block")          // XSS保护
        c.Header("X-Content-Type-Options", "nosniff")          // 防止MIME类型嗅探
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin") // 引用策略
        c.Header("Permissions-Policy", "geolocation=(), microphone=(), camera=()") // 权限策略
        
        c.Next()
    }
}
```

### CSRF防护

#### CSRF防护实现
```go
package main

import (
    "crypto/rand"
    "crypto/subtle"
    "encoding/base64"
    "fmt"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/gorilla/sessions"
    "github.com/pkg/errors"
)

// CSRF令牌管理器
type CSRFTokenManager struct {
    store sessions.Store
}

func NewCSRFTokenManager(secret []byte) *CSRFTokenManager {
    store := sessions.NewCookieStore(secret)
    store.Options = &sessions.Options{
        Path:     "/",
        MaxAge:   86400 * 7, // 7天
        HttpOnly: true,
        Secure:   true, // 生产环境应设置为true
        SameSite: http.SameSiteStrictMode,
    }
    
    return &CSRFTokenManager{store: store}
}

// 生成CSRF令牌
func (ctm *CSRFTokenManager) GenerateToken() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", errors.Wrap(err, "failed to generate random bytes")
    }
    
    return base64.URLEncoding.EncodeToString(bytes), nil
}

// 验证CSRF令牌
func (ctm *CSRFTokenManager) ValidateToken(sessionToken, requestToken string) bool {
    if sessionToken == "" || requestToken == "" {
        return false
    }
    
    // 使用常数时间比较防止时序攻击
    sessionBytes, err1 := base64.URLEncoding.DecodeString(sessionToken)
    requestBytes, err2 := base64.URLEncoding.DecodeString(requestToken)
    
    if err1 != nil || err2 != nil {
        return false
    }
    
    return subtle.ConstantTimeCompare(sessionBytes, requestBytes) == 1
}

// 获取会话中的CSRF令牌
func (ctm *CSRFTokenManager) GetSessionToken(c *gin.Context) (string, error) {
    session, err := ctm.store.Get(c.Request, "csrf-session")
    if err != nil {
        return "", errors.Wrap(err, "failed to get session")
    }
    
    if token, ok := session.Values["csrf_token"].(string); ok {
        return token, nil
    }
    
    return "", nil
}

// 设置会话中的CSRF令牌
func (ctm *CSRFTokenManager) SetSessionToken(c *gin.Context, token string) error {
    session, err := ctm.store.Get(c.Request, "csrf-session")
    if err != nil {
        return errors.Wrap(err, "failed to get session")
    }
    
    session.Values["csrf_token"] = token
    return session.Save(c.Request, c.Writer)
}

// CSRF防护中间件
func (ctm *CSRFTokenManager) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 对于需要CSRF保护的方法
        if c.Request.Method == "POST" || c.Request.Method == "PUT" || 
           c.Request.Method == "DELETE" || c.Request.Method == "PATCH" {
            
            // 从会话获取令牌
            sessionToken, err := ctm.GetSessionToken(c)
            if err != nil {
                c.JSON(http.StatusForbidden, gin.H{"error": "CSRF令牌验证失败"})
                c.Abort()
                return
            }
            
            // 从请求获取令牌
            var requestToken string
            // 首先检查表单字段
            requestToken = c.PostForm("_csrf_token")
            if requestToken == "" {
                // 然后检查请求头
                requestToken = c.GetHeader("X-CSRF-Token")
            }
            if requestToken == "" {
                // 最后检查查询参数（不推荐）
                requestToken = c.Query("_csrf_token")
            }
            
            // 验证令牌
            if !ctm.ValidateToken(sessionToken, requestToken) {
                c.JSON(http.StatusForbidden, gin.H{"error": "无效的CSRF令牌"})
                c.Abort()
                return
            }
        }
        
        c.Next()
    }
}

// 生成CSRF令牌的处理函数
func (ctm *CSRFTokenManager) GenerateTokenHandler(c *gin.Context) {
    token, err := ctm.GenerateToken()
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "生成令牌失败"})
        return
    }
    
    // 保存到会话
    if err := ctm.SetSessionToken(c, token); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "保存令牌失败"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "token": token,
        "expires": time.Now().Add(24 * time.Hour).Unix(),
    })
}

// 双重提交Cookie模式的CSRF防护
type DoubleSubmitCookieCSRF struct {
    cookieName string
    secret     []byte
}

func NewDoubleSubmitCookieCSRF(secret []byte) *DoubleSubmitCookieCSRF {
    return &DoubleSubmitCookieCSRF{
        cookieName: "csrf_token",
        secret:     secret,
    }
}

// 设置CSRF Cookie
func (dsc *DoubleSubmitCookieCSRF) SetCSRFCookie(c *gin.Context) (string, error) {
    token, err := dsc.generateToken()
    if err != nil {
        return "", err
    }
    
    c.SetCookie(dsc.cookieName, token, 3600, "/", "", true, true)
    return token, nil
}

// 验证CSRF令牌
func (dsc *DoubleSubmitCookieCSRF) ValidateCSRFToken(c *gin.Context) error {
    // 获取Cookie中的令牌
    cookieToken, err := c.Cookie(dsc.cookieName)
    if err != nil {
        return fmt.Errorf("missing CSRF cookie")
    }
    
    // 获取请求中的令牌
    var requestToken string
    requestToken = c.PostForm("_csrf_token")
    if requestToken == "" {
        requestToken = c.GetHeader("X-CSRF-Token")
    }
    
    if requestToken == "" {
        return fmt.Errorf("missing CSRF token in request")
    }
    
    // 验证令牌匹配
    if cookieToken != requestToken {
        return fmt.Errorf("CSRF token mismatch")
    }
    
    return nil
}

func (dsc *DoubleSubmitCookieCSRF) generateToken() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    
    return base64.URLEncoding.EncodeToString(bytes), nil
}

// CSRF防护示例
func CSRFProtectionExample() {
    r := gin.Default()
    
    // 初始化CSRF管理器
    csrfSecret := []byte("your-csrf-secret-key-must-be-32-bytes")
    csrfManager := NewCSRFTokenManager(csrfSecret)
    
    // 使用CSRF中间件
    r.Use(csrfManager.Middleware())
    
    // 使用安全头中间件
    r.Use(SecurityHeadersMiddleware())
    
    // 生成CSRF令牌
    r.GET("/csrf-token", func(c *gin.Context) {
        csrfManager.GenerateTokenHandler(c)
    })
    
    // 受保护的表单提交
    r.POST("/transfer", func(c *gin.Context) {
        amount := c.PostForm("amount")
        toAccount := c.PostForm("to_account")
        
        c.JSON(http.StatusOK, gin.H{
            "message": "转账成功",
            "amount":  amount,
            "to":      toAccount,
        })
    })
    
    // 受保护的删除操作
    r.DELETE("/user/:id", func(c *gin.Context) {
        userID := c.Param("id")
        
        c.JSON(http.StatusOK, gin.H{
            "message": "用户删除成功",
            "user_id": userID,
        })
    })
    
    r.Run(":8080")
}
```

### SQL注入防护

#### SQL注入防护实现
```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "regexp"
    "strings"
    
    _ "github.com/go-sql-driver/mysql"
    "github.com/jmoiron/sqlx"
)

// SQL注入防护器
type SQLInjectionProtection struct {
    db *sqlx.DB
}

func NewSQLInjectionProtection(dataSourceName string) (*SQLInjectionProtection, error) {
    db, err := sqlx.Connect("mysql", dataSourceName)
    if err != nil {
        return nil, err
    }
    
    return &SQLInjectionProtection{db: db}, nil
}

// 参数化查询 - 最佳防护方法
func (sip *SQLInjectionProtection) GetUserByID(userID int) (*User, error) {
    var user User
    query := "SELECT id, name, email FROM users WHERE id = ?"
    
    err := sip.db.Get(&user, query, userID)
    if err != nil {
        return nil, err
    }
    
    return &user, nil
}

// 安全的用户查询
func (sip *SQLInjectionProtection) GetUserByEmail(email string) (*User, error) {
    // 输入验证
    if !isValidEmail(email) {
        return nil, fmt.Errorf("invalid email format")
    }
    
    var user User
    query := "SELECT id, name, email FROM users WHERE email = ?"
    
    err := sip.db.Get(&user, query, email)
    if err != nil {
        return nil, err
    }
    
    return &user, nil
}

// 批量查询安全实现
func (sip *SQLInjectionProtection) GetUsersByIDs(userIDs []int) ([]User, error) {
    if len(userIDs) == 0 {
        return []User{}, nil
    }
    
    // 构建占位符
    placeholders := make([]string, len(userIDs))
    args := make([]interface{}, len(userIDs))
    
    for i, id := range userIDs {
        placeholders[i] = "?"
        args[i] = id
    }
    
    query := fmt.Sprintf("SELECT id, name, email FROM users WHERE id IN (%s)", 
        strings.Join(placeholders, ","))
    
    var users []User
    err := sip.db.Select(&users, query, args...)
    if err != nil {
        return nil, err
    }
    
    return users, nil
}

// 动态查询构建器
type QueryBuilder struct {
    baseQuery string
    wheres    []string
    args      []interface{}
}

func NewQueryBuilder(baseQuery string) *QueryBuilder {
    return &QueryBuilder{
        baseQuery: baseQuery,
        wheres:    make([]string, 0),
        args:      make([]interface{}, 0),
    }
}

func (qb *QueryBuilder) Where(column string, value interface{}) *QueryBuilder {
    // 验证列名（防止列名注入）
    if !isValidColumnName(column) {
        panic("invalid column name")
    }
    
    qb.wheres = append(qb.wheres, column+" = ?")
    qb.args = append(qb.args, value)
    return qb
}

func (qb *QueryBuilder) WhereIn(column string, values []interface{}) *QueryBuilder {
    if !isValidColumnName(column) {
        panic("invalid column name")
    }
    
    if len(values) == 0 {
        return qb
    }
    
    placeholders := make([]string, len(values))
    for i := range values {
        placeholders[i] = "?"
    }
    
    qb.wheres = append(qb.wheres, column+" IN ("+strings.Join(placeholders, ",")+")")
    qb.args = append(qb.args, values...)
    return qb
}

func (qb *QueryBuilder) Build() (string, []interface{}) {
    query := qb.baseQuery
    
    if len(qb.wheres) > 0 {
        query += " WHERE " + strings.Join(qb.wheres, " AND ")
    }
    
    return query, qb.args
}

// 输入验证函数
func isValidEmail(email string) bool {
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    return emailRegex.MatchString(email)
}

func isValidColumnName(column string) bool {
    // 白名单验证允许的列名
    allowedColumns := map[string]bool{
        "id":    true,
        "name":  true,
        "email": true,
        "age":   true,
        "status": true,
        "created_at": true,
    }
    
    // 检查是否只包含字母、数字和下划线
    columnRegex := regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)
    if !columnRegex.MatchString(column) {
        return false
    }
    
    return allowedColumns[column]
}

// SQL关键字过滤器
type SQLKeywordFilter struct {
    dangerousKeywords []string
}

func NewSQLKeywordFilter() *SQLKeywordFilter {
    return &SQLKeywordFilter{
        dangerousKeywords: []string{
            "UNION", "SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "CREATE",
            "ALTER", "EXEC", "EXECUTE", "TRUNCATE", "SCRIPT", "OBJECT",
        },
    }
}

func (skf *SQLKeywordFilter) ContainsDangerousKeywords(input string) bool {
    upperInput := strings.ToUpper(input)
    for _, keyword := range skf.dangerousKeywords {
        if strings.Contains(upperInput, keyword) {
            return true
        }
    }
    return false
}

// 安全的搜索功能
func (sip *SQLInjectionProtection) SearchUsers(keyword string) ([]User, error) {
    // 输入清理和验证
    keyword = strings.TrimSpace(keyword)
    if len(keyword) == 0 || len(keyword) > 100 {
        return []User{}, nil
    }
    
    // 转义特殊字符
    keyword = strings.ReplaceAll(keyword, "%", "\\%")
    keyword = strings.ReplaceAll(keyword, "_", "\\_")
    
    // 使用参数化查询
    query := "SELECT id, name, email FROM users WHERE name LIKE ? OR email LIKE ?"
    searchPattern := "%" + keyword + "%"
    
    var users []User
    err := sip.db.Select(&users, query, searchPattern, searchPattern)
    if err != nil {
        return nil, err
    }
    
    return users, nil
}

// 存储过程调用示例
func (sip *SQLInjectionProtection) CallStoredProcedure(procName string, args ...interface{}) error {
    // 验证存储过程名称
    if !isValidStoredProcedureName(procName) {
        return fmt.Errorf("invalid stored procedure name")
    }
    
    // 构建调用语句
    placeholders := make([]string, len(args))
    for i := range args {
        placeholders[i] = "?"
    }
    
    query := fmt.Sprintf("CALL %s(%s)", procName, strings.Join(placeholders, ","))
    
    _, err := sip.db.Exec(query, args...)
    return err
}

func isValidStoredProcedureName(name string) bool {
    // 白名单验证存储过程名称
    allowedProcs := map[string]bool{
        "get_user_info":    true,
        "update_user_info": true,
        "delete_user":      true,
    }
    
    return allowedProcs[name]
}

// ORM安全使用示例
type SafeORM struct {
    db *sqlx.DB
}

func NewSafeORM(db *sqlx.DB) *SafeORM {
    return &SafeORM{db: db}
}

// 安全的条件查询
func (sorm *SafeORM) FindUsers(conditions map[string]interface{}) ([]User, error) {
    qb := NewQueryBuilder("SELECT id, name, email FROM users")
    
    for column, value := range conditions {
        // 验证列名和值
        if !isValidColumnName(column) {
            return nil, fmt.Errorf("invalid column name: %s", column)
        }
        
        qb.Where(column, value)
    }
    
    query, args := qb.Build()
    
    var users []User
    err := sorm.db.Select(&users, query, args...)
    if err != nil {
        return nil, err
    }
    
    return users, nil
}

// 用户模型
type User struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Email string `db:"email"`
    Age   int    `db:"age"`
}

// SQL注入防护示例应用
func SQLInjectionProtectionExample() {
    // 连接数据库
    sip, err := NewSQLInjectionProtection("user:password@tcp(localhost:3306)/dbname")
    if err != nil {
        log.Fatal(err)
    }
    
    // 安全查询示例
    user, err := sip.GetUserByID(1)
    if err != nil {
        log.Printf("查询用户失败: %v", err)
    } else {
        fmt.Printf("找到用户: %+v\n", user)
    }
    
    // 安全搜索示例
    users, err := sip.SearchUsers("john")
    if err != nil {
        log.Printf("搜索用户失败: %v", err)
    } else {
        fmt.Printf("搜索结果: %+v\n", users)
    }
    
    // 安全条件查询示例
    safeORM := NewSafeORM(sip.db)
    conditions := map[string]interface{}{
        "name":  "John",
        "email": "john@example.com",
    }
    
    users, err = safeORM.FindUsers(conditions)
    if err != nil {
        log.Printf("条件查询失败: %v", err)
    } else {
        fmt.Printf("条件查询结果: %+v\n", users)
    }
}
```

### 认证授权机制

#### JWT认证实现
```go
package main

import (
    "crypto/rsa"
    "crypto/x509"
    "encoding/pem"
    "fmt"
    "io/ioutil"
    "net/http"
    "os"
    "strings"
    "time"
    
    "github.com/dgrijalva/jwt-go"
    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
)

// 用户模型
type AuthUser struct {
    ID       uint   `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Password string `json:"password,omitempty"`
    Role     string `json:"role"`
}

// JWT管理器
type JWTManager struct {
    privateKey *rsa.PrivateKey
    publicKey  *rsa.PublicKey
    issuer     string
    audience   string
}

// JWT声明
type UserClaims struct {
    jwt.StandardClaims
    UserID   uint   `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
}

func NewJWTManager(privateKeyPath, publicKeyPath, issuer, audience string) (*JWTManager, error) {
    // 加载私钥
    privateBytes, err := ioutil.ReadFile(privateKeyPath)
    if err != nil {
        return nil, err
    }
    
    privatePEM, _ := pem.Decode(privateBytes)
    privateKey, err := x509.ParsePKCS1PrivateKey(privatePEM.Bytes)
    if err != nil {
        return nil, err
    }
    
    // 加载公钥
    publicBytes, err := ioutil.ReadFile(publicKeyPath)
    if err != nil {
        return nil, err
    }
    
    publicPEM, _ := pem.Decode(publicBytes)
    publicKey, err := x509.ParsePKCS1PublicKey(publicPEM.Bytes)
    if err != nil {
        return nil, err
    }
    
    return &JWTManager{
        privateKey: privateKey,
        publicKey:  publicKey,
        issuer:     issuer,
        audience:   audience,
    }, nil
}

// 生成JWT令牌
func (jwm *JWTManager) GenerateToken(user *AuthUser) (string, error) {
    claims := UserClaims{
        StandardClaims: jwt.StandardClaims{
            Issuer:    jwm.issuer,
            Audience:  jwm.audience,
            ExpiresAt: time.Now().Add(24 * time.Hour).Unix(),
            IssuedAt:  time.Now().Unix(),
        },
        UserID:   user.ID,
        Username: user.Username,
        Role:     user.Role,
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    return token.SignedString(jwm.privateKey)
}

// 验证JWT令牌
func (jwm *JWTManager) VerifyToken(accessToken string) (*UserClaims, error) {
    token, err := jwt.ParseWithClaims(
        accessToken,
        &UserClaims{},
        func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
                return nil, fmt.Errorf("unexpected token signing method")
            }
            return jwm.publicKey, nil
        },
    )
    
    if err != nil {
        return nil, fmt.Errorf("invalid token: %w", err)
    }
    
    claims, ok := token.Claims.(*UserClaims)
    if !ok {
        return nil, fmt.Errorf("invalid token claims")
    }
    
    return claims, nil
}

// 认证服务
type AuthService struct {
    jwtManager *JWTManager
    users      map[string]*AuthUser // 模拟用户存储
}

func NewAuthService(jwtManager *JWTManager) *AuthService {
    return &AuthService{
        jwtManager: jwtManager,
        users: map[string]*AuthUser{
            "admin": {
                ID:       1,
                Username: "admin",
                Email:    "admin@example.com",
                Password: "$2a$10$N.zmdr9k7uOCQb0bta/OauRxaOKSr.QhqyD2R5FKvMQjmHoLkm5Sy", // password
                Role:     "admin",
            },
            "user": {
                ID:       2,
                Username: "user",
                Email:    "user@example.com",
                Password: "$2a$10$N.zmdr9k7uOCQb0bta/OauRxaOKSr.QhqyD2R5FKvMQjmHoLkm5Sy", // password
                Role:     "user",
            },
        },
    }
}

// 用户登录
func (as *AuthService) Login(username, password string) (string, error) {
    user, exists := as.users[username]
    if !exists {
        return "", fmt.Errorf("invalid credentials")
    }
    
    // 验证密码
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
        return "", fmt.Errorf("invalid credentials")
    }
    
    // 生成JWT令牌
    return as.jwtManager.GenerateToken(user)
}

// JWT认证中间件
func (as *AuthService) AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "authorization header required"})
            c.Abort()
            return
        }
        
        // 解析Bearer令牌
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid authorization header format"})
            c.Abort()
            return
        }
        
        // 验证令牌
        claims, err := as.jwtManager.VerifyToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        // 将用户信息存储到上下文中
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role", claims.Role)
        
        c.Next()
    }
}

// 权限检查中间件
func (as *AuthService) RequireRole(requiredRole string) gin.HandlerFunc {
    return func(c *gin.Context) {
        role, exists := c.Get("role")
        if !exists {
            c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
            c.Abort()
            return
        }
        
        if role != requiredRole && role != "admin" {
            c.JSON(http.StatusForbidden, gin.H{"error": "insufficient permissions"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// 基于声明的权限检查
type PermissionChecker struct {
    permissions map[string][]string // role -> permissions
}

func NewPermissionChecker() *PermissionChecker {
    return &PermissionChecker{
        permissions: map[string][]string{
            "admin": {"read", "write", "delete", "manage_users"},
            "user":  {"read"},
            "editor": {"read", "write"},
        },
    }
}

func (pc *PermissionChecker) HasPermission(role, permission string) bool {
    perms, exists := pc.permissions[role]
    if !exists {
        return false
    }
    
    for _, perm := range perms {
        if perm == permission || perm == "admin" {
            return true
        }
    }
    
    return false
}

// 权限检查中间件
func (pc *PermissionChecker) RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        role, exists := c.Get("role")
        if !exists {
            c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
            c.Abort()
            return
        }
        
        if !pc.HasPermission(role.(string), permission) {
            c.JSON(http.StatusForbidden, gin.H{"error": "insufficient permissions"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// OAuth2模拟实现
type OAuth2Service struct {
    clients    map[string]*OAuthClient
    authCodes  map[string]*AuthCode
    accessTokens map[string]*AccessToken
}

type OAuthClient struct {
    ID          string
    Secret      string
    RedirectURI string
    Name        string
}

type AuthCode struct {
    Code        string
    ClientID    string
    UserID      uint
    RedirectURI string
    ExpiresAt   time.Time
    Scope       string
}

type AccessToken struct {
    Token     string
    ClientID  string
    UserID    uint
    ExpiresAt time.Time
    Scope     string
}

func NewOAuth2Service() *OAuth2Service {
    return &OAuth2Service{
        clients: map[string]*OAuthClient{
            "test_client": {
                ID:          "test_client",
                Secret:      "test_secret",
                RedirectURI: "http://localhost:3000/callback",
                Name:        "Test Client",
            },
        },
        authCodes:  make(map[string]*AuthCode),
        accessTokens: make(map[string]*AccessToken),
    }
}

// OAuth2认证示例
func OAuth2Example() {
    r := gin.Default()
    
    // 初始化JWT管理器
    jwtManager, err := NewJWTManager("private.pem", "public.pem", "myapp", "myapp-users")
    if err != nil {
        panic(err)
    }
    
    // 初始化认证服务
    authService := NewAuthService(jwtManager)
    
    // 初始化权限检查器
    permissionChecker := NewPermissionChecker()
    
    // 认证路由
    r.POST("/login", func(c *gin.Context) {
        username := c.PostForm("username")
        password := c.PostForm("password")
        
        token, err := authService.Login(username, password)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "token": token,
            "expires_in": 24 * 3600,
        })
    })
    
    // 受保护的路由
    protected := r.Group("/api")
    protected.Use(authService.AuthMiddleware())
    
    // 用户信息路由
    protected.GET("/user", func(c *gin.Context) {
        userID := c.MustGet("user_id").(uint)
        username := c.MustGet("username").(string)
        role := c.MustGet("role").(string)
        
        c.JSON(http.StatusOK, gin.H{
            "user_id": userID,
            "username": username,
            "role": role,
        })
    })
    
    // 管理员路由
    admin := protected.Group("/admin")
    admin.Use(authService.RequireRole("admin"))
    
    admin.GET("/users", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"message": "admin users list"})
    })
    
    // 权限检查路由
    editor := protected.Group("/editor")
    editor.Use(permissionChecker.RequirePermission("write"))
    
    editor.POST("/content", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"message": "content created"})
    })
    
    r.Run(":8080")
}
```

### CORS处理

#### CORS中间件实现
```go
package main

import (
    "net/http"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
)

// CORS配置
type CORSConfig struct {
    AllowOrigins     []string
    AllowMethods     []string
    AllowHeaders     []string
    ExposeHeaders    []string
    AllowCredentials bool
    MaxAge           time.Duration
}

// 默认CORS配置
func DefaultCORSConfig() CORSConfig {
    return CORSConfig{
        AllowOrigins: []string{"*"},
        AllowMethods: []string{
            http.MethodGet,
            http.MethodPost,
            http.MethodPut,
            http.MethodPatch,
            http.MethodDelete,
            http.MethodOptions,
        },
        AllowHeaders: []string{
            "Origin",
            "Content-Length",
            "Content-Type",
            "Authorization",
            "X-Requested-With",
            "Accept",
            "X-CSRF-Token",
        },
        ExposeHeaders:    []string{},
        AllowCredentials: false,
        MaxAge:           12 * time.Hour,
    }
}

// CORS中间件
type CORSMiddleware struct {
    config CORSConfig
}

func NewCORSMiddleware(config CORSConfig) *CORSMiddleware {
    return &CORSMiddleware{config: config}
}

func (cm *CORSMiddleware) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")
        
        // 检查源是否被允许
        if !cm.isOriginAllowed(origin) {
            c.Next()
            return
        }
        
        // 设置CORS头
        c.Header("Access-Control-Allow-Origin", cm.getAllowedOrigin(origin))
        
        // 预检请求处理
        if c.Request.Method == http.MethodOptions {
            c.Header("Access-Control-Allow-Methods", strings.Join(cm.config.AllowMethods, ", "))
            c.Header("Access-Control-Allow-Headers", strings.Join(cm.config.AllowHeaders, ", "))
            
            if cm.config.AllowCredentials {
                c.Header("Access-Control-Allow-Credentials", "true")
            }
            
            if len(cm.config.ExposeHeaders) > 0 {
                c.Header("Access-Control-Expose-Headers", strings.Join(cm.config.ExposeHeaders, ", "))
            }
            
            c.Header("Access-Control-Max-Age", cm.config.MaxAge.String())
            
            c.AbortWithStatus(http.StatusNoContent)
            return
        }
        
        // 普通请求处理
        if cm.config.AllowCredentials {
            c.Header("Access-Control-Allow-Credentials", "true")
        }
        
        if len(cm.config.ExposeHeaders) > 0 {
            c.Header("Access-Control-Expose-Headers", strings.Join(cm.config.ExposeHeaders, ", "))
        }
        
        c.Next()
    }
}

func (cm *CORSMiddleware) isOriginAllowed(origin string) bool {
    if origin == "" {
        return false
    }
    
    for _, allowedOrigin := range cm.config.AllowOrigins {
        if allowedOrigin == "*" {
            return true
        }
        if allowedOrigin == origin {
            return true
        }
    }
    
    return false
}

func (cm *CORSMiddleware) getAllowedOrigin(origin string) string {
    for _, allowedOrigin := range cm.config.AllowOrigins {
        if allowedOrigin == "*" {
            return "*"
        }
        if allowedOrigin == origin {
            return origin
        }
    }
    return ""
}

// 动态CORS配置
type DynamicCORS struct {
    allowedOrigins map[string]bool
    config         CORSConfig
}

func NewDynamicCORS(allowedOrigins []string, config CORSConfig) *DynamicCORS {
    origins := make(map[string]bool)
    for _, origin := range allowedOrigins {
        origins[origin] = true
    }
    
    return &DynamicCORS{
        allowedOrigins: origins,
        config:         config,
    }
}

func (dc *DynamicCORS) AddOrigin(origin string) {
    dc.allowedOrigins[origin] = true
}

func (dc *DynamicCORS) RemoveOrigin(origin string) {
    delete(dc.allowedOrigins, origin)
}

func (dc *DynamicCORS) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")
        
        // 动态检查源
        if !dc.isOriginAllowed(origin) {
            c.Next()
            return
        }
        
        // 设置CORS头
        c.Header("Access-Control-Allow-Origin", origin)
        c.Header("Access-Control-Allow-Methods", strings.Join(dc.config.AllowMethods, ", "))
        c.Header("Access-Control-Allow-Headers", strings.Join(dc.config.AllowHeaders, ", "))
        
        if dc.config.AllowCredentials {
            c.Header("Access-Control-Allow-Credentials", "true")
        }
        
        if len(dc.config.ExposeHeaders) > 0 {
            c.Header("Access-Control-Expose-Headers", strings.Join(dc.config.ExposeHeaders, ", "))
        }
        
        c.Header("Access-Control-Max-Age", dc.config.MaxAge.String())
        
        if c.Request.Method == http.MethodOptions {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }
        
        c.Next()
    }
}

func (dc *DynamicCORS) isOriginAllowed(origin string) bool {
    if origin == "" {
        return false
    }
    
    // 检查是否在允许列表中
    if dc.allowedOrigins[origin] {
        return true
    }
    
    // 检查通配符匹配
    for allowedOrigin := range dc.allowedOrigins {
        if allowedOrigin == "*" {
            return true
        }
        if strings.HasSuffix(origin, strings.TrimPrefix(allowedOrigin, "*")) {
            return true
        }
    }
    
    return false
}

// CORS处理示例
func CORSExample() {
    r := gin.Default()
    
    // 配置CORS
    corsConfig := CORSConfig{
        AllowOrigins: []string{
            "http://localhost:3000",
            "https://myapp.com",
            "https://*.myapp.com",
        },
        AllowMethods: []string{
            http.MethodGet,
            http.MethodPost,
            http.MethodPut,
            http.MethodDelete,
        },
        AllowHeaders: []string{
            "Origin",
            "Content-Type",
            "Accept",
            "Authorization",
            "X-Requested-With",
        },
        AllowCredentials: true,
        MaxAge:           12 * time.Hour,
    }
    
    // 创建CORS中间件
    corsMiddleware := NewCORSMiddleware(corsConfig)
    r.Use(corsMiddleware.Middleware())
    
    // API路由
    r.GET("/api/data", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "CORS enabled API",
            "data":    []string{"item1", "item2", "item3"},
        })
    })
    
    r.POST("/api/data", func(c *gin.Context) {
        var data map[string]interface{}
        if err := c.ShouldBindJSON(&data); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "message": "Data received",
            "received": data,
        })
    })
    
    r.Run(":8080")
}
```

### 安全头设置

#### 安全头中间件
```go
package main

import (
    "net/http"
    
    "github.com/gin-gonic/gin"
)

// 安全头配置
type SecurityHeadersConfig struct {
    // XSS保护
    XSSProtection string
    
    // 内容类型嗅探保护
    ContentTypeNosniff string
    
    // 框架选项
    FrameOptions string
    
    // 引用策略
    ReferrerPolicy string
    
    // 内容安全策略
    ContentSecurityPolicy string
    
    // 权限策略
    PermissionsPolicy string
    
    // 严格传输安全
    StrictTransportSecurity string
    
    // 特征策略（已废弃，使用权限策略）
    FeaturePolicy string
}

// 默认安全头配置
func DefaultSecurityHeadersConfig() SecurityHeadersConfig {
    return SecurityHeadersConfig{
        XSSProtection:           "1; mode=block",
        ContentTypeNosniff:      "nosniff",
        FrameOptions:            "DENY",
        ReferrerPolicy:          "strict-origin-when-cross-origin",
        ContentSecurityPolicy:   "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
        PermissionsPolicy:       "geolocation=(), microphone=(), camera=()",
        StrictTransportSecurity: "max-age=31536000; includeSubDomains",
        FeaturePolicy:           "",
    }
}

// 安全头中间件
type SecurityHeadersMiddleware struct {
    config SecurityHeadersConfig
}

func NewSecurityHeadersMiddleware(config SecurityHeadersConfig) *SecurityHeadersMiddleware {
    return &SecurityHeadersMiddleware{config: config}
}

func (shm *SecurityHeadersMiddleware) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 设置安全头
        if shm.config.XSSProtection != "" {
            c.Header("X-XSS-Protection", shm.config.XSSProtection)
        }
        
        if shm.config.ContentTypeNosniff != "" {
            c.Header("X-Content-Type-Options", shm.config.ContentTypeNosniff)
        }
        
        if shm.config.FrameOptions != "" {
            c.Header("X-Frame-Options", shm.config.FrameOptions)
        }
        
        if shm.config.ReferrerPolicy != "" {
            c.Header("Referrer-Policy", shm.config.ReferrerPolicy)
        }
        
        if shm.config.ContentSecurityPolicy != "" {
            c.Header("Content-Security-Policy", shm.config.ContentSecurityPolicy)
        }
        
        if shm.config.PermissionsPolicy != "" {
            c.Header("Permissions-Policy", shm.config.PermissionsPolicy)
        }
        
        if shm.config.StrictTransportSecurity != "" {
            c.Header("Strict-Transport-Security", shm.config.StrictTransportSecurity)
        }
        
        if shm.config.FeaturePolicy != "" {
            c.Header("Feature-Policy", shm.config.FeaturePolicy)
        }
        
        // 额外的安全头
        c.Header("X-DNS-Prefetch-Control", "off")
        c.Header("Expect-CT", "max-age=86400, enforce")
        
        c.Next()
    }
}

// 条件安全头中间件
type ConditionalSecurityHeaders struct {
    config SecurityHeadersConfig
}

func NewConditionalSecurityHeaders(config SecurityHeadersConfig) *ConditionalSecurityHeaders {
    return &ConditionalSecurityHeaders{config: config}
}

func (csh *ConditionalSecurityHeaders) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 根据请求条件设置不同的安全头
        
        // HTTPS请求
        if c.Request.TLS != nil || c.GetHeader("X-Forwarded-Proto") == "https" {
            if csh.config.StrictTransportSecurity != "" {
                c.Header("Strict-Transport-Security", csh.config.StrictTransportSecurity)
            }
        }
        
        // API请求
        if strings.HasPrefix(c.Request.URL.Path, "/api/") {
            // API特定的安全头
            c.Header("X-Content-Type-Options", "nosniff")
            c.Header("X-Frame-Options", "DENY")
        }
        
        // 前端请求
        if strings.HasPrefix(c.Request.URL.Path, "/") && !strings.HasPrefix(c.Request.URL.Path, "/api/") {
            // 前端特定的安全头
            if csh.config.ContentSecurityPolicy != "" {
                c.Header("Content-Security-Policy", csh.config.ContentSecurityPolicy)
            }
        }
        
        // 通用安全头
        c.Header("X-XSS-Protection", csh.config.XSSProtection)
        c.Header("X-Content-Type-Options", csh.config.ContentTypeNosniff)
        c.Header("Referrer-Policy", csh.config.ReferrerPolicy)
        c.Header("Permissions-Policy", csh.config.PermissionsPolicy)
        
        c.Next()
    }
}

// 动态安全头管理
type DynamicSecurityHeaders struct {
    headers map[string]string
    mutex   sync.RWMutex
}

func NewDynamicSecurityHeaders() *DynamicSecurityHeaders {
    return &DynamicSecurityHeaders{
        headers: make(map[string]string),
    }
}

func (dsh *DynamicSecurityHeaders) SetHeader(name, value string) {
    dsh.mutex.Lock()
    defer dsh.mutex.Unlock()
    dsh.headers[name] = value
}

func (dsh *DynamicSecurityHeaders) RemoveHeader(name string) {
    dsh.mutex.Lock()
    defer dsh.mutex.Unlock()
    delete(dsh.headers, name)
}

func (dsh *DynamicSecurityHeaders) GetHeader(name string) (string, bool) {
    dsh.mutex.RLock()
    defer dsh.mutex.RUnlock()
    value, exists := dsh.headers[name]
    return value, exists
}

func (dsh *DynamicSecurityHeaders) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        dsh.mutex.RLock()
        defer dsh.mutex.RUnlock()
        
        for name, value := range dsh.headers {
            c.Header(name, value)
        }
        
        c.Next()
    }
}

// 安全头验证器
type SecurityHeadersValidator struct {
    requiredHeaders map[string]string
}

func NewSecurityHeadersValidator(requiredHeaders map[string]string) *SecurityHeadersValidator {
    return &SecurityHeadersValidator{requiredHeaders: requiredHeaders}
}

func (shv *SecurityHeadersValidator) ValidateHeaders(c *gin.Context) bool {
    for name, expectedValue := range shv.requiredHeaders {
        actualValue := c.GetHeader(name)
        if actualValue != expectedValue {
            return false
        }
    }
    return true
}

func (shv *SecurityHeadersValidator) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        if !shv.ValidateHeaders(c) {
            c.JSON(http.StatusForbidden, gin.H{
                "error": "security headers validation failed",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}

// 安全头示例应用
func SecurityHeadersExample() {
    r := gin.Default()
    
    // 配置安全头
    securityConfig := DefaultSecurityHeadersConfig()
    securityConfig.ContentSecurityPolicy = "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com"
    securityConfig.PermissionsPolicy = "geolocation=(), microphone=(), camera=(), geolocation=(self 'https://maps.googleapis.com')"
    securityConfig.StrictTransportSecurity = "max-age=31536000; includeSubDomains; preload"
    
    // 创建安全头中间件
    securityMiddleware := NewSecurityHeadersMiddleware(securityConfig)
    r.Use(securityMiddleware.Middleware())
    
    // 条件安全头
    conditionalConfig := DefaultSecurityHeadersConfig()
    conditionalMiddleware := NewConditionalSecurityHeaders(conditionalConfig)
    r.Use(conditionalMiddleware.Middleware())
    
    // 动态安全头
    dynamicHeaders := NewDynamicSecurityHeaders()
    dynamicHeaders.SetHeader("X-Custom-Security", "custom-value")
    r.Use(dynamicHeaders.Middleware())
    
    // 路由
    r.GET("/", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "Secure application with security headers",
        })
    })
    
    r.GET("/api/status", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "ok",
            "secure": true,
        })
    })
    
    r.Run(":8080")
}
```