## 7.1 反射

### reflect包基础

```go
package main

import (
    "fmt"
    "reflect"
)

func demonstrateReflectBasics() {
    fmt.Println("=== reflect包基础 ===")
    
    // 基本类型反射
    var num int = 42
    var str string = "Hello"
    var slice []int = []int{1, 2, 3}
    
    // 获取类型信息
    fmt.Printf("Type of num: %v\n", reflect.TypeOf(num))
    fmt.Printf("Kind of num: %v\n", reflect.TypeOf(num).Kind())
    
    fmt.Printf("Type of str: %v\n", reflect.TypeOf(str))
    fmt.Printf("Kind of str: %v\n", reflect.TypeOf(str).Kind())
    
    fmt.Printf("Type of slice: %v\n", reflect.TypeOf(slice))
    fmt.Printf("Kind of slice: %v\n", reflect.TypeOf(slice).Kind())
    
    // 获取值信息
    fmt.Printf("Value of num: %v\n", reflect.ValueOf(num))
    fmt.Printf("Value of str: %v\n", reflect.ValueOf(str))
    fmt.Printf("Value of slice: %v\n", reflect.ValueOf(slice))
    
    // 类型和值的区别
    fmt.Printf("Type name: %s\n", reflect.TypeOf(num).Name())
    fmt.Printf("Type string: %s\n", reflect.TypeOf(num).String())
    
    // 检查类型是否可比较
    fmt.Printf("int is comparable: %t\n", reflect.TypeOf(num).Comparable())
    fmt.Printf("[]int is comparable: %t\n", reflect.TypeOf(slice).Comparable())
}

// 自定义类型用于反射示例
type Person struct {
    Name    string `json:"name" validate:"required"`
    Age     int    `json:"age" validate:"min=0"`
    Email   string `json:"email" validate:"email"`
    Address string `json:"address,omitempty"`
}

func (p Person) SayHello() string {
    return fmt.Sprintf("Hello, I'm %s", p.Name)
}

func (p Person) Greet(name string) string {
    return fmt.Sprintf("Hello %s, I'm %s", name, p.Name)
}

func demonstrateStructReflection() {
    fmt.Println("\n=== 结构体反射 ===")
    
    person := Person{
        Name:  "Alice",
        Age:   25,
        Email: "alice@example.com",
    }
    
    // 获取结构体类型信息
    personType := reflect.TypeOf(person)
    fmt.Printf("Struct type: %v\n", personType)
    fmt.Printf("Struct kind: %v\n", personType.Kind())
    fmt.Printf("Number of fields: %d\n", personType.NumField())
    
    // 遍历结构体字段
    fmt.Println("Struct fields:")
    for i := 0; i < personType.NumField(); i++ {
        field := personType.Field(i)
        fmt.Printf("  Field %d: %s (type: %v)\n", i, field.Name, field.Type)
        fmt.Printf("    Tag: %s\n", field.Tag)
        
        // 解析标签
        jsonTag := field.Tag.Get("json")
        validateTag := field.Tag.Get("validate")
        fmt.Printf("    JSON tag: %s, Validate tag: %s\n", jsonTag, validateTag)
    }
    
    // 获取结构体方法信息
    fmt.Printf("Number of methods: %d\n", personType.NumMethod())
    fmt.Println("Struct methods:")
    for i := 0; i < personType.NumMethod(); i++ {
        method := personType.Method(i)
        fmt.Printf("  Method %d: %s (type: %v)\n", i, method.Name, method.Type)
    }
    
    // 获取值信息
    personValue := reflect.ValueOf(person)
    fmt.Printf("Value type: %v\n", personValue.Type())
    fmt.Printf("Can set: %t\n", personValue.CanSet())
    
    // 获取字段值
    nameField := personValue.FieldByName("Name")
    if nameField.IsValid() {
        fmt.Printf("Name field value: %v\n", nameField.String())
    }
    
    // 获取方法值
    sayHelloMethod := personValue.MethodByName("SayHello")
    if sayHelloMethod.IsValid() {
        results := sayHelloMethod.Call(nil)
        if len(results) > 0 {
            fmt.Printf("SayHello result: %v\n", results[0].String())
        }
    }
}

// 接口类型反射
type Speaker interface {
    Speak() string
}

type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}

func demonstrateInterfaceReflection() {
    fmt.Println("\n=== 接口反射 ===")
    
    var speaker Speaker = Dog{}
    
    // 获取接口类型信息
    speakerType := reflect.TypeOf(speaker)
    fmt.Printf("Interface type: %v\n", speakerType)
    fmt.Printf("Interface kind: %v\n", speakerType.Kind())
    
    // 获取接口方法
    fmt.Printf("Number of methods: %d\n", speakerType.NumMethod())
    for i := 0; i < speakerType.NumMethod(); i++ {
        method := speakerType.Method(i)
        fmt.Printf("  Method %d: %s\n", i, method.Name)
    }
    
    // 获取实际类型
    concreteType := reflect.TypeOf(Dog{})
    fmt.Printf("Concrete type: %v\n", concreteType)
    
    // 检查接口实现
    fmt.Printf("Implements Speaker: %t\n", concreteType.Implements(speakerType))
}

func main() {
    demonstrateReflectBasics()
    demonstrateStructReflection()
    demonstrateInterfaceReflection()
}
```

### 类型反射

```go
package main

import (
    "fmt"
    "reflect"
)

// 类型检查和转换工具
func checkType(value interface{}) {
    t := reflect.TypeOf(value)
    v := reflect.ValueOf(value)
    
    fmt.Printf("Value: %v\n", value)
    fmt.Printf("Type: %v\n", t)
    fmt.Printf("Kind: %v\n", t.Kind())
    fmt.Printf("Value: %v\n", v)
    
    // 根据类型进行不同的处理
    switch t.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        fmt.Printf("Integer value: %d\n", v.Int())
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        fmt.Printf("Unsigned integer value: %d\n", v.Uint())
    case reflect.Float32, reflect.Float64:
        fmt.Printf("Float value: %f\n", v.Float())
    case reflect.String:
        fmt.Printf("String value: %s\n", v.String())
    case reflect.Bool:
        fmt.Printf("Boolean value: %t\n", v.Bool())
    case reflect.Slice:
        fmt.Printf("Slice length: %d\n", v.Len())
    case reflect.Map:
        fmt.Printf("Map length: %d\n", v.Len())
    case reflect.Struct:
        fmt.Printf("Struct has %d fields\n", t.NumField())
    default:
        fmt.Printf("Other type: %v\n", t.Kind())
    }
    fmt.Println()
}

func demonstrateTypeChecking() {
    fmt.Println("=== 类型检查 ===")
    
    values := []interface{}{
        42,
        3.14,
        "Hello",
        true,
        []int{1, 2, 3},
        map[string]int{"a": 1, "b": 2},
        Person{Name: "Alice", Age: 25},
    }
    
    for _, value := range values {
        checkType(value)
    }
}

// 动态类型创建
func createTypeDynamically() {
    fmt.Println("=== 动态类型创建 ===")
    
    // 创建基本类型
    intType := reflect.TypeOf(int(0))
    floatType := reflect.TypeOf(float64(0))
    stringType := reflect.TypeOf("")
    
    fmt.Printf("Int type: %v\n", intType)
    fmt.Printf("Float type: %v\n", floatType)
    fmt.Printf("String type: %v\n", stringType)
    
    // 创建切片类型
    sliceType := reflect.SliceOf(intType)
    fmt.Printf("Slice of int type: %v\n", sliceType)
    
    // 创建映射类型
    mapType := reflect.MapOf(stringType, intType)
    fmt.Printf("Map of string to int type: %v\n", mapType)
    
    // 创建指针类型
    ptrType := reflect.PtrTo(intType)
    fmt.Printf("Pointer to int type: %v\n", ptrType)
    
    // 创建结构体类型
    structType := reflect.StructOf([]reflect.StructField{
        {
            Name: "Name",
            Type: stringType,
            Tag:  `json:"name"`,
        },
        {
            Name: "Age",
            Type: intType,
            Tag:  `json:"age"`,
        },
    })
    fmt.Printf("Dynamic struct type: %v\n", structType)
}

// 类型比较和兼容性
func demonstrateTypeCompatibility() {
    fmt.Println("\n=== 类型比较和兼容性 ===")
    
    var a int = 42
    var b int32 = 42
    var c float64 = 42.0
    
    typeA := reflect.TypeOf(a)
    typeB := reflect.TypeOf(b)
    typeC := reflect.TypeOf(c)
    
    fmt.Printf("Type A: %v (kind: %v)\n", typeA, typeA.Kind())
    fmt.Printf("Type B: %v (kind: %v)\n", typeB, typeB.Kind())
    fmt.Printf("Type C: %v (kind: %v)\n", typeC, typeC.Kind())
    
    // 类型相等性
    fmt.Printf("A == B: %t\n", typeA == typeB)
    fmt.Printf("A == C: %t\n", typeA == typeC)
    
    // 类型兼容性
    fmt.Printf("A convertible to B: %t\n", typeA.ConvertibleTo(typeB))
    fmt.Printf("A convertible to C: %t\n", typeA.ConvertibleTo(typeC))
    
    // 基础类型比较
    fmt.Printf("A kind == B kind: %t\n", typeA.Kind() == typeB.Kind())
    fmt.Printf("A kind == C kind: %t\n", typeA.Kind() == typeC.Kind())
    
    // 复杂类型比较
    sliceA := []int{1, 2, 3}
    sliceB := []string{"a", "b", "c"}
    
    sliceTypeA := reflect.TypeOf(sliceA)
    sliceTypeB := reflect.TypeOf(sliceB)
    
    fmt.Printf("Slice A type: %v\n", sliceTypeA)
    fmt.Printf("Slice B type: %v\n", sliceTypeB)
    fmt.Printf("Slice types equal: %t\n", sliceTypeA == sliceTypeB)
    fmt.Printf("Slice element types equal: %t\n", sliceTypeA.Elem() == sliceTypeB.Elem())
}

// 类型信息提取
func extractTypeInfo(t reflect.Type) {
    fmt.Printf("Type: %v\n", t)
    fmt.Printf("  Name: %s\n", t.Name())
    fmt.Printf("  String: %s\n", t.String())
    fmt.Printf("  Kind: %v\n", t.Kind())
    fmt.Printf("  Package path: %s\n", t.PkgPath())
    fmt.Printf("  Comparable: %t\n", t.Comparable())
    
    switch t.Kind() {
    case reflect.Slice:
        fmt.Printf("  Element type: %v\n", t.Elem())
    case reflect.Map:
        fmt.Printf("  Key type: %v\n", t.Key())
        fmt.Printf("  Element type: %v\n", t.Elem())
    case reflect.Ptr:
        fmt.Printf("  Element type: %v\n", t.Elem())
    case reflect.Struct:
        fmt.Printf("  Number of fields: %d\n", t.NumField())
        for i := 0; i < t.NumField(); i++ {
            field := t.Field(i)
            fmt.Printf("    Field %d: %s (%v)\n", i, field.Name, field.Type)
        }
    case reflect.Func:
        fmt.Printf("  Number of inputs: %d\n", t.NumIn())
        fmt.Printf("  Number of outputs: %d\n", t.NumOut())
        for i := 0; i < t.NumIn(); i++ {
            fmt.Printf("    Input %d: %v\n", i, t.In(i))
        }
        for i := 0; i < t.NumOut(); i++ {
            fmt.Printf("    Output %d: %v\n", i, t.Out(i))
        }
    }
    fmt.Println()
}

func demonstrateTypeInfoExtraction() {
    fmt.Println("\n=== 类型信息提取 ===")
    
    types := []reflect.Type{
        reflect.TypeOf(int(0)),
        reflect.TypeOf([]string{}),
        reflect.TypeOf(map[string]int{}),
        reflect.TypeOf(&Person{}),
        reflect.TypeOf(func(int, string) bool { return true }),
    }
    
    for _, t := range types {
        extractTypeInfo(t)
    }
}

// 类型断言和转换
func demonstrateTypeAssertion() {
    fmt.Println("\n=== 类型断言和转换 ===")
    
    var value interface{} = 42
    
    // 使用反射进行类型断言
    v := reflect.ValueOf(value)
    if v.Kind() == reflect.Int {
        intValue := int(v.Int())
        fmt.Printf("Asserted int value: %d\n", intValue)
    }
    
    // 类型转换
    value = 3.14
    v = reflect.ValueOf(value)
    if v.Type().ConvertibleTo(reflect.TypeOf(int(0))) {
        converted := v.Convert(reflect.TypeOf(int(0)))
        fmt.Printf("Converted to int: %d\n", int(converted.Int()))
    }
    
    // 字符串转换
    value = "123"
    v = reflect.ValueOf(value)
    if v.Type().ConvertibleTo(reflect.TypeOf(int(0))) {
        // 字符串不能直接转换为int，需要特殊处理
        if v.Kind() == reflect.String {
            fmt.Printf("String value: %s\n", v.String())
        }
    }
}

func main() {
    demonstrateTypeChecking()
    createTypeDynamically()
    demonstrateTypeCompatibility()
    demonstrateTypeInfoExtraction()
    demonstrateTypeAssertion()
}
```

### 值反射

```go
package main

import (
    "fmt"
    "reflect"
)

// 值的基本操作
func demonstrateValueBasics() {
    fmt.Println("=== 值反射基础 ===")
    
    // 创建可设置的值
    var num int = 42
    v := reflect.ValueOf(&num)  // 传递指针
    fmt.Printf("Can set: %t\n", v.CanSet())  // false，因为v是*int
    
    v = v.Elem()  // 获取指针指向的值
    fmt.Printf("Can set: %t\n", v.CanSet())  // true
    
    // 设置值
    if v.CanSet() {
        v.SetInt(100)
        fmt.Printf("New value: %d\n", num)  // 100
    }
    
    // 字符串值操作
    var str string = "Hello"
    v = reflect.ValueOf(&str).Elem()
    if v.CanSet() {
        v.SetString("World")
        fmt.Printf("New string: %s\n", str)  // World
    }
    
    // 切片值操作
    slice := []int{1, 2, 3}
    v = reflect.ValueOf(&slice).Elem()
    if v.CanSet() {
        // 添加元素
        newSlice := reflect.Append(v, reflect.ValueOf(4))
        v.Set(newSlice)
        fmt.Printf("Extended slice: %v\n", slice)  // [1 2 3 4]
        
        // 修改元素
        if v.Len() > 0 {
            v.Index(0).SetInt(10)
            fmt.Printf("Modified slice: %v\n", slice)  // [10 2 3 4]
        }
    }
}

// 结构体值操作
func demonstrateStructValueOperations() {
    fmt.Println("\n=== 结构体值操作 ===")
    
    person := Person{
        Name:  "Alice",
        Age:   25,
        Email: "alice@example.com",
    }
    
    v := reflect.ValueOf(&person).Elem()
    fmt.Printf("Can set struct: %t\n", v.CanSet())
    
    // 获取字段
    nameField := v.FieldByName("Name")
    if nameField.IsValid() && nameField.CanSet() {
        nameField.SetString("Bob")
        fmt.Printf("Modified person: %+v\n", person)
    }
    
    // 遍历所有字段
    t := v.Type()
    for i := 0; i < v.NumField(); i++ {
        field := v.Field(i)
        fieldType := t.Field(i)
        
        fmt.Printf("Field %s: %v (can set: %t)\n", 
            fieldType.Name, field.Interface(), field.CanSet())
    }
    
    // 调用方法
    sayHelloMethod := v.MethodByName("SayHello")
    if sayHelloMethod.IsValid() {
        results := sayHelloMethod.Call(nil)
        if len(results) > 0 {
            fmt.Printf("Method result: %s\n", results[0].String())
        }
    }
    
    greetMethod := v.MethodByName("Greet")
    if greetMethod.IsValid() {
        // 调用带参数的方法
        args := []reflect.Value{reflect.ValueOf("Charlie")}
        results := greetMethod.Call(args)
        if len(results) > 0 {
            fmt.Printf("Greet method result: %s\n", results[0].String())
        }
    }
}

// 映射值操作
func demonstrateMapValueOperations() {
    fmt.Println("\n=== 映射值操作 ===")
    
    // 创建映射
    m := map[string]int{
        "a": 1,
        "b": 2,
        "c": 3,
    }
    
    v := reflect.ValueOf(&m).Elem()
    fmt.Printf("Map value: %v\n", v.Interface())
    fmt.Printf("Map length: %d\n", v.Len())
    
    // 遍历映射
    for _, key := range v.MapKeys() {
        value := v.MapIndex(key)
        fmt.Printf("Key: %v, Value: %v\n", key.Interface(), value.Interface())
    }
    
    // 设置映射值
    if v.CanSet() {
        key := reflect.ValueOf("d")
        value := reflect.ValueOf(4)
        v.SetMapIndex(key, value)
        fmt.Printf("After adding d: %v\n", m)
    }
    
    // 删除映射键
    key := reflect.ValueOf("b")
    v.SetMapIndex(key, reflect.Value{})  // 传递零值删除键
    fmt.Printf("After deleting b: %v\n", m)
    
    // 创建新的映射
    mapType := reflect.MapOf(reflect.TypeOf(""), reflect.TypeOf(0))
    newMap := reflect.MakeMap(mapType)
    newMap.SetMapIndex(reflect.ValueOf("x"), reflect.ValueOf(100))
    newMap.SetMapIndex(reflect.ValueOf("y"), reflect.ValueOf(200))
    fmt.Printf("New map: %v\n", newMap.Interface())
}

// 切片值操作
func demonstrateSliceValueOperations() {
    fmt.Println("\n=== 切片值操作 ===")
    
    slice := []int{1, 2, 3, 4, 5}
    v := reflect.ValueOf(&slice).Elem()
    
    fmt.Printf("Original slice: %v\n", slice)
    fmt.Printf("Slice length: %d\n", v.Len())
    fmt.Printf("Slice capacity: %d\n", v.Cap())
    
    // 获取元素
    for i := 0; i < v.Len(); i++ {
        elem := v.Index(i)
        fmt.Printf("Element %d: %d\n", i, elem.Int())
    }
    
    // 修改元素
    if v.Len() > 0 {
        v.Index(0).SetInt(10)
        fmt.Printf("After modifying first element: %v\n", slice)
    }
    
    // 添加元素
    newElem := reflect.ValueOf(6)
    v.Set(reflect.Append(v, newElem))
    fmt.Printf("After append: %v\n", slice)
    
    // 批量添加元素
    moreElems := []int{7, 8, 9}
    v.Set(reflect.AppendSlice(v, reflect.ValueOf(moreElems)))
    fmt.Printf("After append slice: %v\n", slice)
    
    // 创建新的切片
    sliceType := reflect.SliceOf(reflect.TypeOf(int(0)))
    newSlice := reflect.MakeSlice(sliceType, 3, 5)
    newSlice.Index(0).SetInt(100)
    newSlice.Index(1).SetInt(200)
    newSlice.Index(2).SetInt(300)
    fmt.Printf("New slice: %v\n", newSlice.Interface())
    
    // 切片操作
    subSlice := v.Slice(2, 5)
    fmt.Printf("Sub slice [2:5]: %v\n", subSlice.Interface())
}

// 动态值创建和操作
func demonstrateDynamicValueCreation() {
    fmt.Println("\n=== 动态值创建 ===")
    
    // 创建基本类型的值
    intVal := reflect.New(reflect.TypeOf(int(0))).Elem()
    intVal.SetInt(42)
    fmt.Printf("Dynamic int: %d\n", intVal.Int())
    
    stringVal := reflect.New(reflect.TypeOf("")).Elem()
    stringVal.SetString("Hello, Dynamic World!")
    fmt.Printf("Dynamic string: %s\n", stringVal.String())
    
    // 创建结构体值
    personType := reflect.TypeOf(Person{})
    personVal := reflect.New(personType).Elem()
    
    // 设置字段值
    personVal.FieldByName("Name").SetString("Dynamic Person")
    personVal.FieldByName("Age").SetInt(30)
    personVal.FieldByName("Email").SetString("dynamic@example.com")
    
    fmt.Printf("Dynamic person: %+v\n", personVal.Interface())
    
    // 创建切片值
    sliceType := reflect.SliceOf(reflect.TypeOf(int(0)))
    sliceVal := reflect.MakeSlice(sliceType, 0, 10)
    
    // 添加元素
    for i := 1; i <= 5; i++ {
        sliceVal = reflect.Append(sliceVal, reflect.ValueOf(i))
    }
    fmt.Printf("Dynamic slice: %v\n", sliceVal.Interface())
    
    // 创建映射值
    mapType := reflect.MapOf(reflect.TypeOf(""), reflect.TypeOf(0))
    mapVal := reflect.MakeMap(mapType)
    
    // 添加键值对
    mapVal.SetMapIndex(reflect.ValueOf("key1"), reflect.ValueOf(100))
    mapVal.SetMapIndex(reflect.ValueOf("key2"), reflect.ValueOf(200))
    fmt.Printf("Dynamic map: %v\n", mapVal.Interface())
}

// 值的深度复制
func deepCopy(src interface{}) interface{} {
    srcValue := reflect.ValueOf(src)
    return deepCopyValue(srcValue).Interface()
}

func deepCopyValue(src reflect.Value) reflect.Value {
    switch src.Kind() {
    case reflect.Ptr:
        if src.IsNil() {
            return reflect.Zero(src.Type())
        }
        dst := reflect.New(src.Type().Elem())
        dst.Elem().Set(deepCopyValue(src.Elem()))
        return dst
        
    case reflect.Slice:
        if src.IsNil() {
            return reflect.Zero(src.Type())
        }
        dst := reflect.MakeSlice(src.Type(), src.Len(), src.Cap())
        for i := 0; i < src.Len(); i++ {
            dst.Index(i).Set(deepCopyValue(src.Index(i)))
        }
        return dst
        
    case reflect.Map:
        if src.IsNil() {
            return reflect.Zero(src.Type())
        }
        dst := reflect.MakeMap(src.Type())
        for _, key := range src.MapKeys() {
            dst.SetMapIndex(key, deepCopyValue(src.MapIndex(key)))
        }
        return dst
        
    case reflect.Struct:
        dst := reflect.New(src.Type()).Elem()
        for i := 0; i < src.NumField(); i++ {
            if src.Field(i).CanSet() {
                dst.Field(i).Set(deepCopyValue(src.Field(i)))
            }
        }
        return dst
        
    default:
        return src
    }
}

func demonstrateDeepCopy() {
    fmt.Println("\n=== 深度复制 ===")
    
    original := Person{
        Name:  "Original",
        Age:   25,
        Email: "original@example.com",
    }
    
    fmt.Printf("Original: %+v\n", original)
    
    // 深度复制
    copied := deepCopy(original).(Person)
    fmt.Printf("Copied: %+v\n", copied)
    
    // 修改原对象
    original.Name = "Modified"
    fmt.Printf("After modification - Original: %+v\n", original)
    fmt.Printf("After modification - Copied: %+v\n", copied)
    
    // 复杂结构复制
    type ComplexStruct struct {
        Persons []Person
        Data    map[string]int
        Ptr     *int
    }
    
    value := 42
    complex := ComplexStruct{
        Persons: []Person{original, copied},
        Data:    map[string]int{"a": 1, "b": 2},
        Ptr:     &value,
    }
    
    complexCopy := deepCopy(complex).(ComplexStruct)
    fmt.Printf("Complex original: %+v\n", complex)
    fmt.Printf("Complex copy: %+v\n", complexCopy)
}

func main() {
    demonstrateValueBasics()
    demonstrateStructValueOperations()
    demonstrateMapValueOperations()
    demonstrateSliceValueOperations()
    demonstrateDynamicValueCreation()
    demonstrateDeepCopy()
}
```

### 反射性能考虑

```go
package main

import (
    "fmt"
    "reflect"
    "testing"
    "time"
)

// 性能基准测试
func BenchmarkDirectAccess(b *testing.B) {
    person := Person{Name: "Alice", Age: 25}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = person.Name
        _ = person.Age
    }
}

func BenchmarkReflectAccess(b *testing.B) {
    person := Person{Name: "Alice", Age: 25}
    v := reflect.ValueOf(person)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = v.FieldByName("Name").String()
        _ = int(v.FieldByName("Age").Int())
    }
}

func demonstratePerformanceComparison() {
    fmt.Println("=== 性能比较 ===")
    
    person := Person{Name: "Alice", Age: 25}
    
    // 直接访问性能测试
    start := time.Now()
    for i := 0; i < 1000000; i++ {
        _ = person.Name
        _ = person.Age
    }
    directTime := time.Since(start)
    
    // 反射访问性能测试
    v := reflect.ValueOf(person)
    start = time.Now()
    for i := 0; i < 1000000; i++ {
        _ = v.FieldByName("Name").String()
        _ = int(v.FieldByName("Age").Int())
    }
    reflectTime := time.Since(start)
    
    fmt.Printf("Direct access time: %v\n", directTime)
    fmt.Printf("Reflect access time: %v\n", reflectTime)
    fmt.Printf("Reflection is %.1fx slower\n", float64(reflectTime)/float64(directTime))
}

// 缓存反射结果
type ReflectCache struct {
    fieldMap map[reflect.Type]map[string]int
}

func NewReflectCache() *ReflectCache {
    return &ReflectCache{
        fieldMap: make(map[reflect.Type]map[string]int),
    }
}

func (rc *ReflectCache) GetFieldIndex(t reflect.Type, fieldName string) int {
    if rc.fieldMap[t] == nil {
        rc.fieldMap[t] = make(map[string]int)
        for i := 0; i < t.NumField(); i++ {
            field := t.Field(i)
            rc.fieldMap[t][field.Name] = i
        }
    }
    
    if index, exists := rc.fieldMap[t][fieldName]; exists {
        return index
    }
    
    return -1
}

func demonstrateCachedReflection() {
    fmt.Println("\n=== 缓存反射结果 ===")
    
    cache := NewReflectCache()
    person := Person{Name: "Alice", Age: 25}
    v := reflect.ValueOf(person)
    t := v.Type()
    
    // 使用缓存的字段索引
    start := time.Now()
    for i := 0; i < 1000000; i++ {
        nameIndex := cache.GetFieldIndex(t, "Name")
        if nameIndex >= 0 {
            _ = v.Field(nameIndex).String()
        }
        
        ageIndex := cache.GetFieldIndex(t, "Age")
        if ageIndex >= 0 {
            _ = int(v.Field(ageIndex).Int())
        }
    }
    cachedTime := time.Since(start)
    
    fmt.Printf("Cached reflection time: %v\n", cachedTime)
    
    // 比较无缓存的反射
    start = time.Now()
    for i := 0; i < 1000000; i++ {
        _ = v.FieldByName("Name").String()
        _ = int(v.FieldByName("Age").Int())
    }
    uncachedTime := time.Since(start)
    
    fmt.Printf("Uncached reflection time: %v\n", uncachedTime)
    fmt.Printf("Cached is %.1fx faster\n", float64(uncachedTime)/float64(cachedTime))
}

// 反射优化技巧
func demonstrateReflectionOptimization() {
    fmt.Println("\n=== 反射优化技巧 ===")
    
    // 1. 预编译反射信息
    type PersonInfo struct {
        NameIndex int
        AgeIndex  int
        Type      reflect.Type
    }
    
    personType := reflect.TypeOf(Person{})
    personInfo := PersonInfo{
        NameIndex: getFieldIndex(personType, "Name"),
        AgeIndex:  getFieldIndex(personType, "Age"),
        Type:      personType,
    }
    
    // 使用预编译信息
    person := Person{Name: "Alice", Age: 25}
    v := reflect.ValueOf(person)
    
    start := time.Now()
    for i := 0; i < 1000000; i++ {
        _ = v.Field(personInfo.NameIndex).String()
        _ = int(v.Field(personInfo.AgeIndex).Int())
    }
    optimizedTime := time.Since(start)
    
    fmt.Printf("Optimized reflection time: %v\n", optimizedTime)
    
    // 2. 避免重复的TypeOf调用
    personTypeCached := reflect.TypeOf(Person{})
    start = time.Now()
    for i := 0; i < 1000000; i++ {
        _ = personTypeCached
    }
    cachedTypeTime := time.Since(start)
    
    start = time.Now()
    for i := 0; i < 1000000; i++ {
        _ = reflect.TypeOf(Person{})
    }
    uncachedTypeTime := time.Since(start)
    
    fmt.Printf("Cached TypeOf time: %v\n", cachedTypeTime)
    fmt.Printf("Uncached TypeOf time: %v\n", uncachedTypeTime)
    fmt.Printf("TypeOf caching improvement: %.1fx\n", 
        float64(uncachedTypeTime)/float64(cachedTypeTime))
}

func getFieldIndex(t reflect.Type, fieldName string) int {
    for i := 0; i < t.NumField(); i++ {
        if t.Field(i).Name == fieldName {
            return i
        }
    }
    return -1
}

// 内存分配分析
func demonstrateMemoryAllocation() {
    fmt.Println("\n=== 内存分配分析 ===")
    
    // 反射会增加内存分配
    person := Person{Name: "Alice", Age: 25}
    
    // 直接访问 - 无额外分配
    fmt.Println("Direct access (minimal allocations):")
    for i := 0; i < 10; i++ {
        name := person.Name
        age := person.Age
        _ = name + fmt.Sprintf("%d", age)
    }
    
    // 反射访问 - 会产生更多分配
    fmt.Println("Reflection access (more allocations):")
    v := reflect.ValueOf(person)
    for i := 0; i < 10; i++ {
        name := v.FieldByName("Name").String()
        age := int(v.FieldByName("Age").Int())
        _ = name + fmt.Sprintf("%d", age)
    }
    
    // 使用索引访问 - 减少分配
    fmt.Println("Indexed access (reduced allocations):")
    for i := 0; i < 10; i++ {
        name := v.Field(0).String()
        age := int(v.Field(1).Int())
        _ = name + fmt.Sprintf("%d", age)
    }
}

// 反射使用建议
func reflectionUsageGuidelines() {
    fmt.Println("\n=== 反射使用建议 ===")
    
    fmt.Println("1. 性能关键路径避免使用反射:")
    fmt.Println("   - 高频调用的函数中避免反射")
    fmt.Println("   - 热点代码路径优先考虑直接访问")
    
    fmt.Println("\n2. 缓存反射结果:")
    fmt.Println("   - 缓存Type和Field信息")
    fmt.Println("   - 预编译常用反射操作")
    fmt.Println("   - 使用索引而非名称访问字段")
    
    fmt.Println("\n3. 合理使用场景:")
    fmt.Println("   - 序列化/反序列化框架")
    fmt.Println("   - ORM和数据库映射")
    fmt.Println("   - 配置文件解析")
    fmt.Println("   - 通用数据处理工具")
    
    fmt.Println("\n4. 性能优化技巧:")
    fmt.Println("   - 避免重复的TypeOf调用")
    fmt.Println("   - 使用Value.Elem()而非多次解引用")
    fmt.Println("   - 批量操作而非单个操作")
    fmt.Println("   - 考虑使用unsafe包进行极致优化")
    
    fmt.Println("\n5. 内存管理:")
    fmt.Println("   - 注意反射产生的临时对象")
    fmt.Println("   - 避免不必要的Value.Interface()调用")
    fmt.Println("   - 及时释放不需要的反射对象")
}

func main() {
    demonstratePerformanceComparison()
    demonstrateCachedReflection()
    demonstrateReflectionOptimization()
    demonstrateMemoryAllocation()
    reflectionUsageGuidelines()
}
```

### 反射实际应用

```go
package main

import (
    "encoding/json"
    "fmt"
    "reflect"
    "strings"
)

// 通用结构体到Map转换器
func StructToMap(obj interface{}) map[string]interface{} {
    result := make(map[string]interface{})
    
    v := reflect.ValueOf(obj)
    t := reflect.TypeOf(obj)
    
    // 处理指针
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
        t = t.Elem()
    }
    
    // 只处理结构体
    if v.Kind() != reflect.Struct {
        return result
    }
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        // 获取JSON标签
        jsonTag := field.Tag.Get("json")
        if jsonTag == "-" {
            continue
        }
        
        // 解析JSON标签
        tagName := field.Name
        if jsonTag != "" {
            parts := strings.Split(jsonTag, ",")
            if parts[0] != "" {
                tagName = parts[0]
            }
        }
        
        // 处理omitempty
        if strings.Contains(jsonTag, "omitempty") && isEmptyValue(value) {
            continue
        }
        
        result[tagName] = value.Interface()
    }
    
    return result
}

func isEmptyValue(v reflect.Value) bool {
    switch v.Kind() {
    case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
        return v.Len() == 0
    case reflect.Bool:
        return !v.Bool()
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        return v.Int() == 0
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
        return v.Uint() == 0
    case reflect.Float32, reflect.Float64:
        return v.Float() == 0
    case reflect.Interface, reflect.Ptr:
        return v.IsNil()
    }
    return false
}

func demonstrateStructToMap() {
    fmt.Println("=== 结构体到Map转换 ===")
    
    person := Person{
        Name:    "Alice",
        Age:     25,
        Email:   "alice@example.com",
        Address: "", // 空字符串，应该被omitempty忽略
    }
    
    result := StructToMap(person)
    fmt.Printf("Converted map: %+v\n", result)
    
    // JSON序列化验证
    jsonData, _ := json.Marshal(result)
    fmt.Printf("JSON: %s\n", jsonData)
}

// 通用Map到结构体转换器
func MapToStruct(m map[string]interface{}, obj interface{}) error {
    v := reflect.ValueOf(obj)
    if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct {
        return fmt.Errorf("obj must be a pointer to struct")
    }
    
    v = v.Elem()
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        if !value.CanSet() {
            continue
        }
        
        // 获取JSON标签
        jsonTag := field.Tag.Get("json")
        if jsonTag == "-" {
            continue
        }
        
        // 解析JSON标签
        tagName := field.Name
        if jsonTag != "" {
            parts := strings.Split(jsonTag, ",")
            if parts[0] != "" {
                tagName = parts[0]
            }
        }
        
        // 从map中获取值
        if mapValue, exists := m[tagName]; exists {
            if err := setFieldValue(value, mapValue); err != nil {
                return fmt.Errorf("field %s: %v", field.Name, err)
            }
        }
    }
    
    return nil
}

func setFieldValue(field reflect.Value, value interface{}) error {
    if value == nil {
        return nil
    }
    
    fieldValue := reflect.ValueOf(value)
    
    // 类型转换
    if fieldValue.Type().ConvertibleTo(field.Type()) {
        field.Set(fieldValue.Convert(field.Type()))
        return nil
    }
    
    // 特殊处理字符串到数字的转换
    if field.Kind() == reflect.String && fieldValue.Kind() != reflect.String {
        field.SetString(fmt.Sprintf("%v", value))
        return nil
    }
    
    // 处理指针类型
    if field.Kind() == reflect.Ptr {
        if field.IsNil() {
            field.Set(reflect.New(field.Type().Elem()))
        }
        return setFieldValue(field.Elem(), value)
    }
    
    return fmt.Errorf("cannot convert %v to %v", fieldValue.Type(), field.Type())
}

func demonstrateMapToStruct() {
    fmt.Println("\n=== Map到结构体转换 ===")
    
    data := map[string]interface{}{
        "name":  "Bob",
        "age":   30,
        "email": "bob@example.com",
    }
    
    var person Person
    if err := MapToStruct(data, &person); err != nil {
        fmt.Printf("Conversion error: %v\n", err)
        return
    }
    
    fmt.Printf("Converted person: %+v\n", person)
    
    // JSON反序列化验证
    jsonData, _ := json.Marshal(data)
    var person2 Person
    json.Unmarshal(jsonData, &person2)
    fmt.Printf("JSON unmarshaled: %+v\n", person2)
}

// 通用验证器
func ValidateStruct(obj interface{}) []string {
    var errors []string
    
    v := reflect.ValueOf(obj)
    t := reflect.TypeOf(obj)
    
    // 处理指针
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
        t = t.Elem()
    }
    
    // 只处理结构体
    if v.Kind() != reflect.Struct {
        return errors
    }
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        // 获取验证标签
        validateTag := field.Tag.Get("validate")
        if validateTag == "" {
            continue
        }
        
        // 解析验证规则
        rules := strings.Split(validateTag, ",")
        for _, rule := range rules {
            if err := validateField(value, rule, field.Name); err != nil {
                errors = append(errors, err.Error())
            }
        }
    }
    
    return errors
}

func validateField(value reflect.Value, rule, fieldName string) error {
    switch {
    case rule == "required":
        if isEmptyValue(value) {
            return fmt.Errorf("%s is required", fieldName)
        }
    case strings.HasPrefix(rule, "min="):
        min := 0
        fmt.Sscanf(strings.TrimPrefix(rule, "min="), "%d", &min)
        switch value.Kind() {
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
            if value.Int() < int64(min) {
                return fmt.Errorf("%s must be at least %d", fieldName, min)
            }
        case reflect.String:
            if value.Len() < min {
                return fmt.Errorf("%s must be at least %d characters", fieldName, min)
            }
        }
    case rule == "email":
        if value.Kind() == reflect.String {
            email := value.String()
            if !strings.Contains(email, "@") || !strings.Contains(email, ".") {
                return fmt.Errorf("%s must be a valid email", fieldName)
            }
        }
    }
    
    return nil
}

func demonstrateValidation() {
    fmt.Println("\n=== 通用验证器 ===")
    
    // 有效的数据
    validPerson := Person{
        Name:  "Alice",
        Age:   25,
        Email: "alice@example.com",
    }
    
    errors := ValidateStruct(validPerson)
    fmt.Printf("Valid person errors: %v\n", errors)
    
    // 无效的数据
    invalidPerson := Person{
        Name:  "",  // required
        Age:   -5,  // min=0
        Email: "invalid-email",  // email
    }
    
    errors = ValidateStruct(invalidPerson)
    fmt.Printf("Invalid person errors: %v\n", errors)
}

// 通用深拷贝工具
type DeepCopyOptions struct {
    SkipPrivateFields bool
    MaxDepth         int
}

func DeepCopyWithOption(src interface{}, options DeepCopyOptions) interface{} {
    return deepCopyWithOptions(reflect.ValueOf(src), options, 0).Interface()
}

func deepCopyWithOptions(src reflect.Value, options DeepCopyOptions, depth int) reflect.Value {
    if options.MaxDepth > 0 && depth >= options.MaxDepth {
        return src
    }
    
    switch src.Kind() {
    case reflect.Ptr:
        if src.IsNil() {
            return reflect.Zero(src.Type())
        }
        dst := reflect.New(src.Type().Elem())
        dst.Elem().Set(deepCopyWithOptions(src.Elem(), options, depth+1))
        return dst
        
    case reflect.Slice:
        if src.IsNil() {
            return reflect.Zero(src.Type())
        }
        dst := reflect.MakeSlice(src.Type(), src.Len(), src.Cap())
        for i := 0; i < src.Len(); i++ {
            dst.Index(i).Set(deepCopyWithOptions(src.Index(i), options, depth+1))
        }
        return dst
        
    case reflect.Map:
        if src.IsNil() {
            return reflect.Zero(src.Type())
        }
        dst := reflect.MakeMap(src.Type())
        for _, key := range src.MapKeys() {
            dst.SetMapIndex(key, deepCopyWithOptions(src.MapIndex(key), options, depth+1))
        }
        return dst
        
    case reflect.Struct:
        dst := reflect.New(src.Type()).Elem()
        for i := 0; i < src.NumField(); i++ {
            field := src.Type().Field(i)
            if options.SkipPrivateFields && !field.IsExported() {
                continue
            }
            if dst.Field(i).CanSet() {
                dst.Field(i).Set(deepCopyWithOptions(src.Field(i), options, depth+1))
            }
        }
        return dst
        
    default:
        return src
    }
}

func demonstrateDeepCopyUtility() {
    fmt.Println("\n=== 通用深拷贝工具 ===")
    
    original := Person{
        Name:  "Original",
        Age:   25,
        Email: "original@example.com",
    }
    
    // 标准深拷贝
    copied := DeepCopyWithOption(original, DeepCopyOptions{})
    fmt.Printf("Standard copy: %+v\n", copied)
    
    // 带选项的深拷贝
    limitedCopy := DeepCopyWithOption(original, DeepCopyOptions{
        MaxDepth: 1,
    })
    fmt.Printf("Limited depth copy: %+v\n", limitedCopy)
}

// 反射驱动的ORM示例
type Model interface {
    GetTableName() string
    GetPrimaryKey() string
}

func GenerateInsertSQL(obj Model) (string, []interface{}) {
    v := reflect.ValueOf(obj)
    t := reflect.TypeOf(obj)
    
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
        t = t.Elem()
    }
    
    var columns []string
    var values []interface{}
    var placeholders []string
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        // 跳过未导出字段
        if !field.IsExported() {
            continue
        }
        
        columnName := strings.ToLower(field.Name)
        columns = append(columns, columnName)
        values = append(values, value.Interface())
        placeholders = append(placeholders, "?")
    }
    
    tableName := obj.GetTableName()
    sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
        tableName,
        strings.Join(columns, ", "),
        strings.Join(placeholders, ", "))
    
    return sql, values
}

func (p Person) GetTableName() string {
    return "users"
}

func (p Person) GetPrimaryKey() string {
    return "id"
}

func demonstrateORM() {
    fmt.Println("\n=== 反射驱动的ORM示例 ===")
    
    person := Person{
        Name:  "Alice",
        Age:   25,
        Email: "alice@example.com",
    }
    
    sql, values := GenerateInsertSQL(person)
    fmt.Printf("Generated SQL: %s\n", sql)
    fmt.Printf("Values: %v\n", values)
}

// 配置文件解析器
type Config struct {
    Database struct {
        Host     string `config:"host"`
        Port     int    `config:"port"`
        Username string `config:"username"`
        Password string `config:"password"`
    } `config:"database"`
    
    Server struct {
        Port int `config:"port"`
        Host string `config:"host"`
    } `config:"server"`
}

func LoadConfig(configMap map[string]interface{}, config interface{}) error {
    v := reflect.ValueOf(config)
    if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct {
        return fmt.Errorf("config must be a pointer to struct")
    }
    
    return loadConfigRecursive(configMap, v.Elem())
}

func loadConfigRecursive(configMap map[string]interface{}, v reflect.Value) error {
    t := v.Type()
    
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        fieldValue := v.Field(i)
        
        if !fieldValue.CanSet() {
            continue
        }
        
        // 获取配置标签
        configTag := field.Tag.Get("config")
        if configTag == "" {
            configTag = strings.ToLower(field.Name)
        }
        
        // 处理嵌套结构体
        if fieldValue.Kind() == reflect.Struct {
            if subMap, ok := configMap[configTag].(map[string]interface{}); ok {
                if err := loadConfigRecursive(subMap, fieldValue); err != nil {
                    return err
                }
            }
            continue
        }
        
        // 设置简单字段值
        if configValue, exists := configMap[configTag]; exists {
            if err := setFieldValue(fieldValue, configValue); err != nil {
                return fmt.Errorf("field %s: %v", field.Name, err)
            }
        }
    }
    
    return nil
}

func demonstrateConfigParser() {
    fmt.Println("\n=== 配置文件解析器 ===")
    
    configData := map[string]interface{}{
        "database": map[string]interface{}{
            "host":     "localhost",
            "port":     5432,
            "username": "admin",
            "password": "secret",
        },
        "server": map[string]interface{}{
            "port": 8080,
            "host": "0.0.0.0",
        },
    }
    
    var config Config
    if err := LoadConfig(configData, &config); err != nil {
        fmt.Printf("Config loading error: %v\n", err)
        return
    }
    
    fmt.Printf("Loaded config: %+v\n", config)
    fmt.Printf("Database host: %s\n", config.Database.Host)
    fmt.Printf("Server port: %d\n", config.Server.Port)
}

func main() {
    demonstrateStructToMap()
    demonstrateMapToStruct()
    demonstrateValidation()
    demonstrateDeepCopyUtility()
    demonstrateORM()
    demonstrateConfigParser()
}
```

### 反射安全性

```go
package main

import (
    "fmt"
    "reflect"
    "unsafe"
)

// 反射安全检查
func demonstrateSecurityChecks() {
    fmt.Println("=== 反射安全检查 ===")
    
    // 1. 检查字段可访问性
    person := Person{Name: "Alice", Age: 25}
    v := reflect.ValueOf(person)
    t := reflect.TypeOf(person)
    
    fmt.Println("Field accessibility:")
    for i := 0; i < v.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        fmt.Printf("  %s: exported=%t, canSet=%t, canInterface=%t\n",
            field.Name, field.IsExported(), value.CanSet(), value.CanInterface())
    }
    
    // 2. 检查方法可调用性
    fmt.Println("Method accessibility:")
    for i := 0; i < t.NumMethod(); i++ {
        method := t.Method(i)
        fmt.Printf("  %s: exported=%t\n", method.Name, method.IsExported())
    }
    
    // 3. 检查指针可寻址性
    ptr := &person
    ptrV := reflect.ValueOf(ptr)
    elemV := ptrV.Elem()
    
    fmt.Printf("Pointer canSet: %t\n", ptrV.CanSet())
    fmt.Printf("Element canSet: %t\n", elemV.CanSet())
    fmt.Printf("Element canAddr: %t\n", elemV.CanAddr())
}

// 安全的字段访问
func safeFieldAccess(obj interface{}, fieldName string) (interface{}, error) {
    v := reflect.ValueOf(obj)
    t := reflect.TypeOf(obj)
    
    // 处理指针
    if v.Kind() == reflect.Ptr {
        if v.IsNil() {
            return nil, fmt.Errorf("pointer is nil")
        }
        v = v.Elem()
        t = t.Elem()
    }
    
    // 检查是否为结构体
    if v.Kind() != reflect.Struct {
        return nil, fmt.Errorf("object is not a struct")
    }
    
    // 查找字段
    field, found := t.FieldByName(fieldName)
    if !found {
        return nil, fmt.Errorf("field %s not found", fieldName)
    }
    
    // 检查字段是否可导出
    if !field.IsExported() {
        return nil, fmt.Errorf("field %s is not exported", fieldName)
    }
    
    // 获取字段值
    fieldValue := v.FieldByName(fieldName)
    if !fieldValue.IsValid() {
        return nil, fmt.Errorf("field %s is not valid", fieldName)
    }
    
    return fieldValue.Interface(), nil
}

func demonstrateSafeFieldAccess() {
    fmt.Println("\n=== 安全字段访问 ===")
    
    person := Person{Name: "Alice", Age: 25}
    
    // 安全访问存在的字段
    if value, err := safeFieldAccess(person, "Name"); err == nil {
        fmt.Printf("Name: %v\n", value)
    } else {
        fmt.Printf("Error accessing Name: %v\n", err)
    }
    
    // 访问不存在的字段
    if value, err := safeFieldAccess(person, "NonExistent"); err != nil {
        fmt.Printf("Error accessing NonExistent: %v\n", err)
    } else {
        fmt.Printf("NonExistent: %v\n", value)
    }
    
    // 访问未导出字段（假设存在）
    type PrivateStruct struct {
        PublicField  string
        privateField string
    }
    
    privateObj := PrivateStruct{PublicField: "public", privateField: "private"}
    
    if value, err := safeFieldAccess(privateObj, "PublicField"); err == nil {
        fmt.Printf("PublicField: %v\n", value)
    }
    
    if value, err := safeFieldAccess(privateObj, "privateField"); err != nil {
        fmt.Printf("Error accessing privateField: %v\n", err)
    }
}

// 安全的方法调用
func safeMethodCall(obj interface{}, methodName string, args ...interface{}) ([]interface{}, error) {
    v := reflect.ValueOf(obj)
    t := reflect.TypeOf(obj)
    
    // 查找方法
    method, found := t.MethodByName(methodName)
    if !found {
        return nil, fmt.Errorf("method %s not found", methodName)
    }
    
    // 检查方法是否可导出
    if !method.IsExported() {
        return nil, fmt.Errorf("method %s is not exported", methodName)
    }
    
    // 准备参数
    in := make([]reflect.Value, len(args)+1) // +1 for receiver
    in[0] = v
    
    for i, arg := range args {
        if i+1 >= len(method.Type.In()) {
            return nil, fmt.Errorf("too many arguments")
        }
        
        expectedType := method.Type.In(i + 1)
        argValue := reflect.ValueOf(arg)
        
        // 类型检查和转换
        if !argValue.Type().AssignableTo(expectedType) {
            if argValue.Type().ConvertibleTo(expectedType) {
                argValue = argValue.Convert(expectedType)
            } else {
                return nil, fmt.Errorf("argument %d: cannot convert %v to %v",
                    i, argValue.Type(), expectedType)
            }
        }
        
        in[i+1] = argValue
    }
    
    // 调用方法
    results := method.Func.Call(in)
    
    // 转换结果
    out := make([]interface{}, len(results))
    for i, result := range results {
        out[i] = result.Interface()
    }
    
    return out, nil
}

func demonstrateSafeMethodCall() {
    fmt.Println("\n=== 安全方法调用 ===")
    
    person := Person{Name: "Alice", Age: 25}
    
    // 调用存在的方法
    if results, err := safeMethodCall(person, "SayHello"); err == nil {
        fmt.Printf("SayHello result: %v\n", results[0])
    } else {
        fmt.Printf("Error calling SayHello: %v\n", err)
    }
    
    // 调用带参数的方法
    if results, err := safeMethodCall(person, "Greet", "Bob"); err == nil {
        fmt.Printf("Greet result: %v\n", results[0])
    } else {
        fmt.Printf("Error calling Greet: %v\n", err)
    }
    
    // 调用不存在的方法
    if results, err := safeMethodCall(person, "NonExistent"); err != nil {
        fmt.Printf("Error calling NonExistent: %v\n", err)
    } else {
        fmt.Printf("NonExistent result: %v\n", results)
    }
}

// 反射沙箱
type ReflectionSandbox struct {
    allowedTypes map[reflect.Type]bool
    allowedOps   map[string]bool
    maxDepth     int
}

func NewReflectionSandbox() *ReflectionSandbox {
    return &ReflectionSandbox{
        allowedTypes: make(map[reflect.Type]bool),
        allowedOps:   make(map[string]bool),
        maxDepth:     10,
    }
}

func (rs *ReflectionSandbox) AllowType(t reflect.Type) {
    rs.allowedTypes[t] = true
}

func (rs *ReflectionSandbox) AllowOperation(op string) {
    rs.allowedOps[op] = true
}

func (rs *ReflectionSandbox) IsTypeAllowed(t reflect.Type) bool {
    return rs.allowedTypes[t]
}

func (rs *ReflectionSandbox) IsOperationAllowed(op string) bool {
    return rs.allowedOps[op]
}

func (rs *ReflectionSandbox) SafeValueOf(i interface{}) reflect.Value {
    t := reflect.TypeOf(i)
    if !rs.IsTypeAllowed(t) {
        panic(fmt.Sprintf("type %v is not allowed", t))
    }
    return reflect.ValueOf(i)
}

func demonstrateSandbox() {
    fmt.Println("\n=== 反射沙箱 ===")
    
    sandbox := NewReflectionSandbox()
    sandbox.AllowType(reflect.TypeOf(Person{}))
    sandbox.AllowType(reflect.TypeOf(""))
    sandbox.AllowType(reflect.TypeOf(0))
    sandbox.AllowOperation("read")
    sandbox.AllowOperation("write")
    
    person := Person{Name: "Alice", Age: 25}
    
    // 在沙箱中安全使用反射
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Sandbox violation: %v\n", r)
        }
    }()
    
    v := sandbox.SafeValueOf(person)
    fmt.Printf("Sandboxed value: %v\n", v.Interface())
    
    // 尝试访问不允许的类型
    // sandbox.SafeValueOf([]int{1, 2, 3}) // 这会触发panic
}

// 反射数据验证
func validateReflectionData(v reflect.Value, maxDepth int) error {
    if maxDepth <= 0 {
        return fmt.Errorf("maximum recursion depth exceeded")
    }
    
    switch v.Kind() {
    case reflect.Ptr:
        if v.IsNil() {
            return nil
        }
        return validateReflectionData(v.Elem(), maxDepth-1)
        
    case reflect.Slice, reflect.Array:
        if v.Len() > 10000 {
            return fmt.Errorf("slice/array too large: %d elements", v.Len())
        }
        for i := 0; i < v.Len(); i++ {
            if err := validateReflectionData(v.Index(i), maxDepth-1); err != nil {
                return err
            }
        }
        
    case reflect.Map:
        if v.Len() > 10000 {
            return fmt.Errorf("map too large: %d elements", v.Len())
        }
        for _, key := range v.MapKeys() {
            if err := validateReflectionData(v.MapIndex(key), maxDepth-1); err != nil {
                return err
            }
        }
        
    case reflect.Struct:
        for i := 0; i < v.NumField(); i++ {
            if err := validateReflectionData(v.Field(i), maxDepth-1); err != nil {
                return err
            }
        }
        
    case reflect.String:
        if v.Len() > 1000000 {
            return fmt.Errorf("string too large: %d characters", v.Len())
        }
        
    case reflect.Interface:
        if !v.IsNil() {
            return validateReflectionData(v.Elem(), maxDepth-1)
        }
    }
    
    return nil
}

func demonstrateDataValidation() {
    fmt.Println("\n=== 反射数据验证 ===")
    
    // 验证正常数据
    person := Person{Name: "Alice", Age: 25}
    v := reflect.ValueOf(person)
    
    if err := validateReflectionData(v, 10); err == nil {
        fmt.Println("Person data is valid")
    } else {
        fmt.Printf("Person data validation error: %v\n", err)
    }
    
    // 验证大字符串
    largeString := ""
    for i := 0; i < 1000001; i++ {
        largeString += "a"
    }
    
    v = reflect.ValueOf(largeString)
    if err := validateReflectionData(v, 10); err != nil {
        fmt.Printf("Large string validation error: %v\n", err)
    }
    
    // 验证递归结构
    type RecursiveStruct struct {
        Value int
        Next  *RecursiveStruct
    }
    
    // 创建深度递归结构
    root := &RecursiveStruct{Value: 1}
    current := root
    for i := 0; i < 15; i++ {
        current.Next = &RecursiveStruct{Value: i + 2}
        current = current.Next
    }
    
    v = reflect.ValueOf(root)
    if err := validateReflectionData(v, 10); err != nil {
        fmt.Printf("Recursive structure validation error: %v\n", err)
    }
}

// 内存安全反射
func demonstrateMemorySafety() {
    fmt.Println("\n=== 内存安全反射 ===")
    
    // 1. 避免使用unsafe包直接操作内存
    // 2. 正确处理指针和nil值
    // 3. 防止内存泄漏
    
    // 安全的指针处理
    var ptr *int
    v := reflect.ValueOf(ptr)
    fmt.Printf("Nil pointer: %v, IsNil: %t\n", v, v.IsNil())
    
    // 安全的切片操作
    slice := make([]int, 0, 10)
    v = reflect.ValueOf(&slice).Elem()
    
    // 安全地扩展切片
    for i := 0; i < 5; i++ {
        v.Set(reflect.Append(v, reflect.ValueOf(i)))
    }
    fmt.Printf("Extended slice: %v\n", slice)
    
    // 避免内存泄漏 - 及时释放大对象
    largeSlice := make([]int, 1000000)
    v = reflect.ValueOf(largeSlice)
    fmt.Printf("Large slice created, length: %d\n", v.Len())
    
    // 当不再需要时，将引用设为nil
    largeSlice = nil
    fmt.Println("Large slice reference cleared")
}

// 反射安全最佳实践
func reflectionSecurityBestPractices() {
    fmt.Println("\n=== 反射安全最佳实践 ===")
    
    fmt.Println("1. 输入验证:")
    fmt.Println("   - 验证所有反射输入数据")
    fmt.Println("   - 限制数据大小和复杂度")
    fmt.Println("   - 检查递归深度")
    
    fmt.Println("\n2. 访问控制:")
    fmt.Println("   - 只访问导出的字段和方法")
    fmt.Println("   - 使用沙箱限制可访问的类型")
    fmt.Println("   - 验证操作权限")
    
    fmt.Println("\n3. 内存安全:")
    fmt.Println("   - 避免使用unsafe包")
    fmt.Println("   - 正确处理nil指针")
    fmt.Println("   - 及时释放大对象引用")
    
    fmt.Println("\n4. 错误处理:")
    fmt.Println("   - 全面的错误检查")
    fmt.Println("   - 优雅的异常处理")
    fmt.Println("   - 详细的错误日志")
    
    fmt.Println("\n5. 性能考虑:")
    fmt.Println("   - 避免在热点路径中使用反射")
    fmt.Println("   - 缓存反射结果")
    fmt.Println("   - 使用索引而非名称访问")
    
    fmt.Println("\n6. 代码审查:")
    fmt.Println("   - 仔细审查反射代码")
    fmt.Println("   - 测试边界条件")
    fmt.Println("   - 监控运行时行为")
}

func main() {
    demonstrateSecurityChecks()
    demonstrateSafeFieldAccess()
    demonstrateSafeMethodCall()
    demonstrateSandbox()
    demonstrateDataValidation()
    demonstrateMemorySafety()
    reflectionSecurityBestPractices()
}
```

### 反射与泛型对比

```go
package main

import (
    "fmt"
    "reflect"
    "time"
)

// 反射实现的通用函数
func ReflectMax(a, b interface{}) interface{} {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    
    if av.Type() != bv.Type() {
        panic("types must match")
    }
    
    switch av.Kind() {
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        if av.Int() > bv.Int() {
            return a
        }
        return b
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        if av.Uint() > bv.Uint() {
            return a
        }
        return b
    case reflect.Float32, reflect.Float64:
        if av.Float() > bv.Float() {
            return a
        }
        return b
    case reflect.String:
        if av.String() > bv.String() {
            return a
        }
        return b
    default:
        panic("unsupported type")
    }
}

// 泛型实现的通用函数
func GenericMax[T comparable](a, b T) T {
    // 需要约束来支持比较操作
    switch any(a).(type) {
    case int, int8, int16, int32, int64,
         uint, uint8, uint16, uint32, uint64,
         float32, float64, string:
        if compareComparable(a, b) > 0 {
            return a
        }
        return b
    default:
        panic("unsupported type")
    }
}

// 比较函数（简化实现）
func compareComparable[T comparable](a, b T) int {
    // 这里需要类型断言来实现比较
    switch va := any(a).(type) {
    case int:
        vb := any(b).(int)
        if va > vb {
            return 1
        } else if va < vb {
            return -1
        }
        return 0
    case string:
        vb := any(b).(string)
        if va > vb {
            return 1
        } else if va < vb {
            return -1
        }
        return 0
    // 其他类型...
    default:
        panic("unsupported comparable type")
    }
}

// 使用类型约束的泛型函数
type Number interface {
    int | int8 | int16 | int32 | int64 |
    uint | uint8 | uint16 | uint32 | uint64 |
    float32 | float64
}

func ConstrainedMax[T Number](a, b T) T {
    if a > b {
        return a
    }
    return b
}

func demonstrateBasicComparison() {
    fmt.Println("=== 基本功能对比 ===")
    
    // 反射实现
    fmt.Println("Reflection implementation:")
    fmt.Printf("  Max(5, 3): %v\n", ReflectMax(5, 3))
    fmt.Printf("  Max(3.14, 2.71): %v\n", ReflectMax(3.14, 2.71))
    fmt.Printf("  Max(\"hello\", \"world\"): %v\n", ReflectMax("hello", "world"))
    
    // 泛型实现
    fmt.Println("Generic implementation:")
    fmt.Printf("  Max(5, 3): %v\n", ConstrainedMax(5, 3))
    fmt.Printf("  Max(3.14, 2.71): %v\n", ConstrainedMax(3.14, 2.71))
    // fmt.Printf("  Max(\"hello\", \"world\"): %v\n", GenericMax("hello", "world")) // 需要特殊处理
}

// 复杂数据结构处理对比

// 反射实现的深度相等比较
func ReflectDeepEqual(a, b interface{}) bool {
    return reflect.DeepEqual(a, b)
}

// 泛型实现的深度相等比较
func GenericDeepEqual[T comparable](a, b T) bool {
    return a == b
}

// 使用类型约束的通用比较
func ConstrainedDeepEqual[T any](a, b T) bool {
    return reflect.DeepEqual(a, b)
}

func demonstrateComplexComparison() {
    fmt.Println("\n=== 复杂数据结构对比 ===")
    
    // 测试复杂结构
    person1 := Person{Name: "Alice", Age: 25, Email: "alice@example.com"}
    person2 := Person{Name: "Alice", Age: 25, Email: "alice@example.com"}
    person3 := Person{Name: "Bob", Age: 30, Email: "bob@example.com"}
    
    // 反射实现
    fmt.Println("Reflection deep equal:")
    fmt.Printf("  person1 == person2: %t\n", ReflectDeepEqual(person1, person2))
    fmt.Printf("  person1 == person3: %t\n", ReflectDeepEqual(person1, person3))
    
    // 泛型实现
    fmt.Println("Generic deep equal:")
    fmt.Printf("  person1 == person2: %t\n", ConstrainedDeepEqual(person1, person2))
    fmt.Printf("  person1 == person3: %t\n", ConstrainedDeepEqual(person1, person3))
    
    // 切片比较
    slice1 := []int{1, 2, 3, 4, 5}
    slice2 := []int{1, 2, 3, 4, 5}
    slice3 := []int{1, 2, 3, 4, 6}
    
    fmt.Println("Slice comparison:")
    fmt.Printf("  slice1 == slice2 (reflect): %t\n", ReflectDeepEqual(slice1, slice2))
    fmt.Printf("  slice1 == slice3 (reflect): %t\n", ReflectDeepEqual(slice1, slice3))
    fmt.Printf("  slice1 == slice2 (generic): %t\n", ConstrainedDeepEqual(slice1, slice2))
    fmt.Printf("  slice1 == slice3 (generic): %t\n", ConstrainedDeepEqual(slice1, slice3))
}

// 性能对比
func performanceComparison() {
    fmt.Println("\n=== 性能对比 ===")
    
    // 整数比较性能测试
    a, b := 100, 200
    
    // 反射实现性能
    start := time.Now()
    for i := 0; i < 1000000; i++ {
        _ = ReflectMax(a, b)
    }
    reflectTime := time.Since(start)
    
    // 泛型实现性能
    start = time.Now()
    for i := 0; i < 1000000; i++ {
        _ = ConstrainedMax(a, b)
    }
    genericTime := time.Since(start)
    
    fmt.Printf("Reflection time: %v\n", reflectTime)
    fmt.Printf("Generic time: %v\n", genericTime)
    fmt.Printf("Generic is %.1fx faster\n", float64(reflectTime)/float64(genericTime))
    
    // 深度相等比较性能
    person1 := Person{Name: "Alice", Age: 25}
    person2 := Person{Name: "Alice", Age: 25}
    
    // 反射实现
    start = time.Now()
    for i := 0; i < 100000; i++ {
        _ = ReflectDeepEqual(person1, person2)
    }
    reflectDeepTime := time.Since(start)
    
    // 泛型实现
    start = time.Now()
    for i := 0; i < 100000; i++ {
        _ = ConstrainedDeepEqual(person1, person2)
    }
    genericDeepTime := time.Since(start)
    
    fmt.Printf("Reflection deep equal time: %v\n", reflectDeepTime)
    fmt.Printf("Generic deep equal time: %v\n", genericDeepTime)
    fmt.Printf("Generic deep equal is %.1fx faster\n", 
        float64(reflectDeepTime)/float64(genericDeepTime))
}

// 类型安全对比
func typeSafetyComparison() {
    fmt.Println("\n=== 类型安全对比 ===")
    
    // 反射实现 - 运行时错误
    fmt.Println("Reflection type safety:")
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("  Runtime panic caught: %v\n", r)
        }
    }()
    
    // 这会导致运行时panic
    // result := ReflectMax(42, "hello")
    // fmt.Printf("  Mixed types result: %v\n", result)
    
    // 泛型实现 - 编译时错误
    fmt.Println("Generic type safety:")
    // GenericMax(42, "hello") // 这会在编译时报错
    
    // 类型约束提供更好的类型安全
    fmt.Printf("  Constrained max(42, 24): %v\n", ConstrainedMax(42, 24))
    fmt.Printf("  Constrained max(3.14, 2.71): %v\n", ConstrainedMax(3.14, 2.71))
}

// 灵活性对比
func flexibilityComparison() {
    fmt.Println("\n=== 灵活性对比 ===")
    
    // 反射 - 运行时处理任意类型
    fmt.Println("Reflection flexibility:")
    values := []interface{}{42, 3.14, "hello", true}
    
    for i := 1; i < len(values); i++ {
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("  Cannot compare %T and %T: %v\n", 
                    values[i-1], values[i], r)
            }
        }()
        
        // result := ReflectMax(values[i-1], values[i])
        // fmt.Printf("  Max(%v, %v) = %v\n", values[i-1], values[i], result)
    }
    
    // 泛型 - 编译时确定类型
    fmt.Println("Generic flexibility:")
    fmt.Printf("  Max(42, 24): %v\n", ConstrainedMax(42, 24))
    fmt.Printf("  Max(3.14, 2.71): %v\n", ConstrainedMax(3.14, 2.71))
    
    // 泛型可以通过接口获得更好的灵活性
    type Stringer interface {
        String() string
    }
    
    // 通用字符串化函数
    stringify := func[T Stringer](value T) string {
        return value.String()
    }
    
    person := Person{Name: "Alice", Age: 25}
    fmt.Printf("  Person string: %s\n", stringify(person))
}

// 内存使用对比
func memoryUsageComparison() {
    fmt.Println("\n=== 内存使用对比 ===")
    
    // 反射会创建额外的对象
    fmt.Println("Reflection memory usage:")
    person := Person{Name: "Alice", Age: 25}
    
    // 反射操作会产生临时对象
    v := reflect.ValueOf(person)
    t := reflect.TypeOf(person)
    
    fmt.Printf("  Type info: %v\n", t)
    fmt.Printf("  Value info: %v\n", v)
    
    // 泛型操作更直接
    fmt.Println("Generic memory usage:")
    result := ConstrainedMax(42, 24)
    fmt.Printf("  Direct result: %v\n", result)
    
    // 反射的内存开销
    fmt.Println("  Reflection creates additional Value and Type objects")
    fmt.Println("  Generic operations work directly with typed values")
}

// 错误处理对比
func errorHandlingComparison() {
    fmt.Println("\n=== 错误处理对比 ===")
    
    // 反射 - 运行时错误
    fmt.Println("Reflection error handling:")
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("  Caught reflection panic: %v\n", r)
        }
    }()
    
    // 可能导致panic的操作
    // result := ReflectMax([]int{1, 2}, []int{3, 4}) // 不支持的类型
    
    // 泛型 - 编译时保证
    fmt.Println("Generic error handling:")
    // ConstrainedMax([]int{1, 2}, []int{3, 4}) // 编译错误，类型不匹配
    
    // 泛型可以返回错误而不是panic
    safeMax := func[T Number](a, b T) (T, error) {
        if a > b {
            return a, nil
        }
        return b, nil
    }
    
    if result, err := safeMax(42, 24); err == nil {
        fmt.Printf("  Safe max result: %v\n", result)
    }
}

// 使用建议对比
func usageRecommendations() {
    fmt.Println("\n=== 使用建议对比 ===")
    
    fmt.Println("Reflection适用场景:")
    fmt.Println("  - 框架和库开发")
    fmt.Println("  - 序列化/反序列化")
    fmt.Println("  - ORM和数据库映射")
    fmt.Println("  - 配置文件解析")
    fmt.Println("  - 动态类型处理")
    
    fmt.Println("\nGeneric适用场景:")
    fmt.Println("  - 类型安全的通用算法")
    fmt.Println("  - 容器和数据结构")
    fmt.Println("  - 数学和数值计算")
    fmt.Println("  - 性能敏感的代码")
    fmt.Println("  - 编译时类型检查")
    
    fmt.Println("\n选择建议:")
    fmt.Println("  - 优先使用泛型获得类型安全和性能")
    fmt.Println("  - 在需要运行时灵活性时使用反射")
    fmt.Println("  - 结合使用两者以获得最佳效果")
    fmt.Println("  - 考虑维护性和可读性")
}

func main() {
    demonstrateBasicComparison()
    demonstrateComplexComparison()
    performanceComparison()
    typeSafetyComparison()
    flexibilityComparison()
    memoryUsageComparison()
    errorHandlingComparison()
    usageRecommendations()
}
```