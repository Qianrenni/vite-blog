## 6.4 数据库操作

### database/sql包

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
)

// 数据库连接和基本操作
func basicDatabaseOperations() {
    fmt.Println("=== 基本数据库操作 ===")
    
    // 连接MySQL数据库
    db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/testdb")
    if err != nil {
        log.Printf("MySQL connection error: %v", err)
        // 继续演示其他操作
    } else {
        defer db.Close()
        
        // 测试连接
        if err := db.Ping(); err != nil {
            log.Printf("MySQL ping error: %v", err)
        } else {
            fmt.Println("MySQL connection successful")
        }
    }
    
    // 连接PostgreSQL数据库
    pgDB, err := sql.Open("postgres", "user=username password=password dbname=testdb sslmode=disable")
    if err != nil {
        log.Printf("PostgreSQL connection error: %v", err)
    } else {
        defer pgDB.Close()
        
        if err := pgDB.Ping(); err != nil {
            log.Printf("PostgreSQL ping error: %v", err)
        } else {
            fmt.Println("PostgreSQL connection successful")
        }
    }
}

// 用户结构体
type User struct {
    ID        int64
    Name      string
    Email     string
    Age       int
    CreatedAt time.Time
}

// 数据库操作示例
func databaseOperations(db *sql.DB) {
    fmt.Println("\n=== 数据库操作示例 ===")
    
    // 创建表
    createTableSQL := `
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTO_INCREMENT,
        name VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        age INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err := db.Exec(createTableSQL)
    if err != nil {
        log.Printf("Create table error: %v", err)
        return
    }
    fmt.Println("Table created successfully")
    
    // 插入数据
    insertSQL := `INSERT INTO users (name, email, age) VALUES (?, ?, ?)`
    result, err := db.Exec(insertSQL, "Alice", "alice@example.com", 25)
    if err != nil {
        log.Printf("Insert error: %v", err)
        return
    }
    
    userID, err := result.LastInsertId()
    if err != nil {
        log.Printf("Get last insert ID error: %v", err)
        return
    }
    fmt.Printf("Inserted user with ID: %d\n", userID)
    
    // 查询单行数据
    var user User
    querySQL := `SELECT id, name, email, age, created_at FROM users WHERE id = ?`
    err = db.QueryRow(querySQL, userID).Scan(&user.ID, &user.Name, &user.Email, &user.Age, &user.CreatedAt)
    if err != nil {
        log.Printf("Query row error: %v", err)
        return
    }
    fmt.Printf("Retrieved user: %+v\n", user)
    
    // 插入更多数据
    users := []User{
        {Name: "Bob", Email: "bob@example.com", Age: 30},
        {Name: "Charlie", Email: "charlie@example.com", Age: 35},
        {Name: "Diana", Email: "diana@example.com", Age: 28},
    }
    
    for _, u := range users {
        _, err := db.Exec(insertSQL, u.Name, u.Email, u.Age)
        if err != nil {
            log.Printf("Insert user error: %v", err)
            continue
        }
    }
    fmt.Println("Additional users inserted")
    
    // 查询多行数据
    queryAllSQL := `SELECT id, name, email, age, created_at FROM users ORDER BY id`
    rows, err := db.Query(queryAllSQL)
    if err != nil {
        log.Printf("Query error: %v", err)
        return
    }
    defer rows.Close()
    
    var allUsers []User
    for rows.Next() {
        var u User
        err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age, &u.CreatedAt)
        if err != nil {
            log.Printf("Scan error: %v", err)
            continue
        }
        allUsers = append(allUsers, u)
    }
    
    if err = rows.Err(); err != nil {
        log.Printf("Rows error: %v", err)
        return
    }
    
    fmt.Printf("All users (%d):\n", len(allUsers))
    for _, u := range allUsers {
        fmt.Printf("  %+v\n", u)
    }
    
    // 更新数据
    updateSQL := `UPDATE users SET age = ? WHERE name = ?`
    result, err = db.Exec(updateSQL, 26, "Alice")
    if err != nil {
        log.Printf("Update error: %v", err)
        return
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        log.Printf("Get rows affected error: %v", err)
        return
    }
    fmt.Printf("Updated %d rows\n", rowsAffected)
    
    // 删除数据
    deleteSQL := `DELETE FROM users WHERE name = ?`
    result, err = db.Exec(deleteSQL, "Bob")
    if err != nil {
        log.Printf("Delete error: %v", err)
        return
    }
    
    rowsAffected, err = result.RowsAffected()
    if err != nil {
        log.Printf("Get rows affected error: %v", err)
        return
    }
    fmt.Printf("Deleted %d rows\n", rowsAffected)
}

// 预处理语句示例
func preparedStatements(db *sql.DB) {
    fmt.Println("\n=== 预处理语句示例 ===")
    
    // 准备插入语句
    insertStmt, err := db.Prepare(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`)
    if err != nil {
        log.Printf("Prepare insert error: %v", err)
        return
    }
    defer insertStmt.Close()
    
    // 使用预处理语句插入多条记录
    users := []User{
        {Name: "Eve", Email: "eve@example.com", Age: 32},
        {Name: "Frank", Email: "frank@example.com", Age: 29},
        {Name: "Grace", Email: "grace@example.com", Age: 31},
    }
    
    for _, u := range users {
        result, err := insertStmt.Exec(u.Name, u.Email, u.Age)
        if err != nil {
            log.Printf("Insert with prepared stmt error: %v", err)
            continue
        }
        
        userID, _ := result.LastInsertId()
        fmt.Printf("Inserted user %s with ID: %d\n", u.Name, userID)
    }
    
    // 准备查询语句
    selectStmt, err := db.Prepare(`SELECT id, name, email, age, created_at FROM users WHERE age > ? ORDER BY age`)
    if err != nil {
        log.Printf("Prepare select error: %v", err)
        return
    }
    defer selectStmt.Close()
    
    // 使用预处理语句查询
    rows, err := selectStmt.Query(30)
    if err != nil {
        log.Printf("Query with prepared stmt error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Users older than 30:")
    for rows.Next() {
        var u User
        err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age, &u.CreatedAt)
        if err != nil {
            log.Printf("Scan error: %v", err)
            continue
        }
        fmt.Printf("  %+v\n", u)
    }
}

// 事务处理示例
func transactionExample(db *sql.DB) {
    fmt.Println("\n=== 事务处理示例 ===")
    
    // 开始事务
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    
    // 准备SQL语句
    insertSQL := `INSERT INTO users (name, email, age) VALUES (?, ?, ?)`
    updateSQL := `UPDATE users SET age = ? WHERE name = ?`
    
    // 执行多个操作
    _, err = tx.Exec(insertSQL, "Henry", "henry@example.com", 40)
    if err != nil {
        tx.Rollback()
        log.Printf("Insert in transaction error: %v", err)
        return
    }
    
    _, err = tx.Exec(updateSQL, 33, "Alice")
    if err != nil {
        tx.Rollback()
        log.Printf("Update in transaction error: %v", err)
        return
    }
    
    // 提交事务
    err = tx.Commit()
    if err != nil {
        log.Printf("Commit transaction error: %v", err)
        return
    }
    
    fmt.Println("Transaction completed successfully")
    
    // 演示回滚
    tx2, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction 2 error: %v", err)
        return
    }
    
    _, err = tx2.Exec(insertSQL, "Invalid", "invalid-email", 25)  // 假设这会失败
    if err != nil {
        fmt.Println("Simulating transaction rollback")
        tx2.Rollback()
        fmt.Println("Transaction rolled back")
    } else {
        tx2.Commit()
    }
}

// 连接池管理
func connectionPoolManagement(db *sql.DB) {
    fmt.Println("\n=== 连接池管理 ===")
    
    // 设置连接池参数
    db.SetMaxOpenConns(25)    // 最大打开连接数
    db.SetMaxIdleConns(25)    // 最大空闲连接数
    db.SetConnMaxLifetime(5 * time.Minute)  // 连接最大生命周期
    
    fmt.Printf("Max open connections: %d\n", db.Stats().MaxOpenConnections)
    fmt.Printf("Open connections: %d\n", db.Stats().OpenConnections)
    fmt.Printf("In use connections: %d\n", db.Stats().InUse)
    fmt.Printf("Idle connections: %d\n", db.Stats().Idle)
    
    // 监控连接池状态
    go func() {
        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            stats := db.Stats()
            fmt.Printf("Pool stats - Open: %d, InUse: %d, Idle: %d, WaitCount: %d\n",
                stats.OpenConnections, stats.InUse, stats.Idle, stats.WaitCount)
        }
    }()
}

// 错误处理和重试机制
func errorHandlingWithRetry(db *sql.DB) {
    fmt.Println("\n=== 错误处理和重试 ===")
    
    // 自定义重试函数
    retry := func(operation func() error, maxRetries int, delay time.Duration) error {
        var err error
        for i := 0; i < maxRetries; i++ {
            err = operation()
            if err == nil {
                return nil
            }
            
            fmt.Printf("Attempt %d failed: %v\n", i+1, err)
            if i < maxRetries-1 {
                time.Sleep(delay)
            }
        }
        return err
    }
    
    // 带重试的数据库操作
    operation := func() error {
        _, err := db.Exec(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
            "RetryUser", "retry@example.com", 25)
        return err
    }
    
    err := retry(operation, 3, 1*time.Second)
    if err != nil {
        log.Printf("Operation failed after retries: %v", err)
    } else {
        fmt.Println("Operation succeeded")
    }
}

// 批量操作示例
func bulkOperations(db *sql.DB) {
    fmt.Println("\n=== 批量操作示例 ===")
    
    // 批量插入
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    
    stmt, err := tx.Prepare(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`)
    if err != nil {
        tx.Rollback()
        log.Printf("Prepare error: %v", err)
        return
    }
    defer stmt.Close()
    
    // 批量插入大量数据
    startTime := time.Now()
    for i := 0; i < 1000; i++ {
        name := fmt.Sprintf("User%d", i)
        email := fmt.Sprintf("user%d@example.com", i)
        age := 20 + (i % 50)
        
        _, err := stmt.Exec(name, email, age)
        if err != nil {
            tx.Rollback()
            log.Printf("Batch insert error: %v", err)
            return
        }
    }
    
    err = tx.Commit()
    if err != nil {
        log.Printf("Commit error: %v", err)
        return
    }
    
    duration := time.Since(startTime)
    fmt.Printf("Bulk insert of 1000 users completed in %v\n", duration)
    
    // 批量查询
    startTime = time.Now()
    rows, err := db.Query(`SELECT id, name, email, age FROM users LIMIT 100`)
    if err != nil {
        log.Printf("Bulk query error: %v", err)
        return
    }
    defer rows.Close()
    
    var count int
    for rows.Next() {
        var u User
        err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age)
        if err != nil {
            log.Printf("Scan error: %v", err)
            continue
        }
        count++
    }
    
    duration = time.Since(startTime)
    fmt.Printf("Bulk query of %d users completed in %v\n", count, duration)
}

// 数据库迁移工具示例
type Migration struct {
    Version int
    Name    string
    Up      string
    Down    string
}

var migrations = []Migration{
    {
        Version: 1,
        Name:    "create_users_table",
        Up: `CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTO_INCREMENT,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            age INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
        Down: `DROP TABLE IF EXISTS users`,
    },
    {
        Version: 2,
        Name:    "create_posts_table",
        Up: `CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTO_INCREMENT,
            user_id INTEGER,
            title VARCHAR(200) NOT NULL,
            content TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id)
        )`,
        Down: `DROP TABLE IF EXISTS posts`,
    },
}

func runMigrations(db *sql.DB) {
    fmt.Println("\n=== 数据库迁移 ===")
    
    // 创建迁移历史表
    _, err := db.Exec(`CREATE TABLE IF NOT EXISTS schema_migrations (
        version INTEGER PRIMARY KEY,
        name VARCHAR(255),
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`)
    if err != nil {
        log.Printf("Create migrations table error: %v", err)
        return
    }
    
    // 获取已应用的迁移版本
    appliedVersions := make(map[int]bool)
    rows, err := db.Query(`SELECT version FROM schema_migrations ORDER BY version`)
    if err != nil {
        log.Printf("Query migrations error: %v", err)
        return
    }
    defer rows.Close()
    
    for rows.Next() {
        var version int
        if err := rows.Scan(&version); err != nil {
            log.Printf("Scan version error: %v", err)
            continue
        }
        appliedVersions[version] = true
    }
    
    // 应用未应用的迁移
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin migration transaction error: %v", err)
        return
    }
    
    for _, migration := range migrations {
        if appliedVersions[migration.Version] {
            continue
        }
        
        fmt.Printf("Applying migration %d: %s\n", migration.Version, migration.Name)
        
        // 执行迁移
        _, err := tx.Exec(migration.Up)
        if err != nil {
            tx.Rollback()
            log.Printf("Migration %d failed: %v", migration.Version, err)
            return
        }
        
        // 记录迁移历史
        _, err = tx.Exec(`INSERT INTO schema_migrations (version, name) VALUES (?, ?)`,
            migration.Version, migration.Name)
        if err != nil {
            tx.Rollback()
            log.Printf("Record migration error: %v", err)
            return
        }
    }
    
    err = tx.Commit()
    if err != nil {
        log.Printf("Commit migrations error: %v", err)
        return
    }
    
    fmt.Println("All migrations applied successfully")
}

// 数据库性能优化
func performanceOptimization(db *sql.DB) {
    fmt.Println("\n=== 性能优化示例 ===")
    
    // 1. 使用索引
    _, err := db.Exec(`CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`)
    if err != nil {
        log.Printf("Create index error: %v", err)
    } else {
        fmt.Println("Email index created")
    }
    
    // 2. 批量操作优化
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    
    // 使用批量插入
    stmt, err := tx.Prepare(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`)
    if err != nil {
        tx.Rollback()
        log.Printf("Prepare error: %v", err)
        return
    }
    defer stmt.Close()
    
    // 批量插入数据
    startTime := time.Now()
    for i := 0; i < 1000; i++ {
        _, err := stmt.Exec(
            fmt.Sprintf("OptimizedUser%d", i),
            fmt.Sprintf("optimized%d@example.com", i),
            25+(i%10),
        )
        if err != nil {
            tx.Rollback()
            log.Printf("Batch insert error: %v", err)
            return
        }
    }
    
    err = tx.Commit()
    if err != nil {
        log.Printf("Commit error: %v", err)
        return
    }
    
    duration := time.Since(startTime)
    fmt.Printf("Optimized batch insert completed in %v\n", duration)
    
    // 3. 查询优化
    // 使用EXPLAIN分析查询计划
    rows, err := db.Query(`EXPLAIN SELECT * FROM users WHERE email = ?`, "alice@example.com")
    if err != nil {
        log.Printf("Explain query error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Query execution plan:")
    for rows.Next() {
        var plan string
        if err := rows.Scan(&plan); err != nil {
            continue
        }
        fmt.Printf("  %s\n", plan)
    }
}

// 数据库连接池监控
type DBMonitor struct {
    db *sql.DB
}

func NewDBMonitor(db *sql.DB) *DBMonitor {
    return &DBMonitor{db: db}
}

func (m *DBMonitor) StartMonitoring() {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            stats := m.db.Stats()
            fmt.Printf("DB Stats - Open: %d, InUse: %d, Idle: %d, WaitCount: %d, WaitDuration: %v\n",
                stats.OpenConnections, stats.InUse, stats.Idle,
                stats.WaitCount, stats.WaitDuration)
        }
    }()
}

func databaseMonitoring(db *sql.DB) {
    fmt.Println("\n=== 数据库监控 ===")
    
    monitor := NewDBMonitor(db)
    monitor.StartMonitoring()
    
    // 模拟数据库负载
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < 5; j++ {
                _, err := db.Exec(`SELECT 1`)
                if err != nil {
                    log.Printf("Query error: %v", err)
                    return
                }
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
    time.Sleep(1 * time.Second) // 等待监控输出
}

// 完整的数据库操作示例
func completeDatabaseExample() {
    fmt.Println("\n=== 完整数据库示例 ===")
    
    // 连接数据库（这里使用SQLite作为示例，因为它不需要外部服务）
    db, err := sql.Open("sqlite3", "./test.db")
    if err != nil {
        log.Printf("SQLite connection error: %v", err)
        return
    }
    defer db.Close()
    
    // 初始化数据库
    runMigrations(db)
    
    // 基本操作
    databaseOperations(db)
    
    // 预处理语句
    preparedStatements(db)
    
    // 事务处理
    transactionExample(db)
    
    // 连接池管理
    connectionPoolManagement(db)
    
    // 错误处理和重试
    errorHandlingWithRetry(db)
    
    // 批量操作
    bulkOperations(db)
    
    // 性能优化
    performanceOptimization(db)
    
    // 监控
    databaseMonitoring(db)
}

func main() {
    // 运行数据库操作示例
    basicDatabaseOperations()
    
    // 注意：以下示例需要实际的数据库服务
    // completeDatabaseExample()
    
    fmt.Println("Database examples completed")
}
```

### MySQL驱动使用

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    "github.com/go-sql-driver/mysql"
)

// MySQL连接配置
func mysqlConnectionConfig() {
    fmt.Println("=== MySQL连接配置 ===")
    
    // 方法1：使用DSN字符串
    db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local")
    if err != nil {
        log.Printf("MySQL connection error: %v", err)
        return
    }
    defer db.Close()
    
    // 方法2：使用Config结构体
    config := mysql.Config{
        User:                 "user",
        Passwd:               "password",
        Net:                  "tcp",
        Addr:                 "localhost:3306",
        DBName:               "dbname",
        AllowNativePasswords: true,
        ParseTime:            true,
        Loc:                  time.Local,
        Params: map[string]string{
            "charset": "utf8mb4",
        },
    }
    
    db2, err := sql.Open("mysql", config.FormatDSN())
    if err != nil {
        log.Printf("MySQL connection with config error: %v", err)
        return
    }
    defer db2.Close()
    
    fmt.Println("MySQL connections configured")
}

// MySQL特定功能
func mysqlSpecificFeatures(db *sql.DB) {
    fmt.Println("\n=== MySQL特定功能 ===")
    
    // 1. JSON字段操作
    createJSONTable := `
    CREATE TABLE IF NOT EXISTS user_profiles (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT,
        profile JSON,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err := db.Exec(createJSONTable)
    if err != nil {
        log.Printf("Create JSON table error: %v", err)
        return
    }
    
    // 插入JSON数据
    insertJSON := `INSERT INTO user_profiles (user_id, profile) VALUES (?, ?)`
    profileData := `{"name": "John", "age": 30, "preferences": {"theme": "dark", "notifications": true}}`
    _, err = db.Exec(insertJSON, 1, profileData)
    if err != nil {
        log.Printf("Insert JSON error: %v", err)
        return
    }
    
    // 查询JSON数据
    queryJSON := `SELECT id, user_id, profile->"$.name" as name, profile->"$.age" as age FROM user_profiles`
    rows, err := db.Query(queryJSON)
    if err != nil {
        log.Printf("Query JSON error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("JSON query results:")
    for rows.Next() {
        var id, userID int
        var name string
        var age interface{} // JSON值可能是null
        err := rows.Scan(&id, &userID, &name, &age)
        if err != nil {
            log.Printf("Scan JSON error: %v", err)
            continue
        }
        fmt.Printf("  ID: %d, UserID: %d, Name: %s, Age: %v\n", id, userID, name, age)
    }
    
    // 2. 存储过程
    createProcedure := `
    CREATE PROCEDURE GetUserCountByAge(IN minAge INT, OUT userCount INT)
    BEGIN
        SELECT COUNT(*) INTO userCount FROM users WHERE age >= minAge;
    END`
    
    _, err = db.Exec(createProcedure)
    if err != nil {
        // 存储过程可能已存在，忽略错误
        log.Printf("Create procedure warning: %v", err)
    }
    
    // 3. 事务隔离级别
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    
    // 设置事务隔离级别
    _, err = tx.Exec("SET TRANSACTION ISOLATION LEVEL READ COMMITTED")
    if err != nil {
        tx.Rollback()
        log.Printf("Set isolation level error: %v", err)
        return
    }
    
    tx.Commit()
    
    // 4. MySQL特定的SQL函数
    queryWithFunctions := `
    SELECT 
        id,
        name,
        email,
        age,
        DATE_FORMAT(created_at, '%Y-%m-%d %H:%i:%s') as formatted_date,
        IFNULL(age, 0) as safe_age,
        CASE 
            WHEN age < 18 THEN 'Minor'
            WHEN age < 65 THEN 'Adult'
            ELSE 'Senior'
        END as age_group
    FROM users
    ORDER BY created_at DESC
    LIMIT 10`
    
    rows, err = db.Query(queryWithFunctions)
    if err != nil {
        log.Printf("Query with functions error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Query with MySQL functions:")
    for rows.Next() {
        var id, age int
        var name, email, formattedDate, ageGroup string
        var safeAge sql.NullInt64
        err := rows.Scan(&id, &name, &email, &age, &formattedDate, &safeAge, &ageGroup)
        if err != nil {
            log.Printf("Scan with functions error: %v", err)
            continue
        }
        fmt.Printf("  %d: %s (%s) - Age: %d, Group: %s, Created: %s\n", 
            id, name, email, age, ageGroup, formattedDate)
    }
}

// MySQL连接池优化
func mysqlConnectionPoolOptimization(db *sql.DB) {
    fmt.Println("\n=== MySQL连接池优化 ===")
    
    // MySQL特定的连接池设置
    db.SetMaxOpenConns(100)           // 最大连接数
    db.SetMaxIdleConns(25)            // 最大空闲连接数
    db.SetConnMaxLifetime(30 * time.Minute)  // 连接最大生命周期
    db.SetConnMaxIdleTime(10 * time.Minute)  // 连接最大空闲时间
    
    // MySQL连接参数优化
    config := mysql.Config{
        User:      "user",
        Passwd:    "password",
        Net:       "tcp",
        Addr:      "localhost:3306",
        DBName:    "dbname",
        ParseTime: true,
        Params: map[string]string{
            "charset":   "utf8mb4",
            "collation": "utf8mb4_unicode_ci",
            "timeout":   "30s",
            "readTimeout": "30s",
            "writeTimeout": "30s",
            "interpolateParams": "true",  // 参数插值优化
        },
    }
    
    optimizedDB, err := sql.Open("mysql", config.FormatDSN())
    if err != nil {
        log.Printf("Optimized MySQL connection error: %v", err)
        return
    }
    defer optimizedDB.Close()
    
    fmt.Println("MySQL connection pool optimized")
}

// MySQL错误处理
func mysqlErrorHandling(db *sql.DB) {
    fmt.Println("\n=== MySQL错误处理 ===")
    
    // 检查特定MySQL错误
    _, err := db.Exec("INVALID SQL STATEMENT")
    if err != nil {
        if mysqlErr, ok := err.(*mysql.MySQLError); ok {
            fmt.Printf("MySQL error code: %d\n", mysqlErr.Number)
            fmt.Printf("MySQL error message: %s\n", mysqlErr.Message)
            
            // 根据错误码处理
            switch mysqlErr.Number {
            case 1062: // Duplicate entry
                fmt.Println("Duplicate entry error")
            case 1146: // Table doesn't exist
                fmt.Println("Table not found error")
            case 1045: // Access denied
                fmt.Println("Access denied error")
            default:
                fmt.Printf("Other MySQL error: %d\n", mysqlErr.Number)
            }
        } else {
            fmt.Printf("Non-MySQL error: %v\n", err)
        }
    }
    
    // 连接错误处理
    pingErr := db.Ping()
    if pingErr != nil {
        if mysqlErr, ok := pingErr.(*mysql.MySQLError); ok {
            fmt.Printf("Ping MySQL error: %d - %s\n", mysqlErr.Number, mysqlErr.Message)
        } else {
            fmt.Printf("Ping error: %v\n", pingErr)
        }
    }
}

// MySQL性能监控
func mysqlPerformanceMonitoring(db *sql.DB) {
    fmt.Println("\n=== MySQL性能监控 ===")
    
    // 查询慢查询日志设置
    rows, err := db.Query(`SHOW VARIABLES LIKE 'slow_query_log%'`)
    if err != nil {
        log.Printf("Show variables error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Slow query log settings:")
    for rows.Next() {
        var variable, value string
        err := rows.Scan(&variable, &value)
        if err != nil {
            continue
        }
        fmt.Printf("  %s: %s\n", variable, value)
    }
    
    // 查询连接状态
    rows, err = db.Query(`SHOW STATUS LIKE 'Threads%'`)
    if err != nil {
        log.Printf("Show status error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Connection status:")
    for rows.Next() {
        var variable, value string
        err := rows.Scan(&variable, &value)
        if err != nil {
            continue
        }
        fmt.Printf("  %s: %s\n", variable, value)
    }
    
    // 查询InnoDB状态
    rows, err = db.Query(`SHOW ENGINE INNODB STATUS`)
    if err != nil {
        log.Printf("Show engine status error: %v", err)
        return
    }
    defer rows.Close()
    
    if rows.Next() {
        var engine, status string
        var detail interface{}
        err := rows.Scan(&engine, &status, &detail)
        if err != nil {
            log.Printf("Scan engine status error: %v", err)
        } else {
            fmt.Printf("InnoDB engine status: %s\n", status)
        }
    }
}

// MySQL备份和恢复
func mysqlBackupRestore(db *sql.DB) {
    fmt.Println("\n=== MySQL备份和恢复 ===")
    
    // 创建备份表
    backupTable := `
    CREATE TABLE IF NOT EXISTS users_backup AS 
    SELECT * FROM users WHERE 1=0`
    
    _, err := db.Exec(backupTable)
    if err != nil {
        log.Printf("Create backup table error: %v", err)
        return
    }
    
    // 备份数据
    backupData := `INSERT INTO users_backup SELECT * FROM users`
    result, err := db.Exec(backupData)
    if err != nil {
        log.Printf("Backup data error: %v", err)
        return
    }
    
    rowsAffected, _ := result.RowsAffected()
    fmt.Printf("Backed up %d rows to users_backup\n", rowsAffected)
    
    // 验证备份
    var count int
    err = db.QueryRow(`SELECT COUNT(*) FROM users_backup`).Scan(&count)
    if err != nil {
        log.Printf("Count backup error: %v", err)
        return
    }
    fmt.Printf("Backup table contains %d rows\n", count)
}

// MySQL高级特性
func mysqlAdvancedFeatures(db *sql.DB) {
    fmt.Println("\n=== MySQL高级特性 ===")
    
    // 1. 分区表
    createPartitionedTable := `
    CREATE TABLE IF NOT EXISTS sales_data (
        id INT AUTO_INCREMENT,
        sale_date DATE,
        amount DECIMAL(10,2),
        region VARCHAR(50),
        PRIMARY KEY (id, sale_date)
    ) PARTITION BY RANGE (YEAR(sale_date)) (
        PARTITION p2020 VALUES LESS THAN (2021),
        PARTITION p2021 VALUES LESS THAN (2022),
        PARTITION p2022 VALUES LESS THAN (2023),
        PARTITION p_future VALUES LESS THAN MAXVALUE
    )`
    
    _, err := db.Exec(createPartitionedTable)
    if err != nil {
        log.Printf("Create partitioned table error: %v", err)
    } else {
        fmt.Println("Partitioned table created")
    }
    
    // 2. 视图
    createView := `
    CREATE OR REPLACE VIEW user_summary AS
    SELECT 
        COUNT(*) as total_users,
        AVG(age) as average_age,
        MIN(age) as youngest,
        MAX(age) as oldest
    FROM users`
    
    _, err = db.Exec(createView)
    if err != nil {
        log.Printf("Create view error: %v", err)
    } else {
        fmt.Println("View created")
        
        // 查询视图
        rows, err := db.Query(`SELECT * FROM user_summary`)
        if err != nil {
            log.Printf("Query view error: %v", err)
            return
        }
        defer rows.Close()
        
        if rows.Next() {
            var total, avg, min, max float64
            err := rows.Scan(&total, &avg, &min, &max)
            if err != nil {
                log.Printf("Scan view error: %v", err)
                return
            }
            fmt.Printf("User summary - Total: %.0f, Avg Age: %.1f, Min: %.0f, Max: %.0f\n", 
                total, avg, min, max)
        }
    }
    
    // 3. 触发器
    createTrigger := `
    CREATE TRIGGER update_user_timestamp 
    BEFORE UPDATE ON users
    FOR EACH ROW
    SET NEW.updated_at = CURRENT_TIMESTAMP`
    
    _, err = db.Exec(createTrigger)
    if err != nil {
        log.Printf("Create trigger warning: %v", err)
    } else {
        fmt.Println("Trigger created")
    }
    
    // 4. 事件调度器
    enableEventScheduler := `SET GLOBAL event_scheduler = ON`
    _, err = db.Exec(enableEventScheduler)
    if err != nil {
        log.Printf("Enable event scheduler error: %v", err)
    }
    
    createEvent := `
    CREATE EVENT IF NOT EXISTS cleanup_old_users
    ON SCHEDULE EVERY 1 DAY
    DO
    DELETE FROM users WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR)`
    
    _, err = db.Exec(createEvent)
    if err != nil {
        log.Printf("Create event warning: %v", err)
    } else {
        fmt.Println("Event created")
    }
}

func main() {
    // 运行MySQL示例
    mysqlConnectionConfig()
    
    // 以下示例需要实际的MySQL数据库连接
    // mysqlSpecificFeatures(db)
    // mysqlConnectionPoolOptimization(db)
    // mysqlErrorHandling(db)
    // mysqlPerformanceMonitoring(db)
    // mysqlBackupRestore(db)
    // mysqlAdvancedFeatures(db)
    
    fmt.Println("MySQL examples completed")
}
```

### PostgreSQL驱动使用

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    
    "github.com/lib/pq"
)

// PostgreSQL连接配置
func postgresConnectionConfig() {
    fmt.Println("=== PostgreSQL连接配置 ===")
    
    // 方法1：使用连接字符串
    db, err := sql.Open("postgres", "user=username password=password dbname=testdb sslmode=disable")
    if err != nil {
        log.Printf("PostgreSQL connection error: %v", err)
        return
    }
    defer db.Close()
    
    // 方法2：使用连接参数
    connStr := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        "localhost", 5432, "username", "password", "testdb", "disable")
    
    db2, err := sql.Open("postgres", connStr)
    if err != nil {
        log.Printf("PostgreSQL connection with params error: %v", err)
        return
    }
    defer db2.Close()
    
    // 方法3：使用pq连接参数
    complexConnStr := "postgres://username:password@localhost:5432/testdb?sslmode=disable&connect_timeout=10"
    db3, err := sql.Open("postgres", complexConnStr)
    if err != nil {
        log.Printf("PostgreSQL complex connection error: %v", err)
        return
    }
    defer db3.Close()
    
    fmt.Println("PostgreSQL connections configured")
}

// PostgreSQL特定功能
func postgresSpecificFeatures(db *sql.DB) {
    fmt.Println("\n=== PostgreSQL特定功能 ===")
    
    // 1. JSONB字段操作
    createJSONTable := `
    CREATE TABLE IF NOT EXISTS user_profiles (
        id SERIAL PRIMARY KEY,
        user_id INTEGER,
        profile JSONB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err := db.Exec(createJSONTable)
    if err != nil {
        log.Printf("Create JSONB table error: %v", err)
        return
    }
    
    // 插入JSONB数据
    insertJSON := `INSERT INTO user_profiles (user_id, profile) VALUES ($1, $2)`
    profileData := `{"name": "John", "age": 30, "preferences": {"theme": "dark", "notifications": true}}`
    _, err = db.Exec(insertJSON, 1, profileData)
    if err != nil {
        log.Printf("Insert JSONB error: %v", err)
        return
    }
    
    // 查询JSONB数据
    queryJSON := `SELECT id, user_id, profile->>'name' as name, profile->>'age' as age FROM user_profiles`
    rows, err := db.Query(queryJSON)
    if err != nil {
        log.Printf("Query JSONB error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("JSONB query results:")
    for rows.Next() {
        var id, userID int
        var name string
        var age interface{}
        err := rows.Scan(&id, &userID, &name, &age)
        if err != nil {
            log.Printf("Scan JSONB error: %v", err)
            continue
        }
        fmt.Printf("  ID: %d, UserID: %d, Name: %s, Age: %v\n", id, userID, name, age)
    }
    
    // 2. 数组字段
    createArrayTable := `
    CREATE TABLE IF NOT EXISTS products (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100),
        tags TEXT[],
        prices DECIMAL(10,2)[],
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err = db.Exec(createArrayTable)
    if err != nil {
        log.Printf("Create array table error: %v", err)
        return
    }
    
    // 插入数组数据
    insertArray := `INSERT INTO products (name, tags, prices) VALUES ($1, $2, $3)`
    _, err = db.Exec(insertArray, "Laptop", pq.Array([]string{"electronics", "computer", "laptop"}), 
        pq.Array([]float64{999.99, 899.99, 799.99}))
    if err != nil {
        log.Printf("Insert array error: %v", err)
        return
    }
    
    // 查询数组数据
    queryArray := `SELECT name, tags, prices FROM products WHERE $1 = ANY(tags)`
    rows, err = db.Query(queryArray, "computer")
    if err != nil {
        log.Printf("Query array error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Array query results:")
    for rows.Next() {
        var name string
        var tags []string
        var prices []float64
        err := rows.Scan(&name, pq.Array(&tags), pq.Array(&prices))
        if err != nil {
            log.Printf("Scan array error: %v", err)
            continue
        }
        fmt.Printf("  Product: %s, Tags: %v, Prices: %v\n", name, tags, prices)
    }
    
    // 3. 枚举类型
    createEnum := `CREATE TYPE user_status AS ENUM ('active', 'inactive', 'suspended')`
    _, err = db.Exec(createEnum)
    if err != nil {
        log.Printf("Create enum warning: %v", err) // 可能已存在
    }
    
    createUserTable := `
    CREATE TABLE IF NOT EXISTS users_with_status (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100),
        email VARCHAR(100) UNIQUE,
        status user_status DEFAULT 'active',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err = db.Exec(createUserTable)
    if err != nil {
        log.Printf("Create users with status table error: %v", err)
        return
    }
    
    // 插入枚举数据
    insertEnum := `INSERT INTO users_with_status (name, email, status) VALUES ($1, $2, $3)`
    _, err = db.Exec(insertEnum, "Alice", "alice@example.com", "active")
    if err != nil {
        log.Printf("Insert enum error: %v", err)
        return
    }
    
    // 4. 窗口函数
    windowQuery := `
    SELECT 
        name,
        email,
        ROW_NUMBER() OVER (ORDER BY created_at) as row_num,
        RANK() OVER (PARTITION BY status ORDER BY created_at) as rank_in_status,
        LAG(name) OVER (ORDER BY created_at) as previous_user,
        LEAD(name) OVER (ORDER BY created_at) as next_user
    FROM users_with_status
    ORDER BY created_at`
    
    rows, err = db.Query(windowQuery)
    if err != nil {
        log.Printf("Window function query error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Window function results:")
    for rows.Next() {
        var name, email, prevUser, nextUser string
        var rowNum, rankInStatus int
        err := rows.Scan(&name, &email, &rowNum, &rankInStatus, &prevUser, &nextUser)
        if err != nil {
            log.Printf("Scan window function error: %v", err)
            continue
        }
        fmt.Printf("  %s (%s) - Row: %d, Rank: %d, Prev: %s, Next: %s\n", 
            name, email, rowNum, rankInStatus, prevUser, nextUser)
    }
}

// PostgreSQL连接池优化
func postgresConnectionPoolOptimization(db *sql.DB) {
    fmt.Println("\n=== PostgreSQL连接池优化 ===")
    
    // PostgreSQL特定的连接池设置
    db.SetMaxOpenConns(100)
    db.SetMaxIdleConns(25)
    db.SetConnMaxLifetime(30 * time.Minute)
    db.SetConnMaxIdleTime(10 * time.Minute)
    
    // PostgreSQL连接参数优化
    connStr := "postgres://username:password@localhost:5432/testdb?" +
        "sslmode=disable&connect_timeout=10&statement_timeout=30000" +
        "&idle_in_transaction_session_timeout=60000"
    
    optimizedDB, err := sql.Open("postgres", connStr)
    if err != nil {
        log.Printf("Optimized PostgreSQL connection error: %v", err)
        return
    }
    defer optimizedDB.Close()
    
    fmt.Println("PostgreSQL connection pool optimized")
}

// PostgreSQL错误处理
func postgresErrorHandling(db *sql.DB) {
    fmt.Println("\n=== PostgreSQL错误处理 ===")
    
    // 检查特定PostgreSQL错误
    _, err := db.Exec("INVALID SQL STATEMENT")
    if err != nil {
        if pqErr, ok := err.(*pq.Error); ok {
            fmt.Printf("PostgreSQL error code: %s\n", pqErr.Code)
            fmt.Printf("PostgreSQL error message: %s\n", pqErr.Message)
            fmt.Printf("PostgreSQL error detail: %s\n", pqErr.Detail)
            fmt.Printf("PostgreSQL error hint: %s\n", pqErr.Hint)
            
            // 根据错误码处理
            switch pqErr.Code {
            case "23505": // Unique violation
                fmt.Println("Unique constraint violation")
            case "42P01": // Undefined table
                fmt.Println("Table does not exist")
            case "28000": // Invalid authorization
                fmt.Println("Invalid authorization")
            default:
                fmt.Printf("Other PostgreSQL error: %s\n", pqErr.Code)
            }
        } else {
            fmt.Printf("Non-PostgreSQL error: %v\n", err)
        }
    }
    
    // 连接错误处理
    pingErr := db.Ping()
    if pingErr != nil {
        if pqErr, ok := pingErr.(*pq.Error); ok {
            fmt.Printf("Ping PostgreSQL error: %s - %s\n", pqErr.Code, pqErr.Message)
        } else {
            fmt.Printf("Ping error: %v\n", pingErr)
        }
    }
}

// PostgreSQL性能监控
func postgresPerformanceMonitoring(db *sql.DB) {
    fmt.Println("\n=== PostgreSQL性能监控 ===")
    
    // 查询慢查询日志设置
    rows, err := db.Query(`SHOW log_min_duration_statement`)
    if err != nil {
        log.Printf("Show log_min_duration_statement error: %v", err)
        return
    }
    defer rows.Close()
    
    if rows.Next() {
        var value string
        err := rows.Scan(&value)
        if err != nil {
            log.Printf("Scan log_min_duration_statement error: %v", err)
            return
        }
        fmt.Printf("Log min duration statement: %s\n", value)
    }
    
    // 查询连接统计
    rows, err = db.Query(`SELECT count(*) FROM pg_stat_activity`)
    if err != nil {
        log.Printf("Query pg_stat_activity error: %v", err)
        return
    }
    defer rows.Close()
    
    if rows.Next() {
        var activeConnections int
        err := rows.Scan(&activeConnections)
        if err != nil {
            log.Printf("Scan active connections error: %v", err)
            return
        }
        fmt.Printf("Active connections: %d\n", activeConnections)
    }
    
    // 查询表统计信息
    rows, err = db.Query(`
        SELECT 
            schemaname,
            tablename,
            seq_scan,
            seq_tup_read,
            idx_scan,
            idx_tup_fetch
        FROM pg_stat_user_tables 
        ORDER BY seq_scan DESC 
        LIMIT 5`)
    if err != nil {
        log.Printf("Query table stats error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Table statistics (top 5 by sequential scans):")
    for rows.Next() {
        var schema, table string
        var seqScan, seqRead, idxScan, idxFetch int64
        err := rows.Scan(&schema, &table, &seqScan, &seqRead, &idxScan, &idxFetch)
        if err != nil {
            log.Printf("Scan table stats error: %v", err)
            continue
        }
        fmt.Printf("  %s.%s - Seq: %d/%d, Idx: %d/%d\n", 
            schema, table, seqScan, seqRead, idxScan, idxFetch)
    }
}

// PostgreSQL备份和恢复
func postgresBackupRestore(db *sql.DB) {
    fmt.Println("\n=== PostgreSQL备份和恢复 ===")
    
    // 创建备份表
    backupTable := `
    CREATE TABLE IF NOT EXISTS users_backup AS 
    SELECT * FROM users WHERE FALSE`
    
    _, err := db.Exec(backupTable)
    if err != nil {
        log.Printf("Create backup table error: %v", err)
        return
    }
    
    // 备份数据
    backupData := `INSERT INTO users_backup SELECT * FROM users`
    result, err := db.Exec(backupData)
    if err != nil {
        log.Printf("Backup data error: %v", err)
        return
    }
    
    rowsAffected, _ := result.RowsAffected()
    fmt.Printf("Backed up %d rows to users_backup\n", rowsAffected)
    
    // 验证备份
    var count int
    err = db.QueryRow(`SELECT COUNT(*) FROM users_backup`).Scan(&count)
    if err != nil {
        log.Printf("Count backup error: %v", err)
        return
    }
    fmt.Printf("Backup table contains %d rows\n", count)
}

// PostgreSQL高级特性
func postgresAdvancedFeatures(db *sql.DB) {
    fmt.Println("\n=== PostgreSQL高级特性 ===")
    
    // 1. 分区表
    createPartitionedTable := `
    CREATE TABLE IF NOT EXISTS sales_data (
        id SERIAL,
        sale_date DATE NOT NULL,
        amount DECIMAL(10,2),
        region VARCHAR(50)
    ) PARTITION BY RANGE (sale_date)`
    
    _, err := db.Exec(createPartitionedTable)
    if err != nil {
        log.Printf("Create partitioned table error: %v", err)
    } else {
        fmt.Println("Partitioned table created")
    }
    
    // 2. 物化视图
    createMaterializedView := `
    CREATE MATERIALIZED VIEW IF NOT EXISTS user_statistics AS
    SELECT 
        COUNT(*) as total_users,
        AVG(age) as average_age,
        MIN(age) as youngest,
        MAX(age) as oldest
    FROM users`
    
    _, err = db.Exec(createMaterializedView)
    if err != nil {
        log.Printf("Create materialized view error: %v", err)
    } else {
        fmt.Println("Materialized view created")
        
        // 刷新物化视图
        _, err = db.Exec(`REFRESH MATERIALIZED VIEW user_statistics`)
        if err != nil {
            log.Printf("Refresh materialized view error: %v", err)
        } else {
            fmt.Println("Materialized view refreshed")
        }
    }
    
    // 3. 全文搜索
    createSearchTable := `
    CREATE TABLE IF NOT EXISTS articles (
        id SERIAL PRIMARY KEY,
        title VARCHAR(200),
        content TEXT,
        search_vector TSVECTOR
    )`
    
    _, err = db.Exec(createSearchTable)
    if err != nil {
        log.Printf("Create search table error: %v", err)
        return
    }
    
    // 创建全文搜索索引
    createSearchIndex := `
    CREATE INDEX IF NOT EXISTS idx_articles_search ON articles 
    USING GIN(to_tsvector('english', title || ' ' || content))`
    
    _, err = db.Exec(createSearchIndex)
    if err != nil {
        log.Printf("Create search index error: %v", err)
    } else {
        fmt.Println("Full-text search index created")
    }
    
    // 4. 存储过程
    createFunction := `
    CREATE OR REPLACE FUNCTION get_user_count_by_age(min_age INTEGER)
    RETURNS INTEGER AS $$
    DECLARE
        user_count INTEGER;
    BEGIN
        SELECT COUNT(*) INTO user_count FROM users WHERE age >= min_age;
        RETURN user_count;
    END;
    $$ LANGUAGE plpgsql`
    
    _, err = db.Exec(createFunction)
    if err != nil {
        log.Printf("Create function error: %v", err)
    } else {
        fmt.Println("Function created")
        
        // 调用函数
        var count int
        err = db.QueryRow(`SELECT get_user_count_by_age($1)`, 18).Scan(&count)
        if err != nil {
            log.Printf("Call function error: %v", err)
        } else {
            fmt.Printf("Users aged 18+: %d\n", count)
        }
    }
}

func main() {
    // 运行PostgreSQL示例
    postgresConnectionConfig()
    
    // 以下示例需要实际的PostgreSQL数据库连接
    // postgresSpecificFeatures(db)
    // postgresConnectionPoolOptimization(db)
    // postgresErrorHandling(db)
    // postgresPerformanceMonitoring(db)
    // postgresBackupRestore(db)
    // postgresAdvancedFeatures(db)
    
    fmt.Println("PostgreSQL examples completed")
}
```

### 连接池管理

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "sync"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
)

// 通用连接池管理器
type ConnectionPoolManager struct {
    db            *sql.DB
    maxOpenConns  int
    maxIdleConns  int
    maxLifetime   time.Duration
    maxIdleTime   time.Duration
    stats         *PoolStats
    statsMutex    sync.RWMutex
}

type PoolStats struct {
    Created     int64
    Active      int64
    Idle        int64
    Requests    int64
    Errors      int64
    AvgWaitTime time.Duration
}

func NewConnectionPoolManager(driver, dataSource string) (*ConnectionPoolManager, error) {
    db, err := sql.Open(driver, dataSource)
    if err != nil {
        return nil, err
    }
    
    manager := &ConnectionPoolManager{
        db:          db,
        stats:       &PoolStats{},
        maxOpenConns: 25,
        maxIdleConns: 25,
        maxLifetime:  30 * time.Minute,
        maxIdleTime:  10 * time.Minute,
    }
    
    manager.configurePool()
    
    return manager, nil
}

func (pm *ConnectionPoolManager) configurePool() {
    pm.db.SetMaxOpenConns(pm.maxOpenConns)
    pm.db.SetMaxIdleConns(pm.maxIdleConns)
    pm.db.SetConnMaxLifetime(pm.maxLifetime)
    pm.db.SetConnMaxIdleTime(pm.maxIdleTime)
}

func (pm *ConnectionPoolManager) GetDB() *sql.DB {
    return pm.db
}

func (pm *ConnectionPoolManager) GetStats() *PoolStats {
    pm.statsMutex.RLock()
    defer pm.statsMutex.RUnlock()
    
    return &PoolStats{
        Created:     pm.stats.Created,
        Active:      pm.stats.Active,
        Idle:        pm.stats.Idle,
        Requests:    pm.stats.Requests,
        Errors:      pm.stats.Errors,
        AvgWaitTime: pm.stats.AvgWaitTime,
    }
}

func (pm *ConnectionPoolManager) StartMonitoring() {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            stats := pm.db.Stats()
            fmt.Printf("Pool Stats - Open: %d, InUse: %d, Idle: %d, WaitCount: %d, WaitDuration: %v\n",
                stats.OpenConnections, stats.InUse, stats.Idle,
                stats.WaitCount, stats.WaitDuration)
        }
    }()
}

func (pm *ConnectionPoolManager) Close() error {
    return pm.db.Close()
}

// 连接池配置示例
func connectionPoolConfiguration() {
    fmt.Println("=== 连接池配置示例 ===")
    
    // MySQL连接池配置
    mysqlConfig := "user:password@tcp(localhost:3306)/dbname?charset=utf8mb4&parseTime=True"
    mysqlPool, err := NewConnectionPoolManager("mysql", mysqlConfig)
    if err != nil {
        log.Printf("MySQL pool creation error: %v", err)
    } else {
        defer mysqlPool.Close()
        fmt.Println("MySQL connection pool configured")
        mysqlPool.StartMonitoring()
    }
    
    // PostgreSQL连接池配置
    postgresConfig := "postgres://user:password@localhost:5432/dbname?sslmode=disable"
    postgresPool, err := NewConnectionPoolManager("postgres", postgresConfig)
    if err != nil {
        log.Printf("PostgreSQL pool creation error: %v", err)
    } else {
        defer postgresPool.Close()
        fmt.Println("PostgreSQL connection pool configured")
        postgresPool.StartMonitoring()
    }
}

// 连接池性能测试
func connectionPoolPerformanceTest(db *sql.DB) {
    fmt.Println("\n=== 连接池性能测试 ===")
    
    // 设置连接池参数
    db.SetMaxOpenConns(50)
    db.SetMaxIdleConns(25)
    db.SetConnMaxLifetime(30 * time.Minute)
    
    // 并发测试
    const numWorkers = 100
    const numRequests = 1000
    
    var wg sync.WaitGroup
    start := time.Now()
    
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            
            for j := 0; j < numRequests/numWorkers; j++ {
                // 执行简单的查询
                var result int
                err := db.QueryRow("SELECT 1").Scan(&result)
                if err != nil {
                    log.Printf("Worker %d query error: %v", workerID, err)
                    continue
                }
            }
        }(i)
    }
    
    wg.Wait()
    duration := time.Since(start)
    
    fmt.Printf("Completed %d requests with %d workers in %v\n", 
        numRequests, numWorkers, duration)
    fmt.Printf("Average time per request: %v\n", duration/time.Duration(numRequests))
    
    // 显示最终连接池状态
    stats := db.Stats()
    fmt.Printf("Final pool stats - Open: %d, InUse: %d, Idle: %d\n",
        stats.OpenConnections, stats.InUse, stats.Idle)
}

// 智能连接池管理
type SmartConnectionPool struct {
    db            *sql.DB
    minConns      int
    maxConns      int
    currentConns  int
    idleConns     chan *sql.Conn
    mutex         sync.Mutex
    closed        bool
    stats         *SmartPoolStats
    statsMutex    sync.RWMutex
}

type SmartPoolStats struct {
    Created     int64
    Active      int64
    Idle        int64
    Requests    int64
    Errors      int64
    AvgWaitTime time.Duration
}

func NewSmartConnectionPool(driver, dataSource string, minConns, maxConns int) (*SmartConnectionPool, error) {
    db, err := sql.Open(driver, dataSource)
    if err != nil {
        return nil, err
    }
    
    pool := &SmartConnectionPool{
        db:        db,
        minConns:  minConns,
        maxConns:  maxConns,
        idleConns: make(chan *sql.Conn, maxConns),
        stats:     &SmartPoolStats{},
    }
    
    // 预创建最小连接数
    go pool.preCreateConnections()
    
    return pool, nil
}

func (sp *SmartConnectionPool) preCreateConnections() {
    for i := 0; i < sp.minConns; i++ {
        conn, err := sp.db.Conn(context.Background())
        if err == nil {
            select {
            case sp.idleConns <- conn:
                sp.mutex.Lock()
                sp.currentConns++
                sp.mutex.Unlock()
            default:
                conn.Close()
            }
        }
    }
}

func (sp *SmartConnectionPool) Get() (*sql.Conn, error) {
    sp.statsMutex.Lock()
    sp.stats.Requests++
    sp.statsMutex.Unlock()
    
    sp.mutex.Lock()
    if sp.closed {
        sp.mutex.Unlock()
        return nil, fmt.Errorf("pool closed")
    }
    sp.mutex.Unlock()
    
    select {
    case conn := <-sp.idleConns:
        sp.statsMutex.Lock()
        sp.stats.Active++
        sp.stats.Idle--
        sp.statsMutex.Unlock()
        return conn, nil
    default:
        // 检查是否可以创建新连接
        sp.mutex.Lock()
        if sp.currentConns < sp.maxConns {
            sp.currentConns++
            sp.mutex.Unlock()
            
            conn, err := sp.db.Conn(context.Background())
            if err != nil {
                sp.mutex.Lock()
                sp.currentConns--
                sp.mutex.Unlock()
                
                sp.statsMutex.Lock()
                sp.stats.Errors++
                sp.statsMutex.Unlock()
                
                return nil, err
            }
            
            sp.statsMutex.Lock()
            sp.stats.Active++
            sp.stats.Created++
            sp.statsMutex.Unlock()
            
            return conn, nil
        }
        sp.mutex.Unlock()
        
        // 等待空闲连接
        select {
        case conn := <-sp.idleConns:
            sp.statsMutex.Lock()
            sp.stats.Active++
            sp.stats.Idle--
            sp.statsMutex.Unlock()
            return conn, nil
        case <-time.After(30 * time.Second):
            sp.statsMutex.Lock()
            sp.stats.Errors++
            sp.statsMutex.Unlock()
            return nil, fmt.Errorf("connection timeout")
        }
    }
}

func (sp *SmartConnectionPool) Put(conn *sql.Conn) {
    sp.mutex.Lock()
    defer sp.mutex.Unlock()
    
    if sp.closed {
        conn.Close()
        sp.currentConns--
        return
    }
    
    select {
    case sp.idleConns <- conn:
        sp.statsMutex.Lock()
        sp.stats.Active--
        sp.stats.Idle++
        sp.statsMutex.Unlock()
    default:
        // 池已满，关闭连接
        conn.Close()
        sp.currentConns--
        sp.statsMutex.Lock()
        sp.stats.Active--
        sp.statsMutex.Unlock()
    }
}

func (sp *SmartConnectionPool) Close() {
    sp.mutex.Lock()
    defer sp.mutex.Unlock()
    
    if sp.closed {
        return
    }
    
    sp.closed = true
    close(sp.idleConns)
    
    // 关闭所有连接
    for conn := range sp.idleConns {
        conn.Close()
    }
    sp.currentConns = 0
}

func smartConnectionPoolExample() {
    fmt.Println("\n=== 智能连接池示例 ===")
    
    // 这个示例需要实际的数据库连接
    /*
    pool, err := NewSmartConnectionPool("mysql", 
        "user:password@tcp(localhost:3306)/dbname", 5, 20)
    if err != nil {
        log.Printf("Smart pool creation error: %v", err)
        return
    }
    defer pool.Close()
    
    // 并发使用智能连接池
    var wg sync.WaitGroup
    for i := 0; i < 30; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            conn, err := pool.Get()
            if err != nil {
                log.Printf("Get connection %d error: %v", id, err)
                return
            }
            
            // 使用连接执行查询
            var result int
            err = conn.QueryRowContext(context.Background(), "SELECT 1").Scan(&result)
            if err != nil {
                log.Printf("Query error: %v", err)
            }
            
            // 归还连接到池中
            pool.Put(conn)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("Smart connection pool example completed")
    */
    fmt.Println("Smart connection pool example (requires actual database)")
}

// 连接池健康检查
func connectionPoolHealthCheck(db *sql.DB) {
    fmt.Println("\n=== 连接池健康检查 ===")
    
    // 定期健康检查
    ticker := time.NewTicker(60 * time.Second)
    defer ticker.Stop()
    
    healthCheck := func() {
        // 检查数据库连接
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        
        err := db.PingContext(ctx)
        if err != nil {
            log.Printf("Database health check failed: %v", err)
            return
        }
        
        // 检查连接池状态
        stats := db.Stats()
        fmt.Printf("Health check - Open: %d, InUse: %d, Idle: %d\n",
            stats.OpenConnections, stats.InUse, stats.Idle)
        
        // 检查连接池压力
        if stats.WaitCount > 100 {
            log.Printf("High connection pool wait count: %d", stats.WaitCount)
        }
        
        if float64(stats.InUse)/float64(stats.OpenConnections) > 0.8 {
            log.Printf("High connection pool utilization: %.2f%%", 
                float64(stats.InUse)/float64(stats.OpenConnections)*100)
        }
    }
    
    // 立即执行一次健康检查
    healthCheck()
    
    // 定期执行健康检查
    go func() {
        for range ticker.C {
            healthCheck()
        }
    }()
    
    // 模拟运行一段时间
    time.Sleep(2 * time.Minute)
}

// 连接池监控和告警
type PoolMonitor struct {
    db      *sql.DB
    alerts  chan string
    quit    chan bool
}

func NewPoolMonitor(db *sql.DB) *PoolMonitor {
    return &PoolMonitor{
        db:     db,
        alerts: make(chan string, 100),
        quit:   make(chan bool),
    }
}

func (pm *PoolMonitor) Start() {
    go pm.monitorLoop()
    go pm.alertHandler()
}

func (pm *PoolMonitor) monitorLoop() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            pm.checkPoolHealth()
        case <-pm.quit:
            return
        }
    }
}

func (pm *PoolMonitor) checkPoolHealth() {
    stats := pm.db.Stats()
    
    // 检查各种健康指标
    if stats.WaitCount > 50 {
        pm.alerts <- fmt.Sprintf("High wait count: %d", stats.WaitCount)
    }
    
    if stats.WaitDuration > 10*time.Second {
        pm.alerts <- fmt.Sprintf("High wait duration: %v", stats.WaitDuration)
    }
    
    utilization := float64(stats.InUse) / float64(stats.MaxOpenConnections)
    if utilization > 0.9 {
        pm.alerts <- fmt.Sprintf("High utilization: %.2f%%", utilization*100)
    }
    
    if stats.OpenConnections < 5 {
        pm.alerts <- fmt.Sprintf("Low open connections: %d", stats.OpenConnections)
    }
}

func (pm *PoolMonitor) alertHandler() {
    for {
        select {
        case alert := <-pm.alerts:
            log.Printf("POOL ALERT: %s", alert)
            // 这里可以集成到告警系统
        case <-pm.quit:
            return
        }
    }
}

func (pm *PoolMonitor) Stop() {
    close(pm.quit)
}

func poolMonitoringExample() {
    fmt.Println("\n=== 连接池监控示例 ===")
    
    // 这个示例需要实际的数据库连接
    /*
    db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/dbname")
    if err != nil {
        log.Printf("Database connection error: %v", err)
        return
    }
    defer db.Close()
    
    monitor := NewPoolMonitor(db)
    monitor.Start()
    defer monitor.Stop()
    
    // 模拟数据库负载
    var wg sync.WaitGroup
    for i := 0; i < 50; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < 20; j++ {
                var result int
                err := db.QueryRow("SELECT 1").Scan(&result)
                if err != nil {
                    log.Printf("Query error: %v", err)
                    continue
                }
                time.Sleep(100 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
    time.Sleep(1 * time.Minute) // 等待监控运行
    */
    fmt.Println("Pool monitoring example (requires actual database)")
}

// 连接池最佳实践
func connectionPoolBestPractices() {
    fmt.Println("\n=== 连接池最佳实践 ===")
    
    fmt.Println("1. 合理设置连接池大小:")
    fmt.Println("   - MaxOpenConns: 根据应用并发量和数据库承受能力设置")
    fmt.Println("   - MaxIdleConns: 通常设置为MaxOpenConns的50-80%")
    fmt.Println("   - 避免设置过大的连接池，会消耗数据库资源")
    
    fmt.Println("\n2. 设置合适的超时时间:")
    fmt.Println("   - ConnMaxLifetime: 连接最大生命周期，建议15-30分钟")
    fmt.Println("   - ConnMaxIdleTime: 连接最大空闲时间，建议5-10分钟")
    
    fmt.Println("\n3. 监控连接池状态:")
    fmt.Println("   - 定期检查OpenConnections, InUse, Idle等指标")
    fmt.Println("   - 监控WaitCount和WaitDuration")
    fmt.Println("   - 设置告警阈值")
    
    fmt.Println("\n4. 错误处理和重试:")
    fmt.Println("   - 处理连接超时和数据库不可用错误")
    fmt.Println("   - 实现合理的重试机制")
    fmt.Println("   - 区分临时错误和永久错误")
    
    fmt.Println("\n5. 连接泄漏检测:")
    fmt.Println("   - 确保每次获取连接后都正确关闭")
    fmt.Println("   - 使用defer语句保证连接释放")
    fmt.Println("   - 监控长时间未释放的连接")
}

func main() {
    // 运行连接池示例
    connectionPoolConfiguration()
    
    // 以下示例需要实际的数据库连接
    // connectionPoolPerformanceTest(db)
    // smartConnectionPoolExample()
    // connectionPoolHealthCheck(db)
    // poolMonitoringExample()
    
    connectionPoolBestPractices()
    
    fmt.Println("Connection pool examples completed")
}
```

### 事务处理

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
)

// 基本事务处理
func basicTransactionExample(db *sql.DB) {
    fmt.Println("=== 基本事务处理 ===")
    
    // 开始事务
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    
    // 确保事务最终被提交或回滚
    defer func() {
        if err != nil {
            tx.Rollback()
            log.Printf("Transaction rolled back due to error: %v", err)
        } else {
            err = tx.Commit()
            if err != nil {
                log.Printf("Transaction commit error: %v", err)
            } else {
                fmt.Println("Transaction committed successfully")
            }
        }
    }()
    
    // 执行多个操作
    _, err = tx.Exec(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
        "Alice", "alice@example.com", 25)
    if err != nil {
        return
    }
    
    _, err = tx.Exec(`UPDATE users SET age = ? WHERE name = ?`, 26, "Alice")
    if err != nil {
        return
    }
    
    fmt.Println("Transaction operations completed")
}

// 带上下文的事务处理
func contextTransactionExample(db *sql.DB) {
    fmt.Println("\n=== 带上下文的事务处理 ===")
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    // 开始带上下文的事务
    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        log.Printf("Begin transaction with context error: %v", err)
        return
    }
    
    defer func() {
        if err != nil {
            tx.Rollback()
            log.Printf("Transaction rolled back: %v", err)
        } else {
            err = tx.Commit()
            if err != nil {
                log.Printf("Transaction commit error: %v", err)
            } else {
                fmt.Println("Transaction committed successfully")
            }
        }
    }()
    
    // 执行操作
    _, err = tx.ExecContext(ctx, 
        `INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
        "Bob", "bob@example.com", 30)
    if err != nil {
        return
    }
    
    fmt.Println("Context transaction completed")
}

// 事务隔离级别
func transactionIsolationLevels(db *sql.DB) {
    fmt.Println("\n=== 事务隔离级别 ===")
    
    // 读未提交 (Read Uncommitted)
    tx1, err := db.BeginTx(context.Background(), &sql.TxOptions{
        Isolation: sql.LevelReadUncommitted,
    })
    if err != nil {
        log.Printf("Begin read uncommitted transaction error: %v", err)
        return
    }
    defer tx1.Rollback()
    
    // 读已提交 (Read Committed)
    tx2, err := db.BeginTx(context.Background(), &sql.TxOptions{
        Isolation: sql.LevelReadCommitted,
    })
    if err != nil {
        log.Printf("Begin read committed transaction error: %v", err)
        return
    }
    defer tx2.Rollback()
    
    // 可重复读 (Repeatable Read)
    tx3, err := db.BeginTx(context.Background(), &sql.TxOptions{
        Isolation: sql.LevelRepeatableRead,
    })
    if err != nil {
        log.Printf("Begin repeatable read transaction error: %v", err)
        return
    }
    defer tx3.Rollback()
    
    // 可序列化 (Serializable)
    tx4, err := db.BeginTx(context.Background(), &sql.TxOptions{
        Isolation: sql.LevelSerializable,
    })
    if err != nil {
        log.Printf("Begin serializable transaction error: %v", err)
        return
    }
    defer tx4.Rollback()
    
    fmt.Println("Transaction isolation levels demonstrated")
}

// 嵌套事务模拟
func nestedTransactionExample(db *sql.DB) {
    fmt.Println("\n=== 嵌套事务模拟 ===")
    
    // Go的database/sql不直接支持嵌套事务
    // 但我们可以通过保存点来模拟
    tx, err := db.Begin()
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    defer tx.Rollback()
    
    // 创建保存点1
    _, err = tx.Exec("SAVEPOINT sp1")
    if err != nil {
        log.Printf("Create savepoint 1 error: %v", err)
        return
    }
    
    // 执行操作
    _, err = tx.Exec(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
        "Charlie", "charlie@example.com", 35)
    if err != nil {
        log.Printf("Insert error: %v", err)
        return
    }
    
    // 创建保存点2
    _, err = tx.Exec("SAVEPOINT sp2")
    if err != nil {
        log.Printf("Create savepoint 2 error: %v", err)
        return
    }
    
    // 执行更多操作
    _, err = tx.Exec(`UPDATE users SET age = ? WHERE name = ?`, 36, "Charlie")
    if err != nil {
        log.Printf("Update error: %v", err)
        return
    }
    
    // 回滚到保存点2
    _, err = tx.Exec("ROLLBACK TO SAVEPOINT sp2")
    if err != nil {
        log.Printf("Rollback to savepoint 2 error: %v", err)
        return
    }
    
    // 释放保存点2
    _, err = tx.Exec("RELEASE SAVEPOINT sp2")
    if err != nil {
        log.Printf("Release savepoint 2 error: %v", err)
        return
    }
    
    // 提交事务
    err = tx.Commit()
    if err != nil {
        log.Printf("Commit error: %v", err)
        return
    }
    
    fmt.Println("Nested transaction simulation completed")
}

// 事务重试机制
func transactionRetryExample(db *sql.DB) {
    fmt.Println("\n=== 事务重试机制 ===")
    
    maxRetries := 3
    var err error
    
    for i := 0; i < maxRetries; i++ {
        err = executeTransactionWithRetry(db)
        if err == nil {
            fmt.Printf("Transaction succeeded on attempt %d\n", i+1)
            return
        }
        
        fmt.Printf("Transaction failed on attempt %d: %v\n", i+1, err)
        
        // 检查是否是可重试的错误
        if !isRetryableError(err) {
            log.Printf("Non-retryable error, aborting")
            return
        }
        
        // 指数退避
        backoff := time.Duration(i+1) * time.Second
        fmt.Printf("Retrying in %v...\n", backoff)
        time.Sleep(backoff)
    }
    
    log.Printf("Transaction failed after %d retries: %v", maxRetries, err)
}

func executeTransactionWithRetry(db *sql.DB) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 执行业务逻辑
    _, err = tx.Exec(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
        "RetryUser", "retry@example.com", 25)
    if err != nil {
        return err
    }
    
    // 模拟可能失败的操作
    if time.Now().Unix()%2 == 0 {
        return fmt.Errorf("simulated transient error")
    }
    
    return tx.Commit()
}

func isRetryableError(err error) bool {
    // 这里应该根据具体的错误类型判断是否可重试
    // 例如：死锁、连接超时、临时网络错误等
    return true
}

// 分布式事务模拟
func distributedTransactionExample(db1, db2 *sql.DB) {
    fmt.Println("\n=== 分布式事务模拟 ===")
    
    // 在分布式系统中，真正的分布式事务需要使用两阶段提交(2PC)
    // 或者采用最终一致性方案
    
    // 模拟两阶段提交的第一阶段：准备阶段
    tx1, err := db1.Begin()
    if err != nil {
        log.Printf("Begin transaction on db1 error: %v", err)
        return
    }
    defer tx1.Rollback()
    
    tx2, err := db2.Begin()
    if err != nil {
        log.Printf("Begin transaction on db2 error: %v", err)
        return
    }
    defer tx2.Rollback()
    
    // 在两个数据库上执行操作
    _, err = tx1.Exec(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
        "DistributedUser", "distributed@example.com", 40)
    if err != nil {
        log.Printf("Insert on db1 error: %v", err)
        return
    }
    
    _, err = tx2.Exec(`INSERT INTO user_profiles (user_id, profile) VALUES (?, ?)`, 
        1, `{"source": "distributed"}`)
    if err != nil {
        log.Printf("Insert on db2 error: %v", err)
        return
    }
    
    // 第二阶段：提交阶段
    err = tx1.Commit()
    if err != nil {
        log.Printf("Commit on db1 error: %v", err)
        return
    }
    
    err = tx2.Commit()
    if err != nil {
        log.Printf("Commit on db2 error: %v", err)
        return
    }
    
    fmt.Println("Distributed transaction completed")
}

// 事务超时处理
func transactionTimeoutExample(db *sql.DB) {
    fmt.Println("\n=== 事务超时处理 ===")
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        log.Printf("Begin transaction error: %v", err)
        return
    }
    defer tx.Rollback()
    
    // 执行长时间运行的操作
    done := make(chan error, 1)
    go func() {
        _, err := tx.Exec(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`, 
            "TimeoutUser", "timeout@example.com", 45)
        done <- err
    }()
    
    select {
    case err := <-done:
        if err != nil {
            log.Printf("Transaction operation error: %v", err)
            return
        }
        fmt.Println("Transaction operation completed")
    case <-ctx.Done():
        log.Printf("Transaction timed out: %v", ctx.Err())
        return
    }
    
    // 提交事务
    err = tx.Commit()
    if err != nil {
        log.Printf("Commit error: %v", err)
        return
    }
    
    fmt.Println("Transaction with timeout handling completed")
}

// 事务监控和统计
type TransactionMonitor struct {
    stats map[string]*TransactionStats
    mutex sync.RWMutex
}

type TransactionStats struct {
    Committed   int64
    RolledBack  int64
    Errors      int64
    AvgDuration time.Duration
    MaxDuration time.Duration
}

func NewTransactionMonitor() *TransactionMonitor {
    return &TransactionMonitor{
        stats: make(map[string]*TransactionStats),
    }
}

func (tm *TransactionMonitor) RecordTransaction(name string, success bool, duration time.Duration, err error) {
    tm.mutex.Lock()
    defer tm.mutex.Unlock()
    
    if tm.stats[name] == nil {
        tm.stats[name] = &TransactionStats{}
    }
    
    stats := tm.stats[name]
    if success {
        stats.Committed++
    } else {
        stats.RolledBack++
        if err != nil {
            stats.Errors++
        }
    }
    
    // 更新平均持续时间
    totalDuration := stats.AvgDuration*time.Duration(stats.Committed+stats.RolledBack-1) + duration
    stats.AvgDuration = totalDuration / time.Duration(stats.Committed+stats.RolledBack)
    
    // 更新最大持续时间
    if duration > stats.MaxDuration {
        stats.MaxDuration = duration
    }
}

func (tm *TransactionMonitor) GetStats() map[string]*TransactionStats {
    tm.mutex.RLock()
    defer tm.mutex.RUnlock()
    
    result := make(map[string]*TransactionStats)
    for name, stats := range tm.stats {
        result[name] = &TransactionStats{
            Committed:   stats.Committed,
            RolledBack:  stats.RolledBack,
            Errors:      stats.Errors,
            AvgDuration: stats.AvgDuration,
            MaxDuration: stats.MaxDuration,
        }
    }
    return result
}

func transactionMonitoringExample(db *sql.DB) {
    fmt.Println("\n=== 事务监控示例 ===")
    
    monitor := NewTransactionMonitor()
    
    // 模拟多个事务
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            start := time.Now()
            success := false
            var txErr error
            
            tx, err := db.Begin()
            if err != nil {
                txErr = err
            } else {
                // 模拟业务操作
                _, err := tx.Exec(`SELECT 1`)
                if err != nil {
                    tx.Rollback()
                    txErr = err
                } else {
                    err = tx.Commit()
                    if err != nil {
                        txErr = err
                    } else {
                        success = true
                    }
                }
            }
            
            duration := time.Since(start)
            monitor.RecordTransaction("user_transaction", success, duration, txErr)
        }(i)
    }
    
    wg.Wait()
    
    // 显示统计信息
    stats := monitor.GetStats()
    for name, stat := range stats {
        fmt.Printf("Transaction %s - Committed: %d, RolledBack: %d, Errors: %d, AvgDuration: %v, MaxDuration: %v\n",
            name, stat.Committed, stat.RolledBack, stat.Errors, stat.AvgDuration, stat.MaxDuration)
    }
}

// 事务最佳实践
func transactionBestPractices() {
    fmt.Println("\n=== 事务最佳实践 ===")
    
    fmt.Println("1. 保持事务简短:")
    fmt.Println("   - 尽量减少事务中的操作数量")
    fmt.Println("   - 避免在事务中执行长时间运行的操作")
    fmt.Println("   - 快速获取锁，快速释放锁")
    
    fmt.Println("\n2. 合理设置超时:")
    fmt.Println("   - 使用上下文设置事务超时")
    fmt.Println("   - 避免无限期等待锁")
    fmt.Println("   - 根据业务需求设置合适的超时时间")
    
    fmt.Println("\n3. 正确处理错误:")
    fmt.Println("   - 使用defer确保事务最终被提交或回滚")
    fmt.Println("   - 区分可重试错误和不可重试错误")
    fmt.Println("   - 实现合理的重试机制")
    
    fmt.Println("\n4. 选择合适的隔离级别:")
    fmt.Println("   - 根据业务需求选择合适的隔离级别")
    fmt.Println("   - 避免不必要的高隔离级别")
    fmt.Println("   - 理解不同隔离级别的影响")
    
    fmt.Println("\n5. 监控事务性能:")
    fmt.Println("   - 监控事务的执行时间和成功率")
    fmt.Println("   - 监控死锁和超时情况")
    fmt.Println("   - 设置告警阈值")
    
    fmt.Println("\n6. 避免常见陷阱:")
    fmt.Println("   - 不要在循环中开启事务")
    fmt.Println("   - 避免在事务中进行用户交互")
    fmt.Println("   - 注意事务的原子性要求")
}

func main() {
    // 运行事务示例
    // 以下示例需要实际的数据库连接
    
    /*
    basicTransactionExample(db)
    contextTransactionExample(db)
    transactionIsolationLevels(db)
    nestedTransactionExample(db)
    transactionRetryExample(db)
    distributedTransactionExample(db1, db2)
    transactionTimeoutExample(db)
    transactionMonitoringExample(db)
    */
    
    transactionBestPractices()
    
    fmt.Println("Transaction examples completed")
}
```

### 预处理语句

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "sync"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
)

// 基本预处理语句
func basicPreparedStatementExample(db *sql.DB) {
    fmt.Println("=== 基本预处理语句 ===")
    
    // 准备插入语句
    stmt, err := db.Prepare(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`)
    if err != nil {
        log.Printf("Prepare insert statement error: %v", err)
        return
    }
    defer stmt.Close()
    
    // 使用预处理语句多次执行
    users := []struct {
        Name  string
        Email string
        Age   int
    }{
        {"Alice", "alice@example.com", 25},
        {"Bob", "bob@example.com", 30},
        {"Charlie", "charlie@example.com", 35},
    }
    
    for _, user := range users {
        result, err := stmt.Exec(user.Name, user.Email, user.Age)
        if err != nil {
            log.Printf("Execute prepared statement error: %v", err)
            continue
        }
        
        lastInsertID, _ := result.LastInsertId()
        fmt.Printf("Inserted user %s with ID: %d\n", user.Name, lastInsertID)
    }
    
    // 准备查询语句
    queryStmt, err := db.Prepare(`SELECT id, name, email, age FROM users WHERE age > ? ORDER BY age`)
    if err != nil {
        log.Printf("Prepare query statement error: %v", err)
        return
    }
    defer queryStmt.Close()
    
    // 执行查询
    rows, err := queryStmt.Query(25)
    if err != nil {
        log.Printf("Execute query statement error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Users older than 25:")
    for rows.Next() {
        var id, age int
        var name, email string
        err := rows.Scan(&id, &name, &email, &age)
        if err != nil {
            log.Printf("Scan row error: %v", err)
            continue
        }
        fmt.Printf("  ID: %d, Name: %s, Email: %s, Age: %d\n", id, name, email, age)
    }
}

// 预处理语句性能测试
func preparedStatementPerformanceTest(db *sql.DB) {
    fmt.Println("\n=== 预处理语句性能测试 ===")
    
    // 创建测试表
    _, err := db.Exec(`CREATE TABLE IF NOT EXISTS performance_test (
        id INTEGER PRIMARY KEY AUTO_INCREMENT,
        name VARCHAR(100),
        value INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`)
    if err != nil {
        log.Printf("Create test table error: %v", err)
        return
    }
    
    // 测试普通查询
    start := time.Now()
    for i := 0; i < 1000; i++ {
        _, err := db.Exec(`INSERT INTO performance_test (name, value) VALUES (?, ?)`, 
            fmt.Sprintf("User%d", i), i)
        if err != nil {
            log.Printf("Insert error: %v", err)
            return
        }
    }
    normalDuration := time.Since(start)
    
    // 清理数据
    _, err = db.Exec(`DELETE FROM performance_test`)
    if err != nil {
        log.Printf("Delete error: %v", err)
        return
    }
    
    // 测试预处理语句
    stmt, err := db.Prepare(`INSERT INTO performance_test (name, value) VALUES (?, ?)`)
    if err != nil {
        log.Printf("Prepare statement error: %v", err)
        return
    }
    defer stmt.Close()
    
    start = time.Now()
    for i := 0; i < 1000; i++ {
        _, err := stmt.Exec(fmt.Sprintf("User%d", i), i)
        if err != nil {
            log.Printf("Execute prepared statement error: %v", err)
            return
        }
    }
    preparedDuration := time.Since(start)
    
    fmt.Printf("Normal execution time: %v\n", normalDuration)
    fmt.Printf("Prepared statement time: %v\n", preparedDuration)
    fmt.Printf("Performance improvement: %v\n", normalDuration-preparedDuration)
}

// 预处理语句连接池管理
func preparedStatementPoolManagement(db *sql.DB) {
    fmt.Println("\n=== 预处理语句连接池管理 ===")
    
    // 创建预处理语句管理器
    type PreparedStatementManager struct {
        db    *sql.DB
        stmts map[string]*sql.Stmt
        mutex sync.RWMutex
    }
    
    manager := &PreparedStatementManager{
        db:    db,
        stmts: make(map[string]*sql.Stmt),
    }
    
    // 获取预处理语句
    getStatement := func(query string) (*sql.Stmt, error) {
        manager.mutex.RLock()
        stmt, exists := manager.stmts[query]
        manager.mutex.RUnlock()
        
        if exists {
            return stmt, nil
        }
        
        manager.mutex.Lock()
        defer manager.mutex.Unlock()
        
        // 双重检查
        if stmt, exists := manager.stmts[query]; exists {
            return stmt, nil
        }
        
        stmt, err := manager.db.Prepare(query)
        if err != nil {
            return nil, err
        }
        
        manager.stmts[query] = stmt
        return stmt, nil
    }
    
    // 使用管理器
    stmt, err := getStatement(`SELECT id, name, email FROM users WHERE age > ?`)
    if err != nil {
        log.Printf("Get statement error: %v", err)
        return
    }
    
    rows, err := stmt.Query(18)
    if err != nil {
        log.Printf("Query error: %v", err)
        return
    }
    defer rows.Close()
    
    fmt.Println("Query using prepared statement manager:")
    for rows.Next() {
        var id int
        var name, email string
        err := rows.Scan(&id, &name, &email)
        if err != nil {
            log.Printf("Scan error: %v", err)
            continue
        }
        fmt.Printf("  ID: %d, Name: %s, Email: %s\n", id, name, email)
    }
    
    // 清理预处理语句
    manager.mutex.Lock()
    for _, stmt := range manager.stmts {
        stmt.Close()
    }
    manager.stmts = make(map[string]*sql.Stmt)
    manager.mutex.Unlock()
}

// 预处理语句缓存
type PreparedStatementCache struct {
    db    *sql.DB
    cache map[string]*sql.Stmt
    mutex sync.RWMutex
    maxSize int
}

func NewPreparedStatementCache(db *sql.DB, maxSize int) *PreparedStatementCache {
    return &PreparedStatementCache{
        db:      db,
        cache:   make(map[string]*sql.Stmt),
        maxSize: maxSize,
    }
}

func (c *PreparedStatementCache) Get(query string) (*sql.Stmt, error) {
    c.mutex.RLock()
    stmt, exists := c.cache[query]
    c.mutex.RUnlock()
    
    if exists {
        return stmt, nil
    }
    
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    // 双重检查
    if stmt, exists := c.cache[query]; exists {
        return stmt, nil
    }
    
    // 如果缓存已满，移除最老的条目
    if len(c.cache) >= c.maxSize {
        for oldQuery, oldStmt := range c.cache {
            oldStmt.Close()
            delete(c.cache, oldQuery)
            break
        }
    }
    
    stmt, err := c.db.Prepare(query)
    if err != nil {
        return nil, err
    }
    
    c.cache[query] = stmt
    return stmt, nil
}

func (c *PreparedStatementCache) Close() {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    for _, stmt := range c.cache {
        stmt.Close()
    }
    c.cache = make(map[string]*sql.Stmt)
}

func preparedStatementCacheExample(db *sql.DB) {
    fmt.Println("\n=== 预处理语句缓存示例 ===")
    
    cache := NewPreparedStatementCache(db, 10)
    defer cache.Close()
    
    // 使用缓存执行多个查询
    queries := []string{
        `SELECT id, name FROM users WHERE age > ?`,
        `SELECT id, email FROM users WHERE name LIKE ?`,
        `SELECT COUNT(*) FROM users WHERE age BETWEEN ? AND ?`,
    }
    
    for i, query := range queries {
        stmt, err := cache.Get(query)
        if err != nil {
            log.Printf("Get statement %d error: %v", i, err)
            continue
        }
        
        fmt.Printf("Statement %d prepared and cached\n", i)
        
        // 执行语句（示例）
        switch i {
        case 0:
            rows, err := stmt.Query(18)
            if err != nil {
                log.Printf("Query 0 error: %v", err)
                continue
            }
            rows.Close()
        case 1:
            rows, err := stmt.Query("%Alice%")
            if err != nil {
                log.Printf("Query 1 error: %v", err)
                continue
            }
            rows.Close()
        case 2:
            var count int
            err := stmt.QueryRow(18, 65).Scan(&count)
            if err != nil {
                log.Printf("Query 2 error: %v", err)
                continue
            }
            fmt.Printf("Count: %d\n", count)
        }
    }
}

// 预处理语句并发安全
func preparedStatementConcurrencyExample(db *sql.DB) {
    fmt.Println("\n=== 预处理语句并发安全 ===")
    
    // 准备语句
    stmt, err := db.Prepare(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`)
    if err != nil {
        log.Printf("Prepare statement error: %v", err)
        return
    }
    defer stmt.Close()
    
    // 并发使用预处理语句
    var wg sync.WaitGroup
    for i := 0; i < 50; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            name := fmt.Sprintf("ConcurrentUser%d", id)
            email := fmt.Sprintf("concurrent%d@example.com", id)
            age := 20 + (id % 50)
            
            _, err := stmt.Exec(name, email, age)
            if err != nil {
                log.Printf("Concurrent insert error: %v", err)
                return
            }
            
            fmt.Printf("Inserted concurrent user %d\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("Concurrent prepared statement execution completed")
}

// 预处理语句错误处理
func preparedStatementErrorHandling(db *sql.DB) {
    fmt.Println("\n=== 预处理语句错误处理 ===")
    
    // 准备一个可能出错的语句
    stmt, err := db.Prepare(`INSERT INTO non_existent_table (name, email) VALUES (?, ?)`)
    if err != nil {
        log.Printf("Prepare error (expected): %v", err)
        // 这是预期的错误，因为表不存在
    } else {
        stmt.Close()
    }
    
    // 准备正确的语句
    stmt, err = db.Prepare(`INSERT INTO users (name, email, age) VALUES (?, ?, ?)`)
    if err != nil {
        log.Printf("Prepare correct statement error: %v", err)
        return
    }
    defer stmt.Close()
    
    // 执行时的错误处理
    _, err = stmt.Exec("TestUser", "invalid-email", 25)  // 假设email有唯一约束
    if err != nil {
        log.Printf("Execute error: %v", err)
        // 检查是否是约束违反错误
        if isConstraintViolation(err) {
            fmt.Println("Constraint violation detected")
        }
    }
}

func isConstraintViolation(err error) bool {
    // 根据具体的数据库驱动检查错误类型
    // 这里简化处理
    return err != nil
}

// 预处理语句性能监控
type PreparedStatementMonitor struct {
    stats map[string]*StatementStats
    mutex sync.RWMutex
}

type StatementStats struct {
    Prepared    int64
    Executed    int64
    Errors      int64
    AvgDuration time.Duration
    MaxDuration time.Duration
}

func NewPreparedStatementMonitor() *PreparedStatementMonitor {
    return &PreparedStatementMonitor{
        stats: make(map[string]*StatementStats),
    }
}

func (m *PreparedStatementMonitor) RecordPrepare(query string) {
    m.mutex.Lock()
    defer m.mutex.Unlock()
    
    if m.stats[query] == nil {
        m.stats[query] = &StatementStats{}
    }
    m.stats[query].Prepared++
}

func (m *PreparedStatementMonitor) RecordExecution(query string, duration time.Duration, err error) {
    m.mutex.Lock()
    defer m.mutex.Unlock()
    
    if m.stats[query] == nil {
        m.stats[query] = &StatementStats{}
    }
    
    stats := m.stats[query]
    stats.Executed++
    
    if err != nil {
        stats.Errors++
    }
    
    // 更新平均执行时间
    totalDuration := stats.AvgDuration*time.Duration(stats.Executed-1) + duration
    stats.AvgDuration = totalDuration / time.Duration(stats.Executed)
    
    // 更新最大执行时间
    if duration > stats.MaxDuration {
        stats.MaxDuration = duration
    }
}

func (m *PreparedStatementMonitor) GetStats() map[string]*StatementStats {
    m.mutex.RLock()
    defer m.mutex.RUnlock()
    
    result := make(map[string]*StatementStats)
    for query, stats := range m.stats {
        result[query] = &StatementStats{
            Prepared:    stats.Prepared,
            Executed:    stats.Executed,
            Errors:      stats.Errors,
            AvgDuration: stats.AvgDuration,
            MaxDuration: stats.MaxDuration,
        }
    }
    return result
}

func preparedStatementMonitoringExample(db *sql.DB) {
    fmt.Println("\n=== 预处理语句监控示例 ===")
    
    monitor := NewPreparedStatementMonitor()
    
    // 创建带监控的预处理语句包装器
    prepareWithMonitoring := func(query string) (*sql.Stmt, error) {
        start := time.Now()
        stmt, err := db.Prepare(query)
        duration := time.Since(start)
        
        monitor.RecordPrepare(query)
        monitor.RecordExecution(query, duration, err)
        
        return stmt, err
    }
    
    // 使用监控包装器
    stmt, err := prepareWithMonitoring(`SELECT id, name, email FROM users WHERE age > ?`)
    if err != nil {
        log.Printf("Prepare with monitoring error: %v", err)
        return
    }
    defer stmt.Close()
    
    // 执行多次查询进行监控
    for i := 0; i < 100; i++ {
        start := time.Now()
        rows, err := stmt.Query(18 + (i % 50))
        duration := time.Since(start)
        
        monitor.RecordExecution(`SELECT id, name, email FROM users WHERE age > ?`, duration, err)
        
        if err != nil {
            log.Printf("Query error: %v", err)
            continue
        }
        rows.Close()
    }
    
    // 显示监控统计
    stats := monitor.GetStats()
    for query, stat := range stats {
        fmt.Printf("Query: %s\n", query)
        fmt.Printf("  Prepared: %d, Executed: %d, Errors: %d\n", 
            stat.Prepared, stat.Executed, stat.Errors)
        fmt.Printf("  Avg Duration: %v, Max Duration: %v\n", 
            stat.AvgDuration, stat.MaxDuration)
    }
}

// 预处理语句最佳实践
func preparedStatementBestPractices() {
    fmt.Println("\n=== 预处理语句最佳实践 ===")
    
    fmt.Println("1. 何时使用预处理语句:")
    fmt.Println("   - 重复执行相同SQL语句时")
    fmt.Println("   - 需要防止SQL注入攻击时")
    fmt.Println("   - 处理大量数据插入/更新时")
    fmt.Println("   - 执行复杂查询时")
    
    fmt.Println("\n2. 性能优势:")
    fmt.Println("   - 减少SQL解析和编译开销")
    fmt.Println("   - 提高执行效率")
    fmt.Println("   - 减少网络传输")
    fmt.Println("   - 更好的资源利用")
    
    fmt.Println("\n3. 使用注意事项:")
    fmt.Println("   - 及时关闭预处理语句")
    fmt.Println("   - 合理管理预处理语句缓存")
    fmt.Println("   - 避免预处理语句过多占用资源")
    fmt.Println("   - 处理预处理语句错误")
    
    fmt.Println("\n4. 安全性:")
    fmt.Println("   - 使用参数化查询防止SQL注入")
    fmt.Println("   - 验证输入参数")
    fmt.Println("   - 限制查询复杂度")
    fmt.Println("   - 监控异常查询模式")
    
    fmt.Println("\n5. 监控和维护:")
    fmt.Println("   - 监控预处理语句性能")
    fmt.Println("   - 定期清理未使用的预处理语句")
    fmt.Println("   - 分析查询执行计划")
    fmt.Println("   - 优化热点查询")
}

func main() {
    // 运行预处理语句示例
    // 以下示例需要实际的数据库连接
    
    /*
    basicPreparedStatementExample(db)
    preparedStatementPerformanceTest(db)
    preparedStatementPoolManagement(db)
    preparedStatementCacheExample(db)
    preparedStatementConcurrencyExample(db)
    preparedStatementErrorHandling(db)
    preparedStatementMonitoringExample(db)
    */
    
    preparedStatementBestPractices()
    
    fmt.Println("Prepared statement examples completed")
}
```

### 数据库迁移工具

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "os"
    "sort"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
    _ "github.com/lib/pq"
)

// 迁移结构
type Migration struct {
    Version   int
    Name      string
    Up        string
    Down      string
    CreatedAt time.Time
}

// 迁移管理器
type MigrationManager struct {
    db        *sql.DB
    migrations []Migration
}

func NewMigrationManager(db *sql.DB) *MigrationManager {
    return &MigrationManager{
        db: db,
        migrations: []Migration{
            {
                Version: 1,
                Name:    "create_users_table",
                Up: `CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTO_INCREMENT,
                    name VARCHAR(100) NOT NULL,
                    email VARCHAR(100) UNIQUE NOT NULL,
                    age INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                )`,
                Down: `DROP TABLE IF EXISTS users`,
                CreatedAt: time.Now(),
            },
            {
                Version: 2,
                Name:    "create_posts_table",
                Up: `CREATE TABLE IF NOT EXISTS posts (
                    id INTEGER PRIMARY KEY AUTO_INCREMENT,
                    user_id INTEGER NOT NULL,
                    title VARCHAR(200) NOT NULL,
                    content TEXT,
                    published BOOLEAN DEFAULT FALSE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
                )`,
                Down: `DROP TABLE IF EXISTS posts`,
                CreatedAt: time.Now(),
            },
            {
                Version: 3,
                Name:    "add_user_indexes",
                Up: `CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
                     CREATE INDEX IF NOT EXISTS idx_users_age ON users(age);
                     CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
                     CREATE INDEX IF NOT EXISTS idx_posts_published ON posts(published)`,
                Down: `DROP INDEX IF EXISTS idx_users_email;
                       DROP INDEX IF EXISTS idx_users_age;
                       DROP INDEX IF EXISTS idx_posts_user_id;
                       DROP INDEX IF EXISTS idx_posts_published`,
                CreatedAt: time.Now(),
            },
            {
                Version: 4,
                Name:    "add_user_status",
                Up: `ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active';
                     CREATE INDEX IF NOT EXISTS idx_users_status ON users(status)`,
                Down: `DROP INDEX IF EXISTS idx_users_status;
                       ALTER TABLE users DROP COLUMN status`,
                CreatedAt: time.Now(),
            },
        },
    }
}

// 初始化迁移表
func (mm *MigrationManager) initMigrationTable() error {
    createTableSQL := `
    CREATE TABLE IF NOT EXISTS schema_migrations (
        version INTEGER PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
    
    _, err := mm.db.Exec(createTableSQL)
    return err
}

// 获取已应用的迁移版本
func (mm *MigrationManager) getAppliedMigrations() (map[int]bool, error) {
    applied := make(map[int]bool)
    
    rows, err := mm.db.Query(`SELECT version FROM schema_migrations ORDER BY version`)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    for rows.Next() {
        var version int
        if err := rows.Scan(&version); err != nil {
            return nil, err
        }
        applied[version] = true
    }
    
    return applied, rows.Err()
}

// 应用迁移
func (mm *MigrationManager) Migrate() error {
    if err := mm.initMigrationTable(); err != nil {
        return fmt.Errorf("init migration table error: %v", err)
    }
    
    applied, err := mm.getAppliedMigrations()
    if err != nil {
        return fmt.Errorf("get applied migrations error: %v", err)
    }
    
    // 按版本排序迁移
    sort.Slice(mm.migrations, func(i, j int) bool {
        return mm.migrations[i].Version < mm.migrations[j].Version
    })
    
    // 开始事务
    tx, err := mm.db.Begin()
    if err != nil {
        return fmt.Errorf("begin transaction error: %v", err)
    }
    defer tx.Rollback()
    
    fmt.Println("Starting database migration...")
    
    for _, migration := range mm.migrations {
        if applied[migration.Version] {
            continue
        }
        
        fmt.Printf("Applying migration %d: %s\n", migration.Version, migration.Name)
        
        // 执行迁移
        _, err := tx.Exec(migration.Up)
        if err != nil {
            return fmt.Errorf("apply migration %d error: %v", migration.Version, err)
        }
        
        // 记录迁移历史
        _, err = tx.Exec(`INSERT INTO schema_migrations (version, name) VALUES (?, ?)`,
            migration.Version, migration.Name)
        if err != nil {
            return fmt.Errorf("record migration %d error: %v", migration.Version, err)
        }
        
        fmt.Printf("Migration %d applied successfully\n", migration.Version)
    }
    
    // 提交事务
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("commit transaction error: %v", err)
    }
    
    fmt.Println("Database migration completed successfully")
    return nil
}

// 回滚迁移
func (mm *MigrationManager) Rollback(steps int) error {
    if steps <= 0 {
        return fmt.Errorf("steps must be positive")
    }
    
    applied, err := mm.getAppliedMigrations()
    if err != nil {
        return fmt.Errorf("get applied migrations error: %v", err)
    }
    
    // 获取要回滚的迁移版本
    var versions []int
    for version := range applied {
        versions = append(versions, version)
    }
    
    // 按版本降序排序
    sort.Sort(sort.Reverse(sort.IntSlice(versions)))
    
    if len(versions) < steps {
        steps = len(versions)
    }
    
    if steps == 0 {
        fmt.Println("No migrations to rollback")
        return nil
    }
    
    // 开始事务
    tx, err := mm.db.Begin()
    if err != nil {
        return fmt.Errorf("begin transaction error: %v", err)
    }
    defer tx.Rollback()
    
    fmt.Printf("Rolling back %d migration(s)...\n", steps)
    
    for i := 0; i < steps; i++ {
        version := versions[i]
        
        // 查找对应的迁移
        var migration *Migration
        for _, m := range mm.migrations {
            if m.Version == version {
                migration = &m
                break
            }
        }
        
        if migration == nil {
            return fmt.Errorf("migration %d not found", version)
        }
        
        fmt.Printf("Rolling back migration %d: %s\n", version, migration.Name)
        
        // 执行回滚
        _, err := tx.Exec(migration.Down)
        if err != nil {
            return fmt.Errorf("rollback migration %d error: %v", version, err)
        }
        
        // 从迁移历史中删除
        _, err = tx.Exec(`DELETE FROM schema_migrations WHERE version = ?`, version)
        if err != nil {
            return fmt.Errorf("delete migration record %d error: %v", version, err)
        }
        
        fmt.Printf("Migration %d rolled back successfully\n", version)
    }
    
    // 提交事务
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("commit transaction error: %v", err)
    }
    
    fmt.Println("Rollback completed successfully")
    return nil
}

// 显示迁移状态
func (mm *MigrationManager) Status() error {
    if err := mm.initMigrationTable(); err != nil {
        return fmt.Errorf("init migration table error: %v", err)
    }
    
    applied, err := mm.getAppliedMigrations()
    if err != nil {
        return fmt.Errorf("get applied migrations error: %v", err)
    }
    
    fmt.Println("Migration Status:")
    fmt.Println("==================")
    
    // 按版本排序
    sort.Slice(mm.migrations, func(i, j int) bool {
        return mm.migrations[i].Version < mm.migrations[j].Version
    })
    
    for _, migration := range mm.migrations {
        status := "Pending"
        if applied[migration.Version] {
            status = "Applied"
        }
        fmt.Printf("Version %d: %s (%s)\n", migration.Version, migration.Name, status)
    }
    
    return nil
}

// 创建新迁移
func (mm *MigrationManager) CreateMigration(name string) error {
    if len(mm.migrations) == 0 {
        return fmt.Errorf("no existing migrations")
    }
    
    // 获取下一个版本号
    nextVersion := mm.migrations[len(mm.migrations)-1].Version + 1
    
    // 创建迁移内容
    migrationContent := fmt.Sprintf(`package main

import (
    "database/sql"
    "fmt"
)

type Migration_%d struct{}

func (m *Migration_%d) Up(db *sql.DB) error {
    sql := `
+"`"+`
    // Add your migration SQL here
    ALTER TABLE your_table ADD COLUMN new_column VARCHAR(255);
`+"`"+`
    _, err := db.Exec(sql)
    if err != nil {
        return fmt.Errorf("migration %d up error: %%v", err)
    }
    return nil
}

func (m *Migration_%d) Down(db *sql.DB) error {
    sql := `
+"`"+`
    // Add your rollback SQL here
    ALTER TABLE your_table DROP COLUMN new_column;
`+"`"+`
    _, err := db.Exec(sql)
    if err != nil {
        return fmt.Errorf("migration %d down error: %%v", err)
    }
    return nil
}
`, nextVersion, nextVersion, nextVersion)
    
    // 写入文件
    filename := fmt.Sprintf("migration_%d_%s.go", nextVersion, name)
    err := os.WriteFile(filename, []byte(migrationContent), 0644)
    if err != nil {
        return fmt.Errorf("create migration file error: %v", err)
    }
    
    fmt.Printf("Created migration file: %s\n", filename)
    return nil
}

// 高级迁移管理器
type AdvancedMigrationManager struct {
    *MigrationManager
    logger *log.Logger
}

func NewAdvancedMigrationManager(db *sql.DB) *AdvancedMigrationManager {
    return &AdvancedMigrationManager{
        MigrationManager: NewMigrationManager(db),
        logger:          log.New(os.Stdout, "[MIGRATION] ", log.LstdFlags),
    }
}

// 带日志的迁移
func (amm *AdvancedMigrationManager) MigrateWithLogging() error {
    amm.logger.Println("Starting migration process")
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        amm.logger.Printf("Migration process completed in %v", duration)
    }()
    
    if err := amm.initMigrationTable(); err != nil {
        amm.logger.Printf("Init migration table error: %v", err)
        return err
    }
    
    applied, err := amm.getAppliedMigrations()
    if err != nil {
        amm.logger.Printf("Get applied migrations error: %v", err)
        return err
    }
    
    sort.Slice(amm.migrations, func(i, j int) bool {
        return amm.migrations[i].Version < amm.migrations[j].Version
    })
    
    tx, err := amm.db.Begin()
    if err != nil {
        amm.logger.Printf("Begin transaction error: %v", err)
        return err
    }
    defer tx.Rollback()
    
    appliedCount := 0
    for _, migration := range amm.migrations {
        if applied[migration.Version] {
            continue
        }
        
        amm.logger.Printf("Applying migration %d: %s", migration.Version, migration.Name)
        
        start := time.Now()
        _, err := tx.Exec(migration.Up)
        if err != nil {
            amm.logger.Printf("Migration %d failed after %v: %v", 
                migration.Version, time.Since(start), err)
            return fmt.Errorf("apply migration %d error: %v", migration.Version, err)
        }
        
        _, err = tx.Exec(`INSERT INTO schema_migrations (version, name) VALUES (?, ?)`,
            migration.Version, migration.Name)
        if err != nil {
            amm.logger.Printf("Record migration %d error: %v", migration.Version, err)
            return fmt.Errorf("record migration %d error: %v", migration.Version, err)
        }
        
        amm.logger.Printf("Migration %d applied successfully in %v", 
            migration.Version, time.Since(start))
        appliedCount++
    }
    
    if err := tx.Commit(); err != nil {
        amm.logger.Printf("Commit transaction error: %v", err)
        return err
    }
    
    amm.logger.Printf("Migration completed: %d migrations applied", appliedCount)
    return nil
}

// 迁移验证
func (amm *AdvancedMigrationManager) Validate() error {
    amm.logger.Println("Validating migrations")
    
    // 检查迁移版本是否连续
    sort.Slice(amm.migrations, func(i, j int) bool {
        return amm.migrations[i].Version < amm.migrations[j].Version
    })
    
    for i := 1; i < len(amm.migrations); i++ {
        if amm.migrations[i].Version != amm.migrations[i-1].Version+1 {
            return fmt.Errorf("migration versions are not sequential: %d -> %d", 
                amm.migrations[i-1].Version, amm.migrations[i].Version)
        }
    }
    
    // 检查是否有重复的版本号
    versions := make(map[int]bool)
    for _, migration := range amm.migrations {
        if versions[migration.Version] {
            return fmt.Errorf("duplicate migration version: %d", migration.Version)
        }
        versions[migration.Version] = true
    }
    
    amm.logger.Println("Migrations validation passed")
    return nil
}

// 迁移备份和恢复
func (amm *AdvancedMigrationManager) Backup() error {
    amm.logger.Println("Creating database backup")
    
    // 这里应该实现实际的备份逻辑
    // 例如：导出表结构和数据
    
    backupFile := fmt.Sprintf("backup_%s.sql", time.Now().Format("20060102_150405"))
    amm.logger.Printf("Backup created: %s", backupFile)
    
    return nil
}

func (amm *AdvancedMigrationManager) Restore(backupFile string) error {
    amm.logger.Printf("Restoring from backup: %s", backupFile)
    
    // 这里应该实现实际的恢复逻辑
    // 例如：导入备份文件
    
    amm.logger.Println("Database restore completed")
    return nil
}

// 迁移监控
type MigrationMonitor struct {
    stats map[string]*MigrationStats
    mutex sync.RWMutex
}

type MigrationStats struct {
    Applied     int64
    RolledBack  int64
    Errors      int64
    AvgDuration time.Duration
    MaxDuration time.Duration
}

func NewMigrationMonitor() *MigrationMonitor {
    return &MigrationMonitor{
        stats: make(map[string]*MigrationStats),
    }
}

func (mm *MigrationMonitor) RecordMigration(name string, success bool, duration time.Duration, err error) {
    mm.mutex.Lock()
    defer mm.mutex.Unlock()
    
    if mm.stats[name] == nil {
        mm.stats[name] = &MigrationStats{}
    }
    
    stats := mm.stats[name]
    if success {
        stats.Applied++
    } else {
        stats.RolledBack++
        if err != nil {
            stats.Errors++
        }
    }
    
    // 更新平均持续时间
    totalDuration := stats.AvgDuration*time.Duration(stats.Applied+stats.RolledBack-1) + duration
    stats.AvgDuration = totalDuration / time.Duration(stats.Applied+stats.RolledBack)
    
    // 更新最大持续时间
    if duration > stats.MaxDuration {
        stats.MaxDuration = duration
    }
}

func (mm *MigrationMonitor) GetStats() map[string]*MigrationStats {
    mm.mutex.RLock()
    defer mm.mutex.RUnlock()
    
    result := make(map[string]*MigrationStats)
    for name, stats := range mm.stats {
        result[name] = &MigrationStats{
            Applied:     stats.Applied,
            RolledBack:  stats.RolledBack,
            Errors:      stats.Errors,
            AvgDuration: stats.AvgDuration,
            MaxDuration: stats.MaxDuration,
        }
    }
    return result
}

// 迁移最佳实践
func migrationBestPractices() {
    fmt.Println("\n=== 数据库迁移最佳实践 ===")
    
    fmt.Println("1. 迁移设计原则:")
    fmt.Println("   - 每个迁移应该只做一件事")
    fmt.Println("   - 迁移应该是幂等的")
    fmt.Println("   - 迁移应该是可逆的")
    fmt.Println("   - 迁移版本号应该是连续的")
    
    fmt.Println("\n2. 迁移安全:")
    fmt.Println("   - 在生产环境执行迁移前先在测试环境验证")
    fmt.Println("   - 创建数据库备份")
    fmt.Println("   - 在低峰期执行迁移")
    fmt.Println("   - 准备回滚方案")
    
    fmt.Println("\n3. 迁移性能:")
    fmt.Println("   - 避免在大表上执行长时间运行的操作")
    fmt.Println("   - 分批处理大量数据")
    fmt.Println("   - 使用索引优化查询")
    fmt.Println("   - 监控迁移执行时间")
    
    fmt.Println("\n4. 迁移管理:")
    fmt.Println("   - 使用版本控制系统管理迁移文件")
    fmt.Println("   - 记录迁移执行历史")
    fmt.Println("   - 监控迁移状态")
    fmt.Println("   - 定期清理旧的迁移记录")
    
    fmt.Println("\n5. 团队协作:")
    fmt.Println("   - 建立迁移命名规范")
    fmt.Println("   - 代码审查迁移脚本")
    fmt.Println("   - 文档化复杂的迁移")
    fmt.Println("   - 协调团队成员的迁移")
}

// 迁移工具使用示例
func migrationToolExample() {
    fmt.Println("=== 迁移工具使用示例 ===")
    
    // 这个示例需要实际的数据库连接
    /*
    db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/dbname")
    if err != nil {
        log.Printf("Database connection error: %v", err)
        return
    }
    defer db.Close()
    
    // 创建迁移管理器
    manager := NewMigrationManager(db)
    
    // 显示当前状态
    if err := manager.Status(); err != nil {
        log.Printf("Status error: %v", err)
        return
    }
    
    // 执行迁移
    if err := manager.Migrate(); err != nil {
        log.Printf("Migration error: %v", err)
        return
    }
    
    // 显示迁移后状态
    if err := manager.Status(); err != nil {
        log.Printf("Status error: %v", err)
        return
    }
    
    // 使用高级迁移管理器
    advancedManager := NewAdvancedMigrationManager(db)
    
    // 验证迁移
    if err := advancedManager.Validate(); err != nil {
        log.Printf("Validation error: %v", err)
        return
    }
    
    // 带日志的迁移
    if err := advancedManager.MigrateWithLogging(); err != nil {
        log.Printf("Advanced migration error: %v", err)
        return
    }
    */
    
    fmt.Println("Migration tool example (requires actual database)")
}

func main() {
    // 运行迁移示例
    migrationToolExample()
    migrationBestPractices()
    
    fmt.Println("Database migration examples completed")
}
```