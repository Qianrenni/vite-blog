## 12.3 安全最佳实践

### 输入验证

#### 输入验证框架实现
```go
package main

import (
    "encoding/json"
    "fmt"
    "net"
    "net/mail"
    "net/url"
    "regexp"
    "strconv"
    "strings"
    "time"
    "unicode"
    
    "github.com/gin-gonic/gin"
)

// 输入验证器接口
type Validator interface {
    Validate(value interface{}) error
}

// 验证错误
type ValidationError struct {
    Field   string
    Message string
}

func (ve ValidationError) Error() string {
    return fmt.Sprintf("field '%s': %s", ve.Field, ve.Message)
}

// 字符串验证器
type StringValidator struct {
    MinLength int
    MaxLength int
    Pattern   *regexp.Regexp
    Required  bool
    Trim      bool
}

func (sv StringValidator) Validate(value interface{}) error {
    str, ok := value.(string)
    if !ok {
        return ValidationError{Field: "string", Message: "must be a string"}
    }
    
    if sv.Trim {
        str = strings.TrimSpace(str)
    }
    
    if sv.Required && str == "" {
        return ValidationError{Field: "string", Message: "is required"}
    }
    
    if sv.MinLength > 0 && len(str) < sv.MinLength {
        return ValidationError{Field: "string", Message: fmt.Sprintf("minimum length is %d", sv.MinLength)}
    }
    
    if sv.MaxLength > 0 && len(str) > sv.MaxLength {
        return ValidationError{Field: "string", Message: fmt.Sprintf("maximum length is %d", sv.MaxLength)}
    }
    
    if sv.Pattern != nil && !sv.Pattern.MatchString(str) {
        return ValidationError{Field: "string", Message: "format is invalid"}
    }
    
    return nil
}

// 数字验证器
type NumberValidator struct {
    Min      *float64
    Max      *float64
    Required bool
}

func (nv NumberValidator) Validate(value interface{}) error {
    var num float64
    
    switch v := value.(type) {
    case int:
        num = float64(v)
    case int32:
        num = float64(v)
    case int64:
        num = float64(v)
    case float32:
        num = float64(v)
    case float64:
        num = v
    default:
        return ValidationError{Field: "number", Message: "must be a number"}
    }
    
    if nv.Required && num == 0 {
        return ValidationError{Field: "number", Message: "is required"}
    }
    
    if nv.Min != nil && num < *nv.Min {
        return ValidationError{Field: "number", Message: fmt.Sprintf("minimum value is %f", *nv.Min)}
    }
    
    if nv.Max != nil && num > *nv.Max {
        return ValidationError{Field: "number", Message: fmt.Sprintf("maximum value is %f", *nv.Max)}
    }
    
    return nil
}

// 邮箱验证器
type EmailValidator struct {
    Required bool
}

func (ev EmailValidator) Validate(value interface{}) error {
    email, ok := value.(string)
    if !ok {
        return ValidationError{Field: "email", Message: "must be a string"}
    }
    
    email = strings.TrimSpace(email)
    
    if ev.Required && email == "" {
        return ValidationError{Field: "email", Message: "is required"}
    }
    
    if email != "" {
        if _, err := mail.ParseAddress(email); err != nil {
            return ValidationError{Field: "email", Message: "invalid email format"}
        }
    }
    
    return nil
}

// URL验证器
type URLValidator struct {
    Required bool
    Schemes  []string
}

func (uv URLValidator) Validate(value interface{}) error {
    urlStr, ok := value.(string)
    if !ok {
        return ValidationError{Field: "url", Message: "must be a string"}
    }
    
    urlStr = strings.TrimSpace(urlStr)
    
    if uv.Required && urlStr == "" {
        return ValidationError{Field: "url", Message: "is required"}
    }
    
    if urlStr != "" {
        parsedURL, err := url.Parse(urlStr)
        if err != nil {
            return ValidationError{Field: "url", Message: "invalid URL format"}
        }
        
        if len(uv.Schemes) > 0 {
            validScheme := false
            for _, scheme := range uv.Schemes {
                if parsedURL.Scheme == scheme {
                    validScheme = true
                    break
                }
            }
            if !validScheme {
                return ValidationError{Field: "url", Message: fmt.Sprintf("scheme must be one of %v", uv.Schemes)}
            }
        }
    }
    
    return nil
}

// IP地址验证器
type IPValidator struct {
    Required bool
    IPv4Only bool
    IPv6Only bool
}

func (ipv IPValidator) Validate(value interface{}) error {
    ipStr, ok := value.(string)
    if !ok {
        return ValidationError{Field: "ip", Message: "must be a string"}
    }
    
    ipStr = strings.TrimSpace(ipStr)
    
    if ipv.Required && ipStr == "" {
        return ValidationError{Field: "ip", Message: "is required"}
    }
    
    if ipStr != "" {
        ip := net.ParseIP(ipStr)
        if ip == nil {
            return ValidationError{Field: "ip", Message: "invalid IP address"}
        }
        
        if ipv.IPv4Only && ip.To4() == nil {
            return ValidationError{Field: "ip", Message: "must be an IPv4 address"}
        }
        
        if ipv.IPv6Only && ip.To4() != nil {
            return ValidationError{Field: "ip", Message: "must be an IPv6 address"}
        }
    }
    
    return nil
}

// 日期时间验证器
type DateTimeValidator struct {
    Required   bool
    Format     string
    After      *time.Time
    Before     *time.Time
}

func (dtv DateTimeValidator) Validate(value interface{}) error {
    var dateTime time.Time
    var err error
    
    switch v := value.(type) {
    case string:
        if dtv.Format == "" {
            dateTime, err = time.Parse(time.RFC3339, v)
        } else {
            dateTime, err = time.Parse(dtv.Format, v)
        }
        if err != nil {
            return ValidationError{Field: "datetime", Message: "invalid date/time format"}
        }
    case time.Time:
        dateTime = v
    default:
        return ValidationError{Field: "datetime", Message: "must be a string or time.Time"}
    }
    
    if dtv.Required && dateTime.IsZero() {
        return ValidationError{Field: "datetime", Message: "is required"}
    }
    
    if dtv.After != nil && dateTime.Before(*dtv.After) {
        return ValidationError{Field: "datetime", Message: fmt.Sprintf("must be after %s", dtv.After.Format(time.RFC3339))}
    
    if dtv.Before != nil && dateTime.After(*dtv.Before) {
        return ValidationError{Field: "datetime", Message: fmt.Sprintf("must be before %s", dtv.Before.Format(time.RFC3339))}
    
    return nil
}

// 输入验证管理器
type InputValidator struct {
    validators map[string]Validator
}

func NewInputValidator() *InputValidator {
    return &InputValidator{
        validators: make(map[string]Validator),
    }
}

func (iv *InputValidator) AddValidator(field string, validator Validator) {
    iv.validators[field] = validator
}

func (iv *InputValidator) Validate(data map[string]interface{}) []ValidationError {
    var errors []ValidationError
    
    for field, validator := range iv.validators {
        value, exists := data[field]
        if !exists {
            // 检查是否为必需字段
            if requiredValidator, ok := validator.(interface{ IsRequired() bool }); ok {
                if requiredValidator.IsRequired() {
                    errors = append(errors, ValidationError{
                        Field:   field,
                        Message: "is required",
                    })
                }
            }
            continue
        }
        
        if err := validator.Validate(value); err != nil {
            if validationErr, ok := err.(ValidationError); ok {
                errors = append(errors, validationErr)
            } else {
                errors = append(errors, ValidationError{
                    Field:   field,
                    Message: err.Error(),
                })
            }
        }
    }
    
    return errors
}

// 为StringValidator添加IsRequired方法
func (sv StringValidator) IsRequired() bool {
    return sv.Required
}

// 为NumberValidator添加IsRequired方法
func (nv NumberValidator) IsRequired() bool {
    return nv.Required
}

// 为EmailValidator添加IsRequired方法
func (ev EmailValidator) IsRequired() bool {
    return ev.Required
}

// 为URLValidator添加IsRequired方法
func (uv URLValidator) IsRequired() bool {
    return uv.Required
}

// 为IPValidator添加IsRequired方法
func (ipv IPValidator) IsRequired() bool {
    return ipv.Required
}

// 为DateTimeValidator添加IsRequired方法
func (dtv DateTimeValidator) IsRequired() bool {
    return dtv.Required
}

// 常用验证器工厂函数
func NewRequiredStringValidator(maxLength int) StringValidator {
    return StringValidator{
        MinLength: 1,
        MaxLength: maxLength,
        Required:  true,
        Trim:      true,
    }
}

func NewEmailValidator() EmailValidator {
    return EmailValidator{Required: true}
}

func NewURLValidator(schemes ...string) URLValidator {
    return URLValidator{
        Required: true,
        Schemes:  schemes,
    }
}

func NewIPValidator() IPValidator {
    return IPValidator{Required: true}
}

func NewAgeValidator() NumberValidator {
    min := 0.0
    max := 150.0
    return NumberValidator{
        Min:      &min,
        Max:      &max,
        Required: true,
    }
}

// 输入清理器
type InputSanitizer struct {
    htmlStripper *regexp.Regexp
    scriptStripper *regexp.Regexp
}

func NewInputSanitizer() *InputSanitizer {
    return &InputSanitizer{
        htmlStripper:   regexp.MustCompile(`<[^>]*>`),
        scriptStripper: regexp.MustCompile(`(?i)<script[^>]*>.*?</script>`),
    }
}

func (is *InputSanitizer) SanitizeString(input string) string {
    // 移除HTML标签
    clean := is.scriptStripper.ReplaceAllString(input, "")
    clean = is.htmlStripper.ReplaceAllString(clean, "")
    
    // 移除多余的空白字符
    clean = strings.TrimSpace(clean)
    
    return clean
}

func (is *InputSanitizer) SanitizeMap(data map[string]interface{}) map[string]interface{} {
    cleanData := make(map[string]interface{})
    
    for key, value := range data {
        switch v := value.(type) {
        case string:
            cleanData[key] = is.SanitizeString(v)
        case map[string]interface{}:
            cleanData[key] = is.SanitizeMap(v)
        case []interface{}:
            cleanData[key] = is.SanitizeSlice(v)
        default:
            cleanData[key] = value
        }
    }
    
    return cleanData
}

func (is *InputSanitizer) SanitizeSlice(slice []interface{}) []interface{} {
    cleanSlice := make([]interface{}, len(slice))
    
    for i, value := range slice {
        switch v := value.(type) {
        case string:
            cleanSlice[i] = is.SanitizeString(v)
        case map[string]interface{}:
            cleanSlice[i] = is.SanitizeMap(v)
        case []interface{}:
            cleanSlice[i] = is.SanitizeSlice(v)
        default:
            cleanSlice[i] = value
        }
    }
    
    return cleanSlice
}

// 输入验证中间件
func InputValidationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 创建验证器
        validator := NewInputValidator()
        
        // 添加常用验证器
        validator.AddValidator("name", NewRequiredStringValidator(100))
        validator.AddValidator("email", NewEmailValidator())
        validator.AddValidator("age", NewAgeValidator())
        
        // 解析JSON数据
        var data map[string]interface{}
        if err := c.ShouldBindJSON(&data); err != nil {
            c.JSON(400, gin.H{"error": "invalid JSON"})
            c.Abort()
            return
        }
        
        // 验证数据
        errors := validator.Validate(data)
        if len(errors) > 0 {
            errorMessages := make([]string, len(errors))
            for i, err := range errors {
                errorMessages[i] = err.Error()
            }
            c.JSON(400, gin.H{
                "error": "validation failed",
                "details": errorMessages,
            })
            c.Abort()
            return
        }
        
        // 清理输入数据
        sanitizer := NewInputSanitizer()
        cleanData := sanitizer.SanitizeMap(data)
        c.Set("clean_data", cleanData)
        
        c.Next()
    }
}

// 用户注册数据结构
type UserRegistration struct {
    Name     string `json:"name" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"required,min=1,max=150"`
    Website  string `json:"website" binding:"omitempty,url"`
    IP       string `json:"ip" binding:"omitempty,ip"`
    Birthday string `json:"birthday" binding:"omitempty"`
}

// 输入验证示例应用
func InputValidationExample() {
    // 创建Gin路由器
    r := gin.Default()
    
    // 使用输入验证中间件
    r.Use(InputValidationMiddleware())
    
    // 用户注册路由
    r.POST("/register", func(c *gin.Context) {
        // 获取清理后的数据
        cleanData, exists := c.Get("clean_data")
        if !exists {
            c.JSON(500, gin.H{"error": "internal error"})
            return
        }
        
        // 处理注册逻辑
        c.JSON(200, gin.H{
            "message": "registration successful",
            "data":    cleanData,
        })
    })
    
    // 直接验证示例
    validator := NewInputValidator()
    
    // 添加验证器
    validator.AddValidator("username", StringValidator{
        MinLength: 3,
        MaxLength: 20,
        Pattern:   regexp.MustCompile(`^[a-zA-Z0-9_]+$`),
        Required:  true,
        Trim:      true,
    })
    
    validator.AddValidator("email", EmailValidator{Required: true})
    validator.AddValidator("age", NumberValidator{
        Min:      float64Ptr(18),
        Max:      float64Ptr(120),
        Required: true,
    })
    validator.AddValidator("website", URLValidator{
        Required: false,
        Schemes:  []string{"http", "https"},
    })
    
    // 测试数据
    testData := map[string]interface{}{
        "username": "john_doe",
        "email":    "john@example.com",
        "age":      25,
        "website":  "https://example.com",
    }
    
    // 验证数据
    errors := validator.Validate(testData)
    if len(errors) > 0 {
        fmt.Println("验证错误:")
        for _, err := range errors {
            fmt.Printf("  %s\n", err.Error())
        }
    } else {
        fmt.Println("数据验证通过")
    }
    
    // 输入清理示例
    sanitizer := NewInputSanitizer()
    dirtyInput := map[string]interface{}{
        "name":    "<script>alert('xss')</script>John Doe",
        "bio":     "<p>This is a <b>bio</b> with <script>malicious</script> content</p>",
        "website": "https://example.com",
    }
    
    cleanInput := sanitizer.SanitizeMap(dirtyInput)
    fmt.Printf("清理前: %+v\n", dirtyInput)
    fmt.Printf("清理后: %+v\n", cleanInput)
    
    // 输入验证最佳实践
    inputValidationBestPractices()
}

func float64Ptr(f float64) *float64 {
    return &f
}

func inputValidationBestPractices() {
    fmt.Println("\n=== 输入验证最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "白名单验证",
            "使用白名单而不是黑名单验证输入",
        },
        {
            "类型安全",
            "明确指定输入数据类型",
        },
        {
            "边界检查",
            "验证数值范围、字符串长度等边界条件",
        },
        {
            "格式验证",
            "使用正则表达式验证特定格式",
        },
        {
            "必需字段检查",
            "明确标识必需字段",
        },
        {
            "输入清理",
            "清理HTML标签和其他潜在危险字符",
        },
        {
            "拒绝超大输入",
            "限制输入数据大小防止拒绝服务攻击",
        },
        {
            "统一验证框架",
            "建立统一的输入验证框架",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}
```

### 输出编码

#### 输出编码实现
```go
package main

import (
    "encoding/json"
    "fmt"
    "html"
    "net/url"
    "regexp"
    "strings"
)

// 输出编码器接口
type Encoder interface {
    Encode(input string) string
}

// HTML编码器
type HTMLEncoder struct{}

func (he *HTMLEncoder) Encode(input string) string {
    return html.EscapeString(input)
}

// URL编码器
type URLEncoder struct{}

func (ue *URLEncoder) Encode(input string) string {
    return url.QueryEscape(input)
}

// JavaScript编码器
type JavaScriptEncoder struct {
    dangerousChars *regexp.Regexp
}

func NewJavaScriptEncoder() *JavaScriptEncoder {
    return &JavaScriptEncoder{
        dangerousChars: regexp.MustCompile(`[^\w\s.,@-]`),
    }
}

func (je *JavaScriptEncoder) Encode(input string) string {
    // 基本的JavaScript编码
    encoded := strings.ReplaceAll(input, "\\", "\\\\")
    encoded = strings.ReplaceAll(encoded, "\"", "\\\"")
    encoded = strings.ReplaceAll(encoded, "'", "\\'")
    encoded = strings.ReplaceAll(encoded, "\n", "\\n")
    encoded = strings.ReplaceAll(encoded, "\r", "\\r")
    encoded = strings.ReplaceAll(encoded, "\t", "\\t")
    
    return encoded
}

// CSS编码器
type CSSEncoder struct {
    dangerousChars *regexp.Regexp
}

func NewCSSEncoder() *CSSEncoder {
    return &CSSEncoder{
        dangerousChars: regexp.MustCompile(`[<>'"&]`),
    }
}

func (ce *CSSEncoder) Encode(input string) string {
    // CSS安全编码
    encoded := html.EscapeString(input)
    encoded = strings.ReplaceAll(encoded, "\\", "\\\\")
    return encoded
}

// JSON编码器
type JSONEncoder struct{}

func (je *JSONEncoder) Encode(input string) string {
    // 使用标准库进行JSON编码
    bytes, _ := json.Marshal(input)
    return string(bytes)
}

// 输出编码管理器
type OutputEncoder struct {
    encoders map[string]Encoder
}

func NewOutputEncoder() *OutputEncoder {
    return &OutputEncoder{
        encoders: map[string]Encoder{
            "html": &HTMLEncoder{},
            "url":  &URLEncoder{},
            "js":   NewJavaScriptEncoder(),
            "css":  NewCSSEncoder(),
            "json": &JSONEncoder{},
        },
    }
}

func (oe *OutputEncoder) AddEncoder(name string, encoder Encoder) {
    oe.encoders[name] = encoder
}

func (oe *OutputEncoder) Encode(context, input string) string {
    if encoder, exists := oe.encoders[context]; exists {
        return encoder.Encode(input)
    }
    return input // 默认不编码
}

// 上下文感知编码器
type ContextAwareEncoder struct {
    outputEncoder *OutputEncoder
}

func NewContextAwareEncoder() *ContextAwareEncoder {
    return &ContextAwareEncoder{
        outputEncoder: NewOutputEncoder(),
    }
}

func (cae *ContextAwareEncoder) EncodeForHTML(input string) string {
    return cae.outputEncoder.Encode("html", input)
}

func (cae *ContextAwareEncoder) EncodeForURL(input string) string {
    return cae.outputEncoder.Encode("url", input)
}

func (cae *ContextAwareEncoder) EncodeForJavaScript(input string) string {
    return cae.outputEncoder.Encode("js", input)
}

func (cae *ContextAwareEncoder) EncodeForCSS(input string) string {
    return cae.outputEncoder.Encode("css", input)
}

func (cae *ContextAwareEncoder) EncodeForJSON(input string) string {
    return cae.outputEncoder.Encode("json", input)
}

// 安全响应包装器
type SafeResponse struct {
    encoder *ContextAwareEncoder
}

func NewSafeResponse() *SafeResponse {
    return &SafeResponse{
        encoder: NewContextAwareEncoder(),
    }
}

func (sr *SafeResponse) HTML(input string) string {
    return sr.encoder.EncodeForHTML(input)
}

func (sr *SafeResponse) URL(input string) string {
    return sr.encoder.EncodeForURL(input)
}

func (sr *SafeResponse) JavaScript(input string) string {
    return sr.encoder.EncodeForJavaScript(input)
}

func (sr *SafeResponse) CSS(input string) string {
    return sr.encoder.EncodeForCSS(input)
}

func (sr *SafeResponse) JSON(input string) string {
    return sr.encoder.EncodeForJSON(input)
}

// 模板安全渲染
type SafeTemplateRenderer struct {
    encoder *ContextAwareEncoder
}

func NewSafeTemplateRenderer() *SafeTemplateRenderer {
    return &SafeTemplateRenderer{
        encoder: NewContextAwareEncoder(),
    }
}

func (str *SafeTemplateRenderer) RenderHTMLTemplate(template string, data map[string]interface{}) string {
    result := template
    
    for key, value := range data {
        var encodedValue string
        
        switch v := value.(type) {
        case string:
            encodedValue = str.encoder.EncodeForHTML(v)
        case int, int32, int64, float32, float64:
            encodedValue = fmt.Sprintf("%v", v)
        default:
            encodedValue = str.encoder.EncodeForHTML(fmt.Sprintf("%v", v))
        }
        
        placeholder := "{{" + key + "}}"
        result = strings.ReplaceAll(result, placeholder, encodedValue)
    }
    
    return result
}

// 内容安全策略
type ContentSecurityPolicy struct {
    directives map[string][]string
}

func NewContentSecurityPolicy() *ContentSecurityPolicy {
    return &ContentSecurityPolicy{
        directives: make(map[string][]string),
    }
}

func (csp *ContentSecurityPolicy) AddDirective(name string, sources []string) {
    csp.directives[name] = sources
}

func (csp *ContentSecurityPolicy) ToString() string {
    var parts []string
    
    for directive, sources := range csp.directives {
        if len(sources) > 0 {
            parts = append(parts, directive+" "+strings.Join(sources, " "))
        } else {
            parts = append(parts, directive)
        }
    }
    
    return strings.Join(parts, "; ")
}

// 输出编码示例应用
func OutputEncodingExample() {
    // 创建上下文感知编码器
    encoder := NewContextAwareEncoder()
    
    // 测试数据
    testData := "<script>alert('XSS')</script> & \"Hello World\""
    fmt.Printf("原始数据: %s\n", testData)
    
    // HTML编码
    htmlEncoded := encoder.EncodeForHTML(testData)
    fmt.Printf("HTML编码: %s\n", htmlEncoded)
    
    // URL编码
    urlEncoded := encoder.EncodeForURL(testData)
    fmt.Printf("URL编码: %s\n", urlEncoded)
    
    // JavaScript编码
    jsEncoded := encoder.EncodeForJavaScript(testData)
    fmt.Printf("JavaScript编码: %s\n", jsEncoded)
    
    // CSS编码
    cssEncoded := encoder.EncodeForCSS(testData)
    fmt.Printf("CSS编码: %s\n", cssEncoded)
    
    // JSON编码
    jsonEncoded := encoder.EncodeForJSON(testData)
    fmt.Printf("JSON编码: %s\n", jsonEncoded)
    
    // 安全响应示例
    fmt.Println("\n=== 安全响应示例 ===")
    safeResponse := NewSafeResponse()
    
    userInput := "<img src=x onerror=alert('XSS')>"
    htmlOutput := safeResponse.HTML(userInput)
    fmt.Printf("安全HTML输出: %s\n", htmlOutput)
    
    urlInput := "https://example.com?param=<script>"
    urlOutput := safeResponse.URL(urlInput)
    fmt.Printf("安全URL输出: %s\n", urlOutput)
    
    // 模板安全渲染示例
    fmt.Println("\n=== 模板安全渲染 ===")
    renderer := NewSafeTemplateRenderer()
    
    template := `<div class="user-info">
        <h1>{{name}}</h1>
        <p>Email: {{email}}</p>
        <p>Bio: {{bio}}</p>
    </div>`
    
    templateData := map[string]interface{}{
        "name":  "<script>alert('XSS')</script>John",
        "email": "john@example.com",
        "bio":   "I love coding & <script>hacking</script>",
    }
    
    rendered := renderer.RenderHTMLTemplate(template, templateData)
    fmt.Printf("渲染结果:\n%s\n", rendered)
    
    // 内容安全策略示例
    fmt.Println("\n=== 内容安全策略 ===")
    csp := NewContentSecurityPolicy()
    csp.AddDirective("default-src", []string{"'self'"})
    csp.AddDirective("script-src", []string{"'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com"})
    csp.AddDirective("style-src", []string{"'self'", "'unsafe-inline'", "https://fonts.googleapis.com"})
    csp.AddDirective("img-src", []string{"'self'", "https:", "data:"})
    csp.AddDirective("font-src", []string{"'self'", "https://fonts.gstatic.com"})
    csp.AddDirective("connect-src", []string{"'self'"})
    
    fmt.Printf("CSP策略: %s\n", csp.ToString())
    
    // 输出编码最佳实践
    outputEncodingBestPractices()
}

func outputEncodingBestPractices() {
    fmt.Println("\n=== 输出编码最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "上下文感知编码",
            "根据输出上下文选择合适的编码方式",
        },
        {
            "HTML编码",
            "在HTML内容中输出用户数据时使用",
        },
        {
            "URL编码",
            "在URL参数中输出用户数据时使用",
        },
        {
            "JavaScript编码",
            "在JavaScript代码中输出用户数据时使用",
        },
        {
            "CSS编码",
            "在CSS样式中输出用户数据时使用",
        },
        {
            "统一编码框架",
            "建立统一的输出编码框架",
        },
        {
            "模板引擎集成",
            "与模板引擎集成自动编码",
        },
        {
            "内容安全策略",
            "配合CSP提供额外安全保护",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}
```

### 安全头设置

#### 安全头设置实现
```go
package main

import (
    "fmt"
    "net/http"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
)

// 安全头配置
type SecurityHeadersConfig struct {
    // XSS保护
    XSSProtection string
    
    // 内容类型嗅探保护
    ContentTypeNosniff string
    
    // 框架选项
    FrameOptions string
    
    // 引用策略
    ReferrerPolicy string
    
    // 内容安全策略
    ContentSecurityPolicy string
    
    // 权限策略
    PermissionsPolicy string
    
    // 严格传输安全
    StrictTransportSecurity string
    
    // 特征策略（已废弃，使用权限策略）
    FeaturePolicy string
    
    // DNS预取控制
    DNSPrefetchControl string
    
    // 期望CT
    ExpectCT string
    
    // 清理站点数据
    ClearSiteData string
}

// 默认安全头配置
func DefaultSecurityHeadersConfig() SecurityHeadersConfig {
    return SecurityHeadersConfig{
        XSSProtection:           "1; mode=block",
        ContentTypeNosniff:      "nosniff",
        FrameOptions:            "DENY",
        ReferrerPolicy:          "strict-origin-when-cross-origin",
        ContentSecurityPolicy:   "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
        PermissionsPolicy:       "geolocation=(), microphone=(), camera=()",
        StrictTransportSecurity: "max-age=31536000; includeSubDomains",
        DNSPrefetchControl:      "off",
        ExpectCT:                "max-age=86400, enforce",
    }
}

// 安全头中间件
type SecurityHeadersMiddleware struct {
    config SecurityHeadersConfig
}

func NewSecurityHeadersMiddleware(config SecurityHeadersConfig) *SecurityHeadersMiddleware {
    return &SecurityHeadersMiddleware{config: config}
}

func (shm *SecurityHeadersMiddleware) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 设置安全头
        if shm.config.XSSProtection != "" {
            c.Header("X-XSS-Protection", shm.config.XSSProtection)
        }
        
        if shm.config.ContentTypeNosniff != "" {
            c.Header("X-Content-Type-Options", shm.config.ContentTypeNosniff)
        }
        
        if shm.config.FrameOptions != "" {
            c.Header("X-Frame-Options", shm.config.FrameOptions)
        }
        
        if shm.config.ReferrerPolicy != "" {
            c.Header("Referrer-Policy", shm.config.ReferrerPolicy)
        }
        
        if shm.config.ContentSecurityPolicy != "" {
            c.Header("Content-Security-Policy", shm.config.ContentSecurityPolicy)
        }
        
        if shm.config.PermissionsPolicy != "" {
            c.Header("Permissions-Policy", shm.config.PermissionsPolicy)
        }
        
        if shm.config.StrictTransportSecurity != "" && isHTTPSRequest(c) {
            c.Header("Strict-Transport-Security", shm.config.StrictTransportSecurity)
        }
        
        if shm.config.DNSPrefetchControl != "" {
            c.Header("X-DNS-Prefetch-Control", shm.config.DNSPrefetchControl)
        }
        
        if shm.config.ExpectCT != "" {
            c.Header("Expect-CT", shm.config.ExpectCT)
        }
        
        if shm.config.ClearSiteData != "" {
            c.Header("Clear-Site-Data", shm.config.ClearSiteData)
        }
        
        c.Next()
    }
}

func isHTTPSRequest(c *gin.Context) bool {
    return c.Request.TLS != nil || c.GetHeader("X-Forwarded-Proto") == "https"
}

// 条件安全头中间件
type ConditionalSecurityHeaders struct {
    config SecurityHeadersConfig
}

func NewConditionalSecurityHeaders(config SecurityHeadersConfig) *ConditionalSecurityHeaders {
    return &ConditionalSecurityHeaders{config: config}
}

func (csh *ConditionalSecurityHeaders) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 根据请求条件设置不同的安全头
        
        // HTTPS请求
        if isHTTPSRequest(c) {
            if csh.config.StrictTransportSecurity != "" {
                c.Header("Strict-Transport-Security", csh.config.StrictTransportSecurity)
            }
        }
        
        // API请求
        if strings.HasPrefix(c.Request.URL.Path, "/api/") {
            // API特定的安全头
            c.Header("X-Content-Type-Options", "nosniff")
            c.Header("X-Frame-Options", "DENY")
        }
        
        // 前端请求
        if strings.HasPrefix(c.Request.URL.Path, "/") && !strings.HasPrefix(c.Request.URL.Path, "/api/") {
            // 前端特定的安全头
            if csh.config.ContentSecurityPolicy != "" {
                c.Header("Content-Security-Policy", csh.config.ContentSecurityPolicy)
            }
        }
        
        // 通用安全头
        c.Header("X-XSS-Protection", csh.config.XSSProtection)
        c.Header("X-Content-Type-Options", csh.config.ContentTypeNosniff)
        c.Header("Referrer-Policy", csh.config.ReferrerPolicy)
        c.Header("Permissions-Policy", csh.config.PermissionsPolicy)
        c.Header("X-DNS-Prefetch-Control", csh.config.DNSPrefetchControl)
        
        c.Next()
    }
}

// 动态安全头管理
type DynamicSecurityHeaders struct {
    headers map[string]string
}

func NewDynamicSecurityHeaders() *DynamicSecurityHeaders {
    return &DynamicSecurityHeaders{
        headers: make(map[string]string),
    }
}

func (dsh *DynamicSecurityHeaders) SetHeader(name, value string) {
    dsh.headers[name] = value
}

func (dsh *DynamicSecurityHeaders) RemoveHeader(name string) {
    delete(dsh.headers, name)
}

func (dsh *DynamicSecurityHeaders) GetHeader(name string) (string, bool) {
    value, exists := dsh.headers[name]
    return value, exists
}

func (dsh *DynamicSecurityHeaders) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        for name, value := range dsh.headers {
            c.Header(name, value)
        }
        c.Next()
    }
}

// 安全头验证器
type SecurityHeadersValidator struct {
    requiredHeaders map[string]string
}

func NewSecurityHeadersValidator(requiredHeaders map[string]string) *SecurityHeadersValidator {
    return &SecurityHeadersValidator{requiredHeaders: requiredHeaders}
}

func (shv *SecurityHeadersValidator) ValidateHeaders(c *gin.Context) bool {
    for name, expectedValue := range shv.requiredHeaders {
        actualValue := c.GetHeader(name)
        if actualValue != expectedValue {
            return false
        }
    }
    return true
}

func (shv *SecurityHeadersValidator) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        if !shv.ValidateHeaders(c) {
            c.JSON(http.StatusForbidden, gin.H{
                "error": "security headers validation failed",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}

// 安全头报告器
type SecurityHeadersReporter struct {
    reports chan SecurityReport
}

type SecurityReport struct {
    Timestamp time.Time
    Endpoint  string
    Headers   map[string]string
    Issues    []SecurityIssue
}

type SecurityIssue struct {
    Type     string
    Message  string
    Severity string
}

func NewSecurityHeadersReporter() *SecurityHeadersReporter {
    return &SecurityHeadersReporter{
        reports: make(chan SecurityReport, 100),
    }
}

func (shr *SecurityHeadersReporter) Report(c *gin.Context) {
    headers := make(map[string]string)
    for _, header := range []string{
        "X-XSS-Protection",
        "X-Content-Type-Options",
        "X-Frame-Options",
        "Content-Security-Policy",
        "Strict-Transport-Security",
        "Referrer-Policy",
        "Permissions-Policy",
    } {
        if value := c.GetHeader(header); value != "" {
            headers[header] = value
        }
    }
    
    issues := shr.analyzeHeaders(headers)
    
    report := SecurityReport{
        Timestamp: time.Now(),
        Endpoint:  c.Request.URL.Path,
        Headers:   headers,
        Issues:    issues,
    }
    
    select {
    case shr.reports <- report:
    default:
        // 队列满时丢弃报告
    }
}

func (shr *SecurityHeadersReporter) analyzeHeaders(headers map[string]string) []SecurityIssue {
    var issues []SecurityIssue
    
    // 检查必需的安全头
    requiredHeaders := []string{
        "X-Content-Type-Options",
        "X-Frame-Options",
        "X-XSS-Protection",
    }
    
    for _, header := range requiredHeaders {
        if _, exists := headers[header]; !exists {
            issues = append(issues, SecurityIssue{
                Type:     "missing_header",
                Message:  fmt.Sprintf("Missing security header: %s", header),
                Severity: "high",
            })
        }
    }
    
    // 检查CSP策略
    if csp, exists := headers["Content-Security-Policy"]; exists {
        if strings.Contains(csp, "'unsafe-inline'") {
            issues = append(issues, SecurityIssue{
                Type:     "weak_csp",
                Message:  "CSP contains 'unsafe-inline'",
                Severity: "medium",
            })
        }
        if strings.Contains(csp, "'unsafe-eval'") {
            issues = append(issues, SecurityIssue{
                Type:     "weak_csp",
                Message:  "CSP contains 'unsafe-eval'",
                Severity: "high",
            })
        }
    } else {
        issues = append(issues, SecurityIssue{
            Type:     "missing_csp",
            Message:  "Missing Content-Security-Policy header",
            Severity: "high",
        })
    }
    
    return issues
}

func (shr *SecurityHeadersReporter) StartReporting() {
    go func() {
        for report := range shr.reports {
            shr.processReport(report)
        }
    }()
}

func (shr *SecurityHeadersReporter) processReport(report SecurityReport) {
    fmt.Printf("Security Report - %s\n", report.Timestamp.Format(time.RFC3339))
    fmt.Printf("Endpoint: %s\n", report.Endpoint)
    fmt.Printf("Issues found: %d\n", len(report.Issues))
    
    for _, issue := range report.Issues {
        fmt.Printf("  [%s] %s: %s\n", issue.Severity, issue.Type, issue.Message)
    }
    fmt.Println()
}

// 安全头示例应用
func SecurityHeadersExample() {
    // 创建Gin路由器
    r := gin.Default()
    
    // 配置安全头
    securityConfig := DefaultSecurityHeadersConfig()
    securityConfig.ContentSecurityPolicy = "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com"
    securityConfig.PermissionsPolicy = "geolocation=(), microphone=(), camera=(), geolocation=(self 'https://maps.googleapis.com')"
    securityConfig.StrictTransportSecurity = "max-age=31536000; includeSubDomains; preload"
    
    // 创建安全头中间件
    securityMiddleware := NewSecurityHeadersMiddleware(securityConfig)
    r.Use(securityMiddleware.Middleware())
    
    // 条件安全头
    conditionalConfig := DefaultSecurityHeadersConfig()
    conditionalMiddleware := NewConditionalSecurityHeaders(conditionalConfig)
    r.Use(conditionalMiddleware.Middleware())
    
    // 动态安全头
    dynamicHeaders := NewDynamicSecurityHeaders()
    dynamicHeaders.SetHeader("X-Custom-Security", "custom-value")
    r.Use(dynamicHeaders.Middleware())
    
    // 安全头报告器
    reporter := NewSecurityHeadersReporter()
    reporter.StartReporting()
    
    // 路由
    r.GET("/", func(c *gin.Context) {
        // 生成安全报告
        reporter.Report(c)
        
        c.JSON(http.StatusOK, gin.H{
            "message": "Secure application with security headers",
        })
    })
    
    r.GET("/api/status", func(c *gin.Context) {
        // 生成安全报告
        reporter.Report(c)
        
        c.JSON(http.StatusOK, gin.H{
            "status": "ok",
            "secure": true,
        })
    })
    
    // 显示当前安全头配置
    fmt.Println("=== 当前安全头配置 ===")
    fmt.Printf("X-XSS-Protection: %s\n", securityConfig.XSSProtection)
    fmt.Printf("X-Content-Type-Options: %s\n", securityConfig.ContentTypeNosniff)
    fmt.Printf("X-Frame-Options: %s\n", securityConfig.FrameOptions)
    fmt.Printf("Content-Security-Policy: %s\n", securityConfig.ContentSecurityPolicy)
    fmt.Printf("Permissions-Policy: %s\n", securityConfig.PermissionsPolicy)
    fmt.Printf("Strict-Transport-Security: %s\n", securityConfig.StrictTransportSecurity)
    
    // 安全头最佳实践
    securityHeadersBestPractices()
}

func securityHeadersBestPractices() {
    fmt.Println("\n=== 安全头最佳实践 ===")
    practices := []struct {
        Header string
        Value  string
        Description string
    }{
        {
            "X-Frame-Options",
            "DENY or SAMEORIGIN",
            "防止点击劫持攻击",
        },
        {
            "X-Content-Type-Options",
            "nosniff",
            "防止MIME类型嗅探",
        },
        {
            "X-XSS-Protection",
            "1; mode=block",
            "启用浏览器XSS保护",
        },
        {
            "Content-Security-Policy",
            "严格策略",
            "防止XSS和其他代码注入攻击",
        },
        {
            "Strict-Transport-Security",
            "max-age=31536000",
            "强制HTTPS连接",
        },
        {
            "Referrer-Policy",
            "strict-origin-when-cross-origin",
            "控制引用信息发送",
        },
        {
            "Permissions-Policy",
            "限制敏感API访问",
            "控制浏览器API权限",
        },
        {
            "Expect-CT",
            "enforce",
            "证书透明度验证",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Header, practice.Value)
        fmt.Printf("  说明: %s\n\n", practice.Description)
    }
}
```

### 安全审计

#### 安全审计实现
```go
package main

import (
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "os"
    "path/filepath"
    "runtime"
    "strings"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// 审计事件类型
type AuditEventType string

const (
    EventTypeLogin        AuditEventType = "login"
    EventTypeLogout       AuditEventType = "logout"
    EventTypeAccess       AuditEventType = "access"
    EventTypeModify       AuditEventType = "modify"
    EventTypeDelete       AuditEventType = "delete"
    EventTypeError        AuditEventType = "error"
    EventTypeSecurity     AuditEventType = "security"
    EventTypeSystem       AuditEventType = "system"
)

// 审计事件
type AuditEvent struct {
    ID          string         `json:"id"`
    Timestamp   time.Time      `json:"timestamp"`
    EventType   AuditEventType `json:"event_type"`
    UserID      string         `json:"user_id,omitempty"`
    UserName    string         `json:"user_name,omitempty"`
    IPAddress   string         `json:"ip_address,omitempty"`
    UserAgent   string         `json:"user_agent,omitempty"`
    Resource    string         `json:"resource,omitempty"`
    Action      string         `json:"action,omitempty"`
    Status      string         `json:"status,omitempty"`
    Details     interface{}    `json:"details,omitempty"`
    Severity    string         `json:"severity,omitempty"`
    SessionID   string         `json:"session_id,omitempty"`
    RequestID   string         `json:"request_id,omitempty"`
}

// 审计日志存储接口
type AuditLogStorage interface {
    Store(event *AuditEvent) error
    Query(filter *AuditQueryFilter) ([]*AuditEvent, error)
    DeleteOldLogs(before time.Time) error
}

// 审计查询过滤器
type AuditQueryFilter struct {
    EventType AuditEventType `json:"event_type,omitempty"`
    UserID    string         `json:"user_id,omitempty"`
    Resource  string         `json:"resource,omitempty"`
    FromTime  time.Time      `json:"from_time,omitempty"`
    ToTime    time.Time      `json:"to_time,omitempty"`
    Limit     int            `json:"limit,omitempty"`
    Offset    int            `json:"offset,omitempty"`
}

// 文件审计日志存储
type FileAuditLogStorage struct {
    filePath string
    mutex    sync.RWMutex
}

func NewFileAuditLogStorage(filePath string) *FileAuditLogStorage {
    return &FileAuditLogStorage{filePath: filePath}
}

func (fals *FileAuditLogStorage) Store(event *AuditEvent) error {
    fals.mutex.Lock()
    defer fals.mutex.Unlock()
    
    file, err := os.OpenFile(fals.filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        return err
    }
    defer file.Close()
    
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    _, err = file.Write(append(data, '\n'))
    return err
}

func (fals *FileAuditLogStorage) Query(filter *AuditQueryFilter) ([]*AuditEvent, error) {
    fals.mutex.RLock()
    defer fals.mutex.RUnlock()
    
    file, err := os.Open(fals.filePath)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    
    var events []*AuditEvent
    decoder := json.NewDecoder(file)
    
    for decoder.More() {
        var event AuditEvent
        if err := decoder.Decode(&event); err != nil {
            if err == io.EOF {
                break
            }
            continue
        }
        
        if fals.matchesFilter(&event, filter) {
            events = append(events, &event)
        }
    }
    
    return events, nil
}

func (fals *FileAuditLogStorage) matchesFilter(event *AuditEvent, filter *AuditQueryFilter) bool {
    if filter.EventType != "" && event.EventType != filter.EventType {
        return false
    }
    
    if filter.UserID != "" && event.UserID != filter.UserID {
        return false
    }
    
    if filter.Resource != "" && !strings.Contains(event.Resource, filter.Resource) {
        return false
    }
    
    if !filter.FromTime.IsZero() && event.Timestamp.Before(filter.FromTime) {
        return false
    }
    
    if !filter.ToTime.IsZero() && event.Timestamp.After(filter.ToTime) {
        return false
    }
    
    return true
}

func (fals *FileAuditLogStorage) DeleteOldLogs(before time.Time) error {
    // 简化实现：实际应用中需要更复杂的日志轮换逻辑
    return nil
}

// 审计管理器
type AuditManager struct {
    storage AuditLogStorage
    logger  *log.Logger
}

func NewAuditManager(storage AuditLogStorage) *AuditManager {
    return &AuditManager{
        storage: storage,
        logger:  log.New(os.Stdout, "AUDIT: ", log.LstdFlags),
    }
}

func (am *AuditManager) LogEvent(event *AuditEvent) {
    // 生成事件ID
    if event.ID == "" {
        event.ID = am.generateEventID(event)
    }
    
    // 设置时间戳
    if event.Timestamp.IsZero() {
        event.Timestamp = time.Now()
    }
    
    // 存储事件
    if err := am.storage.Store(event); err != nil {
        am.logger.Printf("Failed to store audit event: %v", err)
        return
    }
    
    // 记录到日志
    am.logger.Printf("Event: %s, User: %s, Resource: %s, Action: %s",
        event.EventType, event.UserName, event.Resource, event.Action)
}

func (am *AuditManager) QueryEvents(filter *AuditQueryFilter) ([]*AuditEvent, error) {
    return am.storage.Query(filter)
}

func (am *AuditManager) generateEventID(event *AuditEvent) string {
    data := fmt.Sprintf("%s%s%s%s%d",
        event.EventType,
        event.UserID,
        event.Resource,
        event.Action,
        event.Timestamp.UnixNano())
    
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:16])
}

// Gin审计中间件
type AuditMiddleware struct {
    auditManager *AuditManager
}

func NewAuditMiddleware(auditManager *AuditManager) *AuditMiddleware {
    return &AuditMiddleware{auditManager: auditManager}
}

func (am *AuditMiddleware) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 记录请求开始时间
        startTime := time.Now()
        
        // 生成请求ID
        requestID := generateRequestID()
        c.Set("request_id", requestID)
        
        // 获取用户信息（如果有）
        userID, userName := am.getUserInfo(c)
        
        // 记录访问事件
        accessEvent := &AuditEvent{
            EventType: EventTypeAccess,
            UserID:    userID,
            UserName:  userName,
            IPAddress: c.ClientIP(),
            UserAgent: c.GetHeader("User-Agent"),
            Resource:  c.Request.URL.Path,
            Action:    c.Request.Method,
            RequestID: requestID,
            Severity:  "info",
        }
        
        am.auditManager.LogEvent(accessEvent)
        
        // 处理请求
        c.Next()
        
        // 记录响应事件
        endTime := time.Now()
        duration := endTime.Sub(startTime)
        
        statusEvent := &AuditEvent{
            EventType: EventTypeAccess,
            UserID:    userID,
            UserName:  userName,
            IPAddress: c.ClientIP(),
            UserAgent: c.GetHeader("User-Agent"),
            Resource:  c.Request.URL.Path,
            Action:    fmt.Sprintf("%s %d", c.Request.Method, c.Writer.Status()),
            Status:    fmt.Sprintf("completed in %v", duration),
            RequestID: requestID,
            Severity:  "info",
        }
        
        am.auditManager.LogEvent(statusEvent)
    }
}

func (am *AuditMiddleware) getUserInfo(c *gin.Context) (string, string) {
    // 从上下文中获取用户信息（需要与认证系统集成）
    userID, _ := c.Get("user_id")
    userName, _ := c.Get("username")
    
    userIDStr, _ := userID.(string)
    userNameStr, _ := userName.(string)
    
    return userIDStr, userNameStr
}

func generateRequestID() string {
    hash := sha256.Sum256([]byte(fmt.Sprintf("%d", time.Now().UnixNano())))
    return hex.EncodeToString(hash[:8])
}

// 安全日志分析器
type SecurityAnalyzer struct {
    auditManager *AuditManager
}

func NewSecurityAnalyzer(auditManager *AuditManager) *SecurityAnalyzer {
    return &SecurityAnalyzer{auditManager: auditManager}
}

func (sa *SecurityAnalyzer) AnalyzeSecurityEvents() {
    // 分析安全相关事件
    filter := &AuditQueryFilter{
        FromTime: time.Now().Add(-24 * time.Hour),
    }
    
    events, err := sa.auditManager.QueryEvents(filter)
    if err != nil {
        log.Printf("Failed to query audit events: %v", err)
        return
    }
    
    // 分析异常行为
    sa.analyzeFailedLogins(events)
    sa.analyzeSuspiciousActivity(events)
    sa.analyzeSystemEvents(events)
}

func (sa *SecurityAnalyzer) analyzeFailedLogins(events []*AuditEvent) {
    failedLogins := make(map[string]int)
    
    for _, event := range events {
        if event.EventType == EventTypeLogin && event.Status == "failed" {
            key := fmt.Sprintf("%s:%s", event.IPAddress, event.UserName)
            failedLogins[key]++
        }
    }
    
    // 报告频繁失败的登录尝试
    for key, count := range failedLogins {
        if count > 5 {
            log.Printf("WARNING: Multiple failed login attempts from %s", key)
        }
    }
}

func (sa *SecurityAnalyzer) analyzeSuspiciousActivity(events []*AuditEvent) {
    // 分析可疑活动模式
    for _, event := range events {
        if sa.isSuspiciousEvent(event) {
            log.Printf("SUSPICIOUS: Suspicious activity detected - %s", event.ID)
        }
    }
}

func (sa *SecurityAnalyzer) isSuspiciousEvent(event *AuditEvent) bool {
    // 检查各种可疑模式
    suspiciousPatterns := []func(*AuditEvent) bool{
        sa.isUnusualTimeAccess,
        sa.isMultipleFailedActions,
        sa.isUnauthorizedAccess,
    }
    
    for _, pattern := range suspiciousPatterns {
        if pattern(event) {
            return true
        }
    }
    
    return false
}

func (sa *SecurityAnalyzer) isUnusualTimeAccess(event *AuditEvent) bool {
    // 检查非工作时间访问
    hour := event.Timestamp.Hour()
    return hour < 6 || hour > 22
}

func (sa *SecurityAnalyzer) isMultipleFailedActions(event *AuditEvent) bool {
    // 检查多次失败操作
    return strings.Contains(event.Status, "failed") && 
           strings.Contains(event.Status, "multiple")
}

func (sa *SecurityAnalyzer) isUnauthorizedAccess(event *AuditEvent) bool {
    // 检查未授权访问尝试
    return event.EventType == EventTypeAccess && 
           event.Status == "403"
}

func (sa *SecurityAnalyzer) analyzeSystemEvents(events []*AuditEvent) {
    // 分析系统级事件
    for _, event := range events {
        if event.EventType == EventTypeSystem {
            log.Printf("SYSTEM: %s - %s", event.Action, event.Details)
        }
    }
}

// 合规性检查器
type ComplianceChecker struct {
    auditManager *AuditManager
    requirements map[string]ComplianceRequirement
}

type ComplianceRequirement struct {
    Name        string
    Description string
    CheckFunc   func([]*AuditEvent) bool
    Frequency   time.Duration
}

func NewComplianceChecker(auditManager *AuditManager) *ComplianceChecker {
    return &ComplianceChecker{
        auditManager: auditManager,
        requirements: make(map[string]ComplianceRequirement),
    }
}

func (cc *ComplianceChecker) AddRequirement(req ComplianceRequirement) {
    cc.requirements[req.Name] = req
}

func (cc *ComplianceChecker) CheckCompliance() map[string]bool {
    results := make(map[string]bool)
    
    // 获取审计事件
    filter := &AuditQueryFilter{
        FromTime: time.Now().Add(-7 * 24 * time.Hour), // 最近7天
    }
    
    events, err := cc.auditManager.QueryEvents(filter)
    if err != nil {
        log.Printf("Failed to query audit events for compliance check: %v", err)
        return results
    }
    
    // 检查各项要求
    for name, req := range cc.requirements {
        results[name] = req.CheckFunc(events)
    }
    
    return results
}

// 审计报告生成器
type AuditReporter struct {
    auditManager *AuditManager
}

func NewAuditReporter(auditManager *AuditManager) *AuditReporter {
    return &AuditReporter{auditManager: auditManager}
}

func (ar *AuditReporter) GenerateDailyReport() string {
    filter := &AuditQueryFilter{
        FromTime: time.Now().Add(-24 * time.Hour),
    }
    
    events, err := ar.auditManager.QueryEvents(filter)
    if err != nil {
        return fmt.Sprintf("Failed to generate report: %v", err)
    }
    
    var report strings.Builder
    report.WriteString(fmt.Sprintf("Daily Audit Report - %s\n", time.Now().Format("2006-01-02")))
    report.WriteString("=====================================\n\n")
    
    // 统计各类事件
    eventStats := make(map[AuditEventType]int)
    for _, event := range events {
        eventStats[event.EventType]++
    }
    
    report.WriteString("Event Statistics:\n")
    for eventType, count := range eventStats {
        report.WriteString(fmt.Sprintf("  %s: %d\n", eventType, count))
    }
    
    report.WriteString(fmt.Sprintf("\nTotal Events: %d\n", len(events)))
    
    return report.String()
}

func (ar *AuditReporter) ExportToJSON(filePath string) error {
    filter := &AuditQueryFilter{
        FromTime: time.Now().Add(-24 * time.Hour),
    }
    
    events, err := ar.auditManager.QueryEvents(filter)
    if err != nil {
        return err
    }
    
    data, err := json.MarshalIndent(events, "", "  ")
    if err != nil {
        return err
    }
    
    return os.WriteFile(filePath, data, 0644)
}

// 审计示例应用
func AuditExample() {
    // 创建审计存储
    auditFile := "audit.log"
    storage := NewFileAuditLogStorage(auditFile)
    
    // 创建审计管理器
    auditManager := NewAuditManager(storage)
    
    // 创建Gin路由器
    r := gin.Default()
    
    // 创建审计中间件
    auditMiddleware := NewAuditMiddleware(auditManager)
    r.Use(auditMiddleware.Middleware())
    
    // 路由示例
    r.GET("/api/users", func(c *gin.Context) {
        // 记录用户查询事件
        event := &AuditEvent{
            EventType: EventTypeAccess,
            Action:    "query_users",
            Resource:  "/api/users",
            Status:    "success",
        }
        auditManager.LogEvent(event)
        
        c.JSON(200, gin.H{"users": []string{"user1", "user2"}})
    })
    
    r.POST("/api/login", func(c *gin.Context) {
        // 记录登录事件
        event := &AuditEvent{
            EventType: EventTypeLogin,
            Action:    "user_login",
            Resource:  "/api/login",
            Status:    "success",
            Details:   map[string]interface{}{"method": "password"},
        }
        auditManager.LogEvent(event)
        
        c.JSON(200, gin.H{"message": "login successful"})
    })
    
    // 安全分析器
    analyzer := NewSecurityAnalyzer(auditManager)
    go func() {
        ticker := time.NewTicker(1 * time.Hour)
        defer ticker.Stop()
        
        for range ticker.C {
            analyzer.AnalyzeSecurityEvents()
        }
    }()
    
    // 合规性检查器
    complianceChecker := NewComplianceChecker(auditManager)
    complianceChecker.AddRequirement(ComplianceRequirement{
        Name:        "login_auditing",
        Description: "All login attempts must be audited",
        CheckFunc: func(events []*AuditEvent) bool {
            // 检查是否有登录审计记录
            for _, event := range events {
                if event.EventType == EventTypeLogin {
                    return true
                }
            }
            return false
        },
        Frequency: 24 * time.Hour,
    })
    
    // 审计报告器
    reporter := NewAuditReporter(auditManager)
    
    // 定期生成报告
    go func() {
        ticker := time.NewTicker(24 * time.Hour)
        defer ticker.Stop()
        
        for range ticker.C {
            report := reporter.GenerateDailyReport()
            fmt.Println(report)
            
            // 导出JSON报告
            fileName := fmt.Sprintf("audit_report_%s.json", time.Now().Format("20060102"))
            reporter.ExportToJSON(fileName)
        }
    }()
    
    // 显示审计功能
    fmt.Println("=== 审计系统已启动 ===")
    fmt.Printf("审计日志文件: %s\n", auditFile)
    
    // 模拟一些审计事件
    simulateAuditEvents(auditManager)
    
    // 合规性检查示例
    complianceResults := complianceChecker.CheckCompliance()
    fmt.Println("\n=== 合规性检查结果 ===")
    for requirement, passed := range complianceResults {
        status := "PASSED"
        if !passed {
            status = "FAILED"
        }
        fmt.Printf("%s: %s\n", requirement, status)
    }
    
    // 审计最佳实践
    auditBestPractices()
}

func simulateAuditEvents(auditManager *AuditManager) {
    events := []*AuditEvent{
        {
            EventType: EventTypeLogin,
            UserID:    "user123",
            UserName:  "john_doe",
            IPAddress: "192.168.1.100",
            Resource:  "/api/login",
            Action:    "login",
            Status:    "success",
            Severity:  "info",
        },
        {
            EventType: EventTypeAccess,
            UserID:    "user123",
            UserName:  "john_doe",
            IPAddress: "192.168.1.100",
            Resource:  "/api/users",
            Action:    "GET",
            Status:    "success",
            Severity:  "info",
        },
        {
            EventType: EventTypeModify,
            UserID:    "user123",
            UserName:  "john_doe",
            IPAddress: "192.168.1.100",
            Resource:  "/api/users/456",
            Action:    "PUT",
            Status:    "success",
            Severity:  "medium",
        },
        {
            EventType: EventTypeSecurity,
            UserID:    "user123",
            UserName:  "john_doe",
            IPAddress: "192.168.1.100",
            Resource:  "/api/sensitive",
            Action:    "access",
            Status:    "denied",
            Severity:  "high",
            Details:   "Access to sensitive resource denied",
        },
    }
    
    for _, event := range events {
        auditManager.LogEvent(event)
    }
    
    fmt.Println("模拟审计事件已记录")
}

func auditBestPractices() {
    fmt.Println("\n=== 审计最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "完整事件记录",
            "记录所有重要安全相关事件",
        },
        {
            "不可篡改日志",
            "使用不可变日志存储防止篡改",
        },
        {
            "实时监控",
            "实时分析审计日志检测异常",
        },
        {
            "定期审查",
            "定期审查审计日志和报告",
        },
        {
            "合规性检查",
            "确保符合相关法规要求",
        },
        {
            "日志轮换",
            "实施日志轮换和归档策略",
        },
        {
            "访问控制",
            "限制审计日志的访问权限",
        },
        {
            "告警机制",
            "建立异常事件告警机制",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}
```

### 漏洞扫描

#### 漏洞扫描实现
```go
package main

import (
    "crypto/tls"
    "encoding/json"
    "fmt"
    "net/http"
    "net/url"
    "regexp"
    "strings"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
)

// 漏洞类型定义
type VulnerabilityType string

const (
    VulnSQLInjection      VulnerabilityType = "SQL_INJECTION"
    VulnXSS               VulnerabilityType = "XSS"
    VulnCSRF              VulnerabilityType = "CSRF"
    VulnCommandInjection  VulnerabilityType = "COMMAND_INJECTION"
    VulnPathTraversal     VulnerabilityType = "PATH_TRAVERSAL"
    VulnInsecureHeaders   VulnerabilityType = "INSECURE_HEADERS"
    VulnWeakCrypto        VulnerabilityType = "WEAK_CRYPTO"
    VulnOpenRedirect      VulnerabilityType = "OPEN_REDIRECT"
    VulnInformationLeak   VulnerabilityType = "INFORMATION_LEAK"
    VulnMisconfiguration  VulnerabilityType = "MISCONFIGURATION"
)

// 漏洞严重程度
type Severity string

const (
    SeverityCritical Severity = "CRITICAL"
    SeverityHigh     Severity = "HIGH"
    SeverityMedium   Severity = "MEDIUM"
    SeverityLow      Severity = "LOW"
    SeverityInfo     Severity = "INFO"
)

// 漏洞信息
type Vulnerability struct {
    ID          string           `json:"id"`
    Type        VulnerabilityType `json:"type"`
    Severity    Severity         `json:"severity"`
    Title       string           `json:"title"`
    Description string           `json:"description"`
    URL         string           `json:"url"`
    Parameter   string           `json:"parameter,omitempty"`
    Evidence    string           `json:"evidence,omitempty"`
    Remediation string           `json:"remediation,omitempty"`
    Timestamp   time.Time        `json:"timestamp"`
    Scanner     string           `json:"scanner"`
}

// 扫描配置
type ScanConfig struct {
    TargetURL     string
    Concurrent    int
    Timeout       time.Duration
    UserAgent     string
    FollowRedirects bool
    CustomHeaders map[string]string
    ScanTypes     []VulnerabilityType
}

// 默认扫描配置
func DefaultScanConfig() *ScanConfig {
    return &ScanConfig{
        Concurrent:      10,
        Timeout:         30 * time.Second,
        UserAgent:       "Security-Scanner/1.0",
        FollowRedirects: true,
        CustomHeaders:   make(map[string]string),
        ScanTypes: []VulnerabilityType{
            VulnSQLInjection,
            VulnXSS,
            VulnCSRF,
            VulnCommandInjection,
            VulnPathTraversal,
            VulnInsecureHeaders,
            VulnOpenRedirect,
            VulnInformationLeak,
        },
    }
}

// 漏洞扫描器接口
type VulnerabilityScanner interface {
    Scan(config *ScanConfig) ([]*Vulnerability, error)
    GetType() VulnerabilityType
}

// SQL注入扫描器
type SQLInjectionScanner struct {
    payloads []string
    patterns []*regexp.Regexp
}

func NewSQLInjectionScanner() *SQLInjectionScanner {
    return &SQLInjectionScanner{
        payloads: []string{
            "' OR '1'='1",
            "' OR 1=1--",
            "'; DROP TABLE users--",
            "' UNION SELECT * FROM users--",
            "1' ORDER BY 1--",
        },
        patterns: []*regexp.Regexp{
            regexp.MustCompile(`(?i)sql syntax.*mysql`),
            regexp.MustCompile(`(?i)warning.*mysql`),
            regexp.MustCompile(`(?i)unclosed quotation`),
            regexp.MustCompile(`(?i)quoted string not properly terminated`),
            regexp.MustCompile(`(?i)sql server.*error`),
        },
    }
}

func (sis *SQLInjectionScanner) Scan(config *ScanConfig) ([]*Vulnerability, error) {
    var vulnerabilities []*Vulnerability
    
    // 解析目标URL
    targetURL, err := url.Parse(config.TargetURL)
    if err != nil {
        return nil, err
    }
    
    // 测试GET参数
    vulnerabilities = append(vulnerabilities, sis.testGETParameters(targetURL, config)...)
    
    // 测试POST参数
    vulnerabilities = append(vulnerabilities, sis.testPOSTParameters(targetURL, config)...)
    
    return vulnerabilities, nil
}

func (sis *SQLInjectionScanner) testGETParameters(baseURL *url.URL, config *ScanConfig) []*Vulnerability {
    var vulnerabilities []*Vulnerability
    
    // 获取原始查询参数
    params := baseURL.Query()
    
    // 测试每个参数
    for paramName := range params {
        for _, payload := range sis.payloads {
            // 创建测试URL
            testURL := *baseURL
            testParams := testURL.Query()
            testParams.Set(paramName, payload)
            testURL.RawQuery = testParams.Encode()
            
            // 发送请求
            client := sis.createHTTPClient(config)
            resp, err := client.Get(testURL.String())
            if err != nil {
                continue
            }
            
            // 检查响应
            if sis.isVulnerable(resp) {
                vulnerabilities = append(vulnerabilities, &Vulnerability{
                    ID:          generateVulnerabilityID(),
                    Type:        VulnSQLInjection,
                    Severity:    SeverityHigh,
                    Title:       "SQL Injection Vulnerability",
                    Description: fmt.Sprintf("Parameter '%s' is vulnerable to SQL injection", paramName),
                    URL:         testURL.String(),
                    Parameter:   paramName,
                    Evidence:    payload,
                    Remediation: "Use parameterized queries and input validation",
                    Timestamp:   time.Now(),
                    Scanner:     "SQLInjectionScanner",
                })
            }
        }
    }
    
    return vulnerabilities
}

func (sis *SQLInjectionScanner) testPOSTParameters(baseURL *url.URL, config *ScanConfig) []*Vulnerability {
    // POST参数测试实现
    return []*Vulnerability{}
}

func (sis *SQLInjectionScanner) createHTTPClient(config *ScanConfig) *http.Client {
    transport := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   config.Timeout,
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
            if config.FollowRedirects {
                return nil
            }
            return http.ErrUseLastResponse
        },
    }
}

func (sis *SQLInjectionScanner) isVulnerable(resp *http.Response) bool {
    // 检查响应内容是否包含SQL错误模式
    // 这里简化实现，实际应用中需要更复杂的检测逻辑
    return false
}

func (sis *SQLInjectionScanner) GetType() VulnerabilityType {
    return VulnSQLInjection
}

// XSS扫描器
type XSSScanner struct {
    payloads []string
    patterns []*regexp.Regexp
}

func NewXSSScanner() *XSSScanner {
    return &XSSScanner{
        payloads: []string{
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "';alert('XSS');//",
        },
        patterns: []*regexp.Regexp{
            regexp.MustCompile(`<script[^>]*>.*?</script>`),
            regexp.MustCompile(`on\w+\s*=`),
            regexp.MustCompile(`javascript:`),
            regexp.MustCompile(`<[^>]*on\w+\s*=[^>]*>`),
        },
    }
}

func (xs *XSSScanner) Scan(config *ScanConfig) ([]*Vulnerability, error) {
    var vulnerabilities []*Vulnerability
    
    targetURL, err := url.Parse(config.TargetURL)
    if err != nil {
        return nil, err
    }
    
    vulnerabilities = append(vulnerabilities, xs.testParameters(targetURL, config)...)
    
    return vulnerabilities, nil
}

func (xs *XSSScanner) testParameters(baseURL *url.URL, config *ScanConfig) []*Vulnerability {
    var vulnerabilities []*Vulnerability
    
    // 测试GET参数
    params := baseURL.Query()
    for paramName := range params {
        for _, payload := range xs.payloads {
            testURL := *baseURL
            testParams := testURL.Query()
            testParams.Set(paramName, payload)
            testURL.RawQuery = testParams.Encode()
            
            client := xs.createHTTPClient(config)
            resp, err := client.Get(testURL.String())
            if err != nil {
                continue
            }
            
            if xs.isVulnerable(resp, payload) {
                vulnerabilities = append(vulnerabilities, &Vulnerability{
                    ID:          generateVulnerabilityID(),
                    Type:        VulnXSS,
                    Severity:    SeverityMedium,
                    Title:       "Cross-Site Scripting (XSS)",
                    Description: fmt.Sprintf("Parameter '%s' is vulnerable to XSS", paramName),
                    URL:         testURL.String(),
                    Parameter:   paramName,
                    Evidence:    payload,
                    Remediation: "Encode output and validate input",
                    Timestamp:   time.Now(),
                    Scanner:     "XSSScanner",
                })
            }
        }
    }
    
    return vulnerabilities
}

func (xs *XSSScanner) createHTTPClient(config *ScanConfig) *http.Client {
    transport := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   config.Timeout,
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
            if config.FollowRedirects {
                return nil
            }
            return http.ErrUseLastResponse
        },
    }
}

func (xs *XSSScanner) isVulnerable(resp *http.Response, payload string) bool {
    // 检查响应中是否包含payload
    return false
}

func (xs *XSSScanner) GetType() VulnerabilityType {
    return VulnXSS
}

// 安全头扫描器
type SecurityHeadersScanner struct {
    requiredHeaders map[string]string
}

func NewSecurityHeadersScanner() *SecurityHeadersScanner {
    return &SecurityHeadersScanner{
        requiredHeaders: map[string]string{
            "X-Frame-Options":           "",
            "X-Content-Type-Options":    "nosniff",
            "X-XSS-Protection":          "1; mode=block",
            "Strict-Transport-Security": "",
            "Content-Security-Policy":   "",
        },
    }
}

func (shs *SecurityHeadersScanner) Scan(config *ScanConfig) ([]*Vulnerability, error) {
    var vulnerabilities []*Vulnerability
    
    client := shs.createHTTPClient(config)
    resp, err := client.Get(config.TargetURL)
    if err != nil {
        return nil, err
    }
    
    vulnerabilities = append(vulnerabilities, shs.checkHeaders(resp)...)
    
    return vulnerabilities, nil
}

func (shs *SecurityHeadersScanner) checkHeaders(resp *http.Response) []*Vulnerability {
    var vulnerabilities []*Vulnerability
    
    for headerName, expectedValue := range shs.requiredHeaders {
        actualValue := resp.Header.Get(headerName)
        
        if actualValue == "" {
            vulnerabilities = append(vulnerabilities, &Vulnerability{
                ID:          generateVulnerabilityID(),
                Type:        VulnInsecureHeaders,
                Severity:    SeverityMedium,
                Title:       fmt.Sprintf("Missing Security Header: %s", headerName),
                Description: fmt.Sprintf("Security header '%s' is missing", headerName),
                URL:         resp.Request.URL.String(),
                Evidence:    fmt.Sprintf("Header '%s' not found", headerName),
                Remediation: fmt.Sprintf("Add '%s' header to responses", headerName),
                Timestamp:   time.Now(),
                Scanner:     "SecurityHeadersScanner",
            })
        } else if expectedValue != "" && actualValue != expectedValue {
            vulnerabilities = append(vulnerabilities, &Vulnerability{
                ID:          generateVulnerabilityID(),
                Type:        VulnInsecureHeaders,
                Severity:    SeverityLow,
                Title:       fmt.Sprintf("Incorrect Security Header: %s", headerName),
                Description: fmt.Sprintf("Security header '%s' has incorrect value", headerName),
                URL:         resp.Request.URL.String(),
                Evidence:    fmt.Sprintf("Expected: '%s', Got: '%s'", expectedValue, actualValue),
                Remediation: fmt.Sprintf("Set '%s' header to correct value", headerName),
                Timestamp:   time.Now(),
                Scanner:     "SecurityHeadersScanner",
            })
        }
    }
    
    return vulnerabilities
}

func (shs *SecurityHeadersScanner) createHTTPClient(config *ScanConfig) *http.Client {
    transport := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    
    return &http.Client{
        Transport: transport,
        Timeout:   config.Timeout,
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
            if config.FollowRedirects {
                return nil
            }
            return http.ErrUseLastResponse
        },
    }
}

func (shs *SecurityHeadersScanner) GetType() VulnerabilityType {
    return VulnInsecureHeaders
}

// 漏洞扫描管理器
type VulnerabilityScannerManager struct {
    scanners map[VulnerabilityType]VulnerabilityScanner
    results  []*Vulnerability
    mutex    sync.RWMutex
}

func NewVulnerabilityScannerManager() *VulnerabilityScannerManager {
    manager := &VulnerabilityScannerManager{
        scanners: make(map[VulnerabilityType]VulnerabilityScanner),
        results:  make([]*Vulnerability, 0),
    }
    
    // 注册默认扫描器
    manager.RegisterScanner(NewSQLInjectionScanner())
    manager.RegisterScanner(NewXSSScanner())
    manager.RegisterScanner(NewSecurityHeadersScanner())
    
    return manager
}

func (vsm *VulnerabilityScannerManager) RegisterScanner(scanner VulnerabilityScanner) {
    vsm.scanners[scanner.GetType()] = scanner
}

func (vsm *VulnerabilityScannerManager) Scan(config *ScanConfig) ([]*Vulnerability, error) {
    var allVulnerabilities []*Vulnerability
    var wg sync.WaitGroup
    resultsChan := make(chan []*Vulnerability, len(config.ScanTypes))
    
    // 并发执行扫描
    for _, scanType := range config.ScanTypes {
        if scanner, exists := vsm.scanners[scanType]; exists {
            wg.Add(1)
            go func(s VulnerabilityScanner, c *ScanConfig) {
                defer wg.Done()
                vulnerabilities, err := s.Scan(c)
                if err != nil {
                    fmt.Printf("Scanner %s failed: %v\n", s.GetType(), err)
                    return
                }
                resultsChan <- vulnerabilities
            }(scanner, config)
        }
    }
    
    // 等待所有扫描完成
    go func() {
        wg.Wait()
        close(resultsChan)
    }()
    
    // 收集结果
    for vulnerabilities := range resultsChan {
        allVulnerabilities = append(allVulnerabilities, vulnerabilities...)
    }
    
    // 存储结果
    vsm.mutex.Lock()
    vsm.results = append(vsm.results, allVulnerabilities...)
    vsm.mutex.Unlock()
    
    return allVulnerabilities, nil
}

func (vsm *VulnerabilityScannerManager) GetResults() []*Vulnerability {
    vsm.mutex.RLock()
    defer vsm.mutex.RUnlock()
    
    results := make([]*Vulnerability, len(vsm.results))
    copy(results, vsm.results)
    return results
}

func (vsm *VulnerabilityScannerManager) ClearResults() {
    vsm.mutex.Lock()
    defer vsm.mutex.Unlock()
    vsm.results = make([]*Vulnerability, 0)
}

func (vsm *VulnerabilityScannerManager) GetResultsBySeverity(severity Severity) []*Vulnerability {
    vsm.mutex.RLock()
    defer vsm.mutex.RUnlock()
    
    var filtered []*Vulnerability
    for _, vuln := range vsm.results {
        if vuln.Severity == severity {
            filtered = append(filtered, vuln)
        }
    }
    return filtered
}

// 扫描报告生成器
type ScanReportGenerator struct{}

func NewScanReportGenerator() *ScanReportGenerator {
    return &ScanReportGenerator{}
}

func (srg *ScanReportGenerator) GenerateJSONReport(vulnerabilities []*Vulnerability) ([]byte, error) {
    report := map[string]interface{}{
        "scan_timestamp": time.Now(),
        "total_vulnerabilities": len(vulnerabilities),
        "vulnerabilities": vulnerabilities,
        "summary": srg.generateSummary(vulnerabilities),
    }
    
    return json.MarshalIndent(report, "", "  ")
}

func (srg *ScanReportGenerator) generateSummary(vulnerabilities []*Vulnerability) map[string]interface{} {
    summary := make(map[string]int)
    
    for _, vuln := range vulnerabilities {
        summary[string(vuln.Severity)]++
    }
    
    return summary
}

func (srg *ScanReportGenerator) GenerateTextReport(vulnerabilities []*Vulnerability) string {
    var report strings.Builder
    
    report.WriteString(fmt.Sprintf("Vulnerability Scan Report - %s\n", time.Now().Format(time.RFC3339)))
    report.WriteString("========================================\n\n")
    
    report.WriteString(fmt.Sprintf("Total Vulnerabilities: %d\n\n", len(vulnerabilities)))
    
    // 按严重程度分组
    severityGroups := map[Severity][]*Vulnerability{
        SeverityCritical: make([]*Vulnerability, 0),
        SeverityHigh:     make([]*Vulnerability, 0),
        SeverityMedium:   make([]*Vulnerability, 0),
        SeverityLow:      make([]*Vulnerability, 0),
        SeverityInfo:     make([]*Vulnerability, 0),
    }
    
    for _, vuln := range vulnerabilities {
        severityGroups[vuln.Severity] = append(severityGroups[vuln.Severity], vuln)
    }
    
    severities := []Severity{SeverityCritical, SeverityHigh, SeverityMedium, SeverityLow, SeverityInfo}
    for _, severity := range severities {
        vulns := severityGroups[severity]
        if len(vulns) > 0 {
            report.WriteString(fmt.Sprintf("\n%s Vulnerabilities (%d):\n", severity, len(vulns)))
            report.WriteString(strings.Repeat("-", 30) + "\n")
            
            for _, vuln := range vulns {
                report.WriteString(fmt.Sprintf("  [%s] %s\n", vuln.Type, vuln.Title))
                report.WriteString(fmt.Sprintf("    URL: %s\n", vuln.URL))
                if vuln.Parameter != "" {
                    report.WriteString(fmt.Sprintf("    Parameter: %s\n", vuln.Parameter))
                }
                report.WriteString(fmt.Sprintf("    Remediation: %s\n\n", vuln.Remediation))
            }
        }
    }
    
    return report.String()
}

// 漏洞扫描示例应用
func VulnerabilityScanningExample() {
    // 创建扫描管理器
    scannerManager := NewVulnerabilityScannerManager()
    
    // 创建扫描配置
    config := DefaultScanConfig()
    config.TargetURL = "http://localhost:8080"
    config.Concurrent = 5
    config.Timeout = 10 * time.Second
    
    // 启动测试服务器
    go startTestServer()
    time.Sleep(100 * time.Millisecond) // 等待服务器启动
    
    // 执行扫描
    fmt.Println("开始漏洞扫描...")
    vulnerabilities, err := scannerManager.Scan(config)
    if err != nil {
        fmt.Printf("扫描失败: %v\n", err)
        return
    }
    
    fmt.Printf("扫描完成，发现 %d 个漏洞\n", len(vulnerabilities))
    
    // 显示结果
    for _, vuln := range vulnerabilities {
        fmt.Printf("[%s] %s - %s\n", vuln.Severity, vuln.Type, vuln.Title)
        fmt.Printf("  URL: %s\n", vuln.URL)
        if vuln.Parameter != "" {
            fmt.Printf("  参数: %s\n", vuln.Parameter)
        }
        fmt.Printf("  证据: %s\n", vuln.Evidence)
        fmt.Printf("  修复建议: %s\n\n", vuln.Remediation)
    }
    
    // 生成报告
    reportGenerator := NewScanReportGenerator()
    
    // JSON报告
    jsonReport, err := reportGenerator.GenerateJSONReport(vulnerabilities)
    if err != nil {
        fmt.Printf("生成JSON报告失败: %v\n", err)
    } else {
        fmt.Printf("JSON报告已生成，大小: %d 字节\n", len(jsonReport))
    }
    
    // 文本报告
    textReport := reportGenerator.GenerateTextReport(vulnerabilities)
    fmt.Println("\n=== 扫描报告 ===")
    fmt.Println(textReport)
    
    // 漏洞扫描最佳实践
    vulnerabilityScanningBestPractices()
}

func startTestServer() {
    r := gin.Default()
    
    r.GET("/test", func(c *gin.Context) {
        name := c.Query("name")
        c.HTML(200, "test.html", gin.H{
            "name": name,
        })
    })
    
    r.POST("/login", func(c *gin.Context) {
        username := c.PostForm("username")
        password := c.PostForm("password")
        c.JSON(200, gin.H{
            "username": username,
            "password": password,
        })
    })
    
    r.Run(":8080")
}

func generateVulnerabilityID() string {
    return fmt.Sprintf("VULN-%d", time.Now().UnixNano())
}

func vulnerabilityScanningBestPractices() {
    fmt.Println("\n=== 漏洞扫描最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "定期扫描",
            "定期执行安全扫描，包括自动化和手动测试",
        },
        {
            "多层防护",
            "结合静态分析、动态扫描和人工测试",
        },
        {
            "权限控制",
            "扫描时使用最小权限原则",
        },
        {
            "环境隔离",
            "在隔离环境中进行扫描测试",
        },
        {
            "结果验证",
            "验证扫描结果避免误报和漏报",
        },
        {
            "持续集成",
            "将安全扫描集成到CI/CD流程中",
        },
        {
            "报告管理",
            "建立漏洞报告和跟踪机制",
        },
        {
            "修复优先级",
            "根据严重程度优先修复高危漏洞",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}
```

### 安全测试

#### 安全测试实现
```go
package main

import (
    "crypto/rand"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "net/http"
    "net/http/httptest"
    "regexp"
    "strings"
    "testing"
    "time"
    
    "github.com/gin-gonic/gin"
)

// 安全测试套件
type SecurityTestSuite struct {
    tests []SecurityTest
}

// 安全测试接口
type SecurityTest interface {
    Name() string
    Description() string
    Run() *TestResult
}

// 测试结果
type TestResult struct {
    TestName    string
    Passed      bool
    Severity    string
    Description string
    Evidence    string
    Remediation string
    Duration    time.Duration
}

// XSS测试
type XSSTest struct {
    router *gin.Engine
    url    string
}

func NewXSSTest(router *gin.Engine, url string) *XSSTest {
    return &XSSTest{router: router, url: url}
}

func (xt *XSSTest) Name() string {
    return "XSS Security Test"
}

func (xt *XSSTest) Description() string {
    return "Tests for Cross-Site Scripting vulnerabilities"
}

func (xt *XSSTest) Run() *TestResult {
    start := time.Now()
    
    // XSS测试载荷
    payloads := []string{
        "<script>alert('XSS')</script>",
        "javascript:alert('XSS')",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "';alert('XSS');//",
    }
    
    for _, payload := range payloads {
        if xt.testPayload(payload) {
            return &TestResult{
                TestName:    xt.Name(),
                Passed:      false,
                Severity:    "HIGH",
                Description: "XSS vulnerability detected",
                Evidence:    fmt.Sprintf("Payload '%s' was not properly sanitized", payload),
                Remediation: "Implement proper input validation and output encoding",
                Duration:    time.Since(start),
            }
        }
    }
    
    return &TestResult{
        TestName:    xt.Name(),
        Passed:      true,
        Severity:    "INFO",
        Description: "No XSS vulnerabilities found",
        Duration:    time.Since(start),
    }
}

func (xt *XSSTest) testPayload(payload string) bool {
    // 创建测试请求
    req, _ := http.NewRequest("GET", xt.url+"?input="+payload, nil)
    w := httptest.NewRecorder()
    
    // 执行请求
    xt.router.ServeHTTP(w, req)
    
    // 检查响应中是否包含未转义的payload
    response := w.Body.String()
    return strings.Contains(response, payload) && !strings.Contains(response, "&lt;")
}

// SQL注入测试
type SQLInjectionTest struct {
    router *gin.Engine
    url    string
}

func NewSQLInjectionTest(router *gin.Engine, url string) *SQLInjectionTest {
    return &SQLInjectionTest{router: router, url: url}
}

func (sit *SQLInjectionTest) Name() string {
    return "SQL Injection Test"
}

func (sit *SQLInjectionTest) Description() string {
    return "Tests for SQL Injection vulnerabilities"
}

func (sit *SQLInjectionTest) Run() *TestResult {
    start := time.Now()
    
    // SQL注入测试载荷
    payloads := []string{
        "' OR '1'='1",
        "' OR 1=1--",
        "'; DROP TABLE users--",
        "' UNION SELECT * FROM users--",
        "1' ORDER BY 1--",
    }
    
    errorPatterns := []*regexp.Regexp{
        regexp.MustCompile(`(?i)sql syntax.*mysql`),
        regexp.MustCompile(`(?i)warning.*mysql`),
        regexp.MustCompile(`(?i)unclosed quotation`),
        regexp.MustCompile(`(?i)quoted string not properly terminated`),
        regexp.MustCompile(`(?i)sql server.*error`),
    }
    
    for _, payload := range payloads {
        if sit.testPayload(payload, errorPatterns) {
            return &TestResult{
                TestName:    sit.Name(),
                Passed:      false,
                Severity:    "CRITICAL",
                Description: "SQL Injection vulnerability detected",
                Evidence:    fmt.Sprintf("Payload '%s' caused SQL error", payload),
                Remediation: "Use parameterized queries and input validation",
                Duration:    time.Since(start),
            }
        }
    }
    
    return &TestResult{
        TestName:    sit.Name(),
        Passed:      true,
        Severity:    "INFO",
        Description: "No SQL Injection vulnerabilities found",
        Duration:    time.Since(start),
    }
}

func (sit *SQLInjectionTest) testPayload(payload string, errorPatterns []*regexp.Regexp) bool {
    // 创建测试请求
    req, _ := http.NewRequest("GET", sit.url+"?id="+payload, nil)
    w := httptest.NewRecorder()
    
    // 执行请求
    sit.router.ServeHTTP(w, req)
    
    // 检查响应中是否包含SQL错误信息
    response := strings.ToLower(w.Body.String())
    for _, pattern := range errorPatterns {
        if pattern.MatchString(response) {
            return true
        }
    }
    
    return false
}

// CSRF测试
type CSRFTest struct {
    router *gin.Engine
    url    string
}

func NewCSRFTest(router *gin.Engine, url string) *CSRFTest {
    return &CSRFTest{router: router, url: url}
}

func (ct *CSRFTest) Name() string {
    return "CSRF Protection Test"
}

func (ct *CSRFTest) Description() string {
    return "Tests for Cross-Site Request Forgery protection"
}

func (ct *CSRFTest) Run() *TestResult {
    start := time.Now()
    
    // 测试POST请求是否需要CSRF令牌
    req, _ := http.NewRequest("POST", ct.url, strings.NewReader("data=test"))
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
    w := httptest.NewRecorder()
    
    // 执行请求
    ct.router.ServeHTTP(w, req)
    
    // 检查响应状态码
    if w.Code == 200 || w.Code == 302 {
        return &TestResult{
            TestName:    ct.Name(),
            Passed:      false,
            Severity:    "HIGH",
            Description: "CSRF protection missing",
            Evidence:    "POST request was processed without CSRF token",
            Remediation: "Implement CSRF protection tokens",
            Duration:    time.Since(start),
        }
    }
    
    return &TestResult{
        TestName:    ct.Name(),
        Passed:      true,
        Severity:    "INFO",
        Description: "CSRF protection is in place",
        Duration:    time.Since(start),
    }
}

// 安全头测试
type SecurityHeadersTest struct {
    router *gin.Engine
    url    string
}

func NewSecurityHeadersTest(router *gin.Engine, url string) *SecurityHeadersTest {
    return &SecurityHeadersTest{router: router, url: url}
}

func (sht *SecurityHeadersTest) Name() string {
    return "Security Headers Test"
}

func (sht *SecurityHeadersTest) Description() string {
    return "Tests for security-related HTTP headers"
}

func (sht *SecurityHeadersTest) Run() *TestResult {
    start := time.Now()
    
    // 创建测试请求
    req, _ := http.NewRequest("GET", sht.url, nil)
    w := httptest.NewRecorder()
    
    // 执行请求
    sht.router.ServeHTTP(w, req)
    
    // 检查必需的安全头
    requiredHeaders := map[string]string{
        "X-Frame-Options":        "DENY",
        "X-Content-Type-Options": "nosniff",
        "X-XSS-Protection":       "1; mode=block",
    }
    
    missingHeaders := make([]string, 0)
    incorrectHeaders := make([]string, 0)
    
    for header, expectedValue := range requiredHeaders {
        actualValue := w.Header().Get(header)
        if actualValue == "" {
            missingHeaders = append(missingHeaders, header)
        } else if expectedValue != "" && actualValue != expectedValue {
            incorrectHeaders = append(incorrectHeaders, header)
        }
    }
    
    if len(missingHeaders) > 0 || len(incorrectHeaders) > 0 {
        evidence := ""
        if len(missingHeaders) > 0 {
            evidence += fmt.Sprintf("Missing headers: %v", missingHeaders)
        }
        if len(incorrectHeaders) > 0 {
            evidence += fmt.Sprintf(" Incorrect headers: %v", incorrectHeaders)
        }
        
        return &TestResult{
            TestName:    sht.Name(),
            Passed:      false,
            Severity:    "MEDIUM",
            Description: "Missing or incorrect security headers",
            Evidence:    evidence,
            Remediation: "Add required security headers to responses",
            Duration:    time.Since(start),
        }
    }
    
    return &TestResult{
        TestName:    sht.Name(),
        Passed:      true,
        Severity:    "INFO",
        Description: "All required security headers are present",
        Duration:    time.Since(start),
    }
}

// 认证测试
type AuthenticationTest struct {
    router *gin.Engine
    url    string
}

func NewAuthenticationTest(router *gin.Engine, url string) *AuthenticationTest {
    return &AuthenticationTest{router: router, url: url}
}

func (at *AuthenticationTest) Name() string {
    return "Authentication Test"
}

func (at *AuthenticationTest) Description() string {
    return "Tests for authentication and authorization"
}

func (at *AuthenticationTest) Run() *TestResult {
    start := time.Now()
    
    // 测试未认证访问受保护资源
    req, _ := http.NewRequest("GET", at.url, nil)
    w := httptest.NewRecorder()
    
    // 执行请求
    at.router.ServeHTTP(w, req)
    
    // 检查响应状态码
    if w.Code == 200 {
        return &TestResult{
            TestName:    at.Name(),
            Passed:      false,
            Severity:    "HIGH",
            Description: "Unauthenticated access to protected resource",
            Evidence:    "Protected resource accessible without authentication",
            Remediation: "Implement proper authentication and authorization",
            Duration:    time.Since(start),
        }
    }
    
    return &TestResult{
        TestName:    at.Name(),
        Passed:      true,
        Severity:    "INFO",
        Description: "Authentication is properly enforced",
        Duration:    time.Since(start),
    }
}

// 输入验证测试
type InputValidationTest struct {
    router *gin.Engine
    url    string
}

func NewInputValidationTest(router *gin.Engine, url string) *InputValidationTest {
    return &InputValidationTest{router: router, url: url}
}

func (ivt *InputValidationTest) Name() string {
    return "Input Validation Test"
}

func (ivt *InputValidationTest) Description() string {
    return "Tests for input validation and sanitization"
}

func (ivt *InputValidationTest) Run() *TestResult {
    start := time.Now()
    
    // 测试超长输入
    longInput := strings.Repeat("A", 10000)
    req, _ := http.NewRequest("POST", ivt.url, strings.NewReader("input="+longInput))
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
    w := httptest.NewRecorder()
    
    // 执行请求
    ivt.router.ServeHTTP(w, req)
    
    // 检查响应状态码
    if w.Code == 500 {
        return &TestResult{
            TestName:    ivt.Name(),
            Passed:      false,
            Severity:    "MEDIUM",
            Description: "Application crashed with large input",
            Evidence:    "Server returned 500 error with large input",
            Remediation: "Implement proper input length validation",
            Duration:    time.Since(start),
        }
    }
    
    return &TestResult{
        TestName:    ivt.Name(),
        Passed:      true,
        Severity:    "INFO",
        Description: "Input validation is properly implemented",
        Duration:    time.Since(start),
    }
}

// 安全测试管理器
type SecurityTestManager struct {
    tests []SecurityTest
}

func NewSecurityTestManager() *SecurityTestManager {
    return &SecurityTestManager{
        tests: make([]SecurityTest, 0),
    }
}

func (stm *SecurityTestManager) AddTest(test SecurityTest) {
    stm.tests = append(stm.tests, test)
}

func (stm *SecurityTestManager) RunAllTests() []*TestResult {
    results := make([]*TestResult, 0, len(stm.tests))
    
    for _, test := range stm.tests {
        result := test.Run()
        results = append(results, result)
        fmt.Printf("Running %s... %s\n", test.Name(), statusEmoji(result.Passed))
    }
    
    return results
}

func (stm *SecurityTestManager) RunTestByName(name string) *TestResult {
    for _, test := range stm.tests {
        if test.Name() == name {
            return test.Run()
        }
    }
    return nil
}

func (stm *SecurityTestManager) GetTestResultsBySeverity(severity string) []*TestResult {
    var results []*TestResult
    for _, test := range stm.tests {
        result := test.Run()
        if result.Severity == severity {
            results = append(results, result)
        }
    }
    return results
}

// 测试报告生成器
type TestReportGenerator struct{}

func NewTestReportGenerator() *TestReportGenerator {
    return &TestReportGenerator{}
}

func (trg *TestReportGenerator) GenerateReport(results []*TestResult) string {
    var report strings.Builder
    
    report.WriteString(fmt.Sprintf("Security Test Report - %s\n", time.Now().Format(time.RFC3339)))
    report.WriteString("========================================\n\n")
    
    totalTests := len(results)
    passedTests := 0
    failedTests := 0
    
    // 统计结果
    for _, result := range results {
        if result.Passed {
            passedTests++
        } else {
            failedTests++
        }
    }
    
    report.WriteString(fmt.Sprintf("Total Tests: %d\n", totalTests))
    report.WriteString(fmt.Sprintf("Passed: %d\n", passedTests))
    report.WriteString(fmt.Sprintf("Failed: %d\n\n", failedTests))
    
    // 按严重程度分组显示失败的测试
    severityOrder := []string{"CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"}
    
    for _, severity := range severityOrder {
        failedResults := make([]*TestResult, 0)
        for _, result := range results {
            if !result.Passed && result.Severity == severity {
                failedResults = append(failedResults, result)
            }
        }
        
        if len(failedResults) > 0 {
            report.WriteString(fmt.Sprintf("%s Issues (%d):\n", severity, len(failedResults)))
            report.WriteString(strings.Repeat("-", 20) + "\n")
            
            for _, result := range failedResults {
                report.WriteString(fmt.Sprintf("  [%s] %s\n", result.TestName, result.Description))
                report.WriteString(fmt.Sprintf("    Evidence: %s\n", result.Evidence))
                report.WriteString(fmt.Sprintf("    Remediation: %s\n", result.Remediation))
                report.WriteString(fmt.Sprintf("    Duration: %v\n\n", result.Duration))
            }
        }
    }
    
    // 显示通过的测试
    passedResults := make([]*TestResult, 0)
    for _, result := range results {
        if result.Passed {
            passedResults = append(passedResults, result)
        }
    }
    
    if len(passedResults) > 0 {
        report.WriteString(fmt.Sprintf("\nPassed Tests (%d):\n", len(passedResults)))
        report.WriteString(strings.Repeat("-", 15) + "\n")
        
        for _, result := range passedResults {
            report.WriteString(fmt.Sprintf("  [%s] %s\n", result.TestName, result.Description))
        }
    }
    
    return report.String()
}

func (trg *TestReportGenerator) GenerateJSONReport(results []*TestResult) ([]byte, error) {
    report := map[string]interface{}{
        "timestamp": time.Now(),
        "summary": map[string]int{
            "total":  len(results),
            "passed": countPassed(results),
            "failed": countFailed(results),
        },
        "results": results,
    }
    
    // 这里需要实现JSON序列化逻辑
    return []byte{}, nil
}

func countPassed(results []*TestResult) int {
    count := 0
    for _, result := range results {
        if result.Passed {
            count++
        }
    }
    return count
}

func countFailed(results []*TestResult) int {
    count := 0
    for _, result := range results {
        if !result.Passed {
            count++
        }
    }
    return count
}

// 持续安全测试
type ContinuousSecurityTester struct {
    testManager *SecurityTestManager
    interval    time.Duration
    stopChan    chan struct{}
}

func NewContinuousSecurityTester(testManager *SecurityTestManager, interval time.Duration) *ContinuousSecurityTester {
    return &ContinuousSecurityTester{
        testManager: testManager,
        interval:    interval,
        stopChan:    make(chan struct{}),
    }
}

func (cst *ContinuousSecurityTester) Start() {
    ticker := time.NewTicker(cst.interval)
    go func() {
        for {
            select {
            case <-ticker.C:
                fmt.Println("\n=== Running Continuous Security Tests ===")
                results := cst.testManager.RunAllTests()
                cst.processResults(results)
            case <-cst.stopChan:
                ticker.Stop()
                return
            }
        }
    }()
}

func (cst *ContinuousSecurityTester) Stop() {
    close(cst.stopChan)
}

func (cst *ContinuousSecurityTester) processResults(results []*TestResult) {
    failedCount := 0
    for _, result := range results {
        if !result.Passed {
            failedCount++
            fmt.Printf("❌ %s: %s\n", result.TestName, result.Description)
        }
    }
    
    if failedCount > 0 {
        fmt.Printf("⚠️  %d security issues detected!\n", failedCount)
    } else {
        fmt.Println("✅ All security tests passed!")
    }
}

// 辅助函数
func statusEmoji(passed bool) string {
    if passed {
        return "✅"
    }
    return "❌"
}

// 安全测试示例应用
func SecurityTestingExample() {
    // 创建测试路由器
    router := createTestRouter()
    
    // 创建测试管理器
    testManager := NewSecurityTestManager()
    
    // 添加测试
    testManager.AddTest(NewXSSTest(router, "/test"))
    testManager.AddTest(NewSQLInjectionTest(router, "/user"))
    testManager.AddTest(NewCSRFTest(router, "/transfer"))
    testManager.AddTest(NewSecurityHeadersTest(router, "/"))
    testManager.AddTest(NewAuthenticationTest(router, "/admin"))
    testManager.AddTest(NewInputValidationTest(router, "/submit"))
    
    // 运行所有测试
    fmt.Println("=== 运行安全测试 ===")
    results := testManager.RunAllTests()
    
    // 生成报告
    reportGenerator := NewTestReportGenerator()
    report := reportGenerator.GenerateReport(results)
    fmt.Println("\n" + report)
    
    // 显示测试统计
    fmt.Println("\n=== 测试统计 ===")
    showTestStatistics(results)
    
    // 持续测试示例
    fmt.Println("\n=== 启动持续安全测试 ===")
    continuousTester := NewContinuousSecurityTester(testManager, 30*time.Second)
    continuousTester.Start()
    defer continuousTester.Stop()
    
    // 运行一段时间后停止
    time.Sleep(2 * time.Second)
    
    // 安全测试最佳实践
    securityTestingBestPractices()
}

func createTestRouter() *gin.Engine {
    r := gin.Default()
    
    // 测试路由
    r.GET("/test", func(c *gin.Context) {
        input := c.Query("input")
        c.HTML(200, "test.html", gin.H{
            "input": input,
        })
    })
    
    r.GET("/user", func(c *gin.Context) {
        id := c.Query("id")
        // 模拟SQL查询
        c.JSON(200, gin.H{
            "id": id,
            "name": "test user",
        })
    })
    
    r.POST("/transfer", func(c *gin.Context) {
        // 模拟转账功能
        c.JSON(200, gin.H{
            "status": "success",
        })
    })
    
    r.GET("/", func(c *gin.Context) {
        // 设置安全头
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.JSON(200, gin.H{
            "message": "secure endpoint",
        })
    })
    
    r.GET("/admin", func(c *gin.Context) {
        // 模拟需要认证的端点
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.Status(401)
            return
        }
        c.JSON(200, gin.H{
            "message": "admin panel",
        })
    })
    
    r.POST("/submit", func(c *gin.Context) {
        input := c.PostForm("input")
        if len(input) > 1000 {
            c.Status(400)
            return
        }
        c.JSON(200, gin.H{
            "received": input,
        })
    })
    
    return r
}

func showTestStatistics(results []*TestResult) {
    total := len(results)
    passed := 0
    failed := 0
    
    severityCount := make(map[string]int)
    
    for _, result := range results {
        if result.Passed {
            passed++
        } else {
            failed++
        }
        severityCount[result.Severity]++
    }
    
    fmt.Printf("总计测试: %d\n", total)
    fmt.Printf("通过测试: %d (%.1f%%)\n", passed, float64(passed)/float64(total)*100)
    fmt.Printf("失败测试: %d (%.1f%%)\n", failed, float64(failed)/float64(total)*100)
    
    fmt.Println("\n按严重程度统计:")
    for severity, count := range severityCount {
        fmt.Printf("  %s: %d\n", severity, count)
    }
}

func securityTestingBestPractices() {
    fmt.Println("\n=== 安全测试最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "自动化测试",
            "将安全测试集成到CI/CD流程中",
        },
        {
            "多层测试",
            "结合单元测试、集成测试和端到端测试",
        },
        {
            "定期扫描",
            "定期执行安全扫描和渗透测试",
        },
        {
            "威胁建模",
            "基于威胁模型设计测试用例",
        },
        {
            "边界测试",
            "测试输入边界和异常情况",
        },
        {
            "权限测试",
            "验证不同权限级别的访问控制",
        },
        {
            "回归测试",
            "确保安全修复不会引入新问题",
        },
        {
            "报告跟踪",
            "建立漏洞报告和修复跟踪机制",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}

// 示例测试函数
func ExampleSecurityTests() {
    // 这些函数可以在实际测试中使用
    fmt.Println("安全测试示例函数已定义")
}
```