## 3.2 高级函数特性

### 递归函数

```go
package main

import (
    "fmt"
    "time"
)

// 基本递归 - 计算阶乘
func factorial(n int) int {
    // 基础情况（递归终止条件）
    if n <= 1 {
        return 1
    }
    // 递归情况
    return n * factorial(n-1)
}

// 递归 - 斐波那契数列
func fibonacci(n int) int {
    // 基础情况
    if n <= 1 {
        return n
    }
    // 递归情况
    return fibonacci(n-1) + fibonacci(n-2)
}

// 优化的斐波那契（记忆化递归）
func fibonacciMemo(n int, memo map[int]int) int {
    // 检查是否已经计算过
    if val, exists := memo[n]; exists {
        return val
    }
    
    // 基础情况
    if n <= 1 {
        memo[n] = n
        return n
    }
    
    // 递归计算并存储结果
    result := fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo)
    memo[n] = result
    return result
}

// 递归 - 二分查找
func binarySearch(arr []int, target, left, right int) int {
    // 基础情况：未找到
    if left > right {
        return -1
    }
    
    mid := (left + right) / 2
    
    // 基础情况：找到目标
    if arr[mid] == target {
        return mid
    }
    
    // 递归情况
    if arr[mid] > target {
        return binarySearch(arr, target, left, mid-1)
    }
    return binarySearch(arr, target, mid+1, right)
}

// 递归 - 树遍历
type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

// 前序遍历
func preorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    result := []int{root.Value}
    result = append(result, preorderTraversal(root.Left)...)
    result = append(result, preorderTraversal(root.Right)...)
    return result
}

// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    result := inorderTraversal(root.Left)
    result = append(result, root.Value)
    result = append(result, inorderTraversal(root.Right)...)
    return result
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    result := postorderTraversal(root.Left)
    result = append(result, postorderTraversal(root.Right)...)
    result = append(result, root.Value)
    return result
}

// 递归 - 快速排序
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    pivot := arr[0]
    var left, right []int
    
    for i := 1; i < len(arr); i++ {
        if arr[i] <= pivot {
            left = append(left, arr[i])
        } else {
            right = append(right, arr[i])
        }
    }
    
    sortedLeft := quickSort(left)
    sortedRight := quickSort(right)
    
    result := append(sortedLeft, pivot)
    result = append(result, sortedRight...)
    return result
}

// 递归 - 汉诺塔问题
func hanoi(n int, from, to, aux string) {
    if n == 1 {
        fmt.Printf("将盘子从 %s 移动到 %s\n", from, to)
        return
    }
    
    hanoi(n-1, from, aux, to)
    fmt.Printf("将盘子从 %s 移动到 %s\n", from, to)
    hanoi(n-1, aux, to, from)
}

// 递归 - 文件系统遍历（模拟）
func traverseFileSystem(path string, depth int) {
    // 基础情况：达到最大深度
    if depth > 3 {
        return
    }
    
    indent := ""
    for i := 0; i < depth; i++ {
        indent += "  "
    }
    
    fmt.Printf("%s%s/\n", indent, path)
    
    // 模拟子目录
    subdirs := []string{"subdir1", "subdir2", "subdir3"}
    for _, subdir := range subdirs {
        traverseFileSystem(subdir, depth+1)
    }
}

// 尾递归优化示例
func tailRecursiveSum(n, acc int) int {
    if n <= 0 {
        return acc
    }
    return tailRecursiveSum(n-1, acc+n)
}

func main() {
    // 基本递归 - 阶乘
    fmt.Println("=== 基本递归 - 阶乘 ===")
    for i := 0; i <= 10; i++ {
        fmt.Printf("%d! = %d\n", i, factorial(i))
    }
    
    // 递归 - 斐波那契数列
    fmt.Println("\n=== 递归 - 斐波那契数列 ===")
    start := time.Now()
    for i := 0; i <= 10; i++ {
        fmt.Printf("F(%d) = %d\n", i, fibonacci(i))
    }
    fmt.Printf("普通递归耗时: %v\n", time.Since(start))
    
    // 优化的斐波那契
    fmt.Println("\n=== 优化的斐波那契 ===")
    start = time.Now()
    memo := make(map[int]int)
    for i := 0; i <= 50; i++ {
        fmt.Printf("F(%d) = %d\n", i, fibonacciMemo(i, memo))
    }
    fmt.Printf("记忆化递归耗时: %v\n", time.Since(start))
    
    // 递归 - 二分查找
    fmt.Println("\n=== 递归 - 二分查找 ===")
    arr := []int{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}
    fmt.Printf("数组: %v\n", arr)
    
    targets := []int{7, 12, 1, 19, 20}
    for _, target := range targets {
        index := binarySearch(arr, target, 0, len(arr)-1)
        if index != -1 {
            fmt.Printf("找到 %d 在索引 %d\n", target, index)
        } else {
            fmt.Printf("未找到 %d\n", target)
        }
    }
    
    // 递归 - 树遍历
    fmt.Println("\n=== 递归 - 树遍历 ===")
    // 构建示例树:
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5
    root := &TreeNode{
        Value: 1,
        Left: &TreeNode{
            Value: 2,
            Left:  &TreeNode{Value: 4},
            Right: &TreeNode{Value: 5},
        },
        Right: &TreeNode{Value: 3},
    }
    
    fmt.Printf("前序遍历: %v\n", preorderTraversal(root))
    fmt.Printf("中序遍历: %v\n", inorderTraversal(root))
    fmt.Printf("后序遍历: %v\n", postorderTraversal(root))
    
    // 递归 - 快速排序
    fmt.Println("\n=== 递归 - 快速排序 ===")
    unsorted := []int{64, 34, 25, 12, 22, 11, 90, 5}
    fmt.Printf("排序前: %v\n", unsorted)
    sorted := quickSort(unsorted)
    fmt.Printf("排序后: %v\n", sorted)
    
    // 递归 - 汉诺塔问题
    fmt.Println("\n=== 递归 - 汉诺塔问题 ===")
    hanoi(3, "A", "C", "B")
    
    // 递归 - 文件系统遍历
    fmt.Println("\n=== 递归 - 文件系统遍历 ===")
    traverseFileSystem("root", 0)
    
    // 尾递归优化
    fmt.Println("\n=== 尾递归优化 ===")
    fmt.Printf("1到100的和: %d\n", tailRecursiveSum(100, 0))
    
    // 递归深度限制演示
    fmt.Println("\n=== 递归深度限制演示 ===")
    demonstrateRecursionLimits()
}

func demonstrateRecursionLimits() {
    // 演示栈溢出
    fmt.Println("注意：深度递归可能导致栈溢出")
    
    // 计算递归深度
    maxDepth := getMaxRecursionDepth(0)
    fmt.Printf("当前环境最大递归深度约为: %d\n", maxDepth)
}

func getMaxRecursionDepth(depth int) int {
    defer func() {
        if recover() != nil {
            // 栈溢出被捕获
        }
    }()
    
    return getMaxRecursionDepth(depth + 1)
}
```

### 匿名函数

```go
package main

import (
    "fmt"
    "math"
    "sort"
    "time"
)

// 基本匿名函数
func basicAnonymousFunction() {
    // 直接调用匿名函数
    func() {
        fmt.Println("这是一个匿名函数")
    }()
    
    // 带参数的匿名函数
    func(name string) {
        fmt.Printf("Hello, %s!\n", name)
    }("World")
    
    // 带返回值的匿名函数
    result := func(a, b int) int {
        return a + b
    }(10, 20)
    fmt.Printf("匿名函数结果: %d\n", result)
}

// 匿名函数赋值给变量
func anonymousFunctionAssignment() {
    // 简单匿名函数
    greet := func(name string) {
        fmt.Printf("你好, %s!\n", name)
    }
    greet("Go语言")
    
    // 带返回值的匿名函数
    add := func(a, b int) int {
        return a + b
    }
    fmt.Printf("加法结果: %d\n", add(5, 3))
    
    // 复杂匿名函数
    calculator := func(operation string) func(int, int) int {
        switch operation {
        case "add":
            return func(a, b int) int { return a + b }
        case "multiply":
            return func(a, b int) int { return a * b }
        default:
            return func(a, b int) int { return 0 }
        }
    }
    
    addFunc := calculator("add")
    mulFunc := calculator("multiply")
    
    fmt.Printf("加法: %d\n", addFunc(10, 5))
    fmt.Printf("乘法: %d\n", mulFunc(10, 5))
}

// 匿名函数作为参数
func functionAsParameter() {
    // 函数接受匿名函数作为参数
    processNumbers := func(numbers []int, processor func(int) int) []int {
        result := make([]int, len(numbers))
        for i, num := range numbers {
            result[i] = processor(num)
        }
        return result
    }
    
    numbers := []int{1, 2, 3, 4, 5}
    
    // 平方处理
    squared := processNumbers(numbers, func(x int) int {
        return x * x
    })
    fmt.Printf("平方: %v\n", squared)
    
    // 双倍处理
    doubled := processNumbers(numbers, func(x int) int {
        return x * 2
    })
    fmt.Printf("双倍: %v\n", doubled)
}

// 匿名函数与排序
func anonymousFunctionWithSorting() {
    // 自定义排序
    people := []struct {
        Name string
        Age  int
    }{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
        {"Diana", 28},
    }
    
    // 按年龄排序
    sort.Slice(people, func(i, j int) bool {
        return people[i].Age < people[j].Age
    })
    
    fmt.Println("按年龄排序:")
    for _, person := range people {
        fmt.Printf("  %s: %d\n", person.Name, person.Age)
    }
    
    // 按姓名长度排序
    sort.Slice(people, func(i, j int) bool {
        return len(people[i].Name) < len(people[j].Name)
    })
    
    fmt.Println("按姓名长度排序:")
    for _, person := range people {
        fmt.Printf("  %s: %d\n", person.Name, person.Age)
    }
}

// 匿名函数与并发
func anonymousFunctionWithConcurrency() {
    // 启动多个goroutine执行匿名函数
    for i := 0; i < 3; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d 开始\n", id)
            time.Sleep(time.Duration(id) * time.Second)
            fmt.Printf("Goroutine %d 结束\n", id)
        }(i)
    }
    
    // 等待一段时间让goroutine执行
    time.Sleep(4 * time.Second)
}

// 匿名函数与闭包
func anonymousFunctionWithClosure() {
    // 创建计数器
    createCounter := func() func() int {
        count := 0
        return func() int {
            count++
            return count
        }
    }
    
    counter1 := createCounter()
    counter2 := createCounter()
    
    fmt.Println("计数器1:")
    for i := 0; i < 3; i++ {
        fmt.Printf("  %d\n", counter1())
    }
    
    fmt.Println("计数器2:")
    for i := 0; i < 3; i++ {
        fmt.Printf("  %d\n", counter2())
    }
}

// 匿名函数与错误处理
func anonymousFunctionWithErrorHandling() {
    // 错误处理包装器
    safeDivide := func(a, b float64) (float64, error) {
        if b == 0 {
            return 0, fmt.Errorf("除数不能为零")
        }
        return a / b, nil
    }
    
    // 使用匿名函数处理错误
    handleOperation := func(operation func() (float64, error), onSuccess func(float64)) {
        if result, err := operation(); err != nil {
            fmt.Printf("错误: %v\n", err)
        } else {
            onSuccess(result)
        }
    }
    
    // 正常情况
    handleOperation(
        func() (float64, error) { return safeDivide(10, 2) },
        func(result float64) { fmt.Printf("结果: %.2f\n", result) },
    )
    
    // 错误情况
    handleOperation(
        func() (float64, error) { return safeDivide(10, 0) },
        func(result float64) { fmt.Printf("结果: %.2f\n", result) },
    )
}

// 匿名函数与数学计算
func anonymousFunctionWithMath() {
    // 数学函数工厂
    createMathFunction := func(operation string) func(float64) float64 {
        switch operation {
        case "square":
            return func(x float64) float64 { return x * x }
        case "sqrt":
            return func(x float64) float64 { return math.Sqrt(x) }
        case "abs":
            return func(x float64) float64 { return math.Abs(x) }
        default:
            return func(x float64) float64 { return x }
        }
    }
    
    numbers := []float64{4, 9, -16, 25}
    
    squareFunc := createMathFunction("square")
    sqrtFunc := createMathFunction("sqrt")
    absFunc := createMathFunction("abs")
    
    fmt.Println("数学函数应用:")
    for _, num := range numbers {
        fmt.Printf("  原数: %.2f, 平方: %.2f, 平方根: %.2f, 绝对值: %.2f\n",
            num, squareFunc(num), sqrtFunc(math.Abs(num)), absFunc(num))
    }
}

// 匿名函数与数据处理管道
func anonymousFunctionWithPipeline() {
    // 数据处理管道
    pipeline := func(data []int, processors ...func(int) int) []int {
        result := make([]int, len(data))
        copy(result, data)
        
        for _, processor := range processors {
            for i := range result {
                result[i] = processor(result[i])
            }
        }
        
        return result
    }
    
    data := []int{1, 2, 3, 4, 5}
    
    // 定义处理函数
    double := func(x int) int { return x * 2 }
    addOne := func(x int) int { return x + 1 }
    square := func(x int) int { return x * x }
    
    // 应用管道
    result := pipeline(data, double, addOne, square)
    fmt.Printf("原始数据: %v\n", data)
    fmt.Printf("处理后: %v\n", result)
}

func main() {
    fmt.Println("=== 基本匿名函数 ===")
    basicAnonymousFunction()
    
    fmt.Println("\n=== 匿名函数赋值给变量 ===")
    anonymousFunctionAssignment()
    
    fmt.Println("\n=== 匿名函数作为参数 ===")
    functionAsParameter()
    
    fmt.Println("\n=== 匿名函数与排序 ===")
    anonymousFunctionWithSorting()
    
    fmt.Println("\n=== 匿名函数与并发 ===")
    anonymousFunctionWithConcurrency()
    
    fmt.Println("\n=== 匿名函数与闭包 ===")
    anonymousFunctionWithClosure()
    
    fmt.Println("\n=== 匿名函数与错误处理 ===")
    anonymousFunctionWithErrorHandling()
    
    fmt.Println("\n=== 匿名函数与数学计算 ===")
    anonymousFunctionWithMath()
    
    fmt.Println("\n=== 匿名函数与数据处理管道 ===")
    anonymousFunctionWithPipeline()
    
    // 实际应用示例
    fmt.Println("\n=== 实际应用示例 ===")
    realWorldExamples()
}

func realWorldExamples() {
    // HTTP中间件模拟
    type HandlerFunc func(string) string
    
    // 日志中间件
    logMiddleware := func(next HandlerFunc) HandlerFunc {
        return func(request string) string {
            fmt.Printf("请求开始: %s\n", request)
            result := next(request)
            fmt.Printf("请求结束: %s\n", request)
            return result
        }
    }
    
    // 认证中间件
    authMiddleware := func(next HandlerFunc) HandlerFunc {
        return func(request string) string {
            if request == "admin" {
                return next(request)
            }
            return "权限拒绝"
        }
    }
    
    // 业务处理函数
    businessHandler := func(request string) string {
        return fmt.Sprintf("处理请求: %s", request)
    }
    
    // 组合中间件
    handler := logMiddleware(authMiddleware(businessHandler))
    
    fmt.Println("中间件示例:")
    fmt.Printf("admin请求: %s\n", handler("admin"))
    fmt.Printf("user请求: %s\n", handler("user"))
    
    // 事件处理系统
    fmt.Println("\n事件处理系统:")
    eventSystemExample()
}

func eventSystemExample() {
    // 简单的事件系统
    type Event struct {
        Type string
        Data interface{}
    }
    
    type EventHandler func(Event)
    
    handlers := make(map[string][]EventHandler)
    
    // 注册事件处理器
    registerHandler := func(eventType string, handler EventHandler) {
        handlers[eventType] = append(handlers[eventType], handler)
    }
    
    // 触发事件
    triggerEvent := func(event Event) {
        if eventHandlers, exists := handlers[event.Type]; exists {
            for _, handler := range eventHandlers {
                handler(event)
            }
        }
    }
    
    // 注册处理器
    registerHandler("user_login", func(e Event) {
        userData := e.Data.(map[string]string)
        fmt.Printf("用户登录: %s (IP: %s)\n", userData["username"], userData["ip"])
    })
    
    registerHandler("user_logout", func(e Event) {
        userData := e.Data.(map[string]string)
        fmt.Printf("用户登出: %s\n", userData["username"])
    })
    
    // 触发事件
    triggerEvent(Event{
        Type: "user_login",
        Data: map[string]string{"username": "alice", "ip": "192.168.1.1"},
    })
    
    triggerEvent(Event{
        Type: "user_logout",
        Data: map[string]string{"username": "alice"},
    })
}
```

### 闭包概念和应用

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 闭包基本概念
func basicClosure() {
    fmt.Println("=== 闭包基本概念 ===")
    
    // 闭包捕获外部变量
    x := 10
    closure := func() int {
        return x * 2  // 捕获外部变量x
    }
    
    fmt.Printf("闭包结果: %d\n", closure())
    
    // 修改外部变量
    x = 20
    fmt.Printf("修改后闭包结果: %d\n", closure())
    
    // 闭包修改外部变量
    increment := func() {
        x++  // 修改外部变量
    }
    
    fmt.Printf("修改前x: %d\n", x)
    increment()
    fmt.Printf("修改后x: %d\n", x)
}

// 闭包与计数器
func closureCounter() {
    fmt.Println("\n=== 闭包与计数器 ===")
    
    // 创建计数器工厂
    createCounter := func() func() int {
        count := 0
        return func() int {
            count++
            return count
        }
    }
    
    // 创建多个独立的计数器
    counter1 := createCounter()
    counter2 := createCounter()
    
    fmt.Println("计数器1:")
    for i := 0; i < 5; i++ {
        fmt.Printf("  %d ", counter1())
    }
    fmt.Println()
    
    fmt.Println("计数器2:")
    for i := 0; i < 3; i++ {
        fmt.Printf("  %d ", counter2())
    }
    fmt.Println()
    
    fmt.Println("计数器1继续:")
    for i := 0; i < 3; i++ {
        fmt.Printf("  %d ", counter1())
    }
    fmt.Println()
}

// 闭包与状态管理
func closureStateManagement() {
    fmt.Println("\n=== 闭包与状态管理 ===")
    
    // 创建状态管理器
    createStateManager := func(initialState int) (func() int, func(int), func()) {
        state := initialState
        
        // 获取状态
        getState := func() int {
            return state
        }
        
        // 设置状态
        setState := func(newValue int) {
            state = newValue
        }
        
        // 重置状态
        resetState := func() {
            state = initialState
        }
        
        return getState, setState, resetState
    }
    
    // 创建状态管理器实例
    get, set, reset := createStateManager(100)
    
    fmt.Printf("初始状态: %d\n", get())
    
    set(200)
    fmt.Printf("设置后状态: %d\n", get())
    
    reset()
    fmt.Printf("重置后状态: %d\n", get())
}

// 闭包与配置管理
func closureConfiguration() {
    fmt.Println("\n=== 闭包与配置管理 ===")
    
    // 创建配置管理器
    createConfigManager := func() func(string, ...interface{}) interface{} {
        config := make(map[string]interface{})
        
        return func(action string, args ...interface{}) interface{} {
            switch action {
            case "set":
                if len(args) >= 2 {
                    key, ok1 := args[0].(string)
                    if ok1 {
                        config[key] = args[1]
                    }
                }
                return nil
            case "get":
                if len(args) >= 1 {
                    key, ok := args[0].(string)
                    if ok {
                        return config[key]
                    }
                }
                return nil
            case "list":
                return config
            default:
                return nil
            }
        }
    }
    
    // 创建配置管理器实例
    config := createConfigManager()
    
    // 设置配置
    config("set", "database_url", "localhost:5432")
    config("set", "max_connections", 100)
    config("set", "debug_mode", true)
    
    // 获取配置
    fmt.Printf("数据库URL: %v\n", config("get", "database_url"))
    fmt.Printf("最大连接数: %v\n", config("get", "max_connections"))
    fmt.Printf("调试模式: %v\n", config("get", "debug_mode"))
    
    // 列出所有配置
    fmt.Printf("所有配置: %v\n", config("list"))
}

// 闭包与缓存
func closureCache() {
    fmt.Println("\n=== 闭包与缓存 ===")
    
    // 创建简单的缓存
    createCache := func() func(string, func() interface{}) interface{} {
        cache := make(map[string]interface{})
        
        return func(key string, compute func() interface{}) interface{} {
            // 检查缓存
            if value, exists := cache[key]; exists {
                fmt.Printf("缓存命中: %s\n", key)
                return value
            }
            
            // 计算并缓存
            fmt.Printf("计算并缓存: %s\n", key)
            value := compute()
            cache[key] = value
            return value
        }
    }
    
    // 创建缓存实例
    cache := createCache()
    
    // 昂贵的计算函数
    expensiveComputation := func(n int) func() interface{} {
        return func() interface{} {
            time.Sleep(100 * time.Millisecond) // 模拟耗时操作
            result := 1
            for i := 1; i <= n; i++ {
                result *= i
            }
            return result
        }
    }
    
    // 使用缓存
    fmt.Println("第一次计算:")
    result1 := cache("factorial_5", expensiveComputation(5))
    fmt.Printf("5! = %v\n", result1)
    
    fmt.Println("第二次计算（应该从缓存获取）:")
    result2 := cache("factorial_5", expensiveComputation(5))
    fmt.Printf("5! = %v\n", result2)
    
    fmt.Println("计算其他值:")
    result3 := cache("factorial_10", expensiveComputation(10))
    fmt.Printf("10! = %v\n", result3)
}

// 闭包与并发安全
func closureConcurrency() {
    fmt.Println("\n=== 闭包与并发安全 ===")
    
    // 创建线程安全的计数器
    createSafeCounter := func() func() int {
        var mu sync.Mutex
        count := 0
        
        return func() int {
            mu.Lock()
            defer mu.Unlock()
            count++
            return count
        }
    }
    
    // 创建安全计数器
    safeCounter := createSafeCounter()
    
    // 启动多个goroutine
    var wg sync.WaitGroup
    results := make(chan int, 10)
    
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            result := safeCounter()
            results <- result
        }()
    }
    
    // 等待所有goroutine完成
    wg.Wait()
    close(results)
    
    // 收集结果
    fmt.Println("并发计数结果:")
    for result := range results {
        fmt.Printf("  %d\n", result)
    }
}

// 闭包与函数工厂
func closureFunctionFactory() {
    fmt.Println("\n=== 闭包与函数工厂 ===")
    
    // 创建数学运算工厂
    createMathOperation := func(operation string, factor float64) func(float64) float64 {
        switch operation {
        case "multiply":
            return func(x float64) float64 {
                return x * factor
            }
        case "add":
            return func(x float64) float64 {
                return x + factor
            }
        case "power":
            return func(x float64) float64 {
                result := 1.0
                for i := 0; i < int(factor); i++ {
                    result *= x
                }
                return result
            }
        default:
            return func(x float64) float64 { return x }
        }
    }
    
    // 创建不同的运算函数
    double := createMathOperation("multiply", 2)
    addTen := createMathOperation("add", 10)
    square := createMathOperation("power", 2)
    
    numbers := []float64{1, 2, 3, 4, 5}
    
    fmt.Println("数学运算工厂:")
    for _, num := range numbers {
        fmt.Printf("  原数: %.0f, 双倍: %.0f, 加10: %.0f, 平方: %.0f\n",
            num, double(num), addTen(num), square(num))
    }
}

// 闭包与事件系统
func closureEventSystem() {
    fmt.Println("\n=== 闭包与事件系统 ===")
    
    // 创建事件系统
    createEventSystem := func() (func(string, func(interface{})), func(string, interface{})) {
        listeners := make(map[string][]func(interface{}))
        
        // 注册监听器
        on := func(event string, callback func(interface{})) {
            listeners[event] = append(listeners[event], callback)
        }
        
        // 触发事件
        emit := func(event string, data interface{}) {
            if callbacks, exists := listeners[event]; exists {
                for _, callback := range callbacks {
                    callback(data)
                }
            }
        }
        
        return on, emit
    }
    
    // 创建事件系统实例
    on, emit := createEventSystem()
    
    // 注册事件监听器
    on("user_login", func(data interface{}) {
        userData := data.(map[string]string)
        fmt.Printf("用户登录事件: %s 登录成功\n", userData["username"])
    })
    
    on("user_login", func(data interface{}) {
        userData := data.(map[string]string)
        fmt.Printf("安全系统: 记录 %s 的登录IP: %s\n", userData["username"], userData["ip"])
    })
    
    on("order_created", func(data interface{}) {
        orderData := data.(map[string]interface{})
        fmt.Printf("订单创建事件: 订单 #%v 创建成功，金额: %.2f\n",
            orderData["id"], orderData["amount"])
    })
    
    // 触发事件
    emit("user_login", map[string]string{
        "username": "alice",
        "ip":       "192.168.1.100",
    })
    
    emit("order_created", map[string]interface{}{
        "id":     12345,
        "amount": 99.99,
        "user":   "alice",
    })
}

// 闭包与装饰器模式
func closureDecorator() {
    fmt.Println("\n=== 闭包与装饰器模式 ===")
    
    // 装饰器工厂
    createLogger := func(prefix string, fn func(int, int) int) func(int, int) int {
        return func(a, b int) int {
            fmt.Printf("[%s] 调用函数，参数: %d, %d\n", prefix, a, b)
            result := fn(a, b)
            fmt.Printf("[%s] 函数返回: %d\n", prefix, result)
            return result
        }
    }
    
    // 原始函数
    add := func(a, b int) int {
        return a + b
    }
    
    multiply := func(a, b int) int {
        return a * b
    }
    
    // 应用装饰器
    loggedAdd := createLogger("ADD", add)
    loggedMultiply := createLogger("MUL", multiply)
    
    fmt.Println("调用装饰后的函数:")
    result1 := loggedAdd(5, 3)
    result2 := loggedMultiply(4, 6)
    
    fmt.Printf("最终结果: %d, %d\n", result1, result2)
}

func main() {
    basicClosure()
    closureCounter()
    closureStateManagement()
    closureConfiguration()
    closureCache()
    closureConcurrency()
    closureFunctionFactory()
    closureEventSystem()
    closureDecorator()
    
    // 实际应用场景
    fmt.Println("\n=== 实际应用场景 ===")
    realWorldApplications()
}

func realWorldApplications() {
    // API客户端模拟
    fmt.Println("API客户端模拟:")
    apiClientExample()
    
    // 数据验证器
    fmt.Println("\n数据验证器:")
    validatorExample()
}

func apiClientExample() {
    // 创建API客户端工厂
    createAPIClient := func(baseURL string, apiKey string) func(string) string {
        return func(endpoint string) string {
            // 模拟API调用
            return fmt.Sprintf("GET %s%s (API Key: %s)", baseURL, endpoint, apiKey[:5]+"...")
        }
    }
    
    // 创建特定的API客户端
    githubClient := createAPIClient("https://api.github.com/", "ghp_1234567890")
    weatherClient := createAPIClient("https://api.weather.com/", "w_1234567890")
    
    fmt.Println(githubClient("/users/octocat"))
    fmt.Println(weatherClient("/current?city=Beijing"))
}

func validatorExample() {
    // 创建验证器工厂
    createValidator := func() func(interface{}, func(interface{}) bool, string) error {
        return func(value interface{}, rule func(interface{}) bool, message string) error {
            if !rule(value) {
                return fmt.Errorf("验证失败: %s", message)
            }
            return nil
        }
    }
    
    // 创建验证器实例
    validate := createValidator()
    
    // 定义验证规则
    notEmpty := func(v interface{}) bool {
        if str, ok := v.(string); ok {
            return len(str) > 0
        }
        return false
    }
    
    isPositive := func(v interface{}) bool {
        if num, ok := v.(int); ok {
            return num > 0
        }
        return false
    }
    
    // 使用验证器
    err1 := validate("hello", notEmpty, "字符串不能为空")
    if err1 != nil {
        fmt.Printf("错误: %v\n", err1)
    } else {
        fmt.Println("验证通过: 字符串")
    }
    
    err2 := validate("", notEmpty, "字符串不能为空")
    if err2 != nil {
        fmt.Printf("错误: %v\n", err2)
    }
    
    err3 := validate(5, isPositive, "数字必须为正数")
    if err3 != nil {
        fmt.Printf("错误: %v\n", err3)
    } else {
        fmt.Println("验证通过: 正数")
    }
    
    err4 := validate(-1, isPositive, "数字必须为正数")
    if err4 != nil {
        fmt.Printf("错误: %v\n", err4)
    }
}
```

### 函数作为参数传递

```go
package main

import (
    "fmt"
    "sort"
    "strings"
    "time"
)

// 基本函数作为参数
func basicFunctionAsParameter() {
    fmt.Println("=== 基本函数作为参数 ===")
    
    // 定义函数类型
    type Operation func(int, int) int
    
    // 执行操作的函数
    executeOperation := func(a, b int, op Operation) int {
        return op(a, b)
    }
    
    // 定义具体操作
    add := func(a, b int) int { return a + b }
    multiply := func(a, b int) int { return a * b }
    subtract := func(a, b int) int { return a - b }
    
    // 使用函数作为参数
    fmt.Printf("10 + 5 = %d\n", executeOperation(10, 5, add))
    fmt.Printf("10 * 5 = %d\n", executeOperation(10, 5, multiply))
    fmt.Printf("10 - 5 = %d\n", executeOperation(10, 5, subtract))
}

// 函数作为参数 - 数据处理
func functionAsParameterDataProcessing() {
    fmt.Println("\n=== 函数作为参数 - 数据处理 ===")
    
    // 数据处理管道
    processData := func(data []int, processor func(int) int) []int {
        result := make([]int, len(data))
        for i, value := range data {
            result[i] = processor(value)
        }
        return result
    }
    
    // 过滤数据
    filterData := func(data []int, predicate func(int) bool) []int {
        var result []int
        for _, value := range data {
            if predicate(value) {
                result = append(result, value)
            }
        }
        return result
    }
    
    // 归约数据
    reduceData := func(data []int, reducer func(int, int) int, initial int) int {
        result := initial
        for _, value := range data {
            result = reducer(result, value)
        }
        return result
    }
    
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Printf("原始数据: %v\n", numbers)
    
    // 平方处理
    squared := processData(numbers, func(x int) int { return x * x })
    fmt.Printf("平方: %v\n", squared)
    
    // 过滤偶数
    evenNumbers := filterData(numbers, func(x int) bool { return x%2 == 0 })
    fmt.Printf("偶数: %v\n", evenNumbers)
    
    // 求和
    sum := reduceData(numbers, func(acc, x int) int { return acc + x }, 0)
    fmt.Printf("总和: %d\n", sum)
    
    // 求积
    product := reduceData(numbers, func(acc, x int) int { return acc * x }, 1)
    fmt.Printf("乘积: %d\n", product)
}

// 函数作为参数 - 排序
func functionAsParameterSorting() {
    fmt.Println("\n=== 函数作为参数 - 排序 ===")
    
    // 自定义排序函数
    type Person struct {
        Name string
        Age  int
        City string
    }
    
    people := []Person{
        {"Alice", 30, "New York"},
        {"Bob", 25, "London"},
        {"Charlie", 35, "Tokyo"},
        {"Diana", 28, "Paris"},
        {"Eve", 32, "New York"},
    }
    
    fmt.Println("原始数据:")
    for _, p := range people {
        fmt.Printf("  %s, %d岁, %s\n", p.Name, p.Age, p.City)
    }
    
    // 按年龄排序
    sortByAge := func(i, j int) bool {
        return people[i].Age < people[j].Age
    }
    
    sort.Slice(people, sortByAge)
    fmt.Println("按年龄排序:")
    for _, p := range people {
        fmt.Printf("  %s, %d岁, %s\n", p.Name, p.Age, p.City)
    }
    
    // 按姓名排序
    sortByName := func(i, j int) bool {
        return people[i].Name < people[j].Name
    }
    
    sort.Slice(people, sortByName)
    fmt.Println("按姓名排序:")
    for _, p := range people {
        fmt.Printf("  %s, %d岁, %s\n", p.Name, p.Age, p.City)
    }
    
    // 按城市排序
    sortByCity := func(i, j int) bool {
        return people[i].City < people[j].City
    }
    
    sort.Slice(people, sortByCity)
    fmt.Println("按城市排序:")
    for _, p := range people {
        fmt.Printf("  %s, %d岁, %s\n", p.Name, p.Age, p.City)
    }
}

// 函数作为参数 - 字符串处理
func functionAsParameterStringProcessing() {
    fmt.Println("\n=== 函数作为参数 - 字符串处理 ===")
    
    // 字符串处理函数
    processString := func(s string, processor func(string) string) string {
        return processor(s)
    }
    
    // 字符串变换函数
    transformers := map[string]func(string) string{
        "uppercase": strings.ToUpper,
        "lowercase": strings.ToLower,
        "title":     strings.ToTitle,
        "reverse": func(s string) string {
            runes := []rune(s)
            for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                runes[i], runes[j] = runes[j], runes[i]
            }
            return string(runes)
        },
        "remove_spaces": func(s string) string {
            return strings.ReplaceAll(s, " ", "")
        },
    }
    
    text := "Hello World Go Language"
    fmt.Printf("原始文本: %s\n", text)
    
    for name, transformer := range transformers {
        result := processString(text, transformer)
        fmt.Printf("%s: %s\n", name, result)
    }
}

// 函数作为参数 - 中间件模式
func functionAsParameterMiddleware() {
    fmt.Println("\n=== 函数作为参数 - 中间件模式 ===")
    
    // 中间件类型定义
    type Middleware func(http.Handler) http.Handler
    type Handler func(string) string
    
    // HTTP处理器接口（简化版）
    type http struct{}
    
    func (h http) ServeHTTP(request string) string {
        return fmt.Sprintf("处理请求: %s", request)
    }
    
    // 中间件函数
    logMiddleware := func(next Handler) Handler {
        return func(request string) string {
            fmt.Printf("[LOG] 开始处理请求: %s\n", request)
            result := next(request)
            fmt.Printf("[LOG] 请求处理完成: %s\n", request)
            return result
        }
    }
    
    authMiddleware := func(next Handler) Handler {
        return func(request string) string {
            if strings.HasPrefix(request, "admin/") {
                fmt.Printf("[AUTH] 管理员权限验证通过\n")
                return next(request)
            }
            return "[AUTH] 权限拒绝"
        }
    }
    
    timeoutMiddleware := func(next Handler) Handler {
        return func(request string) string {
            fmt.Printf("[TIMEOUT] 设置超时时间为5秒\n")
            return next(request)
        }
    }
    
    // 原始处理器
    businessHandler := func(request string) string {
        return fmt.Sprintf("业务逻辑处理: %s", request)
    }
    
    // 应用中间件（从内到外）
    handler := logMiddleware(authMiddleware(timeoutMiddleware(businessHandler)))
    
    // 测试不同请求
    requests := []string{
        "admin/dashboard",
        "user/profile",
        "public/home",
    }
    
    for _, request := range requests {
        fmt.Printf("\n处理请求: %s\n", request)
        result := handler(request)
        fmt.Printf("结果: %s\n", result)
    }
}

// 函数作为参数 - 事件处理
func functionAsParameterEventHandling() {
    fmt.Println("\n=== 函数作为参数 - 事件处理 ===")
    
    // 事件系统
    type Event struct {
        Type string
        Data interface{}
    }
    
    type EventHandler func(Event)
    
    // 事件管理器
    type EventManager struct {
        handlers map[string][]EventHandler
    }
    
    // 创建事件管理器
    newEventManager := func() *EventManager {
        return &EventManager{
            handlers: make(map[string][]EventHandler),
        }
    }
    
    // 注册事件处理器
    func (em *EventManager) On(eventType string, handler EventHandler) {
        em.handlers[eventType] = append(em.handlers[eventType], handler)
    }
    
    // 触发事件
    func (em *EventManager) Emit(event Event) {
        if handlers, exists := em.handlers[event.Type]; exists {
            for _, handler := range handlers {
                handler(event)
            }
        }
    }
    
    // 创建事件管理器实例
    em := newEventManager()
    
    // 注册事件处理器
    em.On("user_login", func(e Event) {
        userData := e.Data.(map[string]string)
        fmt.Printf("[用户系统] 用户 %s 登录成功\n", userData["username"])
    })
    
    em.On("user_login", func(e Event) {
        userData := e.Data.(map[string]string)
        fmt.Printf("[安全系统] 记录登录IP: %s\n", userData["ip"])
    })
    
    em.On("order_created", func(e Event) {
        orderData := e.Data.(map[string]interface{})
        fmt.Printf("[订单系统] 创建订单 #%v，金额: %.2f\n",
            orderData["id"], orderData["amount"])
    })
    
    em.On("order_created", func(e Event) {
        orderData := e.Data.(map[string]interface{})
        fmt.Printf("[库存系统] 检查商品库存，订单ID: %v\n", orderData["id"])
    })
    
    // 触发事件
    em.Emit(Event{
        Type: "user_login",
        Data: map[string]string{
            "username": "alice",
            "ip":       "192.168.1.100",
        },
    })
    
    fmt.Println()
    
    em.Emit(Event{
        Type: "order_created",
        Data: map[string]interface{}{
            "id":     12345,
            "amount": 99.99,
            "items":  []string{"商品A", "商品B"},
        },
    })
}

// 函数作为参数 - 策略模式
func functionAsParameterStrategy() {
    fmt.Println("\n=== 函数作为参数 - 策略模式 ===")
    
    // 排序策略
    type SortStrategy func([]int) []int
    
    // 不同的排序算法
    bubbleSort := func(arr []int) []int {
        result := make([]int, len(arr))
        copy(result, arr)
        
        n := len(result)
        for i := 0; i < n-1; i++ {
            for j := 0; j < n-i-1; j++ {
                if result[j] > result[j+1] {
                    result[j], result[j+1] = result[j+1], result[j]
                }
            }
        }
        return result
    }
    
    selectionSort := func(arr []int) []int {
        result := make([]int, len(arr))
        copy(result, arr)
        
        n := len(result)
        for i := 0; i < n-1; i++ {
            minIdx := i
            for j := i + 1; j < n; j++ {
                if result[j] < result[minIdx] {
                    minIdx = j
                }
            }
            result[i], result[minIdx] = result[minIdx], result[i]
        }
        return result
    }
    
    insertionSort := func(arr []int) []int {
        result := make([]int, len(arr))
        copy(result, arr)
        
        for i := 1; i < len(result); i++ {
            key := result[i]
            j := i - 1
            for j >= 0 && result[j] > key {
                result[j+1] = result[j]
                j--
            }
            result[j+1] = key
        }
        return result
    }
    
    // 排序上下文
    sortWithContext := func(data []int, strategy SortStrategy) []int {
        fmt.Printf("使用策略排序 %d 个元素\n", len(data))
        start := time.Now()
        result := strategy(data)
        duration := time.Since(start)
        fmt.Printf("排序完成，耗时: %v\n", duration)
        return result
    }
    
    // 测试数据
    testData := []int{64, 34, 25, 12, 22, 11, 90, 5}
    fmt.Printf("原始数据: %v\n", testData)
    
    // 使用不同策略
    strategies := map[string]SortStrategy{
        "冒泡排序": bubbleSort,
        "选择排序": selectionSort,
        "插入排序": insertionSort,
    }
    
    for name, strategy := range strategies {
        fmt.Printf("\n使用 %s:\n", name)
        sorted := sortWithContext(testData, strategy)
        fmt.Printf("排序结果: %v\n", sorted)
    }
}

// 函数作为参数 - 验证器
func functionAsParameterValidator() {
    fmt.Println("\n=== 函数作为参数 - 验证器 ===")
    
    // 验证器类型
    type Validator func(interface{}) bool
    type ValidationError struct {
        Field   string
        Message string
    }
    
    // 验证函数
    validate := func(data map[string]interface{}, rules map[string]Validator) []ValidationError {
        var errors []ValidationError
        
        for field, validator := range rules {
            if value, exists := data[field]; exists {
                if !validator(value) {
                    errors = append(errors, ValidationError{
                        Field:   field,
                        Message: fmt.Sprintf("%s 验证失败", field),
                    })
                }
            }
        }
        
        return errors
    }
    
    // 预定义验证器
    notEmpty := func(v interface{}) bool {
        if str, ok := v.(string); ok {
            return len(str) > 0
        }
        return false
    }
    
    isPositive := func(v interface{}) bool {
        if num, ok := v.(int); ok {
            return num > 0
        }
        return false
    }
    
    isValidEmail := func(v interface{}) bool {
        if email, ok := v.(string); ok {
            return strings.Contains(email, "@") && strings.Contains(email, ".")
        }
        return false
    }
    
    minLength := func(minLen int) Validator {
        return func(v interface{}) bool {
            if str, ok := v.(string); ok {
                return len(str) >= minLen
            }
            return false
        }
    }
    
    // 测试数据
    userData := map[string]interface{}{
        "username": "alice",
        "email":    "alice@example.com",
        "age":      25,
        "password": "password123",
    }
    
    fmt.Printf("用户数据: %v\n", userData)
    
    // 验证规则
    rules := map[string]Validator{
        "username": notEmpty,
        "email":    isValidEmail,
        "age":      isPositive,
        "password": minLength(8),
    }
    
    // 执行验证
    errors := validate(userData, rules)
    
    if len(errors) == 0 {
        fmt.Println("✓ 所有验证通过")
    } else {
        fmt.Println("✗ 验证失败:")
        for _, err := range errors {
            fmt.Printf("  - %s: %s\n", err.Field, err.Message)
        }
    }
    
    // 测试无效数据
    fmt.Println("\n测试无效数据:")
    invalidData := map[string]interface{}{
        "username": "",
        "email":    "invalid-email",
        "age":      -5,
        "password": "123",
    }
    
    fmt.Printf("无效数据: %v\n", invalidData)
    errors = validate(invalidData, rules)
    
    if len(errors) == 0 {
        fmt.Println("✓ 所有验证通过")
    } else {
        fmt.Println("✗ 验证失败:")
        for _, err := range errors {
            fmt.Printf("  - %s: %s\n", err.Field, err.Message)
        }
    }
}

func main() {
    basicFunctionAsParameter()
    functionAsParameterDataProcessing()
    functionAsParameterSorting()
    functionAsParameterStringProcessing()
    functionAsParameterMiddleware()
    functionAsParameterEventHandling()
    functionAsParameterStrategy()
    functionAsParameterValidator()
    
    // 实际应用场景
    fmt.Println("\n=== 实际应用场景 ===")
    realWorldApplications()
}

func realWorldApplications() {
    // API客户端配置
    fmt.Println("API客户端配置:")
    apiClientConfiguration()
    
    // 数据处理管道
    fmt.Println("\n数据处理管道:")
    dataProcessingPipeline()
}

func apiClientConfiguration() {
    // API客户端配置结构
    type APIClient struct {
        baseURL    string
        timeout    time.Duration
        middlewares []func(func(string) string) func(string) string
    }
    
    // 创建API客户端
    createAPIClient := func(baseURL string, config func(*APIClient)) *APIClient {
        client := &APIClient{
            baseURL: baseURL,
            timeout: 30 * time.Second,
        }
        
        if config != nil {
            config(client)
        }
        
        return client
    }
    
    // 配置函数
    withTimeout := func(timeout time.Duration) func(*APIClient) {
        return func(client *APIClient) {
            client.timeout = timeout
        }
    }
    
    withAuthMiddleware := func(token string) func(*APIClient) {
        return func(client *APIClient) {
            client.middlewares = append(client.middlewares, func(next func(string) string) func(string) string {
                return func(endpoint string) string {
                    fmt.Printf("[AUTH] 添加认证头: %s\n", token[:5]+"...")
                    return next(endpoint)
                }
            })
        }
    }
    
    withLoggingMiddleware := func() func(*APIClient) {
        return func(client *APIClient) {
            client.middlewares = append(client.middlewares, func(next func(string) string) func(string) string {
                return func(endpoint string) string {
                    fmt.Printf("[LOG] 请求: %s\n", endpoint)
                    result := next(endpoint)
                    fmt.Printf("[LOG] 响应: %s\n", result)
                    return result
                }
            })
        }
    }
    
    // 创建配置好的客户端
    client := createAPIClient("https://api.example.com",
        func(c *APIClient) {
            withTimeout(60*time.Second)(c)
            withAuthMiddleware("secret_token_12345")(c)
            withLoggingMiddleware()(c)
        })
    
    fmt.Printf("客户端配置: URL=%s, Timeout=%v\n", client.baseURL, client.timeout)
    fmt.Printf("中间件数量: %d\n", len(client.middlewares))
}

func dataProcessingPipeline() {
    // 数据处理管道
    type DataProcessor struct {
        processors []func([]int) []int
    }
    
    // 添加处理器
    func (dp *DataProcessor) AddProcessor(processor func([]int) []int) *DataProcessor {
        dp.processors = append(dp.processors, processor)
        return dp
    }
    
    // 处理数据
    func (dp *DataProcessor) Process(data []int) []int {
        result := make([]int, len(data))
        copy(result, data)
        
        for _, processor := range dp.processors {
            result = processor(result)
        }
        
        return result
    }
    
    // 预定义处理器
    filterEven := func(data []int) []int {
        var result []int
        for _, v := range data {
            if v%2 == 0 {
                result = append(result, v)
            }
        }
        return result
    }
    
    squareAll := func(data []int) []int {
        result := make([]int, len(data))
        for i, v := range data {
            result[i] = v * v
        }
        return result
    }
    
    sumAll := func(data []int) []int {
        sum := 0
        for _, v := range data {
            sum += v
        }
        return []int{sum}
    }
    
    // 创建处理管道
    pipeline := &DataProcessor{}
    pipeline.AddProcessor(filterEven).
        AddProcessor(squareAll).
        AddProcessor(sumAll)
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Printf("原始数据: %v\n", numbers)
    
    // 处理数据
    result := pipeline.Process(numbers)
    fmt.Printf("处理结果: %v\n", result)
}
```

### 函数类型和函数变量

```go
package main

import (
    "fmt"
    "math"
    "reflect"
    "sort"
)

// 函数类型定义
type (
    // 基本函数类型
    CalculatorFunc func(int, int) int
    StringProcessor func(string) string
    Validator func(interface{}) bool
    EventHandler func(string, interface{})
    
    // 复杂函数类型
    DataProcessor func([]int) []int
    AsyncOperation func(func(error)) error
    Middleware func(func(interface{}) interface{}) func(interface{}) interface{}
)

// 函数变量声明和初始化
func functionVariableDeclaration() {
    fmt.Println("=== 函数变量声明和初始化 ===")
    
    // 声明函数变量
    var addFunc CalculatorFunc
    var processString StringProcessor
    var validate Validator
    
    // 初始化函数变量
    addFunc = func(a, b int) int {
        return a + b
    }
    
    processString = func(s string) string {
        return s + " processed"
    }
    
    validate = func(v interface{}) bool {
        if str, ok := v.(string); ok {
            return len(str) > 0
        }
        return false
    }
    
    // 使用函数变量
    fmt.Printf("addFunc(5, 3) = %d\n", addFunc(5, 3))
    fmt.Printf("processString('hello') = %s\n", processString("hello"))
    fmt.Printf("validate('test') = %t\n", validate("test"))
    fmt.Printf("validate('') = %t\n", validate(""))
}

// 函数变量赋值和重新赋值
func functionVariableAssignment() {
    fmt.Println("\n=== 函数变量赋值和重新赋值 ===")
    
    // 初始赋值
    var operation CalculatorFunc = func(a, b int) int {
        return a + b
    }
    
    fmt.Printf("初始操作(10, 5) = %d\n", operation(10, 5))
    
    // 重新赋值
    operation = func(a, b int) int {
        return a * b
    }
    
    fmt.Printf("重新赋值后(10, 5) = %d\n", operation(10, 5))
    
    // 条件赋值
    useAddition := true
    if useAddition {
        operation = func(a, b int) int { return a + b }
    } else {
        operation = func(a, b int) int { return a - b }
    }
    
    fmt.Printf("条件赋值后(10, 5) = %d\n", operation(10, 5))
}

// 函数变量作为数据结构成员
func functionVariableInStruct() {
    fmt.Println("\n=== 函数变量作为数据结构成员 ===")
    
    // 包含函数变量的结构体
    type MathOperation struct {
        Name      string
        Operation CalculatorFunc
        Priority  int
    }
    
    // 创建操作集合
    operations := []MathOperation{
        {
            Name: "加法",
            Operation: func(a, b int) int { return a + b },
            Priority:  1,
        },
        {
            Name: "乘法",
            Operation: func(a, b int) int { return a * b },
            Priority:  2,
        },
        {
            Name: "最大值",
            Operation: func(a, b int) int {
                if a > b {
                    return a
                }
                return b
            },
            Priority: 3,
        },
    }
    
    // 使用操作
    x, y := 10, 5
    fmt.Printf("计算 %d 和 %d:\n", x, y)
    
    for _, op := range operations {
        result := op.Operation(x, y)
        fmt.Printf("  %s (优先级 %d): %d\n", op.Name, op.Priority, result)
    }
}

// 函数变量切片和映射
func functionVariableCollections() {
    fmt.Println("\n=== 函数变量切片和映射 ===")
    
    // 函数变量切片
    processors := []DataProcessor{
        func(data []int) []int {
            // 过滤偶数
            var result []int
            for _, v := range data {
                if v%2 == 0 {
                    result = append(result, v)
                }
            }
            return result
        },
        func(data []int) []int {
            // 平方
            result := make([]int, len(data))
            for i, v := range data {
                result[i] = v * v
            }
            return result
        },
        func(data []int) []int {
            // 排序
            result := make([]int, len(data))
            copy(result, data)
            sort.Ints(result)
            return result
        },
    }
    
    // 应用处理器
    numbers := []int{5, 2, 8, 1, 9, 3}
    fmt.Printf("原始数据: %v\n", numbers)
    
    for i, processor := range processors {
        result := processor(numbers)
        fmt.Printf("处理器 %d 结果: %v\n", i+1, result)
    }
    
    // 函数变量映射
    stringOperations := map[string]StringProcessor{
        "uppercase": func(s string) string { return strings.ToUpper(s) },
        "lowercase": func(s string) string { return strings.ToLower(s) },
        "reverse": func(s string) string {
            runes := []rune(s)
            for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
                runes[i], runes[j] = runes[j], runes[i]
            }
            return string(runes)
        },
        "length": func(s string) string { return fmt.Sprintf("长度: %d", len(s)) },
    }
    
    text := "Hello World"
    fmt.Printf("\n处理文本: %s\n", text)
    
    for name, operation := range stringOperations {
        result := operation(text)
        fmt.Printf("  %s: %s\n", name, result)
    }
}

// 函数变量的类型检查和反射
func functionVariableReflection() {
    fmt.Println("\n=== 函数变量的类型检查和反射 ===")
    
    // 定义一些函数变量
    var add CalculatorFunc = func(a, b int) int { return a + b }
    var multiply CalculatorFunc = func(a, b int) int { return a * b }
    var process StringProcessor = func(s string) string { return strings.ToUpper(s) }
    
    // 使用反射检查函数类型
    addType := reflect.TypeOf(add)
    processType := reflect.TypeOf(process)
    
    fmt.Printf("add 函数类型: %v\n", addType)
    fmt.Printf("process 函数类型: %v\n", processType)
    
    // 检查函数签名
    fmt.Printf("add 函数输入参数数量: %d\n", addType.NumIn())
    fmt.Printf("add 函数输出参数数量: %d\n", addType.NumOut())
    
    for i := 0; i < addType.NumIn(); i++ {
        fmt.Printf("  参数 %d 类型: %v\n", i, addType.In(i))
    }
    
    for i := 0; i < addType.NumOut(); i++ {
        fmt.Printf("  返回值 %d 类型: %v\n", i, addType.Out(i))
    }
    
    // 比较函数类型
    fmt.Printf("add 和 multiply 类型相同: %t\n", reflect.TypeOf(add) == reflect.TypeOf(multiply))
    fmt.Printf("add 和 process 类型相同: %t\n", reflect.TypeOf(add) == reflect.TypeOf(process))
}

// 函数变量与接口
func functionVariableWithInterface() {
    fmt.Println("\n=== 函数变量与接口 ===")
    
    // 定义接口
    type Operation interface {
        Execute(a, b int) int
    }
    
    // 函数类型实现接口
    type FuncOperation struct {
        Name string
        Func CalculatorFunc
    }
    
    func (fo FuncOperation) Execute(a, b int) int {
        return fo.Func(a, b)
    }
    
    // 创建操作实例
    operations := []Operation{
        FuncOperation{
            Name: "加法",
            Func: func(a, b int) int { return a + b },
        },
        FuncOperation{
            Name: "减法",
            Func: func(a, b int) int { return a - b },
        },
        FuncOperation{
            Name: "乘法",
            Func: func(a, b int) int { return a * b },
        },
    }
    
    // 使用操作
    x, y := 15, 5
    fmt.Printf("计算 %d 和 %d:\n", x, y)
    
    for _, op := range operations {
        result := op.Execute(x, y)
        // 注意：这里无法直接访问Name，因为接口中没有这个字段
        fmt.Printf("  结果: %d\n", result)
    }
}

// 函数变量与闭包
func functionVariableWithClosure() {
    fmt.Println("\n=== 函数变量与闭包 ===")
    
    // 创建配置化的函数工厂
    createConfiguredProcessor := func(config map[string]interface{}) DataProcessor {
        multiplier := 1
        if m, ok := config["multiplier"].(int); ok {
            multiplier = m
        }
        
        offset := 0
        if o, ok := config["offset"].(int); ok {
            offset = o
        }
        
        return func(data []int) []int {
            result := make([]int, len(data))
            for i, v := range data {
                result[i] = v*multiplier + offset
            }
            return result
        }
    }
    
    // 创建不同的处理器
    processor1 := createConfiguredProcessor(map[string]interface{}{
        "multiplier": 2,
        "offset":     0,
    })
    
    processor2 := createConfiguredProcessor(map[string]interface{}{
        "multiplier": 1,
        "offset":     10,
    })
    
    processor3 := createConfiguredProcessor(map[string]interface{}{
        "multiplier": 3,
        "offset":     5,
    })
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Printf("原始数据: %v\n", numbers)
    
    processors := []struct {
        name      string
        processor DataProcessor
    }{
        {"乘以2", processor1},
        {"加10", processor2},
        {"乘以3加5", processor3},
    }
    
    for _, p := range processors {
        result := p.processor(numbers)
        fmt.Printf("%s: %v\n", p.name, result)
    }
}

// 函数变量与并发
func functionVariableConcurrency() {
    fmt.Println("\n=== 函数变量与并发 ===")
    
    // 异步操作类型
    type AsyncTask struct {
        Name     string
        Function AsyncOperation
    }
    
    // 创建异步任务
    tasks := []AsyncTask{
        {
            Name: "任务1",
            Function: func(callback func(error)) error {
                go func() {
                    // 模拟耗时操作
                    // time.Sleep(100 * time.Millisecond)
                    callback(nil)
                }()
                return nil
            },
        },
        {
            Name: "任务2",
            Function: func(callback func(error)) error {
                go func() {
                    // 模拟耗时操作
                    // time.Sleep(200 * time.Millisecond)
                    callback(fmt.Errorf("任务2失败"))
                }()
                return nil
            },
        },
    }
    
    // 执行异步任务
    fmt.Println("开始执行异步任务...")
    results := make(chan string, len(tasks))
    
    for _, task := range tasks {
        task.Function(func(err error) {
            if err != nil {
                results <- fmt.Sprintf("%s: 失败 - %v", task.Name, err)
            } else {
                results <- fmt.Sprintf("%s: 成功", task.Name)
            }
        })
    }
    
    // 收集结果
    for i := 0; i < len(tasks); i++ {
        result := <-results
        fmt.Println(result)
    }
}

// 函数变量的实际应用
func functionVariableRealApplications() {
    fmt.Println("\n=== 函数变量的实际应用 ===")
    
    // 策略模式实现
    type SortStrategy func([]int) []int
    
    strategies := map[string]SortStrategy{
        "快速排序": func(arr []int) []int {
            if len(arr) <= 1 {
                return arr
            }
            
            pivot := arr[0]
            var left, right []int
            
            for i := 1; i < len(arr); i++ {
                if arr[i] <= pivot {
                    left = append(left, arr[i])
                } else {
                    right = append(right, arr[i])
                }
            }
            
            sortedLeft := strategies["快速排序"](left)
            sortedRight := strategies["快速排序"](right)
            
            result := append(sortedLeft, pivot)
            result = append(result, sortedRight...)
            return result
        },
        "归并排序": func(arr []int) []int {
            if len(arr) <= 1 {
                return arr
            }
            
            mid := len(arr) / 2
            left := strategies["归并排序"](arr[:mid])
            right := strategies["归并排序"](arr[mid:])
            
            return merge(left, right)
        },
    }
    
    // 归并函数
    merge := func(left, right []int) []int {
        result := make([]int, 0, len(left)+len(right))
        i, j := 0, 0
        
        for i < len(left) && j < len(right) {
            if left[i] <= right[j] {
                result = append(result, left[i])
                i++
            } else {
                result = append(result, right[j])
                j++
            }
        }
        
        result = append(result, left[i:]...)
        result = append(result, right[j:]...)
        return result
    }
    
    // 测试数据
    testData := []int{64, 34, 25, 12, 22, 11, 90, 5}
    fmt.Printf("原始数据: %v\n", testData)
    
    // 使用不同策略
    for name, strategy := range strategies {
        sorted := strategy(testData)
        fmt.Printf("%s结果: %v\n", name, sorted)
    }
}

func main() {
    functionVariableDeclaration()
    functionVariableAssignment()
    functionVariableInStruct()
    functionVariableCollections()
    functionVariableReflection()
    functionVariableWithInterface()
    functionVariableWithClosure()
    functionVariableConcurrency()
    functionVariableRealApplications()
    
    // 高级应用示例
    fmt.Println("\n=== 高级应用示例 ===")
    advancedApplications()
}

func advancedApplications() {
    // 事件驱动架构
    fmt.Println("事件驱动架构:")
    eventDrivenArchitecture()
    
    // 插件系统
    fmt.Println("\n插件系统:")
    pluginSystem()
}

func eventDrivenArchitecture() {
    // 事件系统
    type EventSystem struct {
        listeners map[string][]EventHandler
    }
    
    // 创建事件系统
    newEventSystem := func() *EventSystem {
        return &EventSystem{
            listeners: make(map[string][]EventHandler),
        }
    }
    
    // 注册监听器
    func (es *EventSystem) On(eventType string, handler EventHandler) {
        es.listeners[eventType] = append(es.listeners[eventType], handler)
    }
    
    // 触发事件
    func (es *EventSystem) Emit(eventType string, data interface{}) {
        if handlers, exists := es.listeners[eventType]; exists {
            for _, handler := range handlers {
                handler(eventType, data)
            }
        }
    }
    
    // 创建事件系统实例
    es := newEventSystem()
    
    // 注册事件处理器（使用函数变量）
    userLoginHandler := func(eventType string, data interface{}) {
        userData := data.(map[string]string)
        fmt.Printf("[用户系统] %s 事件: 用户 %s 登录\n", eventType, userData["username"])
    }
    
    securityHandler := func(eventType string, data interface{}) {
        userData := data.(map[string]string)
        fmt.Printf("[安全系统] %s 事件: 记录IP %s\n", eventType, userData["ip"])
    }
    
    logHandler := func(eventType string, data interface{}) {
        fmt.Printf("[日志系统] %s 事件触发\n", eventType)
    }
    
    // 注册处理器
    es.On("user_login", userLoginHandler)
    es.On("user_login", securityHandler)
    es.On("user_login", logHandler)
    
    // 触发事件
    es.Emit("user_login", map[string]string{
        "username": "alice",
        "ip":       "192.168.1.100",
    })
}

func pluginSystem() {
    // 插件接口
    type Plugin interface {
        Name() string
        Execute(data interface{}) interface{}
    }
    
    // 函数式插件
    type FunctionPlugin struct {
        name string
        fn   func(interface{}) interface{}
    }
    
    func (fp FunctionPlugin) Name() string {
        return fp.name
    }
    
    func (fp FunctionPlugin) Execute(data interface{}) interface{} {
        return fp.fn(data)
    }
    
    // 创建插件工厂
    createPlugin := func(name string, fn func(interface{}) interface{}) Plugin {
        return FunctionPlugin{name: name, fn: fn}
    }
    
    // 预定义插件
    plugins := []Plugin{
        createPlugin("字符串长度", func(data interface{}) interface{} {
            if str, ok := data.(string); ok {
                return len(str)
            }
            return 0
        }),
        createPlugin("数字平方", func(data interface{}) interface{} {
            if num, ok := data.(int); ok {
                return num * num
            }
            return 0
        }),
        createPlugin("转大写", func(data interface{}) interface{} {
            if str, ok := data.(string); ok {
                return strings.ToUpper(str)
            }
            return data
        }),
    }
    
    // 使用插件
    testData := []interface{}{"hello", 5, "world", 10}
    
    fmt.Println("插件处理结果:")
    for _, plugin := range plugins {
        fmt.Printf("插件: %s\n", plugin.Name())
        for _, data := range testData {
            result := plugin.Execute(data)
            fmt.Printf("  %v -> %v\n", data, result)
        }
        fmt.Println()
    }
}
```

### 高阶函数

```go
package main

import (
    "fmt"
    "sort"
    "strings"
    "time"
)

// 高阶函数基本概念
func higherOrderFunctionBasics() {
    fmt.Println("=== 高阶函数基本概念 ===")
    
    // 接受函数作为参数的函数
    applyFunction := func(value int, fn func(int) int) int {
        return fn(value)
    }
    
    // 返回函数的函数
    createMultiplier := func(factor int) func(int) int {
        return func(value int) int {
            return value * factor
        }
    }
    
    // 使用示例
    result1 := applyFunction(5, func(x int) int { return x * x })
    fmt.Printf("5的平方: %d\n", result1)
    
    double := createMultiplier(2)
    triple := createMultiplier(3)
    
    fmt.Printf("5的双倍: %d\n", double(5))
    fmt.Printf("5的三倍: %d\n", triple(5))
}

// 高阶函数 - 映射操作
func higherOrderFunctionMap() {
    fmt.Println("\n=== 高阶函数 - 映射操作 ===")
    
    // Map函数实现
    mapInt := func(slice []int, fn func(int) int) []int {
        result := make([]int, len(slice))
        for i, v := range slice {
            result[i] = fn(v)
        }
        return result
    }
    
    mapString := func(slice []string, fn func(string) string) []string {
        result := make([]string, len(slice))
        for i, v := range slice {
            result[i] = fn(v)
        }
        return result
    }
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5}
    words := []string{"hello", "world", "go", "programming"}
    
    fmt.Printf("原始数字: %v\n", numbers)
    fmt.Printf("原始字符串: %v\n", words)
    
    // 应用映射
    squared := mapInt(numbers, func(x int) int { return x * x })
    fmt.Printf("平方: %v\n", squared)
    
    uppercased := mapString(words, strings.ToUpper)
    fmt.Printf("大写: %v\n", uppercased)
    
    lengths := mapString(words, func(s string) string { return fmt.Sprintf("%d", len(s)) })
    fmt.Printf("长度: %v\n", lengths)
}

// 高阶函数 - 过滤操作
func higherOrderFunctionFilter() {
    fmt.Println("\n=== 高阶函数 - 过滤操作 ===")
    
    // Filter函数实现
    filterInt := func(slice []int, predicate func(int) bool) []int {
        var result []int
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    filterString := func(slice []string, predicate func(string) bool) []string {
        var result []string
        for _, v := range slice {
            if predicate(v) {
                result = append(result, v)
            }
        }
        return result
    }
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    words := []string{"apple", "banana", "cherry", "date", "elderberry"}
    
    fmt.Printf("原始数字: %v\n", numbers)
    fmt.Printf("原始字符串: %v\n", words)
    
    // 过滤偶数
    evenNumbers := filterInt(numbers, func(x int) bool { return x%2 == 0 })
    fmt.Printf("偶数: %v\n", evenNumbers)
    
    // 过滤大于5的数字
    greaterThanFive := filterInt(numbers, func(x int) bool { return x > 5 })
    fmt.Printf("大于5: %v\n", greaterThanFive)
    
    // 过滤长字符串
    longWords := filterString(words, func(s string) bool { return len(s) > 5 })
    fmt.Printf("长单词: %v\n", longWords)
    
    // 过滤包含特定字母的字符串
    containsA := filterString(words, func(s string) bool { return strings.Contains(s, "a") })
    fmt.Printf("包含'a': %v\n", containsA)
}

// 高阶函数 - 归约操作
func higherOrderFunctionReduce() {
    fmt.Println("\n=== 高阶函数 - 归约操作 ===")
    
    // Reduce函数实现
    reduceInt := func(slice []int, reducer func(int, int) int, initial int) int {
        result := initial
        for _, v := range slice {
            result = reducer(result, v)
        }
        return result
    }
    
    reduceString := func(slice []string, reducer func(string, string) string, initial string) string {
        result := initial
        for _, v := range slice {
            result = reducer(result, v)
        }
        return result
    }
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5}
    words := []string{"Hello", " ", "World", " ", "Go"}
    
    fmt.Printf("数字: %v\n", numbers)
    fmt.Printf("字符串: %v\n", words)
    
    // 求和
    sum := reduceInt(numbers, func(acc, x int) int { return acc + x }, 0)
    fmt.Printf("求和: %d\n", sum)
    
    // 求积
    product := reduceInt(numbers, func(acc, x int) int { return acc * x }, 1)
    fmt.Printf("求积: %d\n", product)
    
    // 最大值
    max := reduceInt(numbers, func(acc, x int) int {
        if x > acc {
            return x
        }
        return acc
    }, numbers[0])
    fmt.Printf("最大值: %d\n", max)
    
    // 字符串连接
    concatenated := reduceString(words, func(acc, s string) string { return acc + s }, "")
    fmt.Printf("连接: %s\n", concatenated)
}

// 高阶函数 - 组合操作
func higherOrderFunctionComposition() {
    fmt.Println("\n=== 高阶函数 - 组合操作 ===")
    
    // 函数组合
    compose := func(f, g func(int) int) func(int) int {
        return func(x int) int {
            return f(g(x))
        }
    }
    
    // 函数管道
    pipe := func(value int, functions ...func(int) int) int {
        result := value
        for _, fn := range functions {
            result = fn(result)
        }
        return result
    }
    
    // 基本函数
    double := func(x int) int { return x * 2 }
    addTen := func(x int) int { return x + 10 }
    square := func(x int) int { return x * x }
    
    // 函数组合示例
    doubleThenAddTen := compose(addTen, double)
    addTenThenSquare := compose(square, addTen)
    
    fmt.Printf("double(5) = %d\n", double(5))
    fmt.Printf("addTen(5) = %d\n", addTen(5))
    fmt.Printf("doubleThenAddTen(5) = %d\n", doubleThenAddTen(5))
    fmt.Printf("addTenThenSquare(5) = %d\n", addTenThenSquare(5))
    
    // 函数管道示例
    result := pipe(5, double, addTen, square)
    fmt.Printf("pipe(5, double, addTen, square) = %d\n", result)
    
    // 更复杂的组合
    complexPipe := pipe(3, square, double, addTen, square)
    fmt.Printf("complexPipe(3) = %d\n", complexPipe)
}

// 高阶函数 - 柯里化
func higherOrderFunctionCurrying() {
    fmt.Println("\n=== 高阶函数 - 柯里化 ===")
    
    // 柯里化函数
    curryAdd := func(a int) func(int) int {
        return func(b int) int {
            return a + b
        }
    }
    
    curryMultiply := func(a int) func(int) func(int) int {
        return func(b int) func(int) int {
            return func(c int) int {
                return a * b * c
            }
        }
    }
    
    // 使用柯里化函数
    addFive := curryAdd(5)
    fmt.Printf("addFive(3) = %d\n", addFive(3))
    fmt.Printf("addFive(10) = %d\n", addFive(10))
    
    multiplyByTwo := curryMultiply(2)
    multiplyByTwoAndThree := multiplyByTwo(3)
    fmt.Printf("multiplyByTwoAndThree(4) = %d\n", multiplyByTwoAndThree(4))
    
    // 直接调用
    result := curryMultiply(2)(3)(4)
    fmt.Printf("curryMultiply(2)(3)(4) = %d\n", result)
}

// 高阶函数 - 部分应用
func higherOrderFunctionPartialApplication() {
    fmt.Println("\n=== 高阶函数 - 部分应用 ===")
    
    // 部分应用函数
    partialApply := func(fn func(int, int, int) int, a int) func(int, int) int {
        return func(b, c int) int {
            return fn(a, b, c)
        }
    }
    
    // 三参数函数
    calculate := func(a, b, c int) int {
        return a*b + c
    }
    
    // 部分应用
    calculateWithTwo := partialApply(calculate, 2)
    calculateWithFive := partialApply(calculate, 5)
    
    fmt.Printf("calculate(2, 3, 4) = %d\n", calculate(2, 3, 4))
    fmt.Printf("calculateWithTwo(3, 4) = %d\n", calculateWithTwo(3, 4))
    fmt.Printf("calculateWithFive(3, 4) = %d\n", calculateWithFive(3, 4))
    
    // 更复杂的部分应用
    createFormatter := func(prefix string) func(string) string {
        return func(suffix string) string {
            return prefix + ": " + suffix
        }
    }
    
    infoFormatter := createFormatter("INFO")
    errorFormatter := createFormatter("ERROR")
    
    fmt.Printf("infoFormatter('系统启动') = %s\n", infoFormatter("系统启动"))
    fmt.Printf("errorFormatter('连接失败') = %s\n", errorFormatter("连接失败"))
}

// 高阶函数 - 装饰器模式
func higherOrderFunctionDecorator() {
    fmt.Println("\n=== 高阶函数 - 装饰器模式 ===")
    
    // 装饰器函数
    createLogger := func(prefix string, fn func(int, int) int) func(int, int) int {
        return func(a, b int) int {
            fmt.Printf("[%s] 调用函数，参数: %d, %d\n", prefix, a, b)
            result := fn(a, b)
            fmt.Printf("[%s] 函数返回: %d\n", prefix, result)
            return result
        }
    }
    
    createTimer := func(fn func(int, int) int) func(int, int) int {
        return func(a, b int) int {
            start := time.Now()
            result := fn(a, b)
            duration := time.Since(start)
            fmt.Printf("函数执行时间: %v\n", duration)
            return result
        }
    }
    
    // 基本函数
    add := func(a, b int) int { return a + b }
    multiply := func(a, b int) int { return a * b }
    
    // 应用装饰器
    loggedAdd := createLogger("ADD", add)
    timedMultiply := createTimer(multiply)
    loggedAndTimedAdd := createTimer(createLogger("LOG+TIME", add))
    
    fmt.Println("调用loggedAdd(5, 3):")
    result1 := loggedAdd(5, 3)
    fmt.Printf("结果: %d\n\n", result1)
    
    fmt.Println("调用timedMultiply(4, 6):")
    result2 := timedMultiply(4, 6)
    fmt.Printf("结果: %d\n\n", result2)
    
    fmt.Println("调用loggedAndTimedAdd(10, 20):")
    result3 := loggedAndTimedAdd(10, 20)
    fmt.Printf("结果: %d\n", result3)
}

// 高阶函数 - 函数工厂
func higherOrderFunctionFactory() {
    fmt.Println("\n=== 高阶函数 - 函数工厂 ===")
    
    // 数学运算工厂
    createMathOperation := func(operation string) func(float64, float64) float64 {
        switch operation {
        case "add":
            return func(a, b float64) float64 { return a + b }
        case "subtract":
            return func(a, b float64) float64 { return a - b }
        case "multiply":
            return func(a, b float64) float64 { return a * b }
        case "divide":
            return func(a, b float64) float64 {
                if b != 0 {
                    return a / b
                }
                return 0
            }
        default:
            return func(a, b float64) float64 { return 0 }
        }
    }
    
    // 创建不同的运算函数
    add := createMathOperation("add")
    subtract := createMathOperation("subtract")
    multiply := createMathOperation("multiply")
    divide := createMathOperation("divide")
    
    // 使用工厂创建的函数
    fmt.Printf("加法: %.2f\n", add(10.5, 5.3))
    fmt.Printf("减法: %.2f\n", subtract(10.5, 5.3))
    fmt.Printf("乘法: %.2f\n", multiply(10.5, 5.3))
    fmt.Printf("除法: %.2f\n", divide(10.5, 5.3))
    
    // 验证器工厂
    createValidator := func(rule string) func(interface{}) bool {
        switch rule {
        case "not_empty":
            return func(v interface{}) bool {
                if str, ok := v.(string); ok {
                    return len(str) > 0
                }
                return false
            }
        case "positive":
            return func(v interface{}) bool {
                if num, ok := v.(int); ok {
                    return num > 0
                }
                return false
            }
        case "email":
            return func(v interface{}) bool {
                if email, ok := v.(string); ok {
                    return strings.Contains(email, "@") && strings.Contains(email, ".")
                }
                return false
            }
        default:
            return func(v interface{}) bool { return true }
        }
    }
    
    // 创建验证器
    notEmptyValidator := createValidator("not_empty")
    positiveValidator := createValidator("positive")
    emailValidator := createValidator("email")
    
    // 测试验证器
    fmt.Printf("notEmptyValidator('hello'): %t\n", notEmptyValidator("hello"))
    fmt.Printf("notEmptyValidator(''): %t\n", notEmptyValidator(""))
    fmt.Printf("positiveValidator(5): %t\n", positiveValidator(5))
    fmt.Printf("positiveValidator(-1): %t\n", positiveValidator(-1))
    fmt.Printf("emailValidator('test@example.com'): %t\n", emailValidator("test@example.com"))
    fmt.Printf("emailValidator('invalid'): %t\n", emailValidator("invalid"))
}

// 高阶函数的实际应用
func higherOrderFunctionRealApplications() {
    fmt.Println("\n=== 高阶函数的实际应用 ===")
    
    // 数据处理管道
    type Pipeline struct {
        operations []func([]int) []int
    }
    
    func (p *Pipeline) Add(operation func([]int) []int) *Pipeline {
        p.operations = append(p.operations, operation)
        return p
    }
    
    func (p *Pipeline) Process(data []int) []int {
        result := make([]int, len(data))
        copy(result, data)
        
        for _, operation := range p.operations {
            result = operation(result)
        }
        
        return result
    }
    
    // 创建管道
    pipeline := &Pipeline{}
    
    // 添加操作
    pipeline.Add(func(data []int) []int {
        // 过滤偶数
        var result []int
        for _, v := range data {
            if v%2 == 0 {
                result = append(result, v)
            }
        }
        return result
    })
    
    pipeline.Add(func(data []int) []int {
        // 平方
        result := make([]int, len(data))
        for i, v := range data {
            result[i] = v * v
        }
        return result
    })
    
    pipeline.Add(func(data []int) []int {
        // 排序
        result := make([]int, len(data))
        copy(result, data)
        sort.Ints(result)
        return result
    })
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Printf("原始数据: %v\n", numbers)
    
    // 处理数据
    result := pipeline.Process(numbers)
    fmt.Printf("处理结果: %v\n", result)
}

func main() {
    higherOrderFunctionBasics()
    higherOrderFunctionMap()
    higherOrderFunctionFilter()
    higherOrderFunctionReduce()
    higherOrderFunctionComposition()
    higherOrderFunctionCurrying()
    higherOrderFunctionPartialApplication()
    higherOrderFunctionDecorator()
    higherOrderFunctionFactory()
    higherOrderFunctionRealApplications()
    
    // 高级应用示例
    fmt.Println("\n=== 高级应用示例 ===")
    advancedApplications()
}

func advancedApplications() {
    // 函数式编程风格的数据处理
    fmt.Println("函数式编程风格的数据处理:")
    functionalDataProcessing()
    
    // 配置化的函数组合
    fmt.Println("\n配置化的函数组合:")
    configurableFunctionComposition()
}

func functionalDataProcessing() {
    // 模拟用户数据
    type User struct {
        Name     string
        Age      int
        Active   bool
        Score    float64
        Category string
    }
    
    users := []User{
        {"Alice", 25, true, 85.5, "A"},
        {"Bob", 30, false, 92.0, "B"},
        {"Charlie", 22, true, 78.5, "A"},
        {"Diana", 28, true, 95.0, "C"},
        {"Eve", 35, false, 88.0, "B"},
    }
    
    fmt.Println("原始用户数据:")
    for _, user := range users {
        fmt.Printf("  %+v\n", user)
    }
    
    // 高阶函数实现数据处理
    filterUsers := func(users []User, predicate func(User) bool) []User {
        var result []User
        for _, user := range users {
            if predicate(user) {
                result = append(result, user)
            }
        }
        return result
    }
    
    mapUsers := func(users []User, mapper func(User) User) []User {
        result := make([]User, len(users))
        for i, user := range users {
            result[i] = mapper(user)
        }
        return result
    }
    
    sortUsers := func(users []User, less func(User, User) bool) []User {
        result := make([]User, len(users))
        copy(result, users)
        sort.Slice(result, func(i, j int) bool {
            return less(result[i], result[j])
        })
        return result
    }
    
    // 应用函数式处理
    fmt.Println("\n处理活跃用户，按分数排序:")
    activeUsers := filterUsers(users, func(u User) bool { return u.Active })
    sortedUsers := sortUsers(activeUsers, func(a, b User) bool { return a.Score > b.Score })
    
    for _, user := range sortedUsers {
        fmt.Printf("  %s (年龄: %d, 分数: %.1f)\n", user.Name, user.Age, user.Score)
    }
    
    // 提升所有用户的分数
    fmt.Println("\n提升所有用户分数后:")
    boostedUsers := mapUsers(users, func(u User) User {
        u.Score += 5.0
        return u
    })
    
    for _, user := range boostedUsers {
        fmt.Printf("  %s: %.1f\n", user.Name, user.Score)
    }
}

func configurableFunctionComposition() {
    // 可配置的处理管道
    type ConfigurablePipeline struct {
        config map[string]interface{}
        steps  []func(interface{}) interface{}
    }
    
    func NewConfigurablePipeline(config map[string]interface{}) *ConfigurablePipeline {
        return &ConfigurablePipeline{
            config: config,
            steps:  make([]func(interface{}) interface{}, 0),
        }
    }
    
    func (cp *ConfigurablePipeline) AddStep(stepName string) *ConfigurablePipeline {
        var step func(interface{}) interface{}
        
        switch stepName {
        case "string_to_upper":
            step = func(data interface{}) interface{} {
                if str, ok := data.(string); ok {
                    return strings.ToUpper(str)
                }
                return data
            }
        case "add_prefix":
            prefix := cp.config["prefix"].(string)
            step = func(data interface{}) interface{} {
                if str, ok := data.(string); ok {
                    return prefix + str
                }
                return data
            }
        case "add_suffix":
            suffix := cp.config["suffix"].(string)
            step = func(data interface{}) interface{} {
                if str, ok := data.(string); ok {
                    return str + suffix
                }
                return data
            }
        case "count_chars":
            step = func(data interface{}) interface{} {
                if str, ok := data.(string); ok {
                    return len(str)
                }
                return data
            }
        }
        
        if step != nil {
            cp.steps = append(cp.steps, step)
        }
        
        return cp
    }
    
    func (cp *ConfigurablePipeline) Process(data interface{}) interface{} {
        result := data
        for _, step := range cp.steps {
            result = step(result)
        }
        return result
    }
    
    // 创建配置
    config := map[string]interface{}{
        "prefix": "[INFO] ",
        "suffix": " [END]",
    }
    
    // 创建管道
    pipeline := NewConfigurablePipeline(config)
    pipeline.AddStep("add_prefix").
        AddStep("string_to_upper").
        AddStep("add_suffix")
    
    // 处理数据
    input := "hello world"
    result := pipeline.Process(input)
    fmt.Printf("输入: %s\n", input)
    fmt.Printf("输出: %v\n", result)
    
    // 创建另一个管道用于计数
    countPipeline := NewConfigurablePipeline(nil)
    countPipeline.AddStep("string_to_upper").
        AddStep("count_chars")
    
    countResult := countPipeline.Process(input)
    fmt.Printf("字符计数: %v\n", countResult)
}
```

### 函数工厂模式

```go
package main

import (
    "fmt"
    "math"
    "strings"
    "time"
)

// 基本函数工厂
func basicFunctionFactory() {
    fmt.Println("=== 基本函数工厂 ===")
    
    // 简单的函数工厂
    createCalculator := func(operation string) func(float64, float64) float64 {
        switch operation {
        case "add":
            return func(a, b float64) float64 { return a + b }
        case "subtract":
            return func(a, b float64) float64 { return a - b }
        case "multiply":
            return func(a, b float64) float64 { return a * b }
        case "divide":
            return func(a, b float64) float64 {
                if b != 0 {
                    return a / b
                }
                return math.Inf(1) // 返回无穷大
            }
        default:
            return func(a, b float64) float64 { return 0 }
        }
    }
    
    // 使用工厂创建函数
    add := createCalculator("add")
    subtract := createCalculator("subtract")
    multiply := createCalculator("multiply")
    divide := createCalculator("divide")
    
    fmt.Printf("加法: %.2f\n", add(10.5, 5.3))
    fmt.Printf("减法: %.2f\n", subtract(10.5, 5.3))
    fmt.Printf("乘法: %.2f\n", multiply(10.5, 5.3))
    fmt.Printf("除法: %.2f\n", divide(10.5, 5.3))
}

// 配置化函数工厂
func configurableFunctionFactory() {
    fmt.Println("\n=== 配置化函数工厂 ===")
    
    // 配置结构
    type Config struct {
        Prefix    string
        Suffix    string
        Separator string
        Multiplier int
    }
    
    // 字符串处理工厂
    createStringProcessor := func(config Config) func(string) string {
        return func(input string) string {
            result := input
            
            // 添加前缀
            if config.Prefix != "" {
                result = config.Prefix + result
            }
            
            // 添加后缀
            if config.Suffix != "" {
                result = result + config.Suffix
            }
            
            // 重复字符串
            if config.Multiplier > 1 {
                original := result
                for i := 1; i < config.Multiplier; i++ {
                    result += config.Separator + original
                }
            }
            
            return result
        }
    }
    
    // 创建不同的处理器
    processor1 := createStringProcessor(Config{
        Prefix:    "[INFO] ",
        Suffix:    " [END]",
        Separator: " | ",
        Multiplier: 1,
    })
    
    processor2 := createStringProcessor(Config{
        Prefix:    ">>> ",
        Suffix:    " <<<",
        Separator: " -> ",
        Multiplier: 3,
    })
    
    processor3 := createStringProcessor(Config{
        Prefix:    "",
        Suffix:    "",
        Separator: ", ",
        Multiplier: 2,
    })
    
    // 测试处理器
    input := "Hello World"
    fmt.Printf("输入: %s\n", input)
    fmt.Printf("处理器1: %s\n", processor1(input))
    fmt.Printf("处理器2: %s\n", processor2(input))
    fmt.Printf("处理器3: %s\n", processor3(input))
}

// 泛型函数工厂（Go 1.18+）
func genericFunctionFactory() {
    fmt.Println("\n=== 泛型函数工厂 ===")
    
    // 泛型映射工厂
    createMapper := func[T any, R any](transform func(T) R) func([]T) []R {
        return func(slice []T) []R {
            result := make([]R, len(slice))
            for i, v := range slice {
                result[i] = transform(v)
            }
            return result
        }
    }
    
    // 泛型过滤工厂
    createFilter := func[T any](predicate func(T) bool) func([]T) []T {
        return func(slice []T) []T {
            var result []T
            for _, v := range slice {
                if predicate(v) {
                    result = append(result, v)
                }
            }
            return result
        }
    }
    
    // 创建具体的映射函数
    squareMapper := createMapper(func(x int) int { return x * x })
    stringLengthMapper := createMapper(func(s string) int { return len(s) })
    toUpperMapper := createMapper(func(s string) string { return strings.ToUpper(s) })
    
    // 创建具体的过滤函数
    evenFilter := createFilter(func(x int) bool { return x%2 == 0 })
    longStringFilter := createFilter(func(s string) bool { return len(s) > 5 })
    containsAFilter := createFilter(func(s string) bool { return strings.Contains(s, "a") })
    
    // 测试数据
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    words := []string{"apple", "banana", "cherry", "date", "elderberry"}
    
    fmt.Printf("数字: %v\n", numbers)
    fmt.Printf("平方: %v\n", squareMapper(numbers))
    fmt.Printf("偶数: %v\n", evenFilter(numbers))
    fmt.Printf("偶数的平方: %v\n", squareMapper(evenFilter(numbers)))
    
    fmt.Printf("\n字符串: %v\n", words)
    fmt.Printf("长度: %v\n", stringLengthMapper(words))
    fmt.Printf("大写: %v\n", toUpperMapper(words))
    fmt.Printf("长字符串: %v\n", longStringFilter(words))
    fmt.Printf("包含'a': %v\n", containsAFilter(words))
}

// 验证器工厂
func validatorFactory() {
    fmt.Println("\n=== 验证器工厂 ===")
    
    // 验证器类型
    type Validator func(interface{}) bool
    
    // 验证器工厂
    createValidator := func(ruleType string, config ...interface{}) Validator {
        switch ruleType {
        case "not_empty":
            return func(v interface{}) bool {
                if str, ok := v.(string); ok {
                    return len(str) > 0
                }
                return false
            }
        case "min_length":
            minLength := 0
            if len(config) > 0 {
                if length, ok := config[0].(int); ok {
                    minLength = length
                }
            }
            return func(v interface{}) bool {
                if str, ok := v.(string); ok {
                    return len(str) >= minLength
                }
                return false
            }
        case "max_length":
            maxLength := 100
            if len(config) > 0 {
                if length, ok := config[0].(int); ok {
                    maxLength = length
                }
            }
            return func(v interface{}) bool {
                if str, ok := v.(string); ok {
                    return len(str) <= maxLength
                }
                return false
            }
        case "range":
            min, max := 0, 100
            if len(config) > 1 {
                if minValue, ok := config[0].(int); ok {
                    min = minValue
                }
                if maxValue, ok := config[1].(int); ok {
                    max = maxValue
                }
            }
            return func(v interface{}) bool {
                if num, ok := v.(int); ok {
                    return num >= min && num <= max
                }
                return false
            }
        case "email":
            return func(v interface{}) bool {
                if email, ok := v.(string); ok {
                    return strings.Contains(email, "@") && strings.Contains(email, ".")
                }
                return false
            }
        default:
            return func(v interface{}) bool { return true }
        }
    }
    
    // 创建验证器
    notEmptyValidator := createValidator("not_empty")
    minLengthValidator := createValidator("min_length", 5)
    maxLengthValidator := createValidator("max_length", 20)
    rangeValidator := createValidator("range", 1, 100)
    emailValidator := createValidator("email")
    
    // 测试数据
    testData := []interface{}{
        "hello",
        "",
        "test@example.com",
        "invalid-email",
        50,
        150,
        -10,
    }
    
    fmt.Println("验证器测试:")
    for _, data := range testData {
        fmt.Printf("数据: %v\n", data)
        fmt.Printf("  非空: %t\n", notEmptyValidator(data))
        fmt.Printf("  最小长度5: %t\n", minLengthValidator(data))
        fmt.Printf("  最大长度20: %t\n", maxLengthValidator(data))
        fmt.Printf("  范围1-100: %t\n", rangeValidator(data))
        fmt.Printf("  邮箱格式: %t\n", emailValidator(data))
        fmt.Println()
    }
}

// 中间件工厂
func middlewareFactory() {
    fmt.Println("\n=== 中间件工厂 ===")
    
    // 中间件类型
    type Middleware func(func(string) string) func(string) string
    
    // 中间件工厂
    createMiddleware := func(middlewareType string, config ...interface{}) Middleware {
        switch middlewareType {
        case "logger":
            prefix := "LOG"
            if len(config) > 0 {
                if p, ok := config[0].(string); ok {
                    prefix = p
                }
            }
            return func(next func(string) string) func(string) string {
                return func(input string) string {
                    fmt.Printf("[%s] 开始处理: %s\n", prefix, input)
                    result := next(input)
                    fmt.Printf("[%s] 处理完成: %s\n", prefix, result)
                    return result
                }
            }
        case "timer":
            return func(next func(string) string) func(string) string {
                return func(input string) string {
                    start := time.Now()
                    result := next(input)
                    duration := time.Since(start)
                    fmt.Printf("[TIMER] 执行时间: %v\n", duration)
                    return result
                }
            }
        case "uppercase":
            return func(next func(string) string) func(string) string {
                return func(input string) string {
                    result := next(input)
                    return strings.ToUpper(result)
                }
            }
        case "add_prefix":
            prefix := ""
            if len(config) > 0 {
                if p, ok := config[0].(string); ok {
                    prefix = p
                }
            }
            return func(next func(string) string) func(string) string {
                return func(input string) string {
                    result := next(input)
                    return prefix + result
                }
            }
        default:
            return func(next func(string) string) func(string) string {
                return next
            }
        }
    }
    
    // 基本处理器
    basicHandler := func(input string) string {
        return "处理结果: " + input
    }
    
    // 创建中间件
    loggerMiddleware := createMiddleware("logger", "HANDLER")
    timerMiddleware := createMiddleware("timer")
    uppercaseMiddleware := createMiddleware("uppercase")
    prefixMiddleware := createMiddleware("add_prefix", "[RESULT] ")
    
    // 应用中间件（从内到外）
    handler := loggerMiddleware(
        timerMiddleware(
            uppercaseMiddleware(
                prefixMiddleware(basicHandler),
            ),
        ),
    )
    
    // 测试处理器
    fmt.Println("调用处理器:")
    result := handler("hello world")
    fmt.Printf("最终结果: %s\n", result)
}

// 策略工厂
func strategyFactory() {
    fmt.Println("\n=== 策略工厂 ===")
    
    // 排序策略接口
    type SortStrategy interface {
        Sort([]int) []int
        Name() string
    }
    
    // 具体策略实现
    type BubbleSort struct{}
    type QuickSort struct{}
    type MergeSort struct{}
    
    func (bs BubbleSort) Sort(arr []int) []int {
        result := make([]int, len(arr))
        copy(result, arr)
        
        n := len(result)
        for i := 0; i < n-1; i++ {
            for j := 0; j < n-i-1; j++ {
                if result[j] > result[j+1] {
                    result[j], result[j+1] = result[j+1], result[j]
                }
            }
        }
        return result
    }
    
    func (bs BubbleSort) Name() string { return "冒泡排序" }
    
    func (qs QuickSort) Sort(arr []int) []int {
        if len(arr) <= 1 {
            return arr
        }
        
        result := make([]int, len(arr))
        copy(result, arr)
        
        var quickSort func([]int, int, int)
        quickSort = func(arr []int, low, high int) {
            if low < high {
                pi := partition(arr, low, high)
                quickSort(arr, low, pi-1)
                quickSort(arr, pi+1, high)
            }
        }
        
        quickSort(result, 0, len(result)-1)
        return result
    }
    
    func (qs QuickSort) Name() string { return "快速排序" }
    
    func (ms MergeSort) Sort(arr []int) []int {
        if len(arr) <= 1 {
            return arr
        }
        
        mid := len(arr) / 2
        left := ms.Sort(arr[:mid])
        right := ms.Sort(arr[mid:])
        
        return merge(left, right)
    }
    
    func (ms MergeSort) Name() string { return "归并排序" }
    
    // 辅助函数
    func partition(arr []int, low, high int) int {
        pivot := arr[high]
        i := low - 1
        
        for j := low; j < high; j++ {
            if arr[j] < pivot {
                i++
                arr[i], arr[j] = arr[j], arr[i]
            }
        }
        arr[i+1], arr[high] = arr[high], arr[i+1]
        return i + 1
    }
    
    func merge(left, right []int) []int {
        result := make([]int, 0, len(left)+len(right))
        i, j := 0, 0
        
        for i < len(left) && j < len(right) {
            if left[i] <= right[j] {
                result = append(result, left[i])
                i++
            } else {
                result = append(result, right[j])
                j++
            }
        }
        
        result = append(result, left[i:]...)
        result = append(result, right[j:]...)
        return result
    }
    
    // 策略工厂
    createSortStrategy := func(strategyType string) SortStrategy {
        switch strategyType {
        case "bubble":
            return BubbleSort{}
        case "quick":
            return QuickSort{}
        case "merge":
            return MergeSort{}
        default:
            return BubbleSort{}
        }
    }
    
    // 测试数据
    testData := []int{64, 34, 25, 12, 22, 11, 90, 5}
    fmt.Printf("原始数据: %v\n", testData)
    
    // 使用不同策略
    strategies := []string{"bubble", "quick", "merge"}
    
    for _, strategyType := range strategies {
        strategy := createSortStrategy(strategyType)
        sorted := strategy.Sort(testData)
        fmt.Printf("%s: %v\n", strategy.Name(), sorted)
    }
}

// 数据库连接工厂
func databaseConnectionFactory() {
    fmt.Println("\n=== 数据库连接工厂 ===")
    
    // 数据库连接配置
    type DBConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        Database string
        Timeout  time.Duration
    }
    
    // 数据库连接接口
    type DatabaseConnection interface {
        Connect() error
        Query(query string) string
        Close() error
    }
    
    // MySQL连接实现
    type MySQLConnection struct {
        config DBConfig
    }
    
    func (m *MySQLConnection) Connect() error {
        fmt.Printf("连接MySQL: %s:%d/%s\n", m.config.Host, m.config.Port, m.config.Database)
        return nil
    }
    
    func (m *MySQLConnection) Query(query string) string {
        return fmt.Sprintf("MySQL执行查询: %s", query)
    }
    
    func (m *MySQLConnection) Close() error {
        fmt.Println("关闭MySQL连接")
        return nil
    }
    
    // PostgreSQL连接实现
    type PostgreSQLConnection struct {
        config DBConfig
    }
    
    func (p *PostgreSQLConnection) Connect() error {
        fmt.Printf("连接PostgreSQL: %s:%d/%s\n", p.config.Host, p.config.Port, p.config.Database)
        return nil
    }
    
    func (p *PostgreSQLConnection) Query(query string) string {
        return fmt.Sprintf("PostgreSQL执行查询: %s", query)
    }
    
    func (p *PostgreSQLConnection) Close() error {
        fmt.Println("关闭PostgreSQL连接")
        return nil
    }
    
    // 数据库连接工厂
    createDatabaseConnection := func(dbType string, config DBConfig) DatabaseConnection {
        switch dbType {
        case "mysql":
            return &MySQLConnection{config: config}
        case "postgresql":
            return &PostgreSQLConnection{config: config}
        default:
            return &MySQLConnection{config: config}
        }
    }
    
    // 配置
    mysqlConfig := DBConfig{
        Host:     "localhost",
        Port:     3306,
        Username: "root",
        Password: "password",
        Database: "mydb",
        Timeout:  30 * time.Second,
    }
    
    postgresConfig := DBConfig{
        Host:     "localhost",
        Port:     5432,
        Username: "postgres",
        Password: "password",
        Database: "mydb",
        Timeout:  30 * time.Second,
    }
    
    // 创建连接
    mysqlConn := createDatabaseConnection("mysql", mysqlConfig)
    postgresConn := createDatabaseConnection("postgresql", postgresConfig)
    
    // 使用连接
    connections := []DatabaseConnection{mysqlConn, postgresConn}
    
    for _, conn := range connections {
        conn.Connect()
        result := conn.Query("SELECT * FROM users")
        fmt.Println(result)
        conn.Close()
        fmt.Println()
    }
}

// 实际应用示例
func realWorldFactoryExamples() {
    fmt.Println("\n=== 实际应用示例 ===")
    
    // API客户端工厂
    fmt.Println("API客户端工厂:")
    apiClientFactory()
    
    // 日志处理器工厂
    fmt.Println("\n日志处理器工厂:")
    logHandlerFactory()
}

func apiClientFactory() {
    // API客户端配置
    type APIConfig struct {
        BaseURL   string
        APIKey    string
        Timeout   time.Duration
        Retry     int
        UserAgent string
    }
    
    // API客户端接口
    type APIClient interface {
        Get(endpoint string) string
        Post(endpoint string, data string) string
    }
    
    // REST API客户端
    type RESTClient struct {
        config APIConfig
    }
    
    func (r *RESTClient) Get(endpoint string) string {
        return fmt.Sprintf("GET %s%s (API Key: %s)", r.config.BaseURL, endpoint, r.config.APIKey[:5]+"...")
    }
    
    func (r *RESTClient) Post(endpoint string, data string) string {
        return fmt.Sprintf("POST %s%s (数据: %s)", r.config.BaseURL, endpoint, data)
    }
    
    // GraphQL客户端
    type GraphQLClient struct {
        config APIConfig
    }
    
    func (g *GraphQLClient) Get(endpoint string) string {
        return fmt.Sprintf("GraphQL查询 %s (API Key: %s)", endpoint, g.config.APIKey[:5]+"...")
    }
    
    func (g *GraphQLClient) Post(endpoint string, data string) string {
        return fmt.Sprintf("GraphQL变更 %s (数据: %s)", endpoint, data)
    }
    
    // API客户端工厂
    createAPIClient := func(clientType string, config APIConfig) APIClient {
        switch clientType {
        case "rest":
            return &RESTClient{config: config}
        case "graphql":
            return &GraphQLClient{config: config}
        default:
            return &RESTClient{config: config}
        }
    }
    
    // 配置
    restConfig := APIConfig{
        BaseURL:   "https://api.example.com/",
        APIKey:    "sk_1234567890abcdef",
        Timeout:   30 * time.Second,
        Retry:     3,
        UserAgent: "MyApp/1.0",
    }
    
    graphqlConfig := APIConfig{
        BaseURL:   "https://graphql.example.com/",
        APIKey:    "gql_1234567890abcdef",
        Timeout:   30 * time.Second,
        Retry:     3,
        UserAgent: "MyApp/1.0",
    }
    
    // 创建客户端
    restClient := createAPIClient("rest", restConfig)
    graphqlClient := createAPIClient("graphql", graphqlConfig)
    
    // 使用客户端
    fmt.Println(restClient.Get("/users"))
    fmt.Println(restClient.Post("/users", `{"name":"Alice"}`))
    fmt.Println()
    fmt.Println(graphqlClient.Get(`{ users { id name } }`))
    fmt.Println(graphqlClient.Post(`mutation { createUser(name: "Bob") }`, ""))
}

func logHandlerFactory() {
    // 日志级别
    type LogLevel int
    
    const (
        DEBUG LogLevel = iota
        INFO
        WARN
        ERROR
    )
    
    // 日志处理器接口
    type LogHandler interface {
        Handle(level LogLevel, message string)
    }
    
    // 控制台日志处理器
    type ConsoleHandler struct {
        format string
    }
    
    func (c *ConsoleHandler) Handle(level LogLevel, message string) {
        levelStr := []string{"DEBUG", "INFO", "WARN", "ERROR"}[level]
        fmt.Printf("[%s] %s: %s\n", time.Now().Format("15:04:05"), levelStr, message)
    }
    
    // 文件日志处理器
    type FileHandler struct {
        filename string
        format   string
    }
    
    func (f *FileHandler) Handle(level LogLevel, message string) {
        levelStr := []string{"DEBUG", "INFO", "WARN", "ERROR"}[level]
        fmt.Printf("写入文件 %s: [%s] %s\n", f.filename, levelStr, message)
    }
    
    // 日志处理器工厂
    createLogHandler := func(handlerType string, config map[string]interface{}) LogHandler {
        switch handlerType {
        case "console":
            format := "%time% [%level%] %message%"
            if f, ok := config["format"].(string); ok {
                format = f
            }
            return &ConsoleHandler{format: format}
        case "file":
            filename := "app.log"
            if f, ok := config["filename"].(string); ok {
                filename = f
            }
            format := "%time% [%level%] %message%"
            if f, ok := config["format"].(string); ok {
                format = f
            }
            return &FileHandler{filename: filename, format: format}
        default:
            return &ConsoleHandler{}
        }
    }
    
    // 创建处理器
    consoleHandler := createLogHandler("console", map[string]interface{}{
        "format": "%time% [%level%] %message%",
    })
    
    fileHandler := createLogHandler("file", map[string]interface{}{
        "filename": "application.log",
        "format":   "%time% [%level%] %message%",
    })
    
    // 使用处理器
    handlers := []LogHandler{consoleHandler, fileHandler}
    
    messages := []struct {
        level   LogLevel
        message string
    }{
        {INFO, "应用程序启动"},
        {DEBUG, "调试信息"},
        {WARN, "警告信息"},
        {ERROR, "错误信息"},
    }
    
    for _, msg := range messages {
        for _, handler := range handlers {
            handler.Handle(msg.level, msg.message)
        }
    }
}

func main() {
    basicFunctionFactory()
    configurableFunctionFactory()
    genericFunctionFactory()
    validatorFactory()
    middlewareFactory()
    strategyFactory()
    databaseConnectionFactory()
    realWorldFactoryExamples()
}
```

### defer语句详解

```go
package main

import (
    "fmt"
    "io"
    "os"
    "sync"
    "time"
)

// 基本defer语句
func basicDefer() {
    fmt.Println("=== 基本defer语句 ===")
    
    defer fmt.Println("这是defer语句，在函数结束时执行")
    
    fmt.Println("这是正常语句，先执行")
    
    // defer语句在函数返回前执行，即使发生panic也会执行
}

// defer执行顺序
func deferOrder() {
    fmt.Println("\n=== defer执行顺序 ===")
    
    fmt.Println("1. 第一条语句")
    
    defer fmt.Println("4. 第一个defer")
    defer fmt.Println("3. 第二个defer")
    defer fmt.Println("2. 第三个defer")
    
    fmt.Println("1. 最后一条语句")
    
    // defer语句按照后进先出(LIFO)的顺序执行
}

// defer与返回值
func deferWithReturnValue() {
    fmt.Println("\n=== defer与返回值 ===")
    
    result := functionWithNamedReturn()
    fmt.Printf("命名返回值函数结果: %d\n", result)
    
    result2 := functionWithRegularReturn()
    fmt.Printf("普通返回值函数结果: %d\n", result2)
}

func functionWithNamedReturn() (result int) {
    result = 10
    defer func() {
        result += 5  // 修改命名返回值
        fmt.Printf("defer中修改result为: %d\n", result)
    }()
    
    fmt.Printf("函数中result为: %d\n", result)
    return  // 返回修改后的result
}

func functionWithRegularReturn() int {
    result := 10
    defer func() {
        result += 5  // 这个修改不会影响返回值
        fmt.Printf("defer中result为: %d\n", result)
    }()
    
    fmt.Printf("函数中result为: %d\n", result)
    return result  // 返回10，不是15
}

// defer与参数求值
func deferWithParameterEvaluation() {
    fmt.Println("\n=== defer与参数求值 ===")
    
    i := 0
    
    // 参数在defer语句执行时求值
    defer fmt.Printf("defer执行时i的值: %d\n", i)
    
    i++
    fmt.Printf("i递增后: %d\n", i)
    
    // 如果想获取执行时的值，使用闭包
    defer func() {
        fmt.Printf("闭包中获取i的值: %d\n", i)
    }()
}

// defer的实际应用 - 资源清理
func deferForResourceCleanup() {
    fmt.Println("\n=== defer的实际应用 - 资源清理 ===")
    
    // 模拟文件操作
    fileOperation()
    
    // 模拟数据库连接
    databaseOperation()
    
    // 模拟网络连接
    networkOperation()
}

func fileOperation() {
    fmt.Println("文件操作示例:")
    
    // 模拟打开文件
    file := "example.txt"
    fmt.Printf("打开文件: %s\n", file)
    
    // defer确保文件关闭
    defer func() {
        fmt.Printf("关闭文件: %s\n", file)
    }()
    
    // 模拟文件操作
    fmt.Println("  读取文件内容...")
    fmt.Println("  处理文件数据...")
    fmt.Println("  写入文件结果...")
    
    // 即使发生错误，defer也会执行
    // if someError {
    //     return // defer仍然会执行
    // }
}

func databaseOperation() {
    fmt.Println("数据库操作示例:")
    
    // 模拟建立连接
    connection := "db_connection"
    fmt.Printf("建立数据库连接: %s\n", connection)
    
    // defer确保连接关闭
    defer func() {
        fmt.Printf("关闭数据库连接: %s\n", connection)
    }()
    
    // 模拟数据库操作
    fmt.Println("  执行查询...")
    fmt.Println("  处理结果...")
    fmt.Println("  提交事务...")
}

func networkOperation() {
    fmt.Println("网络操作示例:")
    
    // 模拟建立连接
    connection := "network_connection"
    fmt.Printf("建立网络连接: %s\n", connection)
    
    // defer确保连接关闭
    defer func() {
        fmt.Printf("关闭网络连接: %s\n", connection)
    }()
    
    // 模拟网络操作
    fmt.Println("  发送请求...")
    fmt.Println("  接收响应...")
    fmt.Println("  处理数据...")
}

// defer与错误处理
func deferWithErrorHandling() {
    fmt.Println("\n=== defer与错误处理 ===")
    
    result, err := riskyOperation()
    if err != nil {
        fmt.Printf("操作失败: %v\n", err)
    } else {
        fmt.Printf("操作成功: %d\n", result)
    }
}

func riskyOperation() (result int, err error) {
    // defer用于错误处理和资源清理
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("操作恐慌: %v", r)
        }
        fmt.Println("清理资源...")
    }()
    
    fmt.Println("执行风险操作...")
    
    // 模拟可能的错误
    // if someCondition {
    //     panic("操作失败!")
    // }
    
    result = 42
    return
}

// defer与互斥锁
func deferWithMutex() {
    fmt.Println("\n=== defer与互斥锁 ===")
    
    var mu sync.Mutex
    var data int
    
    // 使用defer确保锁被释放
    mu.Lock()
    defer mu.Unlock()
    
    // 模拟临界区操作
    data++
    fmt.Printf("数据更新为: %d\n", data)
    
    // 即使发生错误，锁也会被释放
    // if someError {
    //     return // defer仍然会执行，释放锁
    // }
}

// defer与性能考虑
func deferPerformance() {
    fmt.Println("\n=== defer与性能考虑 ===")
    
    // 简单操作可以直接写，避免defer开销
    start := time.Now()
    
    // 使用defer的版本
    for i := 0; i < 1000; i++ {
        deferExample()
    }
    
    deferTime := time.Since(start)
    
    // 不使用defer的版本
    start = time.Now()
    for i := 0; i < 1000; i++ {
        noDeferExample()
    }
    
    noDeferTime := time.Since(start)
    
    fmt.Printf("使用defer耗时: %v\n", deferTime)
    fmt.Printf("不使用defer耗时: %v\n", noDeferTime)
}

func deferExample() {
    file := &mockFile{}
    defer file.Close()  // defer有轻微开销
    
    file.Write("data")
}

func noDeferExample() {
    file := &mockFile{}
    
    file.Write("data")
    file.Close()  // 直接调用，无defer开销
}

type mockFile struct{}

func (m *mockFile) Write(data string) {
    // 模拟写入操作
}

func (m *mockFile) Close() {
    // 模拟关闭操作
}

// defer与闭包
func deferWithClosure() {
    fmt.Println("\n=== defer与闭包 ===")
    
    for i := 0; i < 3; i++ {
        // 错误的方式：所有defer都会使用最终的i值
        defer func() {
            fmt.Printf("错误的闭包: %d\n", i)
        }()
    }
    
    fmt.Println("等待defer执行...")
    
    // 正确的方式：传递参数给闭包
    for j := 0; j < 3; j++ {
        defer func(index int) {
            fmt.Printf("正确的闭包: %d\n", index)
        }(j)
    }
    
    fmt.Println("等待正确的defer执行...")
}

// defer与panic/recover
func deferWithPanicRecover() {
    fmt.Println("\n=== defer与panic/recover ===")
    
    fmt.Println("开始测试panic/recover...")
    
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("捕获到panic: %v\n", r)
        }
    }()
    
    fmt.Println("即将发生panic...")
    panic("这是一个测试panic")
    
    fmt.Println("这行不会执行")
}

// 多层defer
func multiLevelDefer() {
    fmt.Println("\n=== 多层defer ===")
    
    outerFunction()
}

func outerFunction() {
    defer fmt.Println("外层函数defer 1")
    defer fmt.Println("外层函数defer 2")
    
    fmt.Println("调用内层函数")
    innerFunction()
    
    defer fmt.Println("外层函数defer 3")
}

func innerFunction() {
    defer fmt.Println("内层函数defer 1")
    defer fmt.Println("内层函数defer 2")
    
    fmt.Println("内层函数执行")
    
    defer fmt.Println("内层函数defer 3")
}

// defer的实际应用场景
func deferRealWorldApplications() {
    fmt.Println("\n=== defer的实际应用场景 ===")
    
    // 日志记录
    logWithDefer()
    
    // 性能监控
    performanceMonitor()
    
    // 事务处理
    transactionExample()
}

func logWithDefer() {
    fmt.Println("日志记录示例:")
    
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        fmt.Printf("操作完成，耗时: %v\n", duration)
    }()
    
    fmt.Println("  执行操作...")
    time.Sleep(100 * time.Millisecond) // 模拟耗时操作
}

func performanceMonitor() {
    fmt.Println("性能监控示例:")
    
    traceID := "trace-12345"
    fmt.Printf("开始请求 %s\n", traceID)
    
    defer func() {
        fmt.Printf("结束请求 %s\n", traceID)
    }()
    
    // 模拟请求处理
    fmt.Println("  处理请求...")
    time.Sleep(50 * time.Millisecond)
}

func transactionExample() {
    fmt.Println("事务处理示例:")
    
    fmt.Println("开始事务")
    
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("回滚事务")
        } else {
            fmt.Println("提交事务")
        }
    }()
    
    fmt.Println("  执行数据库操作...")
    
    // 模拟可能的错误
    // panic("数据库错误")
}

// defer与接口
func deferWithInterface() {
    fmt.Println("\n=== defer与接口 ===")
    
    // 使用io.Closer接口
    var closer io.Closer = &mockCloser{name: "测试资源"}
    
    defer func() {
        if err := closer.Close(); err != nil {
            fmt.Printf("关闭错误: %v\n", err)
        }
    }()
    
    fmt.Println("使用资源...")
}

type mockCloser struct {
    name string
}

func (m *mockCloser) Close() error {
    fmt.Printf("关闭资源: %s\n", m.name)
    return nil
}

// defer与并发
func deferWithConcurrency() {
    fmt.Println("\n=== defer与并发 ===")
    
    var wg sync.WaitGroup
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            defer fmt.Printf("Goroutine %d 结束\n", id)
            
            fmt.Printf("Goroutine %d 开始\n", id)
            time.Sleep(time.Duration(id) * 100 * time.Millisecond)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("所有goroutine完成")
}

// defer的最佳实践
func deferBestPractices() {
    fmt.Println("\n=== defer的最佳实践 ===")
    
    // 1. 紧跟资源获取
    bestPractice1()
    
    // 2. 避免在循环中使用defer
    bestPractice2()
    
    // 3. 使用defer进行错误处理
    bestPractice3()
}

func bestPractice1() {
    fmt.Println("最佳实践1: 紧跟资源获取")
    
    // 好的做法
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Printf("打开文件错误: %v\n", err)
        return
    }
    defer file.Close() // 紧跟在获取资源后
    
    // 使用文件...
    fmt.Println("  处理文件...")
}

func bestPractice2() {
    fmt.Println("最佳实践2: 避免在循环中使用defer")
    
    // 不好的做法
    // for i := 0; i < 10; i++ {
    //     file, err := os.Open(fmt.Sprintf("file%d.txt", i))
    //     if err != nil {
    //         continue
    //     }
    //     defer file.Close() // 这会导致所有文件在函数结束时才关闭
    // }
    
    // 好的做法
    for i := 0; i < 3; i++ {
        func() {
            file, err := os.Open(fmt.Sprintf("file%d.txt", i))
            if err != nil {
                fmt.Printf("打开文件%d错误: %v\n", i, err)
                return
            }
            defer file.Close() // 在匿名函数中使用defer
            
            fmt.Printf("  处理文件%d...\n", i)
        }()
    }
}

func bestPractice3() {
    fmt.Println("最佳实践3: 使用defer进行错误处理")
    
    result, err := operationWithErrorHandling()
    if err != nil {
        fmt.Printf("操作失败: %v\n", err)
    } else {
        fmt.Printf("操作成功: %d\n", result)
    }
}

func operationWithErrorHandling() (result int, err error) {
    // defer用于统一错误处理
    defer func() {
        if err != nil {
            fmt.Println("清理资源...")
        }
    }()
    
    // 模拟操作
    fmt.Println("执行操作...")
    
    // 模拟可能的错误
    // if someCondition {
    //     err = errors.New("操作失败")
    //     return
    // }
    
    result = 100
    return
}

func main() {
    basicDefer()
    deferOrder()
    deferWithReturnValue()
    deferWithParameterEvaluation()
    deferForResourceCleanup()
    deferWithErrorHandling()
    deferWithMutex()
    deferPerformance()
    deferWithClosure()
    deferWithPanicRecover()
    multiLevelDefer()
    deferRealWorldApplications()
    deferWithInterface()
    deferWithConcurrency()
    deferBestPractices()
    
    // 高级应用示例
    fmt.Println("\n=== 高级应用示例 ===")
    advancedDeferApplications()
}

func advancedDeferApplications() {
    // 链式调用清理
    fmt.Println("链式调用清理:")
    chainedCleanup()
    
    // 上下文管理
    fmt.Println("\n上下文管理:")
    contextManagement()
}

func chainedCleanup() {
    fmt.Println("链式清理示例:")
    
    // 创建清理链
    cleanupChain := &CleanupChain{}
    
    defer cleanupChain.Execute()
    
    // 添加清理任务
    cleanupChain.Add(func() { fmt.Println("  清理任务1") })
    cleanupChain.Add(func() { fmt.Println("  清理任务2") })
    cleanupChain.Add(func() { fmt.Println("  清理任务3") })
    
    fmt.Println("执行主要操作...")
}

type CleanupChain struct {
    tasks []func()
}

func (c *CleanupChain) Add(task func()) {
    c.tasks = append(c.tasks, task)
}

func (c *CleanupChain) Execute() {
    // 反向执行清理任务
    for i := len(c.tasks) - 1; i >= 0; i-- {
        c.tasks[i]()
    }
}

func contextManagement() {
    fmt.Println("上下文管理示例:")
    
    // 模拟上下文管理器
    ctx := NewContext("main")
    defer ctx.Close()
    
    ctx.Log("开始操作")
    
    // 子操作
    subCtx := ctx.NewChild("sub")
    defer subCtx.Close()
    
    subCtx.Log("子操作执行")
    
    ctx.Log("结束操作")
}

type Context struct {
    name   string
    parent *Context
}

func NewContext(name string) *Context {
    ctx := &Context{name: name}
    fmt.Printf("创建上下文: %s\n", name)
    return ctx
}

func (c *Context) NewChild(name string) *Context {
    child := &Context{name: name, parent: c}
    fmt.Printf("创建子上下文: %s -> %s\n", c.name, name)
    return child
}

func (c *Context) Close() {
    fmt.Printf("关闭上下文: %s\n", c.name)
}

func (c *Context) Log(message string) {
    fmt.Printf("[%s] %s\n", c.name, message)
}
```