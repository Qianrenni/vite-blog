## 2.4 流程控制

### 条件语句（if、else if、else）

```go
package main

import "fmt"

func main() {
    // 基本if语句
    age := 25
    if age >= 18 {
        fmt.Println("成年人")
    }
    
    // if-else语句
    score := 85
    if score >= 60 {
        fmt.Println("及格")
    } else {
        fmt.Println("不及格")
    }
    
    // if-else if-else语句
    grade := 88
    if grade >= 90 {
        fmt.Println("优秀")
    } else if grade >= 80 {
        fmt.Println("良好")
    } else if grade >= 70 {
        fmt.Println("中等")
    } else if grade >= 60 {
        fmt.Println("及格")
    } else {
        fmt.Println("不及格")
    }
    
    // if语句中的初始化语句
    if num := 42; num%2 == 0 {
        fmt.Printf("%d 是偶数\n", num)
    } else {
        fmt.Printf("%d 是奇数\n", num)
    }
    
    // 初始化语句的作用域
    if x := 10; x > 5 {
        fmt.Printf("x = %d, 大于5\n", x)
        // x在这里可以访问
    }
    // fmt.Println(x) // 错误：x超出作用域
    
    // 复杂条件判断
    username := "admin"
    password := "123456"
    isActive := true
    
    if username == "admin" && password == "123456" && isActive {
        fmt.Println("登录成功")
    } else if username != "admin" || password != "123456" {
        fmt.Println("用户名或密码错误")
    } else {
        fmt.Println("账户未激活")
    }
    
    // 嵌套if语句
    num := 15
    if num > 0 {
        if num%2 == 0 {
            fmt.Printf("%d 是正偶数\n", num)
        } else {
            fmt.Printf("%d 是正奇数\n", num)
        }
    } else if num < 0 {
        fmt.Printf("%d 是负数\n", num)
    } else {
        fmt.Println("数字是零")
    }
    
    // 使用函数返回值
    if result, err := divide(10, 2); err == nil {
        fmt.Printf("10 / 2 = %.2f\n", result)
    }
    
    if result, err := divide(10, 0); err != nil {
        fmt.Printf("错误: %v\n", err)
    }
}

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为零")
    }
    return a / b, nil
}
```

### 循环语句（for、range）

```go
package main

import "fmt"

func main() {
    // 基本for循环
    fmt.Println("基本for循环:")
    for i := 0; i < 5; i++ {
        fmt.Printf("i = %d\n", i)
    }
    
    // while风格的for循环
    fmt.Println("\nwhile风格:")
    j := 0
    for j < 5 {
        fmt.Printf("j = %d\n", j)
        j++
    }
    
    // 无限循环
    fmt.Println("\n无限循环示例:")
    count := 0
    for {
        count++
        if count > 3 {
            break
        }
        fmt.Printf("count = %d\n", count)
    }
    
    // 嵌套循环
    fmt.Println("\n嵌套循环:")
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 3; j++ {
            fmt.Printf("(%d,%d) ", i, j)
        }
        fmt.Println()
    }
    
    // 循环控制语句
    fmt.Println("\n循环控制:")
    for i := 1; i <= 10; i++ {
        if i%2 == 0 {
            continue  // 跳过偶数
        }
        if i > 7 {
            break     // 超过7就退出
        }
        fmt.Printf("奇数: %d\n", i)
    }
    
    // range循环 - 数组和切片
    fmt.Println("\nrange循环 - 数组和切片:")
    numbers := []int{10, 20, 30, 40, 50}
    for index, value := range numbers {
        fmt.Printf("索引: %d, 值: %d\n", index, value)
    }
    
    // 只获取索引
    for index := range numbers {
        fmt.Printf("索引: %d\n", index)
    }
    
    // 只获取值
    for _, value := range numbers {
        fmt.Printf("值: %d\n", value)
    }
    
    // range循环 - 字符串
    fmt.Println("\nrange循环 - 字符串:")
    text := "Hello世界"
    for index, char := range text {
        fmt.Printf("索引: %d, 字符: %c, Unicode: %U\n", index, char, char)
    }
    
    // range循环 - 映射
    fmt.Println("\nrange循环 - 映射:")
    scores := map[string]int{
        "Alice": 95,
        "Bob":   87,
        "Charlie": 92,
    }
    for name, score := range scores {
        fmt.Printf("%s: %d分\n", name, score)
    }
    
    // range循环 - 通道（示例）
    fmt.Println("\nrange循环 - 通道:")
    ch := make(chan int, 3)
    go func() {
        for i := 1; i <= 3; i++ {
            ch <- i * 10
        }
        close(ch)
    }()
    
    for value := range ch {
        fmt.Printf("从通道接收: %d\n", value)
    }
    
    // 修改切片元素
    fmt.Println("\n修改切片元素:")
    data := []int{1, 2, 3, 4, 5}
    fmt.Printf("修改前: %v\n", data)
    for i := range data {
        data[i] *= 2
    }
    fmt.Printf("修改后: %v\n", data)
    
    // 传统循环vs range循环性能比较
    largeSlice := make([]int, 1000000)
    for i := 0; i < len(largeSlice); i++ {
        largeSlice[i] = i
    }
    
    // 传统方式
    sum1 := 0
    for i := 0; i < len(largeSlice); i++ {
        sum1 += largeSlice[i]
    }
    
    // range方式
    sum2 := 0
    for _, value := range largeSlice {
        sum2 += value
    }
    
    fmt.Printf("传统循环求和: %d\n", sum1)
    fmt.Printf("range循环求和: %d\n", sum2)
}
```

### 跳转语句（break、continue、goto）

```go
package main

import "fmt"

func main() {
    // break语句 - 跳出循环
    fmt.Println("break语句:")
    for i := 1; i <= 10; i++ {
        if i == 5 {
            break  // 当i等于5时跳出循环
        }
        fmt.Printf("i = %d\n", i)
    }
    
    // continue语句 - 跳过当前迭代
    fmt.Println("\ncontinue语句:")
    for i := 1; i <= 10; i++ {
        if i%2 == 0 {
            continue  // 跳过偶数
        }
        fmt.Printf("奇数: %d\n", i)
    }
    
    // 嵌套循环中的break和continue
    fmt.Println("\n嵌套循环中的控制:")
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 5; j++ {
            if j == 3 {
                break  // 只跳出内层循环
            }
            fmt.Printf("(%d,%d) ", i, j)
        }
        fmt.Println()
    }
    
    // 使用标签跳出多层循环
    fmt.Println("\n使用标签:")
outer:
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 5; j++ {
            if i == 2 && j == 3 {
                break outer  // 跳出外层循环
            }
            fmt.Printf("(%d,%d) ", i, j)
        }
        fmt.Println()
    }
    
    // 使用标签的continue
    fmt.Println("\n使用标签的continue:")
outer2:
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 5; j++ {
            if j == 3 {
                continue outer2  // 跳到外层循环的下一个迭代
            }
            fmt.Printf("(%d,%d) ", i, j)
        }
        fmt.Println()
    }
    
    // goto语句
    fmt.Println("\ngoto语句:")
    i := 0
start:
    if i < 3 {
        fmt.Printf("i = %d\n", i)
        i++
        goto start
    }
    
    // goto的实际应用示例 - 错误处理
    fmt.Println("\ngoto错误处理示例:")
    processFile()
    
    // goto的限制
    fmt.Println("\ngoto限制示例:")
    // goto forward  // 错误：不能跳转到变量声明之前
    x := 10
forward:
    fmt.Printf("x = %d\n", x)
    
    // 但是可以跳转到变量声明之后
    y := 20
    goto backward
    z := 30  // 这行不会执行
backward:
    fmt.Printf("y = %d\n", y)
    // fmt.Printf("z = %d\n", z)  // z可能未初始化
}

func processFile() {
    file := openFile()
    if file == nil {
        goto handleError
    }
    
    data := readFile(file)
    if data == nil {
        goto handleError
    }
    
    processData(data)
    closeFile(file)
    return
    
handleError:
    fmt.Println("处理文件时发生错误")
    if file != nil {
        closeFile(file)
    }
}

// 模拟函数
func openFile() interface{} {
    return "file_handle"
}

func readFile(file interface{}) interface{} {
    return "file_data"
}

func processData(data interface{}) {
    fmt.Println("处理文件数据")
}

func closeFile(file interface{}) {
    fmt.Println("关闭文件")
}
```

### switch语句

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 基本switch语句
    fmt.Println("基本switch:")
    grade := "B"
    switch grade {
    case "A":
        fmt.Println("优秀")
    case "B":
        fmt.Println("良好")
    case "C":
        fmt.Println("中等")
    case "D":
        fmt.Println("及格")
    case "F":
        fmt.Println("不及格")
    default:
        fmt.Println("无效成绩")
    }
    
    // switch表达式
    fmt.Println("\nswitch表达式:")
    day := time.Now().Weekday()
    switch day {
    case time.Monday:
        fmt.Println("星期一")
    case time.Tuesday:
        fmt.Println("星期二")
    case time.Wednesday:
        fmt.Println("星期三")
    case time.Thursday:
        fmt.Println("星期四")
    case time.Friday:
        fmt.Println("星期五")
    case time.Saturday:
        fmt.Println("星期六")
    case time.Sunday:
        fmt.Println("星期日")
    }
    
    // 多个值的case
    fmt.Println("\n多个值的case:")
    letter := "a"
    switch letter {
    case "a", "e", "i", "o", "u":
        fmt.Println("元音字母")
    case "b", "c", "d", "f", "g":
        fmt.Println("辅音字母")
    default:
        fmt.Println("其他字符")
    }
    
    // 表达式switch
    fmt.Println("\n表达式switch:")
    num := 15
    switch {
    case num < 0:
        fmt.Println("负数")
    case num >= 0 && num <= 10:
        fmt.Println("0-10之间的数")
    case num > 10 && num <= 20:
        fmt.Println("11-20之间的数")
    default:
        fmt.Println("大于20的数")
    }
    
    // switch中的初始化语句
    fmt.Println("\nswitch初始化语句:")
    switch hour := time.Now().Hour(); {
    case hour < 12:
        fmt.Println("上午")
    case hour < 18:
        fmt.Println("下午")
    default:
        fmt.Println("晚上")
    }
    
    // fallthrough关键字
    fmt.Println("\nfallthrough示例:")
    score := 85
    switch {
    case score >= 90:
        fmt.Println("A级")
        fallthrough
    case score >= 80:
        fmt.Println("B级")
        fallthrough
    case score >= 70:
        fmt.Println("C级")
        fallthrough
    case score >= 60:
        fmt.Println("D级")
    default:
        fmt.Println("F级")
    }
    
    // 类型switch
    fmt.Println("\n类型switch:")
    var value interface{} = 42
    switch v := value.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case bool:
        fmt.Printf("布尔值: %t\n", v)
    case float64:
        fmt.Printf("浮点数: %.2f\n", v)
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
    
    // 类型switch的实际应用
    fmt.Println("\n类型switch应用:")
    processValue(42)
    processValue("Hello")
    processValue(true)
    processValue(3.14)
    processValue([]int{1, 2, 3})
}

func processValue(value interface{}) {
    switch v := value.(type) {
    case int:
        fmt.Printf("处理整数: %d * 2 = %d\n", v, v*2)
    case string:
        fmt.Printf("处理字符串: %s (长度: %d)\n", v, len(v))
    case bool:
        fmt.Printf("处理布尔值: %t\n", !v)
    case float64:
        fmt.Printf("处理浮点数: %.2f (平方: %.2f)\n", v, v*v)
    default:
        fmt.Printf("处理其他类型: %T\n", v)
    }
}
```

### select语句（并发控制）

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 基本select语句
    fmt.Println("基本select:")
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "来自ch1的消息"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "来自ch2的消息"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("接收到:", msg1)
        case msg2 := <-ch2:
            fmt.Println("接收到:", msg2)
        }
    }
    
    // 带默认分支的select
    fmt.Println("\n带默认分支:")
    ch3 := make(chan string, 1)
    
    select {
    case msg := <-ch3:
        fmt.Println("接收到:", msg)
    default:
        fmt.Println("没有消息可接收")
    }
    
    ch3 <- "消息"
    select {
    case msg := <-ch3:
        fmt.Println("接收到:", msg)
    default:
        fmt.Println("没有消息可接收")
    }
    
    // 发送操作的select
    fmt.Println("\n发送操作:")
    ch4 := make(chan string, 1)
    ch5 := make(chan string, 1)
    
    select {
    case ch4 <- "发送到ch4":
        fmt.Println("成功发送到ch4")
    case ch5 <- "发送到ch5":
        fmt.Println("成功发送到ch5")
    }
    
    fmt.Printf("ch4: %s\n", <-ch4)
    fmt.Printf("ch5: %s\n", <-ch5)
    
    // 超时控制
    fmt.Println("\n超时控制:")
    ch6 := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch6 <- "延迟消息"
    }()
    
    select {
    case msg := <-ch6:
        fmt.Println("接收到:", msg)
    case <-time.After(1 * time.Second):
        fmt.Println("超时了！")
    }
    
    // 多个通道的选择
    fmt.Println("\n多个通道:")
    ticker := time.NewTicker(500 * time.Millisecond)
    defer ticker.Stop()
    
    timeout := time.After(3 * time.Second)
    
    for {
        select {
        case <-ticker.C:
            fmt.Println("滴答...")
        case <-timeout:
            fmt.Println("时间到了！")
            return
        default:
            // 非阻塞操作
            time.Sleep(100 * time.Millisecond)
        }
    }
}

// 实际应用示例：生产者消费者模式
func producerConsumerExample() {
    jobs := make(chan int, 5)
    results := make(chan int, 5)
    
    // 启动3个工作协程
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // 发送5个任务
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)
    
    // 收集结果
    for a := 1; a <= 5; a++ {
        <-results
    }
}

func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("工作协程 %d 开始处理任务 %d\n", id, j)
        time.Sleep(time.Second)
        fmt.Printf("工作协程 %d 完成任务 %d\n", id, j)
        results <- j * 2
    }
}
```

### fallthrough关键字

```go
package main

import "fmt"

func main() {
    // fallthrough基本用法
    fmt.Println("fallthrough基本用法:")
    score := 95
    switch {
    case score >= 90:
        fmt.Println("A级 - 优秀")
        fallthrough
    case score >= 80:
        fmt.Println("B级 - 良好")
        fallthrough
    case score >= 70:
        fmt.Println("C级 - 中等")
        fallthrough
    case score >= 60:
        fmt.Println("D级 - 及格")
    default:
        fmt.Println("F级 - 不及格")
    }
    
    // fallthrough在不同场景中的应用
    fmt.Println("\nfallthrough应用:")
    level := 3
    switch level {
    case 1:
        fmt.Println("初级")
        fallthrough
    case 2:
        fmt.Println("中级")
        fallthrough
    case 3:
        fmt.Println("高级")
        fallthrough
    case 4:
        fmt.Println("专家级")
    }
    
    // fallthrough的限制
    fmt.Println("\nfallthrough限制:")
    value := 2
    switch value {
    case 1:
        fmt.Println("Case 1")
    case 2:
        fmt.Println("Case 2")
        // fallthrough  // 如果取消注释，会编译错误，因为没有下一个case
    default:
        fmt.Println("Default case")
    }
    
    // fallthrough与条件判断
    fmt.Println("\nfallthrough与条件:")
    num := 15
    switch {
    case num > 20:
        fmt.Println("大于20")
    case num > 10:
        fmt.Println("大于10")
        if num < 18 {
            fallthrough  // 只有满足条件才fallthrough
        }
    case num > 5:
        fmt.Println("大于5")
    }
    
    // fallthrough的实际应用场景
    fmt.Println("\n实际应用场景:")
    processUserPermission("admin")
    processUserPermission("editor")
    processUserPermission("viewer")
}

func processUserPermission(role string) {
    fmt.Printf("\n处理角色: %s\n", role)
    switch role {
    case "admin":
        fmt.Println("拥有所有权限")
        fallthrough
    case "editor":
        fmt.Println("可以编辑内容")
        fallthrough
    case "viewer":
        fmt.Println("可以查看内容")
    default:
        fmt.Println("无权限")
    }
}
```

### 标签语句

```go
package main

import "fmt"

func main() {
    // 基本标签使用
    fmt.Println("基本标签:")
    
Loop1:
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 3; j++ {
            if i == 2 && j == 2 {
                break Loop1  // 跳出外层循环
            }
            fmt.Printf("(%d,%d) ", i, j)
        }
        fmt.Println()
    }
    
    // continue with label
    fmt.Println("\ncontinue with label:")
    
Loop2:
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 5; j++ {
            if j == 3 {
                continue Loop2  // 继续外层循环的下一次迭代
            }
            fmt.Printf("(%d,%d) ", i, j)
        }
        fmt.Println()
    }
    
    // 多层嵌套循环
    fmt.Println("\n多层嵌套:")
    
Outer:
    for i := 1; i <= 2; i++ {
    Middle:
        for j := 1; j <= 2; j++ {
        Inner:
            for k := 1; k <= 3; k++ {
                if i == 1 && j == 1 && k == 2 {
                    fmt.Printf("跳过(%d,%d,%d)\n", i, j, k)
                    continue Middle  // 跳到Middle循环
                }
                if i == 2 && j == 1 && k == 2 {
                    fmt.Printf("跳出到Outer(%d,%d,%d)\n", i, j, k)
                    break Outer  // 跳出到Outer循环
                }
                fmt.Printf("(%d,%d,%d) ", i, j, k)
            }
        }
        fmt.Println()
    }
    
    // 标签与goto结合
    fmt.Println("\n标签与goto:")
    
    i := 0
Start:
    if i < 3 {
        fmt.Printf("i = %d\n", i)
        i++
        goto Start
    }
    
    // 复杂的标签使用
    fmt.Println("\n复杂标签使用:")
    
Process:
    for attempt := 1; attempt <= 3; attempt++ {
        fmt.Printf("尝试 %d\n", attempt)
        
        // 模拟操作
        if attempt == 1 {
            fmt.Println("  操作失败，重试...")
            continue Process
        }
        
        if attempt == 2 {
            fmt.Println("  操作成功！")
            break Process
        }
    }
    
    // 标签命名规范
    fmt.Println("\n标签命名:")
    
MainLoop:
    for i := 0; i < 2; i++ {
    SubLoop:
        for j := 0; j < 3; j++ {
            if j == 1 {
                break SubLoop  // 跳出子循环
            }
            fmt.Printf("Main: %d, Sub: %d\n", i, j)
        }
    }
    
    // 标签的作用域
    fmt.Println("\n标签作用域:")
    
GlobalLoop:
    for i := 0; i < 2; i++ {
        if i == 1 {
            goto GlobalLoop  // 可以跳转到前面的标签
        }
        fmt.Printf("Iteration: %d\n", i)
        if i == 0 {
            break GlobalLoop  // 也可以跳出循环
        }
    }
    
    // 实际应用：状态机
    fmt.Println("\n状态机应用:")
    stateMachine()
}

func stateMachine() {
StateA:
    fmt.Println("状态A")
    input := "next"
    switch input {
    case "next":
        goto StateB
    case "end":
        return
    }
    
StateB:
    fmt.Println("状态B")
    input = "back"
    switch input {
    case "back":
        goto StateA
    case "next":
        goto StateC
    case "end":
        return
    }
    
StateC:
    fmt.Println("状态C")
    fmt.Println("状态机结束")
}
```