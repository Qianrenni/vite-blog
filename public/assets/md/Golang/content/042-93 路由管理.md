## 9.3 路由管理

### 路由定义

路由是Web框架的核心组件，负责将HTTP请求映射到相应的处理函数。

```go
package main

import (
    "fmt"
    "net/http"
    "github.com/gorilla/mux"
)

func main() {
    // 使用Gorilla Mux路由器
    r := mux.NewRouter()
    
    // 基本路由定义
    r.HandleFunc("/", homeHandler)
    r.HandleFunc("/users", usersHandler).Methods("GET")
    r.HandleFunc("/users", createUserHandler).Methods("POST")
    r.HandleFunc("/users/{id}", getUserHandler).Methods("GET")
    
    http.ListenAndServe(":8080", r)
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Welcome to the home page!")
}

func usersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "List of users")
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Create new user")
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID := vars["id"]
    fmt.Fprintf(w, "Get user with ID: %s", userID)
}
```

### 路由参数

路由参数允许从URL中提取动态值。

```go
// 基本参数提取
func userHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID := vars["id"]
    fmt.Fprintf(w, "User ID: %s", userID)
}

// 多个参数
func productHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    category := vars["category"]
    productID := vars["id"]
    
    fmt.Fprintf(w, "Category: %s, Product ID: %s", category, productID)
}

// 正则表达式参数
func regexHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    // 只匹配数字
    fmt.Fprintf(w, "Numeric ID: %s", id)
}

// 路由配置
r.HandleFunc("/users/{id:[0-9]+}", userHandler)
r.HandleFunc("/products/{category}/{id}", productHandler)
```

### 路由组

路由组允许将相关路由组织在一起。

```go
func setupRoutes() *mux.Router {
    r := mux.NewRouter()
    
    // API路由组
    api := r.PathPrefix("/api/v1").Subrouter()
    api.HandleFunc("/users", getUsers).Methods("GET")
    api.HandleFunc("/users", createUser).Methods("POST")
    api.HandleFunc("/users/{id}", getUser).Methods("GET")
    api.HandleFunc("/users/{id}", updateUser).Methods("PUT")
    api.HandleFunc("/users/{id}", deleteUser).Methods("DELETE")
    
    // 管理路由组
    admin := r.PathPrefix("/admin").Subrouter()
    admin.Use(authMiddleware) // 中间件
    admin.HandleFunc("/dashboard", adminDashboard)
    admin.HandleFunc("/users", adminUsers)
    
    // 静态文件路由
    r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", 
        http.FileServer(http.Dir("./static/"))))
    
    return r
}

// 中间件示例
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 验证逻辑
        if !isAuthenticated(r) {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next.ServeHTTP(w, r)
    })
}
```

### 路由匹配规则

```go
func setupAdvancedRoutes() *mux.Router {
    r := mux.NewRouter()
    
    // 方法匹配
    r.HandleFunc("/api/users", getUsers).Methods("GET")
    r.HandleFunc("/api/users", createUsers).Methods("POST")
    
    // 主机匹配
    r.HandleFunc("/api/users", getUsers).Host("api.example.com")
    
    // Scheme匹配
    r.HandleFunc("/secure", secureHandler).Schemes("https")
    
    // 头部匹配
    r.HandleFunc("/api/data", getData).Headers("Content-Type", "application/json")
    
    // 查询参数匹配
    r.HandleFunc("/search", searchHandler).Queries("q", "{query}")
    
    // 自定义匹配器
    r.HandleFunc("/custom", customHandler).MatcherFunc(func(r *http.Request, rm *mux.RouteMatch) bool {
        return r.Header.Get("X-API-Version") == "v1"
    })
    
    return r
}
```

### 路由性能优化

```go
type Router struct {
    routes map[string]http.Handler
    mux    *mux.Router
}

func NewRouter() *Router {
    r := &Router{
        routes: make(map[string]http.Handler),
        mux:    mux.NewRouter(),
    }
    return r
}

// 路由缓存
func (r *Router) GetCachedHandler(key string) http.Handler {
    if handler, exists := r.routes[key]; exists {
        return handler
    }
    return nil
}

func (r *Router) SetCachedHandler(key string, handler http.Handler) {
    r.routes[key] = handler
}

// 预编译正则表达式
var (
    userPattern = regexp.MustCompile(`^/users/(\d+)$`)
    postPattern = regexp.MustCompile(`^/posts/(\d+)$`)
)

func optimizedRouter() http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
        path := req.URL.Path
        
        // 快速路径匹配
        switch path {
        case "/":
            homeHandler(w, req)
            return
        case "/health":
            healthHandler(w, req)
            return
        }
        
        // 正则匹配
        if matches := userPattern.FindStringSubmatch(path); matches != nil {
            userID := matches[1]
            userHandler(w, req, userID)
            return
        }
        
        if matches := postPattern.FindStringSubmatch(path); matches != nil {
            postID := matches[1]
            postHandler(w, req, postID)
            return
        }
        
        http.NotFound(w, req)
    })
}
```

### 动态路由

```go
type DynamicRouter struct {
    routes map[string]RouteConfig
    mux    *mux.Router
}

type RouteConfig struct {
    Path    string
    Methods []string
    Handler http.HandlerFunc
    Auth    bool
}

func (dr *DynamicRouter) AddRoute(name string, config RouteConfig) {
    route := dr.mux.HandleFunc(config.Path, config.Handler)
    
    if len(config.Methods) > 0 {
        route.Methods(config.Methods...)
    }
    
    if config.Auth {
        route.Use(authMiddleware)
    }
    
    dr.routes[name] = config
}

func (dr *DynamicRouter) RemoveRoute(name string) {
    delete(dr.routes, name)
    // 重新构建路由器
    dr.rebuildRouter()
}

func (dr *DynamicRouter) rebuildRouter() {
    dr.mux = mux.NewRouter()
    for name, config := range dr.routes {
        dr.AddRoute(name, config)
    }
}

// 配置文件驱动的路由
type RouteConfigFile struct {
    Routes []struct {
        Name    string   `json:"name"`
        Path    string   `json:"path"`
        Methods []string `json:"methods"`
        Handler string   `json:"handler"`
        Auth    bool     `json:"auth"`
    } `json:"routes"`
}

func LoadRoutesFromFile(filename string) (*DynamicRouter, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    
    var config RouteConfigFile
    if err := json.Unmarshal(data, &config); err != nil {
        return nil, err
    }
    
    router := NewDynamicRouter()
    
    for _, route := range config.Routes {
        handler := getHandlerByName(route.Handler)
        router.AddRoute(route.Name, RouteConfig{
            Path:    route.Path,
            Methods: route.Methods,
            Handler: handler,
            Auth:    route.Auth,
        })
    }
    
    return router, nil
}
```