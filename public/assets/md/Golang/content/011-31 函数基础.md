## 3.1 函数基础

### 函数定义和调用

```go
package main

import (
    "fmt"
    "math"
)

// 最简单的函数定义
func sayHello() {
    fmt.Println("Hello, World!")
}

// 带参数的函数
func greet(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

// 带参数和返回值的函数
func add(a, b int) int {
    return a + b
}

// 多个参数类型相同的简写
func multiply(x, y, z int) int {
    return x * y * z
}

// 函数调用
func main() {
    // 调用无参数函数
    sayHello()
    
    // 调用带参数函数
    greet("Alice")
    greet("Bob")
    
    // 调用带返回值函数
    result := add(10, 20)
    fmt.Printf("10 + 20 = %d\n", result)
    
    // 函数表达式调用
    fmt.Printf("5 * 6 * 7 = %d\n", multiply(5, 6, 7))
    
    // 函数链式调用
    fmt.Printf("链式调用结果: %d\n", add(add(1, 2), multiply(3, 4, 5)))
    
    // 在表达式中使用函数
    if add(5, 5) > 9 {
        fmt.Println("5 + 5 大于 9")
    }
    
    // 函数作为值传递给其他函数
    processFunction(add)
}

// 函数作为参数
func processFunction(f func(int, int) int) {
    result := f(100, 200)
    fmt.Printf("处理函数结果: %d\n", result)
}
```

### 函数参数（值传递、引用传递）

```go
package main

import "fmt"

// 值传递 - 基本类型
func modifyInt(x int) {
    x = 100
    fmt.Printf("modifyInt内部: x = %d\n", x)
}

// 值传递 - 数组（整个数组被复制）
func modifyArray(arr [3]int) {
    arr[0] = 100
    fmt.Printf("modifyArray内部: arr = %v\n", arr)
}

// 引用传递 - 切片（传递的是切片的引用）
func modifySlice(slice []int) {
    slice[0] = 100
    fmt.Printf("modifySlice内部: slice = %v\n", slice)
}

// 引用传递 - 映射
func modifyMap(m map[string]int) {
    m["new"] = 999
    fmt.Printf("modifyMap内部: m = %v\n", m)
}

// 引用传递 - 指针
func modifyPointer(ptr *int) {
    *ptr = 100
    fmt.Printf("modifyPointer内部: *ptr = %d\n", *ptr)
}

// 引用传递 - 结构体指针
type Person struct {
    Name string
    Age  int
}

func modifyPerson(p *Person) {
    p.Name = "Modified"
    p.Age = 30
    fmt.Printf("modifyPerson内部: %+v\n", *p)
}

// 值传递 - 结构体（整个结构体被复制）
func modifyPersonValue(p Person) {
    p.Name = "Modified Value"
    p.Age = 30
    fmt.Printf("modifyPersonValue内部: %+v\n", p)
}

func main() {
    // 基本类型值传递
    fmt.Println("=== 基本类型值传递 ===")
    num := 42
    fmt.Printf("调用前: num = %d\n", num)
    modifyInt(num)
    fmt.Printf("调用后: num = %d\n", num) // num没有改变
    
    // 数组值传递
    fmt.Println("\n=== 数组值传递 ===")
    arr := [3]int{1, 2, 3}
    fmt.Printf("调用前: arr = %v\n", arr)
    modifyArray(arr)
    fmt.Printf("调用后: arr = %v\n", arr) // arr没有改变
    
    // 切片引用传递
    fmt.Println("\n=== 切片引用传递 ===")
    slice := []int{1, 2, 3}
    fmt.Printf("调用前: slice = %v\n", slice)
    modifySlice(slice)
    fmt.Printf("调用后: slice = %v\n", slice) // slice被改变了
    
    // 映射引用传递
    fmt.Println("\n=== 映射引用传递 ===")
    m := map[string]int{"a": 1, "b": 2}
    fmt.Printf("调用前: m = %v\n", m)
    modifyMap(m)
    fmt.Printf("调用后: m = %v\n", m) // m被改变了
    
    // 指针引用传递
    fmt.Println("\n=== 指针引用传递 ===")
    ptr := &num
    fmt.Printf("调用前: *ptr = %d\n", *ptr)
    modifyPointer(ptr)
    fmt.Printf("调用后: *ptr = %d\n", *ptr) // ptr指向的值被改变了
    
    // 结构体指针引用传递
    fmt.Println("\n=== 结构体指针引用传递 ===")
    person := Person{Name: "Alice", Age: 25}
    fmt.Printf("调用前: %+v\n", person)
    modifyPerson(&person)
    fmt.Printf("调用后: %+v\n", person) // person被改变了
    
    // 结构体值传递
    fmt.Println("\n=== 结构体值传递 ===")
    person2 := Person{Name: "Bob", Age: 30}
    fmt.Printf("调用前: %+v\n", person2)
    modifyPersonValue(person2)
    fmt.Printf("调用后: %+v\n", person2) // person2没有改变
}
```

### 返回值（单返回值、多返回值）

```go
package main

import (
    "fmt"
    "strconv"
)

// 单返回值函数
func square(x int) int {
    return x * x
}

// 多返回值函数
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为零")
    }
    return a / b, nil
}

// 多个不同类型的返回值
func getUserInfo() (string, int, bool) {
    return "Alice", 25, true
}

// 返回映射
func getScores() map[string]int {
    return map[string]int{
        "Alice": 95,
        "Bob":   87,
        "Charlie": 92,
    }
}

// 返回切片
func getNumbers() []int {
    return []int{1, 2, 3, 4, 5}
}

// 返回结构体
type Result struct {
    Value int
    Error string
}

func processNumber(n int) Result {
    if n < 0 {
        return Result{Value: 0, Error: "负数不被处理"}
    }
    return Result{Value: n * 2, Error: ""}
}

func main() {
    // 单返回值
    fmt.Println("=== 单返回值 ===")
    result := square(5)
    fmt.Printf("5的平方 = %d\n", result)
    
    // 多返回值 - 正常情况
    fmt.Println("\n=== 多返回值 - 正常情况 ===")
    quotient, err := divide(10, 2)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("10 / 2 = %.2f\n", quotient)
    }
    
    // 多返回值 - 错误情况
    fmt.Println("\n=== 多返回值 - 错误情况 ===")
    quotient, err = divide(10, 0)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("10 / 0 = %.2f\n", quotient)
    }
    
    // 忽略部分返回值
    fmt.Println("\n=== 忽略部分返回值 ===")
    quotient, _ = divide(15, 3)  // 忽略错误返回值
    fmt.Printf("15 / 3 = %.2f\n", quotient)
    
    _, err = divide(10, 0)  // 忽略结果返回值
    if err != nil {
        fmt.Printf("操作失败: %v\n", err)
    }
    
    // 多个不同类型的返回值
    fmt.Println("\n=== 多个不同类型的返回值 ===")
    name, age, isActive := getUserInfo()
    fmt.Printf("姓名: %s, 年龄: %d, 活跃状态: %t\n", name, age, isActive)
    
    // 返回映射
    fmt.Println("\n=== 返回映射 ===")
    scores := getScores()
    for name, score := range scores {
        fmt.Printf("%s: %d分\n", name, score)
    }
    
    // 返回切片
    fmt.Println("\n=== 返回切片 ===")
    numbers := getNumbers()
    fmt.Printf("数字列表: %v\n", numbers)
    
    // 返回结构体
    fmt.Println("\n=== 返回结构体 ===")
    result1 := processNumber(10)
    if result1.Error != "" {
        fmt.Printf("错误: %s\n", result1.Error)
    } else {
        fmt.Printf("处理结果: %d\n", result1.Value)
    }
    
    result2 := processNumber(-5)
    if result2.Error != "" {
        fmt.Printf("错误: %s\n", result2.Error)
    } else {
        fmt.Printf("处理结果: %d\n", result2.Value)
    }
    
    // 函数链式调用
    fmt.Println("\n=== 函数链式调用 ===")
    chainResult := square(int(square(2)))
    fmt.Printf("2^2^2 = %d\n", chainResult)
    
    // 多返回值在表达式中的使用
    fmt.Println("\n=== 多返回值在表达式中 ===")
    if result, err := divide(20, 4); err == nil && result > 4 {
        fmt.Printf("20/4 = %.2f 大于4\n", result)
    }
}
```

### 命名返回值

```go
package main

import (
    "fmt"
    "errors"
)

// 命名返回值 - 简单示例
func calculate(a, b int) (sum int, product int) {
    sum = a + b
    product = a * b
    return  // 隐式返回命名变量
}

// 命名返回值 - 复杂示例
func processString(s string) (length int, uppercase string, err error) {
    if s == "" {
        err = errors.New("字符串不能为空")
        return  // 直接返回零值
    }
    
    length = len(s)
    uppercase = ""
    for _, char := range s {
        if char >= 'a' && char <= 'z' {
            uppercase += string(char - 32)  // 转换为大写
        } else {
            uppercase += string(char)
        }
    }
    return  // 返回所有命名变量
}

// 命名返回值 - 错误处理
func divideWithError(a, b float64) (result float64, err error) {
    if b == 0 {
        err = fmt.Errorf("除数不能为零: %f / %f", a, b)
        return  // result为0，err为错误信息
    }
    result = a / b
    return
}

// 命名返回值 - 结构体
type Statistics struct {
    Count int
    Sum   int
    Avg   float64
}

func calculateStats(numbers []int) (stats Statistics, err error) {
    if len(numbers) == 0 {
        err = errors.New("数字列表不能为空")
        return
    }
    
    stats.Count = len(numbers)
    for _, num := range numbers {
        stats.Sum += num
    }
    stats.Avg = float64(stats.Sum) / float64(stats.Count)
    return
}

// 命名返回值 - 指针
func createPerson(name string, age int) (person *Person, err error) {
    if name == "" {
        err = errors.New("姓名不能为空")
        return
    }
    
    person = &Person{
        Name: name,
        Age:  age,
    }
    return
}

type Person struct {
    Name string
    Age  int
}

// 命名返回值 - 在defer中修改
func processWithDefer() (result int) {
    defer func() {
        result *= 2  // 在defer中修改返回值
        fmt.Println("defer中修改结果为:", result)
    }()
    
    result = 10
    fmt.Println("函数中设置结果为:", result)
    return
}

func main() {
    // 命名返回值 - 简单示例
    fmt.Println("=== 命名返回值 - 简单示例 ===")
    sum, product := calculate(5, 3)
    fmt.Printf("和: %d, 积: %d\n", sum, product)
    
    // 命名返回值 - 复杂示例
    fmt.Println("\n=== 命名返回值 - 复杂示例 ===")
    length, uppercase, err := processString("Hello World")
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("长度: %d, 大写: %s\n", length, uppercase)
    }
    
    // 错误情况
    _, _, err = processString("")
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    }
    
    // 命名返回值 - 错误处理
    fmt.Println("\n=== 命名返回值 - 错误处理 ===")
    result, err := divideWithError(10, 2)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %.2f\n", result)
    }
    
    result, err = divideWithError(10, 0)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %.2f\n", result)
    }
    
    // 命名返回值 - 结构体
    fmt.Println("\n=== 命名返回值 - 结构体 ===")
    numbers := []int{1, 2, 3, 4, 5}
    stats, err := calculateStats(numbers)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("统计信息: %+v\n", stats)
    }
    
    // 错误情况
    _, err = calculateStats([]int{})
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    }
    
    // 命名返回值 - 指针
    fmt.Println("\n=== 命名返回值 - 指针 ===")
    person, err := createPerson("Alice", 25)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("创建的人: %+v\n", *person)
    }
    
    // 错误情况
    _, err = createPerson("", 25)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    }
    
    // 命名返回值 - 在defer中修改
    fmt.Println("\n=== 命名返回值 - 在defer中修改 ===")
    finalResult := processWithDefer()
    fmt.Printf("最终结果: %d\n", finalResult)
    
    // 命名返回值的优势
    fmt.Println("\n=== 命名返回值的优势 ===")
    demonstrateBenefits()
}

func demonstrateBenefits() {
    // 优势1: 代码更清晰
    result, err := complexOperation()
    if err != nil {
        fmt.Printf("操作失败: %v\n", err)
        return
    }
    fmt.Printf("操作成功: %d\n", result)
    
    // 优势2: 文档化
    count, sum, average := calculateMetrics([]int{1, 2, 3, 4, 5})
    fmt.Printf("数量: %d, 总和: %d, 平均值: %.2f\n", count, sum, average)
    
    // 优势3: defer中修改返回值
    finalValue := processWithErrorHandling()
    fmt.Printf("处理后的值: %d\n", finalValue)
}

func complexOperation() (result int, err error) {
    result = 42
    // 模拟可能的错误
    // err = errors.New("something went wrong")
    return
}

func calculateMetrics(data []int) (count, sum int, average float64) {
    count = len(data)
    for _, value := range data {
        sum += value
    }
    if count > 0 {
        average = float64(sum) / float64(count)
    }
    return
}

func processWithErrorHandling() (finalValue int) {
    defer func() {
        if finalValue < 0 {
            finalValue = 0  // 确保返回非负值
        }
    }()
    
    finalValue = -5  // 模拟负值
    return
}
```

### 可变参数函数

```go
package main

import (
    "fmt"
    "strings"
)

// 基本可变参数函数
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// 可变参数与固定参数结合
func printInfo(prefix string, values ...interface{}) {
    fmt.Print(prefix + ": ")
    for i, value := range values {
        if i > 0 {
            fmt.Print(", ")
        }
        fmt.Print(value)
    }
    fmt.Println()
}

// 可变字符串参数
func joinStrings(separator string, parts ...string) string {
    return strings.Join(parts, separator)
}

// 可变参数 - 结构体
type Point struct {
    X, Y int
}

func createPoints(points ...Point) []Point {
    return points
}

// 可变参数 - 映射
func mergeMaps(maps ...map[string]int) map[string]int {
    result := make(map[string]int)
    for _, m := range maps {
        for key, value := range m {
            result[key] = value
        }
    }
    return result
}

// 递归可变参数处理
func max(numbers ...int) int {
    if len(numbers) == 0 {
        return 0
    }
    
    if len(numbers) == 1 {
        return numbers[0]
    }
    
    first := numbers[0]
    restMax := max(numbers[1:]...)  // 递归调用
    if first > restMax {
        return first
    }
    return restMax
}

// 可变参数与类型断言
func processMixedTypes(values ...interface{}) {
    for i, value := range values {
        switch v := value.(type) {
        case int:
            fmt.Printf("参数%d: 整数 %d\n", i, v)
        case string:
            fmt.Printf("参数%d: 字符串 %s\n", i, v)
        case bool:
            fmt.Printf("参数%d: 布尔值 %t\n", i, v)
        case float64:
            fmt.Printf("参数%d: 浮点数 %.2f\n", i, v)
        default:
            fmt.Printf("参数%d: 未知类型 %T\n", i, v)
        }
    }
}

// 可变参数 - 函数参数
func applyFunctions(value int, functions ...func(int) int) int {
    result := value
    for _, f := range functions {
        result = f(result)
    }
    return result
}

// 可变参数的实际应用 - 日志函数
func log(level string, messages ...interface{}) {
    fmt.Printf("[%s] ", level)
    for i, msg := range messages {
        if i > 0 {
            fmt.Print(" ")
        }
        fmt.Print(msg)
    }
    fmt.Println()
}

func main() {
    // 基本可变参数
    fmt.Println("=== 基本可变参数 ===")
    fmt.Printf("sum(): %d\n", sum())
    fmt.Printf("sum(1, 2, 3): %d\n", sum(1, 2, 3))
    fmt.Printf("sum(1, 2, 3, 4, 5): %d\n", sum(1, 2, 3, 4, 5))
    
    // 可变参数与固定参数结合
    fmt.Println("\n=== 可变参数与固定参数结合 ===")
    printInfo("数字", 1, 2, 3, 4, 5)
    printInfo("混合", "Hello", 42, true, 3.14)
    printInfo("空参数", "没有其他参数")
    
    // 可变字符串参数
    fmt.Println("\n=== 可变字符串参数 ===")
    result := joinStrings("-", "apple", "banana", "orange")
    fmt.Printf("连接结果: %s\n", result)
    
    result = joinStrings(", ", "Go", "语言", "学习")
    fmt.Printf("连接结果: %s\n", result)
    
    // 可变参数 - 结构体
    fmt.Println("\n=== 可变参数 - 结构体 ===")
    points := createPoints(
        Point{1, 2},
        Point{3, 4},
        Point{5, 6},
    )
    fmt.Printf("创建的点: %+v\n", points)
    
    // 可变参数 - 映射
    fmt.Println("\n=== 可变参数 - 映射 ===")
    map1 := map[string]int{"a": 1, "b": 2}
    map2 := map[string]int{"c": 3, "d": 4}
    map3 := map[string]int{"e": 5, "f": 6}
    
    merged := mergeMaps(map1, map2, map3)
    fmt.Printf("合并后的映射: %v\n", merged)
    
    // 递归可变参数处理
    fmt.Println("\n=== 递归可变参数处理 ===")
    fmt.Printf("max(): %d\n", max())
    fmt.Printf("max(5): %d\n", max(5))
    fmt.Printf("max(1, 5, 3, 9, 2): %d\n", max(1, 5, 3, 9, 2))
    fmt.Printf("max(-1, -5, -3): %d\n", max(-1, -5, -3))
    
    // 可变参数与类型断言
    fmt.Println("\n=== 可变参数与类型断言 ===")
    processMixedTypes(42, "Hello", true, 3.14, []int{1, 2, 3})
    
    // 可变参数 - 函数参数
    fmt.Println("\n=== 可变参数 - 函数参数 ===")
    double := func(x int) int { return x * 2 }
    addTen := func(x int) int { return x + 10 }
    square := func(x int) int { return x * x }
    
    result2 := applyFunctions(5, double, addTen, square)
    fmt.Printf("应用函数结果: %d\n", result2)  // ((5*2)+10)^2 = 400
    
    // 可变参数的实际应用
    fmt.Println("\n=== 可变参数的实际应用 ===")
    log("INFO", "应用程序启动")
    log("DEBUG", "处理用户", "Alice", "ID:", 12345)
    log("ERROR", "数据库连接失败", "原因:", "超时")
    log("WARN", "内存使用率", 85, "%")
    
    // 切片作为可变参数
    fmt.Println("\n=== 切片作为可变参数 ===")
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Printf("切片求和: %d\n", sum(numbers...))  // 使用...展开切片
    
    // 字符串切片作为可变参数
    words := []string{"Go", "is", "awesome"}
    sentence := joinStrings(" ", words...)
    fmt.Printf("句子: %s\n", sentence)
    
    // 可变参数的性能考虑
    fmt.Println("\n=== 可变参数的性能考虑 ===")
    demonstratePerformance()
}

func demonstratePerformance() {
    // 大量参数的可变函数
    largeNumbers := make([]int, 10000)
    for i := range largeNumbers {
        largeNumbers[i] = i
    }
    
    start := sum(largeNumbers...)
    fmt.Printf("大量数字求和: %d\n", start)
    
    // 可变参数与内存分配
    processLargeArgs(largeNumbers...)
}

func processLargeArgs(args ...int) {
    fmt.Printf("处理了 %d 个参数\n", len(args))
    if len(args) > 0 {
        fmt.Printf("第一个参数: %d, 最后一个参数: %d\n", args[0], args[len(args)-1])
    }
}
```

### 函数签名

```go
package main

import (
    "fmt"
    "io"
    "sort"
)

// 函数签名定义
type AddFunc func(int, int) int
type StringProcessor func(string) string
type Validator func(interface{}) bool

// 基本函数签名示例
func add(a, b int) int {
    return a + b
}

func multiply(a, b int) int {
    return a * b
}

// 字符串处理函数签名
func toUpper(s string) string {
    result := ""
    for _, char := range s {
        if char >= 'a' && char <= 'z' {
            result += string(char - 32)
        } else {
            result += string(char)
        }
    }
    return result
}

func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

// 验证器函数签名
func isPositive(v interface{}) bool {
    if num, ok := v.(int); ok {
        return num > 0
    }
    return false
}

func isNotEmpty(v interface{}) bool {
    if str, ok := v.(string); ok {
        return len(str) > 0
    }
    return false
}

// 函数签名在接口中的应用
type Calculator interface {
    Calculate(a, b int) int
}

type AddCalculator struct{}
type MultiplyCalculator struct{}

func (ac AddCalculator) Calculate(a, b int) int {
    return a + b
}

func (mc MultiplyCalculator) Calculate(a, b int) int {
    return a * b
}

// 函数签名与回调
type EventHandler func(event string, data interface{})

func registerHandler(handler EventHandler) {
    // 模拟事件触发
    handler("user_login", map[string]string{
        "username": "alice",
        "ip":       "192.168.1.1",
    })
}

// 函数签名与排序
type Person struct {
    Name string
    Age  int
}

type ByAge []Person
type ByName []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

func (a ByName) Len() int           { return len(a) }
func (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }

// 函数签名与IO操作
type ReaderFunc func([]byte) (int, error)
type WriterFunc func([]byte) (int, error)

func processReader(reader ReaderFunc) error {
    buffer := make([]byte, 1024)
    n, err := reader(buffer)
    if err != nil && err != io.EOF {
        return err
    }
    fmt.Printf("读取了 %d 字节\n", n)
    return nil
}

// 函数签名的类型安全
func executeOperation(op AddFunc, a, b int) int {
    return op(a, b)
}

// 函数签名与泛型（Go 1.18+）
// type Number interface {
//     int | int32 | int64 | float32 | float64
// }
// 
// func GenericSum[T Number](numbers ...T) T {
//     var sum T
//     for _, num := range numbers {
//         sum += num
//     }
//     return sum
// }

func main() {
    // 函数签名基本使用
    fmt.Println("=== 函数签名基本使用 ===")
    var addFunc AddFunc = add
    var mulFunc AddFunc = multiply
    
    fmt.Printf("addFunc(5, 3) = %d\n", addFunc(5, 3))
    fmt.Printf("mulFunc(5, 3) = %d\n", mulFunc(5, 3))
    
    // 函数签名作为参数传递
    fmt.Println("\n=== 函数签名作为参数传递 ===")
    result1 := executeOperation(addFunc, 10, 20)
    result2 := executeOperation(mulFunc, 10, 20)
    fmt.Printf("executeOperation(addFunc, 10, 20) = %d\n", result1)
    fmt.Printf("executeOperation(mulFunc, 10, 20) = %d\n", result2)
    
    // 字符串处理器函数签名
    fmt.Println("\n=== 字符串处理器函数签名 ===")
    var processor StringProcessor = toUpper
    fmt.Printf("toUpper('hello') = %s\n", processor("hello"))
    
    processor = reverse
    fmt.Printf("reverse('hello') = %s\n", processor("hello"))
    
    // 验证器函数签名
    fmt.Println("\n=== 验证器函数签名 ===")
    var validator Validator = isPositive
    fmt.Printf("isPositive(5) = %t\n", validator(5))
    fmt.Printf("isPositive(-5) = %t\n", validator(-5))
    
    validator = isNotEmpty
    fmt.Printf("isNotEmpty('hello') = %t\n", validator("hello"))
    fmt.Printf("isNotEmpty('') = %t\n", validator(""))
    
    // 函数签名在接口中的应用
    fmt.Println("\n=== 函数签名在接口中的应用 ===")
    var calc Calculator = AddCalculator{}
    fmt.Printf("AddCalculator: %d\n", calc.Calculate(5, 3))
    
    calc = MultiplyCalculator{}
    fmt.Printf("MultiplyCalculator: %d\n", calc.Calculate(5, 3))
    
    // 函数签名与回调
    fmt.Println("\n=== 函数签名与回调 ===")
    handler := func(event string, data interface{}) {
        fmt.Printf("事件: %s, 数据: %v\n", event, data)
    }
    registerHandler(handler)
    
    // 函数签名与排序
    fmt.Println("\n=== 函数签名与排序 ===")
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
        {"Diana", 28},
    }
    
    fmt.Println("按年龄排序前:")
    for _, p := range people {
        fmt.Printf("  %s: %d\n", p.Name, p.Age)
    }
    
    sort.Sort(ByAge(people))
    fmt.Println("按年龄排序后:")
    for _, p := range people {
        fmt.Printf("  %s: %d\n", p.Name, p.Age)
    }
    
    sort.Sort(ByName(people))
    fmt.Println("按姓名排序后:")
    for _, p := range people {
        fmt.Printf("  %s: %d\n", p.Name, p.Age)
    }
    
    // 函数签名的组合使用
    fmt.Println("\n=== 函数签名的组合使用 ===")
    demonstrateComposition()
    
    // 函数签名的类型检查
    fmt.Println("\n=== 函数签名的类型检查 ===")
    demonstrateTypeChecking()
}

func demonstrateComposition() {
    // 函数组合
    compose := func(f, g StringProcessor) StringProcessor {
        return func(s string) string {
            return f(g(s))
        }
    }
    
    upperReverse := compose(toUpper, reverse)
    result := upperReverse("hello world")
    fmt.Printf("upperReverse('hello world') = %s\n", result)
}

func demonstrateTypeChecking() {
    // 类型安全检查
    var validFunc AddFunc = func(a, b int) int {
        return a + b
    }
    
    // 以下代码会编译错误，因为签名不匹配
    // var invalidFunc AddFunc = func(a, b float64) float64 {
    //     return a + b
    // }
    
    fmt.Printf("validFunc(1, 2) = %d\n", validFunc(1, 2))
    
    // 函数签名的多态性
    operations := map[string]AddFunc{
        "add":      add,
        "multiply": multiply,
    }
    
    for name, op := range operations {
        result := op(5, 3)
        fmt.Printf("%s(5, 3) = %d\n", name, result)
    }
}
```

### 函数文档

```go
package main

import (
    "errors"
    "fmt"
    "math"
)

// CalculateArea 计算矩形的面积
// 参数:
//   width - 矩形的宽度
//   height - 矩形的高度
// 返回值:
//   float64 - 矩形的面积
//   error - 如果宽度或高度为负数则返回错误
//
// 示例:
//   area, err := CalculateArea(5.0, 3.0)
//   if err != nil {
//       // 处理错误
//   }
//   fmt.Printf("面积: %.2f\n", area)
func CalculateArea(width, height float64) (float64, error) {
    if width < 0 || height < 0 {
        return 0, errors.New("宽度和高度必须为非负数")
    }
    return width * height, nil
}

// Fibonacci 计算斐波那契数列的第n项
// 使用递归方法实现
//
// 参数:
//   n - 要计算的项数（从0开始）
//
// 返回值:
//   int64 - 第n项的值
//
// 注意:
//   当n较大时，递归方法可能导致栈溢出
//   建议使用迭代方法处理大数值
//
// 示例:
//   result := Fibonacci(10)  // 返回55
func Fibonacci(n int) int64 {
    if n <= 1 {
        return int64(n)
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}

// IsPrime 判断一个数是否为质数
// 使用试除法进行判断
//
// 参数:
//   n - 要判断的整数
//
// 返回值:
//   bool - 如果是质数返回true，否则返回false
//
// 时间复杂度: O(√n)
// 空间复杂度: O(1)
//
// 特殊情况:
//   - 负数和0、1不是质数
//   - 2是最小的质数
func IsPrime(n int) bool {
    if n < 2 {
        return false
    }
    if n == 2 {
        return true
    }
    if n%2 == 0 {
        return false
    }
    
    for i := 3; i*i <= n; i += 2 {
        if n%i == 0 {
            return false
        }
    }
    return true
}

// ProcessData 处理数据的通用函数
//
// 参数:
//   data - 要处理的数据切片
//   processor - 数据处理函数
//   validator - 数据验证函数（可选，可以为nil）
//
// 返回值:
//   []interface{} - 处理后的数据
//   error - 处理过程中发生的错误
//
// 处理流程:
//   1. 如果提供了验证器，先验证数据
//   2. 对每个数据项应用处理函数
//   3. 返回处理结果
//
// 并发安全: 该函数不是并发安全的
func ProcessData(
    data []interface{},
    processor func(interface{}) interface{},
    validator func(interface{}) bool,
) ([]interface{}, error) {
    if processor == nil {
        return nil, errors.New("processor函数不能为nil")
    }
    
    // 验证数据
    if validator != nil {
        for _, item := range data {
            if !validator(item) {
                return nil, fmt.Errorf("数据验证失败: %v", item)
            }
        }
    }
    
    // 处理数据
    result := make([]interface{}, len(data))
    for i, item := range data {
        result[i] = processor(item)
    }
    
    return result, nil
}

// ComplexCalculator 复数计算器结构体
type ComplexCalculator struct {
    // precision 精度设置
    precision int
}

// NewComplexCalculator 创建新的复数计算器
//
// 参数:
//   precision - 计算精度（小数点后位数）
//
// 返回值:
//   *ComplexCalculator - 新创建的计算器实例
//
// 错误处理:
//   如果precision为负数，将使用默认精度0
func NewComplexCalculator(precision int) *ComplexCalculator {
    if precision < 0 {
        precision = 0
    }
    return &ComplexCalculator{precision: precision}
}

// Add 复数加法运算
//
// 参数:
//   a, b - 要相加的复数
//
// 返回值:
//   complex128 - 相加结果
//
// 公式:
//   (a + bi) + (c + di) = (a + c) + (b + d)i
func (c *ComplexCalculator) Add(a, b complex128) complex128 {
    return a + b
}

// Multiply 复数乘法运算
//
// 参数:
//   a, b - 要相乘的复数
//
// 返回值:
//   complex128 - 相乘结果
//
// 公式:
//   (a + bi) × (c + di) = (ac - bd) + (ad + bc)i
func (c *ComplexCalculator) Multiply(a, b complex128) complex128 {
    return a * b
}

// Power 复数幂运算
//
// 参数:
//   base - 底数
//   exponent - 指数
//
// 返回值:
//   complex128 - 幂运算结果
//   error - 计算错误
//
// 特殊情况:
//   - 当底数为0且指数为负数时返回错误
//   - 当指数为0时返回1
func (c *ComplexCalculator) Power(base complex128, exponent float64) (complex128, error) {
    if base == 0 && exponent < 0 {
        return 0, errors.New("0不能进行负数次幂运算")
    }
    
    return complex(math.Pow(real(base), exponent), math.Pow(imag(base), exponent)), nil
}

// Deprecated: Use CalculateArea instead
// OldCalculateArea 旧版本的面积计算函数（已废弃）
//
// 这个函数已经被CalculateArea替代，请使用新函数
func OldCalculateArea(width, height float64) float64 {
    return width * height
}

// ExampleCalculateArea 函数示例
func ExampleCalculateArea() {
    area, err := CalculateArea(5.0, 3.0)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        return
    }
    fmt.Printf("面积: %.2f\n", area)
    // Output: 面积: 15.00
}

func main() {
    // 演示函数文档的使用
    fmt.Println("=== 函数文档演示 ===")
    
    // CalculateArea函数
    area, err := CalculateArea(5.0, 3.0)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("矩形面积: %.2f\n", area)
    }
    
    // 错误情况
    _, err = CalculateArea(-1.0, 3.0)
    if err != nil {
        fmt.Printf("错误: %v\n", err)
    }
    
    // Fibonacci函数
    fmt.Println("\n=== 斐波那契数列 ===")
    for i := 0; i <= 10; i++ {
        fmt.Printf("F(%d) = %d\n", i, Fibonacci(i))
    }
    
    // IsPrime函数
    fmt.Println("\n=== 质数判断 ===")
    testNumbers := []int{2, 3, 4, 17, 25, 29, 97}
    for _, num := range testNumbers {
        fmt.Printf("%d 是质数: %t\n", num, IsPrime(num))
    }
    
    // ProcessData函数
    fmt.Println("\n=== 数据处理 ===")
    data := []interface{}{1, 2, 3, 4, 5}
    
    // 处理函数：平方
    processor := func(item interface{}) interface{} {
        if num, ok := item.(int); ok {
            return num * num
        }
        return item
    }
    
    // 验证函数：必须是正数
    validator := func(item interface{}) bool {
        if num, ok := item.(int); ok {
            return num > 0
        }
        return false
    }
    
    result, err := ProcessData(data, processor, validator)
    if err != nil {
        fmt.Printf("处理错误: %v\n", err)
    } else {
        fmt.Printf("处理结果: %v\n", result)
    }
    
    // ComplexCalculator
    fmt.Println("\n=== 复数计算器 ===")
    calc := NewComplexCalculator(2)
    
    a := complex(3, 4)  // 3 + 4i
    b := complex(1, 2)  // 1 + 2i
    
    sum := calc.Add(a, b)
    fmt.Printf("(%v) + (%v) = %v\n", a, b, sum)
    
    product := calc.Multiply(a, b)
    fmt.Printf("(%v) × (%v) = %v\n", a, b, product)
    
    power, err := calc.Power(a, 2)
    if err != nil {
        fmt.Printf("幂运算错误: %v\n", err)
    } else {
        fmt.Printf("(%v)^2 = %v\n", a, power)
    }
    
    // 演示良好的文档实践
    fmt.Println("\n=== 文档实践演示 ===")
    demonstrateGoodDocumentation()
}

func demonstrateGoodDocumentation() {
    // 1. 清晰的函数描述
    fmt.Println("1. 清晰的函数描述:")
    result := performCalculation(10, 5)
    fmt.Printf("计算结果: %d\n", result)
    
    // 2. 详细的参数说明
    fmt.Println("\n2. 详细的参数说明:")
    validateAndProcess("test@example.com")
    
    // 3. 完整的返回值说明
    fmt.Println("\n3. 完整的返回值说明:")
    data, count, err := fetchData()
    if err != nil {
        fmt.Printf("获取数据失败: %v\n", err)
    } else {
        fmt.Printf("获取到 %d 条数据: %v\n", count, data)
    }
    
    // 4. 使用示例
    fmt.Println("\n4. 使用示例:")
    exampleUsage()
    
    // 5. 错误处理说明
    fmt.Println("\n5. 错误处理说明:")
    handlePotentialErrors()
}

// performCalculation 执行计算操作
// 这是一个演示良好文档的函数
func performCalculation(a, b int) int {
    return a + b
}

// validateAndProcess 验证并处理输入
//
// 参数:
//   email - 用户邮箱地址，必须包含@符号
//
// 验证规则:
//   - 长度必须在5-254个字符之间
//   - 必须包含@符号
//   - @符号不能在开头或结尾
func validateAndProcess(email string) {
    fmt.Printf("处理邮箱: %s\n", email)
}

// fetchData 获取数据
//
// 返回值:
//   []string - 数据列表
//   int - 数据条数
//   error - 错误信息（如果有的话）
//
// 可能的错误:
//   - 网络连接失败
//   - 数据格式错误
//   - 权限不足
func fetchData() ([]string, int, error) {
    data := []string{"item1", "item2", "item3"}
    return data, len(data), nil
}

// exampleUsage 使用示例
//
// 示例:
//   result := exampleUsage()
//   fmt.Println(result)
//
// 输出:
//   Hello, World!
func exampleUsage() {
    fmt.Println("Hello, World!")
}

// handlePotentialErrors 错误处理示例
//
// 该函数演示了可能发生的各种错误情况
//
// 网络错误:
//   当无法连接到服务器时返回network error
//
// 数据错误:
//   当数据格式不正确时返回data error
//
// 权限错误:
//   当权限不足时返回permission denied
func handlePotentialErrors() {
    fmt.Println("处理潜在错误...")
}
```