## 6.3 网络编程

### net包基础

```go
package main

import (
    "fmt"
    "net"
    "time"
)

func demonstrateNetPackage() {
    fmt.Println("=== net包基础 ===")
    
    // 解析IP地址
    ip := net.ParseIP("192.168.1.1")
    if ip != nil {
        fmt.Printf("Parsed IP: %s\n", ip.String())
        fmt.Printf("Is IPv4: %t\n", ip.To4() != nil)
        fmt.Printf("Is IPv6: %t\n", ip.To4() == nil && ip.To16() != nil)
    }
    
    // 解析主机名
    ips, err := net.LookupIP("google.com")
    if err != nil {
        fmt.Printf("Lookup IP error: %v\n", err)
    } else {
        fmt.Printf("Google IPs: %v\n", ips)
    }
    
    // 解析端口
    port, err := net.LookupPort("tcp", "http")
    if err != nil {
        fmt.Printf("Lookup port error: %v\n", err)
    } else {
        fmt.Printf("HTTP port: %d\n", port)
    }
    
    // 创建IP地址范围
    _, ipNet, err := net.ParseCIDR("192.168.0.0/24")
    if err != nil {
        fmt.Printf("Parse CIDR error: %v\n", err)
    } else {
        fmt.Printf("CIDR network: %s\n", ipNet.String())
        fmt.Printf("Contains 192.168.0.100: %t\n", ipNet.Contains(net.ParseIP("192.168.0.100")))
        fmt.Printf("Contains 192.168.1.100: %t\n", ipNet.Contains(net.ParseIP("192.168.1.100")))
    }
    
    // MAC地址
    mac, err := net.ParseMAC("01:23:45:67:89:ab")
    if err != nil {
        fmt.Printf("Parse MAC error: %v\n", err)
    } else {
        fmt.Printf("Parsed MAC: %s\n", mac.String())
    }
    
    // 网络接口信息
    interfaces, err := net.Interfaces()
    if err != nil {
        fmt.Printf("Get interfaces error: %v\n", err)
    } else {
        fmt.Printf("Network interfaces:\n")
        for _, iface := range interfaces {
            fmt.Printf("  %s: %s\n", iface.Name, iface.HardwareAddr)
            addrs, _ := iface.Addrs()
            for _, addr := range addrs {
                fmt.Printf("    %s\n", addr.String())
            }
        }
    }
}

// 网络地址解析工具
func networkAddressUtils() {
    fmt.Println("\n=== 网络地址工具 ===")
    
    // 主机解析
    addrs, err := net.LookupHost("www.github.com")
    if err != nil {
        fmt.Printf("Lookup host error: %v\n", err)
    } else {
        fmt.Printf("github.com addresses: %v\n", addrs)
    }
    
    // SRV记录解析
    _, srvs, err := net.LookupSRV("xmpp-server", "tcp", "google.com")
    if err != nil {
        fmt.Printf("Lookup SRV error: %v\n", err)
    } else {
        fmt.Printf("SRV records:\n")
        for _, srv := range srvs {
            fmt.Printf("  Target: %s, Port: %d, Priority: %d\n", 
                srv.Target, srv.Port, srv.Priority)
        }
    }
    
    // TXT记录解析
    txts, err := net.LookupTXT("google.com")
    if err != nil {
        fmt.Printf("Lookup TXT error: %v\n", err)
    } else {
        fmt.Printf("TXT records: %v\n", txts)
    }
    
    // 反向解析
    names, err := net.LookupAddr("8.8.8.8")
    if err != nil {
        fmt.Printf("Reverse lookup error: %v\n", err)
    } else {
        fmt.Printf("8.8.8.8 names: %v\n", names)
    }
}

// 网络连接基础
func networkConnectionBasics() {
    fmt.Println("\n=== 网络连接基础 ===")
    
    // 监听TCP端口
    listener, err := net.Listen("tcp", ":0")  // 0表示随机端口
    if err != nil {
        fmt.Printf("Listen error: %v\n", err)
        return
    }
    defer listener.Close()
    
    fmt.Printf("Listening on: %s\n", listener.Addr().String())
    
    // 解析地址
    tcpAddr, err := net.ResolveTCPAddr("tcp", "localhost:8080")
    if err != nil {
        fmt.Printf("Resolve TCP addr error: %v\n", err)
    } else {
        fmt.Printf("Resolved TCP address: %s\n", tcpAddr.String())
    }
    
    udpAddr, err := net.ResolveUDPAddr("udp", "localhost:53")
    if err != nil {
        fmt.Printf("Resolve UDP addr error: %v\n", err)
    } else {
        fmt.Printf("Resolved UDP address: %s\n", udpAddr.String())
    }
    
    // 连接超时设置
    conn, err := net.DialTimeout("tcp", "google.com:80", 5*time.Second)
    if err != nil {
        fmt.Printf("Dial timeout error: %v\n", err)
    } else {
        fmt.Printf("Connected to: %s\n", conn.RemoteAddr().String())
        conn.Close()
    }
}
```

### TCP编程

```go
package main

import (
    "bufio"
    "fmt"
    "io"
    "net"
    "strings"
    "sync"
    "time"
)

// TCP服务器示例
func tcpServer() {
    // 监听指定端口
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        fmt.Printf("Server listen error: %v\n", err)
        return
    }
    defer listener.Close()
    
    fmt.Println("TCP Server started on :8080")
    
    // 接受连接
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Printf("Accept error: %v\n", err)
            continue
        }
        
        // 为每个连接启动一个goroutine处理
        go handleTCPConnection(conn)
    }
}

// 处理TCP连接
func handleTCPConnection(conn net.Conn) {
    defer conn.Close()
    
    // 设置读写超时
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    conn.SetWriteDeadline(time.Now().Add(30 * time.Second))
    
    remoteAddr := conn.RemoteAddr().String()
    fmt.Printf("Client connected: %s\n", remoteAddr)
    
    // 发送欢迎消息
    welcome := "Welcome to TCP Server!\n"
    conn.Write([]byte(welcome))
    
    // 创建读取器
    reader := bufio.NewReader(conn)
    
    for {
        // 读取消息
        message, err := reader.ReadString('\n')
        if err != nil {
            if err == io.EOF {
                fmt.Printf("Client disconnected: %s\n", remoteAddr)
            } else {
                fmt.Printf("Read error from %s: %v\n", remoteAddr, err)
            }
            return
        }
        
        // 去除换行符
        message = strings.TrimSpace(message)
        fmt.Printf("Received from %s: %s\n", remoteAddr, message)
        
        // 处理特殊命令
        if message == "quit" || message == "exit" {
            conn.Write([]byte("Goodbye!\n"))
            fmt.Printf("Client requested disconnect: %s\n", remoteAddr)
            return
        }
        
        // 回显消息
        response := fmt.Sprintf("Echo: %s\n", message)
        _, err = conn.Write([]byte(response))
        if err != nil {
            fmt.Printf("Write error to %s: %v\n", remoteAddr, err)
            return
        }
    }
}

// TCP客户端示例
func tcpClient() {
    // 连接到服务器
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        fmt.Printf("Client dial error: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Println("Connected to TCP server")
    
    // 创建读写器
    reader := bufio.NewReader(conn)
    writer := bufio.NewWriter(conn)
    
    // 读取欢迎消息
    welcome, err := reader.ReadString('\n')
    if err != nil {
        fmt.Printf("Read welcome error: %v\n", err)
        return
    }
    fmt.Printf("Server: %s", welcome)
    
    // 发送消息
    messages := []string{"Hello Server", "How are you?", "quit"}
    
    for _, msg := range messages {
        // 发送消息
        _, err = writer.WriteString(msg + "\n")
        if err != nil {
            fmt.Printf("Write error: %v\n", err)
            return
        }
        writer.Flush()
        
        // 读取响应
        response, err := reader.ReadString('\n')
        if err != nil {
            fmt.Printf("Read response error: %v\n", err)
            return
        }
        fmt.Printf("Server response: %s", response)
        
        if msg == "quit" {
            break
        }
    }
    
    fmt.Println("Client disconnected")
}

// 高级TCP服务器
type TCPServer struct {
    listener net.Listener
    clients  map[net.Conn]bool
    mutex    sync.RWMutex
    quit     chan interface{}
}

func NewTCPServer(addr string) (*TCPServer, error) {
    listener, err := net.Listen("tcp", addr)
    if err != nil {
        return nil, err
    }
    
    return &TCPServer{
        listener: listener,
        clients:  make(map[net.Conn]bool),
        quit:     make(chan interface{}),
    }, nil
}

func (s *TCPServer) Start() {
    fmt.Printf("Advanced TCP Server started on %s\n", s.listener.Addr().String())
    
    go func() {
        for {
            select {
            case <-s.quit:
                return
            default:
                conn, err := s.listener.Accept()
                if err != nil {
                    select {
                    case <-s.quit:
                        return
                    default:
                        fmt.Printf("Accept error: %v\n", err)
                        continue
                    }
                }
                
                s.mutex.Lock()
                s.clients[conn] = true
                s.mutex.Unlock()
                
                go s.handleClient(conn)
            }
        }
    }()
}

func (s *TCPServer) handleClient(conn net.Conn) {
    defer func() {
        s.mutex.Lock()
        delete(s.clients, conn)
        s.mutex.Unlock()
        conn.Close()
    }()
    
    remoteAddr := conn.RemoteAddr().String()
    fmt.Printf("New client connected: %s\n", remoteAddr)
    
    // 广播新客户端连接
    s.broadcast(fmt.Sprintf("Client %s joined\n", remoteAddr), conn)
    
    reader := bufio.NewReader(conn)
    
    for {
        conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        
        message, err := reader.ReadString('\n')
        if err != nil {
            if err == io.EOF {
                fmt.Printf("Client disconnected: %s\n", remoteAddr)
            } else {
                fmt.Printf("Read error from %s: %v\n", remoteAddr, err)
            }
            break
        }
        
        message = strings.TrimSpace(message)
        fmt.Printf("Received from %s: %s\n", remoteAddr, message)
        
        if message == "quit" || message == "exit" {
            conn.Write([]byte("Goodbye!\n"))
            break
        }
        
        // 广播消息到所有客户端
        broadcastMsg := fmt.Sprintf("[%s]: %s\n", remoteAddr, message)
        s.broadcast(broadcastMsg, conn)
    }
    
    s.broadcast(fmt.Sprintf("Client %s left\n", remoteAddr), conn)
}

func (s *TCPServer) broadcast(message string, exclude net.Conn) {
    s.mutex.RLock()
    defer s.mutex.RUnlock()
    
    for client := range s.clients {
        if client != exclude {
            client.Write([]byte(message))
        }
    }
}

func (s *TCPServer) Stop() {
    close(s.quit)
    s.listener.Close()
    
    // 关闭所有客户端连接
    s.mutex.Lock()
    for client := range s.clients {
        client.Close()
    }
    s.mutex.Unlock()
    
    fmt.Println("TCP Server stopped")
}

func demonstrateAdvancedTCPServer() {
    fmt.Println("\n=== 高级TCP服务器 ===")
    
    server, err := NewTCPServer(":8081")
    if err != nil {
        fmt.Printf("Create server error: %v\n", err)
        return
    }
    
    server.Start()
    
    // 运行一段时间后停止
    time.Sleep(10 * time.Second)
    server.Stop()
}

// TCP连接池
type TCPConnectionPool struct {
    addr     string
    pool     chan net.Conn
    maxConns int
    mutex    sync.Mutex
}

func NewTCPConnectionPool(addr string, maxConns int) *TCPConnectionPool {
    return &TCPConnectionPool{
        addr:     addr,
        pool:     make(chan net.Conn, maxConns),
        maxConns: maxConns,
    }
}

func (p *TCPConnectionPool) Get() (net.Conn, error) {
    select {
    case conn := <-p.pool:
        // 检查连接是否仍然有效
        if conn != nil {
            return conn, nil
        }
    default:
        // 创建新连接
        return net.Dial("tcp", p.addr)
    }
    return nil, fmt.Errorf("no available connections")
}

func (p *TCPConnectionPool) Put(conn net.Conn) {
    select {
    case p.pool <- conn:
    default:
        // 连接池已满，关闭连接
        conn.Close()
    }
}

func (p *TCPConnectionPool) Close() {
    close(p.pool)
    for conn := range p.pool {
        if conn != nil {
            conn.Close()
        }
    }
}
```

### UDP编程

```go
package main

import (
    "fmt"
    "net"
    "strings"
    "time"
)

// UDP服务器示例
func udpServer() {
    // 监听UDP端口
    addr, err := net.ResolveUDPAddr("udp", ":8082")
    if err != nil {
        fmt.Printf("Resolve UDP addr error: %v\n", err)
        return
    }
    
    conn, err := net.ListenUDP("udp", addr)
    if err != nil {
        fmt.Printf("Listen UDP error: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Printf("UDP Server started on %s\n", conn.LocalAddr().String())
    
    // 缓冲区
    buffer := make([]byte, 1024)
    
    for {
        // 读取UDP数据包
        n, clientAddr, err := conn.ReadFromUDP(buffer)
        if err != nil {
            fmt.Printf("Read UDP error: %v\n", err)
            continue
        }
        
        // 处理收到的数据
        message := string(buffer[:n])
        fmt.Printf("Received from %s: %s\n", clientAddr.String(), message)
        
        // 回复客户端
        response := fmt.Sprintf("Echo: %s", message)
        _, err = conn.WriteToUDP([]byte(response), clientAddr)
        if err != nil {
            fmt.Printf("Write UDP error: %v\n", err)
        }
    }
}

// UDP客户端示例
func udpClient() {
    // 解析服务器地址
    serverAddr, err := net.ResolveUDPAddr("udp", "localhost:8082")
    if err != nil {
        fmt.Printf("Resolve server addr error: %v\n", err)
        return
    }
    
    // 创建本地UDP连接
    localAddr, err := net.ResolveUDPAddr("udp", ":0")  // 0表示随机端口
    if err != nil {
        fmt.Printf("Resolve local addr error: %v\n", err)
        return
    }
    
    conn, err := net.DialUDP("udp", localAddr, serverAddr)
    if err != nil {
        fmt.Printf("Dial UDP error: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Printf("UDP Client started on %s\n", conn.LocalAddr().String())
    
    // 发送消息
    messages := []string{"Hello UDP Server", "This is a test", "Goodbye"}
    
    for _, msg := range messages {
        // 发送数据包
        _, err = conn.Write([]byte(msg))
        if err != nil {
            fmt.Printf("Write error: %v\n", err)
            return
        }
        
        // 读取回复
        buffer := make([]byte, 1024)
        conn.SetReadDeadline(time.Now().Add(5 * time.Second))
        n, err := conn.Read(buffer)
        if err != nil {
            fmt.Printf("Read error: %v\n", err)
            return
        }
        
        response := string(buffer[:n])
        fmt.Printf("Server response: %s\n", response)
        
        time.Sleep(1 * time.Second)
    }
    
    fmt.Println("UDP Client finished")
}

// UDP广播示例
func udpBroadcast() {
    // 创建广播地址
    broadcastAddr, err := net.ResolveUDPAddr("udp", "255.255.255.255:8083")
    if err != nil {
        fmt.Printf("Resolve broadcast addr error: %v\n", err)
        return
    }
    
    // 创建UDP连接
    conn, err := net.DialUDP("udp", nil, broadcastAddr)
    if err != nil {
        fmt.Printf("Dial UDP error: %v\n", err)
        return
    }
    defer conn.Close()
    
    // 设置广播标志
    if udpConn, ok := conn.(*net.UDPConn); ok {
        udpConn.SetWriteDeadline(time.Now().Add(10 * time.Second))
    }
    
    // 发送广播消息
    message := "This is a broadcast message"
    _, err = conn.Write([]byte(message))
    if err != nil {
        fmt.Printf("Broadcast write error: %v\n", err)
        return
    }
    
    fmt.Printf("Broadcast message sent: %s\n", message)
}

// UDP多播示例
func udpMulticast() {
    // 多播地址范围：224.0.0.0 到 239.255.255.255
    multicastAddr, err := net.ResolveUDPAddr("udp", "224.0.0.1:8084")
    if err != nil {
        fmt.Printf("Resolve multicast addr error: %v\n", err)
        return
    }
    
    // 监听多播
    conn, err := net.ListenMulticastUDP("udp", nil, multicastAddr)
    if err != nil {
        fmt.Printf("Listen multicast error: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Printf("UDP Multicast listener started on %s\n", multicastAddr.String())
    
    // 设置读取超时
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    
    buffer := make([]byte, 1024)
    for {
        n, srcAddr, err := conn.ReadFromUDP(buffer)
        if err != nil {
            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                fmt.Println("Multicast read timeout")
                break
            }
            fmt.Printf("Read multicast error: %v\n", err)
            continue
        }
        
        message := string(buffer[:n])
        fmt.Printf("Multicast received from %s: %s\n", srcAddr.String(), message)
    }
}

// 高级UDP处理
type UDPServer struct {
    conn *net.UDPConn
    quit chan bool
}

func NewUDPServer(addr string) (*UDPServer, error) {
    udpAddr, err := net.ResolveUDPAddr("udp", addr)
    if err != nil {
        return nil, err
    }
    
    conn, err := net.ListenUDP("udp", udpAddr)
    if err != nil {
        return nil, err
    }
    
    return &UDPServer{
        conn: conn,
        quit: make(chan bool),
    }, nil
}

func (s *UDPServer) Start() {
    fmt.Printf("Advanced UDP Server started on %s\n", s.conn.LocalAddr().String())
    
    buffer := make([]byte, 65507) // UDP最大包大小
    
    go func() {
        for {
            select {
            case <-s.quit:
                return
            default:
                n, clientAddr, err := s.conn.ReadFromUDP(buffer)
                if err != nil {
                    select {
                    case <-s.quit:
                        return
                    default:
                        fmt.Printf("UDP read error: %v\n", err)
                        continue
                    }
                }
                
                go s.handleMessage(buffer[:n], clientAddr)
            }
        }
    }()
}

func (s *UDPServer) handleMessage(data []byte, clientAddr *net.UDPAddr) {
    message := string(data)
    fmt.Printf("UDP message from %s: %s\n", clientAddr.String(), message)
    
    // 根据消息内容进行不同处理
    switch {
    case strings.HasPrefix(message, "ECHO:"):
        response := strings.TrimPrefix(message, "ECHO:")
        s.conn.WriteToUDP([]byte("Echo: "+response), clientAddr)
    case message == "TIME":
        currentTime := time.Now().Format("2006-01-02 15:04:05")
        s.conn.WriteToUDP([]byte(currentTime), clientAddr)
    case message == "QUIT":
        s.conn.WriteToUDP([]byte("Goodbye"), clientAddr)
    default:
        s.conn.WriteToUDP([]byte("Unknown command"), clientAddr)
    }
}

func (s *UDPServer) Stop() {
    close(s.quit)
    s.conn.Close()
    fmt.Println("UDP Server stopped")
}

func demonstrateAdvancedUDPServer() {
    fmt.Println("\n=== 高级UDP服务器 ===")
    
    server, err := NewUDPServer(":8085")
    if err != nil {
        fmt.Printf("Create UDP server error: %v\n", err)
        return
    }
    
    server.Start()
    
    // 运行一段时间后停止
    time.Sleep(15 * time.Second)
    server.Stop()
}
```

### HTTP客户端编程

```go
package main

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "io/ioutil"
    "mime/multipart"
    "net"
    "net/http"
    "net/url"
    "strings"
    "time"
)

// 基本HTTP客户端示例
func basicHTTPClient() {
    fmt.Println("=== 基本HTTP客户端 ===")
    
    // GET请求
    resp, err := http.Get("https://httpbin.org/get")
    if err != nil {
        fmt.Printf("GET error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("GET Status: %s\n", resp.Status)
    fmt.Printf("GET Content-Type: %s\n", resp.Header.Get("Content-Type"))
    
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Printf("Read body error: %v\n", err)
        return
    }
    
    fmt.Printf("GET Response: %s\n", string(body))
    
    // POST请求
    postData := strings.NewReader("key1=value1&key2=value2")
    resp, err = http.Post("https://httpbin.org/post", 
        "application/x-www-form-urlencoded", postData)
    if err != nil {
        fmt.Printf("POST error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, err = ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Printf("Read POST body error: %v\n", err)
        return
    }
    
    fmt.Printf("POST Status: %s\n", resp.Status)
    fmt.Printf("POST Response length: %d bytes\n", len(body))
}

// 高级HTTP客户端
func advancedHTTPClient() {
    fmt.Println("\n=== 高级HTTP客户端 ===")
    
    // 创建自定义HTTP客户端
    client := &http.Client{
        Timeout: 30 * time.Second,
        Transport: &http.Transport{
            MaxIdleConns:        100,
            MaxIdleConnsPerHost: 10,
            IdleConnTimeout:     90 * time.Second,
        },
    }
    
    // 创建请求
    req, err := http.NewRequest("GET", "https://httpbin.org/headers", nil)
    if err != nil {
        fmt.Printf("Create request error: %v\n", err)
        return
    }
    
    // 设置请求头
    req.Header.Set("User-Agent", "Go-HTTP-Client/1.0")
    req.Header.Set("Authorization", "Bearer your-token-here")
    req.Header.Set("Accept", "application/json")
    
    // 发送请求
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Do request error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("Advanced GET Status: %s\n", resp.Status)
    
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Printf("Read body error: %v\n", err)
        return
    }
    
    fmt.Printf("Headers response: %s\n", string(body))
}

// HTTP客户端带超时和取消
func httpClientWithTimeout() {
    fmt.Println("\n=== HTTP客户端带超时 ===")
    
    // 创建带超时的上下文
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 创建请求
    req, err := http.NewRequestWithContext(ctx, "GET", 
        "https://httpbin.org/delay/3", nil)
    if err != nil {
        fmt.Printf("Create request error: %v\n", err)
        return
    }
    
    // 发送请求
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        if ctx.Err() == context.DeadlineExceeded {
            fmt.Println("Request timed out")
        } else {
            fmt.Printf("Request error: %v\n", err)
        }
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("Timed request Status: %s\n", resp.Status)
}

// JSON API客户端
type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

func jsonAPIClient() {
    fmt.Println("\n=== JSON API客户端 ===")
    
    // GET请求获取JSON数据
    resp, err := http.Get("https://jsonplaceholder.typicode.com/users/1")
    if err != nil {
        fmt.Printf("GET error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    var user User
    err = json.NewDecoder(resp.Body).Decode(&user)
    if err != nil {
        fmt.Printf("JSON decode error: %v\n", err)
        return
    }
    
    fmt.Printf("User: %+v\n", user)
    
    // POST请求发送JSON数据
    newUser := User{
        Name:  "John Doe",
        Email: "john@example.com",
    }
    
    jsonData, err := json.Marshal(newUser)
    if err != nil {
        fmt.Printf("JSON marshal error: %v\n", err)
        return
    }
    
    resp, err = http.Post("https://jsonplaceholder.typicode.com/users",
        "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        fmt.Printf("POST error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    var createdUser User
    err = json.NewDecoder(resp.Body).Decode(&createdUser)
    if err != nil {
        fmt.Printf("JSON decode error: %v\n", err)
        return
    }
    
    fmt.Printf("Created user: %+v\n", createdUser)
}

// 文件上传客户端
func fileUploadClient() {
    fmt.Println("\n=== 文件上传客户端 ===")
    
    // 创建multipart表单
    var buf bytes.Buffer
    writer := multipart.NewWriter(&buf)
    
    // 添加表单字段
    writer.WriteField("title", "My Document")
    writer.WriteField("description", "A sample document")
    
    // 添加文件
    fileWriter, err := writer.CreateFormFile("file", "document.txt")
    if err != nil {
        fmt.Printf("Create form file error: %v\n", err)
        return
    }
    
    fileContent := "This is the content of the uploaded file."
    fileWriter.Write([]byte(fileContent))
    
    // 关闭writer
    writer.Close()
    
    // 创建上传请求
    req, err := http.NewRequest("POST", "https://httpbin.org/post", &buf)
    if err != nil {
        fmt.Printf("Create request error: %v\n", err)
        return
    }
    
    // 设置Content-Type
    req.Header.Set("Content-Type", writer.FormDataContentType())
    
    // 发送请求
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Upload error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("Upload Status: %s\n", resp.Status)
    
    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Printf("Upload Response length: %d bytes\n", len(body))
}

// HTTP客户端连接池管理
type HTTPClientPool struct {
    clients []*http.Client
    index   int
}

func NewHTTPClientPool(size int) *HTTPClientPool {
    pool := &HTTPClientPool{
        clients: make([]*http.Client, size),
    }
    
    for i := 0; i < size; i++ {
        pool.clients[i] = &http.Client{
            Transport: &http.Transport{
                MaxIdleConns:        100,
                MaxIdleConnsPerHost: 10,
                IdleConnTimeout:     30 * time.Second,
            },
            Timeout: 30 * time.Second,
        }
    }
    
    return pool
}

func (p *HTTPClientPool) Get() *http.Client {
    client := p.clients[p.index]
    p.index = (p.index + 1) % len(p.clients)
    return client
}

func httpClientPoolExample() {
    fmt.Println("\n=== HTTP客户端连接池 ===")
    
    pool := NewHTTPClientPool(3)
    
    // 并发请求
    var responses []string
    var mutex sync.Mutex
    
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            client := pool.Get()
            resp, err := client.Get("https://httpbin.org/uuid")
            if err != nil {
                fmt.Printf("Request %d error: %v\n", id, err)
                return
            }
            defer resp.Body.Close()
            
            body, err := ioutil.ReadAll(resp.Body)
            if err != nil {
                fmt.Printf("Read body %d error: %v\n", id, err)
                return
            }
            
            mutex.Lock()
            responses = append(responses, string(body))
            mutex.Unlock()
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("Completed %d requests\n", len(responses))
}

// HTTP客户端中间件
type LoggingTransport struct {
    Transport http.RoundTripper
}

func (t *LoggingTransport) RoundTrip(req *http.Request) (*http.Response, error) {
    start := time.Now()
    fmt.Printf("Sending request: %s %s\n", req.Method, req.URL.String())
    
    resp, err := t.Transport.RoundTrip(req)
    if err != nil {
        fmt.Printf("Request failed: %v\n", err)
        return nil, err
    }
    
    duration := time.Since(start)
    fmt.Printf("Response: %s (took %v)\n", resp.Status, duration)
    
    return resp, err
}

func loggingHTTPClient() {
    fmt.Println("\n=== 带日志的HTTP客户端 ===")
    
    client := &http.Client{
        Transport: &LoggingTransport{
            Transport: http.DefaultTransport,
        },
        Timeout: 10 * time.Second,
    }
    
    resp, err := client.Get("https://httpbin.org/get")
    if err != nil {
        fmt.Printf("GET error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("Logging client completed\n")
}
```

### HTTP服务端编程

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "html/template"
    "log"
    "net/http"
    "os"
    "os/signal"
    "strings"
    "sync"
    "syscall"
    "time"
)

// 基本HTTP服务器
func basicHTTPServer() {
    fmt.Println("=== 基本HTTP服务器 ===")
    
    // 简单的处理函数
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World! Request: %s %s\n", r.Method, r.URL.Path)
    })
    
    http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
        name := r.URL.Query().Get("name")
        if name == "" {
            name = "World"
        }
        fmt.Fprintf(w, "Hello, %s!\n", name)
    })
    
    // 启动服务器
    fmt.Println("Server starting on :8080")
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

// 高级HTTP服务器
type APIServer struct {
    server *http.Server
    mux    *http.ServeMux
}

func NewAPIServer(addr string) *APIServer {
    mux := http.NewServeMux()
    
    server := &http.Server{
        Addr:         addr,
        Handler:      mux,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    api := &APIServer{
        server: server,
        mux:    mux,
    }
    
    // 注册路由
    api.registerRoutes()
    
    return api
}

func (s *APIServer) registerRoutes() {
    s.mux.HandleFunc("/", s.homeHandler)
    s.mux.HandleFunc("/api/health", s.healthHandler)
    s.mux.HandleFunc("/api/users", s.usersHandler)
    s.mux.HandleFunc("/api/users/", s.userHandler)
    s.mux.HandleFunc("/api/time", s.timeHandler)
    
    // 静态文件服务
    s.mux.Handle("/static/", http.StripPrefix("/static/", 
        http.FileServer(http.Dir("static/"))))
}

func (s *APIServer) homeHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != "/" {
        http.NotFound(w, r)
        return
    }
    
    w.Header().Set("Content-Type", "text/html")
    fmt.Fprintf(w, `
    <html>
    <head><title>API Server</title></head>
    <body>
        <h1>Welcome to API Server</h1>
        <ul>
            <li><a href="/api/health">Health Check</a></li>
            <li><a href="/api/users">Users</a></li>
            <li><a href="/api/time">Current Time</a></li>
        </ul>
    </body>
    </html>
    `)
}

func (s *APIServer) healthHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    response := map[string]interface{}{
        "status": "healthy",
        "time":   time.Now().Format(time.RFC3339),
    }
    
    json.NewEncoder(w).Encode(response)
}

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

var (
    users = []User{
        {ID: 1, Name: "Alice", Email: "alice@example.com"},
        {ID: 2, Name: "Bob", Email: "bob@example.com"},
        {ID: 3, Name: "Charlie", Email: "charlie@example.com"},
    }
    usersMutex sync.RWMutex
)

func (s *APIServer) usersHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    switch r.Method {
    case "GET":
        usersMutex.RLock()
        defer usersMutex.RUnlock()
        json.NewEncoder(w).Encode(users)
        
    case "POST":
        var user User
        if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
            http.Error(w, "Invalid JSON", http.StatusBadRequest)
            return
        }
        
        usersMutex.Lock()
        user.ID = len(users) + 1
        users = append(users, user)
        usersMutex.Unlock()
        
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)
        
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func (s *APIServer) userHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    // 解析用户ID
    path := strings.TrimPrefix(r.URL.Path, "/api/users/")
    var userID int
    fmt.Sscanf(path, "%d", &userID)
    
    if userID <= 0 {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    usersMutex.RLock()
    defer usersMutex.RUnlock()
    
    // 查找用户
    var user *User
    for i := range users {
        if users[i].ID == userID {
            user = &users[i]
            break
        }
    }
    
    if user == nil {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }
    
    json.NewEncoder(w).Encode(user)
}

func (s *APIServer) timeHandler(w http.ResponseWriter, r *http.Request) {
    response := map[string]string{
        "current_time": time.Now().Format("2006-01-02 15:04:05"),
        "timezone":     time.Now().Location().String(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func (s *APIServer) Start() error {
    fmt.Printf("API Server starting on %s\n", s.server.Addr)
    return s.server.ListenAndServe()
}

func (s *APIServer) Stop(ctx context.Context) error {
    fmt.Println("API Server stopping...")
    return s.server.Shutdown(ctx)
}

func advancedHTTPServer() {
    fmt.Println("\n=== 高级HTTP服务器 ===")
    
    server := NewAPIServer(":8081")
    
    // 优雅关闭
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        <-c
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        server.Stop(ctx)
        os.Exit(0)
    }()
    
    if err := server.Start(); err != nil && err != http.ErrServerClosed {
        fmt.Printf("Server error: %v\n", err)
    }
}

// 中间件示例
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        next.ServeHTTP(w, r)
        
        log.Printf("Completed %s %s in %v", r.Method, r.URL.Path, time.Since(start))
    })
}

func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 简单的API密钥验证
        apiKey := r.Header.Get("X-API-Key")
        if apiKey != "secret-key" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

func corsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// 使用中间件的服务器
func middlewareHTTPServer() {
    fmt.Println("\n=== 带中间件的HTTP服务器 ===")
    
    mux := http.NewServeMux()
    
    // 应用中间件
    var handler http.Handler = mux
    handler = loggingMiddleware(handler)
    handler = corsMiddleware(handler)
    
    // 注册路由
    mux.HandleFunc("/api/data", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "message": "Hello from protected API",
            "time":    time.Now().Format(time.RFC3339),
        })
    })
    
    server := &http.Server{
        Addr:    ":8082",
        Handler: handler,
    }
    
    fmt.Println("Middleware server starting on :8082")
    if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        fmt.Printf("Server error: %v\n", err)
    }
}

// 模板引擎示例
const htmlTemplate = `
<!DOCTYPE html>
<html>
<head>
    <title>{{.Title}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .user { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
    </style>
</head>
<body>
    <h1>{{.Title}}</h1>
    <p>Current time: {{.Time}}</p>
    
    <h2>Users</h2>
    {{range .Users}}
    <div class="user">
        <strong>{{.Name}}</strong> (ID: {{.ID}})<br>
        Email: {{.Email}}
    </div>
    {{else}}
    <p>No users found.</p>
    {{end}}
</body>
</html>
`

func templateHTTPServer() {
    fmt.Println("\n=== 模板HTTP服务器 ===")
    
    tmpl, err := template.New("page").Parse(htmlTemplate)
    if err != nil {
        fmt.Printf("Template parse error: %v\n", err)
        return
    }
    
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        data := struct {
            Title string
            Time  string
            Users []User
        }{
            Title: "Go Template Server",
            Time:  time.Now().Format("2006-01-02 15:04:05"),
            Users: users,
        }
        
        w.Header().Set("Content-Type", "text/html")
        if err := tmpl.Execute(w, data); err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
        }
    })
    
    fmt.Println("Template server starting on :8083")
    if err := http.ListenAndServe(":8083", nil); err != nil {
        fmt.Printf("Server error: %v\n", err)
    }
}

// HTTP服务器性能监控
type Metrics struct {
    Requests    int64
    Errors      int64
    TotalTime   time.Duration
    mutex       sync.RWMutex
}

func (m *Metrics) RecordRequest(duration time.Duration, err bool) {
    m.mutex.Lock()
    defer m.mutex.Unlock()
    
    m.Requests++
    m.TotalTime += duration
    if err {
        m.Errors++
    }
}

func (m *Metrics) GetStats() map[string]interface{} {
    m.mutex.RLock()
    defer m.mutex.RUnlock()
    
    avgTime := time.Duration(0)
    if m.Requests > 0 {
        avgTime = m.TotalTime / time.Duration(m.Requests)
    }
    
    return map[string]interface{}{
        "requests":        m.Requests,
        "errors":          m.Errors,
        "average_duration": avgTime.String(),
        "error_rate":      float64(m.Errors) / float64(m.Requests) * 100,
    }
}

var globalMetrics = &Metrics{}

func metricsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 包装ResponseWriter以捕获状态码
        wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        next.ServeHTTP(wrapped, r)
        
        duration := time.Since(start)
        globalMetrics.RecordRequest(duration, wrapped.statusCode >= 400)
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

func metricsHTTPServer() {
    fmt.Println("\n=== 带监控的HTTP服务器 ===")
    
    mux := http.NewServeMux()
    
    // 应用监控中间件
    var handler http.Handler = mux
    handler = metricsMiddleware(handler)
    handler = loggingMiddleware(handler)
    
    // 注册路由
    mux.HandleFunc("/api/data", func(w http.ResponseWriter, r *http.Request) {
        // 模拟一些处理时间
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "message": "Data endpoint",
            "time":    time.Now().Format(time.RFC3339),
        })
    })
    
    mux.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(globalMetrics.GetStats())
    })
    
    server := &http.Server{
        Addr:    ":8084",
        Handler: handler,
    }
    
    fmt.Println("Metrics server starting on :8084")
    if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        fmt.Printf("Server error: %v\n", err)
    }
}
```

### WebSocket编程

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "sync"
    "time"
    
    "github.com/gorilla/websocket"
)

// WebSocket服务器
type WebSocketServer struct {
    clients    map[*websocket.Conn]bool
    broadcast  chan []byte
    register   chan *websocket.Conn
    unregister chan *websocket.Conn
    mutex      sync.RWMutex
}

func NewWebSocketServer() *WebSocketServer {
    return &WebSocketServer{
        clients:    make(map[*websocket.Conn]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *websocket.Conn),
        unregister: make(chan *websocket.Conn),
    }
}

func (s *WebSocketServer) Run() {
    for {
        select {
        case client := <-s.register:
            s.mutex.Lock()
            s.clients[client] = true
            s.mutex.Unlock()
            log.Printf("Client connected. Total clients: %d", len(s.clients))
            
        case client := <-s.unregister:
            s.mutex.Lock()
            if _, ok := s.clients[client]; ok {
                delete(s.clients, client)
                client.Close()
            }
            s.mutex.Unlock()
            log.Printf("Client disconnected. Total clients: %d", len(s.clients))
            
        case message := <-s.broadcast:
            s.mutex.RLock()
            for client := range s.clients {
                err := client.WriteMessage(websocket.TextMessage, message)
                if err != nil {
                    log.Printf("Error sending message to client: %v", err)
                    client.Close()
                    delete(s.clients, client)
                }
            }
            s.mutex.RUnlock()
        }
    }
}

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // 允许所有来源
    },
}

func (s *WebSocketServer) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("WebSocket upgrade error: %v", err)
        return
    }
    
    s.register <- conn
    
    // 处理客户端消息
    go s.handleClientMessages(conn)
}

func (s *WebSocketServer) handleClientMessages(conn *websocket.Conn) {
    defer func() {
        s.unregister <- conn
    }()
    
    for {
        messageType, message, err := conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Printf("WebSocket error: %v", err)
            }
            break
        }
        
        if messageType == websocket.TextMessage {
            log.Printf("Received message: %s", message)
            
            // 广播消息给所有客户端
            s.broadcast <- message
        }
    }
}

func (s *WebSocketServer) StartBroadcast() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            message := fmt.Sprintf("Server time: %s", time.Now().Format("15:04:05"))
            s.broadcast <- []byte(message)
        }
    }
}

func webSocketServer() {
    fmt.Println("=== WebSocket服务器 ===")
    
    server := NewWebSocketServer()
    
    // 启动消息处理循环
    go server.Run()
    
    // 启动定时广播
    go server.StartBroadcast()
    
    // 注册WebSocket处理函数
    http.HandleFunc("/ws", server.HandleWebSocket)
    
    // 提供简单的HTML页面
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        html := `
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Chat</title>
</head>
<body>
    <h1>WebSocket Chat</h1>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Type a message...">
    <button onclick="sendMessage()">Send</button>
    
    <script>
        const ws = new WebSocket("ws://localhost:8085/ws");
        const messages = document.getElementById("messages");
        const input = document.getElementById("messageInput");
        
        ws.onopen = function(event) {
            addMessage("Connected to WebSocket server");
        };
        
        ws.onmessage = function(event) {
            addMessage("Server: " + event.data);
        };
        
        ws.onclose = function(event) {
            addMessage("Disconnected from server");
        };
        
        ws.onerror = function(error) {
            addMessage("WebSocket error: " + error);
        };
        
        function sendMessage() {
            if (input.value) {
                ws.send(input.value);
                addMessage("You: " + input.value);
                input.value = "";
            }
        }
        
        function addMessage(message) {
            const div = document.createElement("div");
            div.textContent = message;
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }
        
        input.addEventListener("keypress", function(e) {
            if (e.key === "Enter") {
                sendMessage();
            }
        });
    </script>
</body>
</html>
        `
        w.Header().Set("Content-Type", "text/html")
        w.Write([]byte(html))
    })
    
    fmt.Println("WebSocket server starting on :8085")
    log.Fatal(http.ListenAndServe(":8085", nil))
}

// WebSocket客户端
type WebSocketClient struct {
    conn   *websocket.Conn
    send   chan []byte
    done   chan struct{}
    mutex  sync.Mutex
    closed bool
}

func NewWebSocketClient(url string) (*WebSocketClient, error) {
    conn, _, err := websocket.DefaultDialer.Dial(url, nil)
    if err != nil {
        return nil, err
    }
    
    client := &WebSocketClient{
        conn: conn,
        send: make(chan []byte, 256),
        done: make(chan struct{}),
    }
    
    go client.readPump()
    go client.writePump()
    
    return client, nil
}

func (c *WebSocketClient) readPump() {
    defer func() {
        c.Close()
    }()
    
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Printf("WebSocket read error: %v", err)
            }
            break
        }
        
        log.Printf("Received: %s", message)
    }
}

func (c *WebSocketClient) writePump() {
    defer func() {
        c.Close()
    }()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            err := c.conn.WriteMessage(websocket.TextMessage, message)
            if err != nil {
                log.Printf("WebSocket write error: %v", err)
                return
            }
            
        case <-c.done:
            return
        }
    }
}

func (c *WebSocketClient) Send(message string) error {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    if c.closed {
        return fmt.Errorf("client is closed")
    }
    
    select {
    case c.send <- []byte(message):
        return nil
    default:
        return fmt.Errorf("send channel is full")
    }
}

func (c *WebSocketClient) Close() {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    if c.closed {
        return
    }
    
    c.closed = true
    close(c.send)
    close(c.done)
    c.conn.Close()
}

func webSocketClient() {
    fmt.Println("\n=== WebSocket客户端 ===")
    
    client, err := NewWebSocketClient("ws://localhost:8085/ws")
    if err != nil {
        fmt.Printf("Client connection error: %v\n", err)
        return
    }
    defer client.Close()
    
    // 发送消息
    messages := []string{
        "Hello from client 1",
        "How are you?",
        "Goodbye",
    }
    
    for _, msg := range messages {
        err := client.Send(msg)
        if err != nil {
            fmt.Printf("Send error: %v\n", err)
            return
        }
        fmt.Printf("Sent: %s\n", msg)
        time.Sleep(2 * time.Second)
    }
    
    time.Sleep(5 * time.Second)
}
```

### 网络超时处理

```go
package main

import (
    "context"
    "fmt"
    "net"
    "net/http"
    "time"
)

// 连接超时示例
func connectionTimeoutExample() {
    fmt.Println("=== 连接超时示例 ===")
    
    // 设置连接超时
    conn, err := net.DialTimeout("tcp", "google.com:80", 5*time.Second)
    if err != nil {
        fmt.Printf("Connection timeout error: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Println("Connected successfully")
}

// 读写超时示例
func readWriteTimeoutExample() {
    fmt.Println("\n=== 读写超时示例 ===")
    
    listener, err := net.Listen("tcp", ":0")
    if err != nil {
        fmt.Printf("Listen error: %v\n", err)
        return
    }
    defer listener.Close()
    
    fmt.Printf("Listening on %s\n", listener.Addr().String())
    
    // 启动服务器
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            return
        }
        defer conn.Close()
        
        // 设置读写超时
        conn.SetReadDeadline(time.Now().Add(10 * time.Second))
        conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
        
        buffer := make([]byte, 1024)
        n, err := conn.Read(buffer)
        if err != nil {
            fmt.Printf("Read timeout: %v\n", err)
            return
        }
        
        fmt.Printf("Received: %s\n", string(buffer[:n]))
        
        // 模拟处理时间
        time.Sleep(2 * time.Second)
        
        response := "Hello from server"
        _, err = conn.Write([]byte(response))
        if err != nil {
            fmt.Printf("Write error: %v\n", err)
            return
        }
    }()
    
    // 客户端连接
    time.Sleep(100 * time.Millisecond) // 等待服务器启动
    
    conn, err := net.Dial("tcp", listener.Addr().String())
    if err != nil {
        fmt.Printf("Dial error: %v\n", err)
        return
    }
    defer conn.Close()
    
    // 设置客户端超时
    conn.SetWriteDeadline(time.Now().Add(5 * time.Second))
    conn.SetReadDeadline(time.Now().Add(5 * time.Second))
    
    // 发送数据
    _, err = conn.Write([]byte("Hello from client"))
    if err != nil {
        fmt.Printf("Write error: %v\n", err)
        return
    }
    
    // 读取响应
    buffer := make([]byte, 1024)
    n, err := conn.Read(buffer)
    if err != nil {
        fmt.Printf("Read error: %v\n", err)
        return
    }
    
    fmt.Printf("Response: %s\n", string(buffer[:n]))
}

// HTTP客户端超时
func httpClientTimeout() {
    fmt.Println("\n=== HTTP客户端超时 ===")
    
    // 方法1：使用Client.Timeout
    client := &http.Client{
        Timeout: 5 * time.Second,
    }
    
    // 方法2：使用Context超时
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    req, err := http.NewRequestWithContext(ctx, "GET", "https://httpbin.org/delay/2", nil)
    if err != nil {
        fmt.Printf("Create request error: %v\n", err)
        return
    }
    
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Request error: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("Status: %s\n", resp.Status)
}

// TCP连接超时管理
type TimeoutTCPClient struct {
    connTimeout time.Duration
    readTimeout time.Duration
    writeTimeout time.Duration
}

func NewTimeoutTCPClient(connTimeout, readTimeout, writeTimeout time.Duration) *TimeoutTCPClient {
    return &TimeoutTCPClient{
        connTimeout: connTimeout,
        readTimeout: readTimeout,
        writeTimeout: writeTimeout,
    }
}

func (c *TimeoutTCPClient) Connect(address string) (net.Conn, error) {
    conn, err := net.DialTimeout("tcp", address, c.connTimeout)
    if err != nil {
        return nil, err
    }
    
    // 设置读写超时
    if c.readTimeout > 0 {
        conn.SetReadDeadline(time.Now().Add(c.readTimeout))
    }
    if c.writeTimeout > 0 {
        conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
    }
    
    return conn, nil
}

func timeoutTCPClientExample() {
    fmt.Println("\n=== TCP超时客户端 ===")
    
    client := NewTimeoutTCPClient(5*time.Second, 10*time.Second, 10*time.Second)
    
    conn, err := client.Connect("google.com:80")
    if err != nil {
        fmt.Printf("Connect error: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Println("Connected with timeout settings")
}

// 超时处理最佳实践
func timeoutBestPractices() {
    fmt.Println("\n=== 超时处理最佳实践 ===")
    
    // 1. 分层超时设置
    type ServiceConfig struct {
        ConnectTimeout time.Duration
        ReadTimeout    time.Duration
        WriteTimeout   time.Duration
        TotalTimeout   time.Duration
    }
    
    config := ServiceConfig{
        ConnectTimeout: 5 * time.Second,
        ReadTimeout:    30 * time.Second,
        WriteTimeout:   30 * time.Second,
        TotalTimeout:   60 * time.Second,
    }
    
    fmt.Printf("Service config: %+v\n", config)
    
    // 2. 使用Context进行超时控制
    ctx, cancel := context.WithTimeout(context.Background(), config.TotalTimeout)
    defer cancel()
    
    // 3. 重试机制配合超时
    maxRetries := 3
    for i := 0; i < maxRetries; i++ {
        select {
        case <-ctx.Done():
            fmt.Printf("Operation cancelled after %d retries\n", i)
            return
        default:
            // 执行操作
            fmt.Printf("Attempt %d\n", i+1)
            time.Sleep(1 * time.Second) // 模拟操作
            
            if i == maxRetries-1 { // 最后一次尝试
                break
            }
        }
    }
    
    // 4. 动态超时调整
    func calculateTimeout(baseTimeout time.Duration, retryCount int) time.Duration {
        return baseTimeout * time.Duration(retryCount+1)
    }
    
    for i := 0; i < 3; i++ {
        timeout := calculateTimeout(2*time.Second, i)
        fmt.Printf("Retry %d timeout: %v\n", i, timeout)
    }
}

// 超时监控和统计
type TimeoutMonitor struct {
    timeouts map[string]int
    mutex    sync.RWMutex
}

func NewTimeoutMonitor() *TimeoutMonitor {
    return &TimeoutMonitor{
        timeouts: make(map[string]int),
    }
}

func (tm *TimeoutMonitor) RecordTimeout(operation string) {
    tm.mutex.Lock()
    defer tm.mutex.Unlock()
    tm.timeouts[operation]++
}

func (tm *TimeoutMonitor) GetStats() map[string]int {
    tm.mutex.RLock()
    defer tm.mutex.RUnlock()
    
    stats := make(map[string]int)
    for op, count := range tm.timeouts {
        stats[op] = count
    }
    return stats
}

func timeoutMonitoring() {
    fmt.Println("\n=== 超时监控 ===")
    
    monitor := NewTimeoutMonitor()
    
    // 模拟超时记录
    operations := []string{"database_query", "api_call", "file_read", "network_request"}
    
    for i := 0; i < 100; i++ {
        op := operations[i%len(operations)]
        if i%10 == 0 { // 10%的超时率
            monitor.RecordTimeout(op)
        }
    }
    
    stats := monitor.GetStats()
    fmt.Println("Timeout statistics:")
    for op, count := range stats {
        fmt.Printf("  %s: %d timeouts\n", op, count)
    }
}
```

### 连接池管理

```go
package main

import (
    "fmt"
    "net"
    "net/http"
    "sync"
    "time"
)

// TCP连接池
type TCPConnectionPool struct {
    addr         string
    maxConns     int
    idleConns    []*idleConn
    activeConns  int
    mutex        sync.Mutex
    cond         *sync.Cond
    closed       bool
    idleTimeout  time.Duration
}

type idleConn struct {
    conn    net.Conn
    created time.Time
    used    time.Time
}

func NewTCPConnectionPool(addr string, maxConns int, idleTimeout time.Duration) *TCPConnectionPool {
    pool := &TCPConnectionPool{
        addr:        addr,
        maxConns:    maxConns,
        idleConns:   make([]*idleConn, 0, maxConns),
        idleTimeout: idleTimeout,
    }
    pool.cond = sync.NewCond(&pool.mutex)
    return pool
}

func (p *TCPConnectionPool) Get() (net.Conn, error) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    for {
        if p.closed {
            return nil, fmt.Errorf("connection pool closed")
        }
        
        // 尝试从空闲连接中获取
        if len(p.idleConns) > 0 {
            // 从末尾取出连接（最近使用的）
            lastIdx := len(p.idleConns) - 1
            idle := p.idleConns[lastIdx]
            p.idleConns = p.idleConns[:lastIdx]
            
            // 检查连接是否超时
            if time.Since(idle.used) > p.idleTimeout {
                idle.conn.Close()
                p.activeConns--
                continue
            }
            
            idle.used = time.Now()
            return idle.conn, nil
        }
        
        // 检查是否可以创建新连接
        if p.activeConns < p.maxConns {
            conn, err := net.Dial("tcp", p.addr)
            if err != nil {
                return nil, err
            }
            
            p.activeConns++
            return &pooledConn{
                Conn: conn,
                pool: p,
            }, nil
        }
        
        // 等待连接可用
        p.cond.Wait()
    }
}

func (p *TCPConnectionPool) put(conn net.Conn) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        conn.Close()
        p.activeConns--
        return
    }
    
    pooled := &idleConn{
        conn:    conn,
        created: time.Now(),
        used:    time.Now(),
    }
    
    p.idleConns = append(p.idleConns, pooled)
    p.cond.Signal()
}

func (p *TCPConnectionPool) Close() {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        return
    }
    
    p.closed = true
    
    // 关闭所有空闲连接
    for _, idle := range p.idleConns {
        idle.conn.Close()
    }
    p.idleConns = nil
    p.activeConns = 0
    
    p.cond.Broadcast()
}

type pooledConn struct {
    net.Conn
    pool *TCPConnectionPool
}

func (pc *pooledConn) Close() error {
    pc.pool.put(pc.Conn)
    return nil
}

func tcpConnectionPoolExample() {
    fmt.Println("=== TCP连接池示例 ===")
    
    pool := NewTCPConnectionPool("google.com:80", 5, 30*time.Second)
    defer pool.Close()
    
    // 并发获取连接
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            conn, err := pool.Get()
            if err != nil {
                fmt.Printf("Get connection %d error: %v\n", id, err)
                return
            }
            
            fmt.Printf("Got connection %d: %s\n", id, conn.RemoteAddr())
            
            // 模拟使用连接
            time.Sleep(100 * time.Millisecond)
            
            conn.Close() // 返回到连接池
        }(i)
    }
    
    wg.Wait()
    fmt.Println("TCP connection pool example completed")
}

// HTTP客户端连接池
type HTTPClientPool struct {
    clients []*http.Client
    index   int
    mutex   sync.Mutex
}

func NewHTTPClientPool(maxIdleConns, maxIdleConnsPerHost int, idleConnTimeout time.Duration) *HTTPClientPool {
    size := 10 // 连接池大小
    clients := make([]*http.Client, size)
    
    for i := 0; i < size; i++ {
        clients[i] = &http.Client{
            Transport: &http.Transport{
                MaxIdleConns:        maxIdleConns,
                MaxIdleConnsPerHost: maxIdleConnsPerHost,
                IdleConnTimeout:     idleConnTimeout,
                DisableKeepAlives:   false,
            },
            Timeout: 30 * time.Second,
        }
    }
    
    return &HTTPClientPool{
        clients: clients,
    }
}

func (p *HTTPClientPool) Get() *http.Client {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    client := p.clients[p.index]
    p.index = (p.index + 1) % len(p.clients)
    return client
}

func httpClientPoolExample() {
    fmt.Println("\n=== HTTP客户端连接池 ===")
    
    pool := NewHTTPClientPool(100, 10, 90*time.Second)
    
    // 并发HTTP请求
    var wg sync.WaitGroup
    var responses []string
    var mutex sync.Mutex
    
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            client := pool.Get()
            resp, err := client.Get("https://httpbin.org/uuid")
            if err != nil {
                fmt.Printf("Request %d error: %v\n", id, err)
                return
            }
            defer resp.Body.Close()
            
            // 读取响应
            body, err := fmt.Printf("Request %d completed\n", id)
            _ = body
            
            mutex.Lock()
            responses = append(responses, fmt.Sprintf("Response %d", id))
            mutex.Unlock()
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("Completed %d requests\n", len(responses))
}

// 连接池监控
type PoolMonitor struct {
    stats map[string]*PoolStats
    mutex sync.RWMutex
}

type PoolStats struct {
    Created     int64
    Active      int64
    Idle        int64
    Requests    int64
    Errors      int64
    AvgWaitTime time.Duration
}

func NewPoolMonitor() *PoolMonitor {
    return &PoolMonitor{
        stats: make(map[string]*PoolStats),
    }
}

func (pm *PoolMonitor) RecordPoolStats(name string, created, active, idle, requests, errors int64) {
    pm.mutex.Lock()
    defer pm.mutex.Unlock()
    
    if pm.stats[name] == nil {
        pm.stats[name] = &PoolStats{}
    }
    
    stats := pm.stats[name]
    stats.Created = created
    stats.Active = active
    stats.Idle = idle
    stats.Requests = requests
    stats.Errors = errors
}

func (pm *PoolMonitor) GetStats() map[string]*PoolStats {
    pm.mutex.RLock()
    defer pm.mutex.RUnlock()
    
    result := make(map[string]*PoolStats)
    for name, stats := range pm.stats {
        result[name] = &PoolStats{
            Created:  stats.Created,
            Active:   stats.Active,
            Idle:     stats.Idle,
            Requests: stats.Requests,
            Errors:   stats.Errors,
        }
    }
    return result
}

func poolMonitoringExample() {
    fmt.Println("\n=== 连接池监控 ===")
    
    monitor := NewPoolMonitor()
    
    // 模拟记录统计信息
    monitor.RecordPoolStats("tcp_pool", 100, 20, 80, 1000, 5)
    monitor.RecordPoolStats("http_pool", 50, 15, 35, 500, 2)
    
    stats := monitor.GetStats()
    fmt.Println("Pool statistics:")
    for name, stat := range stats {
        fmt.Printf("  %s: Created=%d, Active=%d, Idle=%d, Requests=%d, Errors=%d\n",
            name, stat.Created, stat.Active, stat.Idle, stat.Requests, stat.Errors)
    }
}

// 智能连接池
type SmartConnectionPool struct {
    addr         string
    minConns     int
    maxConns     int
    currentConns int
    idleConns    chan net.Conn
    mutex        sync.Mutex
    closed       bool
    stats        *PoolStats
}

func NewSmartConnectionPool(addr string, minConns, maxConns int) *SmartConnectionPool {
    pool := &SmartConnectionPool{
        addr:      addr,
        minConns:  minConns,
        maxConns:  maxConns,
        idleConns: make(chan net.Conn, maxConns),
        stats:     &PoolStats{},
    }
    
    // 预创建最小连接数
    go pool.preCreateConnections()
    
    return pool
}

func (p *SmartConnectionPool) preCreateConnections() {
    for i := 0; i < p.minConns; i++ {
        conn, err := net.Dial("tcp", p.addr)
        if err == nil {
            p.idleConns <- conn
            p.mutex.Lock()
            p.currentConns++
            p.mutex.Unlock()
        }
    }
}

func (p *SmartConnectionPool) Get() (net.Conn, error) {
    p.mutex.Lock()
    if p.closed {
        p.mutex.Unlock()
        return nil, fmt.Errorf("pool closed")
    }
    p.stats.Requests++
    p.mutex.Unlock()
    
    select {
    case conn := <-p.idleConns:
        return &smartPooledConn{Conn: conn, pool: p}, nil
    default:
        // 检查是否可以创建新连接
        p.mutex.Lock()
        if p.currentConns < p.maxConns {
            p.currentConns++
            p.mutex.Unlock()
            
            conn, err := net.Dial("tcp", p.addr)
            if err != nil {
                p.mutex.Lock()
                p.currentConns--
                p.stats.Errors++
                p.mutex.Unlock()
                return nil, err
            }
            
            return &smartPooledConn{Conn: conn, pool: p}, nil
        }
        p.mutex.Unlock()
        
        // 等待空闲连接
        select {
        case conn := <-p.idleConns:
            return &smartPooledConn{Conn: conn, pool: p}, nil
        case <-time.After(30 * time.Second):
            p.mutex.Lock()
            p.stats.Errors++
            p.mutex.Unlock()
            return nil, fmt.Errorf("connection timeout")
        }
    }
}

func (p *SmartConnectionPool) put(conn net.Conn) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        conn.Close()
        p.currentConns--
        return
    }
    
    select {
    case p.idleConns <- conn:
        // 连接成功放入池中
    default:
        // 池已满，关闭连接
        conn.Close()
        p.currentConns--
    }
}

func (p *SmartConnectionPool) Close() {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if p.closed {
        return
    }
    
    p.closed = true
    close(p.idleConns)
    
    // 关闭所有连接
    for conn := range p.idleConns {
        conn.Close()
    }
    p.currentConns = 0
}

type smartPooledConn struct {
    net.Conn
    pool *SmartConnectionPool
}

func (sc *smartPooledConn) Close() error {
    sc.pool.put(sc.Conn)
    return nil
}

func smartConnectionPoolExample() {
    fmt.Println("\n=== 智能连接池 ===")
    
    pool := NewSmartConnectionPool("google.com:80", 2, 10)
    defer pool.Close()
    
    // 并发使用连接池
    var wg sync.WaitGroup
    for i := 0; i < 15; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            conn, err := pool.Get()
            if err != nil {
                fmt.Printf("Get connection %d error: %v\n", id, err)
                return
            }
            
            fmt.Printf("Got connection %d\n", id)
            time.Sleep(200 * time.Millisecond)
            conn.Close()
        }(i)
    }
    
    wg.Wait()
    fmt.Println("Smart connection pool example completed")
}

func main() {
    // 运行网络编程示例
    demonstrateNetPackage()
    networkAddressUtils()
    networkConnectionBasics()
    
    // TCP编程示例（需要在不同goroutine中运行）
    go tcpServer()
    time.Sleep(100 * time.Millisecond) // 等待服务器启动
    tcpClient()
    
    demonstrateAdvancedTCPServer()
    
    // UDP编程示例
    go udpServer()
    time.Sleep(100 * time.Millisecond)
    udpClient()
    udpBroadcast()
    udpMulticast()
    demonstrateAdvancedUDPServer()
    
    // HTTP客户端示例
    basicHTTPClient()
    advancedHTTPClient()
    httpClientWithTimeout()
    jsonAPIClient()
    fileUploadClient()
    httpClientPoolExample()
    loggingHTTPClient()
    
    // HTTP服务器示例（需要单独运行）
    // basicHTTPServer()
    // advancedHTTPServer()
    // middlewareHTTPServer()
    // templateHTTPServer()
    // metricsHTTPServer()
    
    // WebSocket示例（需要单独运行）
    // webSocketServer()
    // webSocketClient()
    
    // 超时处理示例
    connectionTimeoutExample()
    readWriteTimeoutExample()
    httpClientTimeout()
    timeoutTCPClientExample()
    timeoutBestPractices()
    timeoutMonitoring()
    
    // 连接池示例
    tcpConnectionPoolExample()
    httpClientPoolExample()
    poolMonitoringExample()
    smartConnectionPoolExample()
}
```