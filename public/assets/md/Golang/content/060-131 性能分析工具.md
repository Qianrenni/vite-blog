## 13.1 性能分析工具

### go tool pprof

pprof是Go语言内置的性能分析工具，可以帮助开发者分析CPU使用、内存分配、阻塞等情况。

#### 基本使用方法

```go
package main

import (
    "net/http"
    _ "net/http/pprof"
    "time"
)

func main() {
    // 启动HTTP服务，暴露pprof端点
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()
    
    // 模拟业务逻辑
    for i := 0; i < 1000000; i++ {
        time.Sleep(time.Microsecond)
    }
}
```

#### CPU分析

```go
package main

import (
    "os"
    "runtime/pprof"
    "time"
)

func cpuIntensiveTask() {
    sum := 0
    for i := 0; i < 1000000000; i++ {
        sum += i
    }
}

func main() {
    // 创建CPU分析文件
    f, err := os.Create("cpu.prof")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    // 开始CPU分析
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()

    // 执行需要分析的代码
    cpuIntensiveTask()
}
```

#### 内存分析

```go
package main

import (
    "os"
    "runtime/pprof"
)

func memoryIntensiveTask() []string {
    var result []string
    for i := 0; i < 1000000; i++ {
        result = append(result, "item"+string(rune(i)))
    }
    return result
}

func main() {
    // 执行内存密集型任务
    result := memoryIntensiveTask()
    
    // 创建内存分析文件
    f, err := os.Create("mem.prof")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    // 进行堆内存分析
    pprof.WriteHeapProfile(f)
    
    // 保持引用防止GC
    _ = len(result)
}
```

#### 使用pprof命令行工具

```bash
# 启动pprof交互式界面
go tool pprof cpu.prof

# 或者直接查看Web界面
go tool pprof -http=:8080 cpu.prof

# 常用命令
# top - 显示最耗时的函数
# list <function> - 显示函数的源码和每行的耗时
# web - 生成调用图
# svg - 生成SVG格式的调用图
```

### trace工具

trace工具用于分析程序的并发执行情况，包括goroutine的创建、执行、阻塞等。

```go
package main

import (
    "context"
    "os"
    "runtime/trace"
    "sync"
    "time"
)

func worker(ctx context.Context, id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for i := 0; i < 5; i++ {
        select {
        case <-ctx.Done():
            return
        default:
            time.Sleep(100 * time.Millisecond)
            // 模拟工作
        }
    }
}

func main() {
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    // 启动追踪
    err = trace.Start(f)
    if err != nil {
        panic(err)
    }
    defer trace.Stop()

    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go worker(ctx, i, &wg)
    }

    wg.Wait()
}
```

查看trace结果：
```bash
go tool trace trace.out
```

### benchstat工具

benchstat用于比较基准测试结果的统计差异。

```bash
# 安装benchstat
go install golang.org/x/perf/cmd/benchstat@latest

# 运行基准测试并保存结果
go test -bench=. -count=10 > old.txt
# 修改代码后再次运行
go test -bench=. -count=10 > new.txt

# 比较两次结果
benchstat old.txt new.txt
```

### 内存分析

```go
package main

import (
    "runtime"
    "fmt"
)

func printMemStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    fmt.Printf("Alloc = %d KB", bToKb(m.Alloc))
    fmt.Printf(", TotalAlloc = %d KB", bToKb(m.TotalAlloc))
    fmt.Printf(", Sys = %d KB", bToKb(m.Sys))
    fmt.Printf(", NumGC = %v\n", m.NumGC)
}

func bToKb(b uint64) uint64 {
    return b / 1024
}

func main() {
    printMemStats()
    
    // 创建大量对象
    data := make([][]int, 1000)
    for i := range data {
        data[i] = make([]int, 1000)
    }
    
    printMemStats()
    
    // 强制GC
    runtime.GC()
    printMemStats()
}
```

### 竞态检测

使用`-race`标志检测数据竞争：

```go
package main

import (
    "sync"
    "time"
)

func main() {
    var data int
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    // 启动两个goroutine同时访问共享变量
    go func() {
        defer wg.Done()
        for i := 0; i < 1000; i++ {
            data++ // 数据竞争！
        }
    }()
    
    go func() {
        defer wg.Done()
        for i := 0; i < 1000; i++ {
            data++ // 数据竞争！
        }
    }()
    
    wg.Wait()
}
```

运行竞态检测：
```bash
go run -race main.go
```

### 基准测试工具

```go
package main

import (
    "testing"
    "strings"
)

// 基本基准测试
func BenchmarkStringsJoin(b *testing.B) {
    s := []string{"hello", "world", "go", "benchmark"}
    
    for i := 0; i < b.N; i++ {
        _ = strings.Join(s, " ")
    }
}

// 带有初始化的基准测试
func BenchmarkWithSetup(b *testing.B) {
    // 初始化工作
    data := make([]int, 1000)
    for i := range data {
        data[i] = i
    }
    
    b.ResetTimer() // 重置计时器
    
    for i := 0; i < b.N; i++ {
        // 测试代码
        _ = len(data)
    }
}

// 并发基准测试
func BenchmarkParallel(b *testing.B) {
    data := make([]int, 1000)
    
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            _ = len(data)
        }
    })
}
```

运行基准测试：
```bash
go test -bench=.
go test -bench=. -benchmem  # 显示内存分配
go test -bench=. -cpuprofile=cpu.prof  # 生成CPU分析文件
```