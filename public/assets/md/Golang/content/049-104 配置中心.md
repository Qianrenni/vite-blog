## 10.4 配置中心

### 配置中心概念

配置中心是微服务架构中的重要组件，用于集中管理应用程序的配置信息。它解决了传统配置管理中的诸多问题，如配置分散、更新困难、安全性不足等。

```go
// 配置中心核心概念和接口定义
package config

import (
    "context"
    "encoding/json"
    "fmt"
    "sync"
    "time"
)

// 配置项结构
type ConfigItem struct {
    Key         string                 `json:"key"`
    Value       interface{}            `json:"value"`
    Description string                 `json:"description,omitempty"`
    Version     int64                  `json:"version"`
    CreatedAt   time.Time              `json:"created_at"`
    UpdatedAt   time.Time              `json:"updated_at"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// 配置变更事件
type ConfigChangeEvent struct {
    Key       string      `json:"key"`
    OldValue  interface{} `json:"old_value"`
    NewValue  interface{} `json:"new_value"`
    EventType string      `json:"event_type"` // CREATE, UPDATE, DELETE
    Timestamp time.Time   `json:"timestamp"`
}

// 配置监听器接口
type ConfigListener interface {
    OnChange(event *ConfigChangeEvent)
}

// 配置中心接口
type ConfigCenter interface {
    // 获取配置
    Get(ctx context.Context, key string) (*ConfigItem, error)
    
    // 设置配置
    Set(ctx context.Context, key string, value interface{}) error
    
    // 删除配置
    Delete(ctx context.Context, key string) error
    
    // 批量获取配置
    GetBatch(ctx context.Context, keys []string) (map[string]*ConfigItem, error)
    
    // 获取前缀匹配的配置
    GetByPrefix(ctx context.Context, prefix string) (map[string]*ConfigItem, error)
    
    // 监听配置变化
    Watch(ctx context.Context, key string, listener ConfigListener) error
    
    // 监听前缀匹配的配置变化
    WatchPrefix(ctx context.Context, prefix string, listener ConfigListener) error
    
    // 导出所有配置
    Export(ctx context.Context) (map[string]*ConfigItem, error)
    
    // 导入配置
    Import(ctx context.Context, configs map[string]*ConfigItem) error
}

// 配置客户端接口
type ConfigClient interface {
    // 获取配置值
    GetConfig(key string, defaultValue interface{}) interface{}
    
    // 获取字符串配置
    GetString(key string, defaultValue string) string
    
    // 获取整数配置
    GetInt(key string, defaultValue int) int
    
    // 获取布尔配置
    GetBool(key string, defaultValue bool) bool
    
    // 获取浮点数配置
    GetFloat64(key string, defaultValue float64) float64
    
    // 监听配置变化
    Watch(key string, callback func(interface{}))
    
    // 监听多个配置变化
    WatchMultiple(keys []string, callback func(map[string]interface{}))
    
    // 关闭客户端
    Close() error
}

// 配置管理器
type ConfigManager struct {
    configCenter ConfigCenter
    cache        map[string]*ConfigItem
    listeners    map[string][]ConfigListener
    mutex        sync.RWMutex
    cacheTTL     time.Duration
}

func NewConfigManager(configCenter ConfigCenter, cacheTTL time.Duration) *ConfigManager {
    return &ConfigManager{
        configCenter: configCenter,
        cache:        make(map[string]*ConfigItem),
        listeners:    make(map[string][]ConfigListener),
        cacheTTL:     cacheTTL,
    }
}

func (cm *ConfigManager) Get(ctx context.Context, key string) (*ConfigItem, error) {
    // 先从缓存获取
    if item := cm.getCached(key); item != nil {
        return item, nil
    }
    
    // 从配置中心获取
    item, err := cm.configCenter.Get(ctx, key)
    if err != nil {
        return nil, err
    }
    
    // 缓存结果
    cm.setCache(key, item)
    
    return item, nil
}

func (cm *ConfigManager) Set(ctx context.Context, key string, value interface{}) error {
    oldItem, _ := cm.configCenter.Get(ctx, key)
    
    // 设置配置
    err := cm.configCenter.Set(ctx, key, value)
    if err != nil {
        return err
    }
    
    // 清除缓存
    cm.clearCache(key)
    
    // 触发变更事件
    cm.notifyListeners(&ConfigChangeEvent{
        Key:       key,
        OldValue:  getValue(oldItem),
        NewValue:  value,
        EventType: "UPDATE",
        Timestamp: time.Now(),
    })
    
    return nil
}

func (cm *ConfigManager) Delete(ctx context.Context, key string) error {
    oldItem, _ := cm.configCenter.Get(ctx, key)
    
    // 删除配置
    err := cm.configCenter.Delete(ctx, key)
    if err != nil {
        return err
    }
    
    // 清除缓存
    cm.clearCache(key)
    
    // 触发删除事件
    cm.notifyListeners(&ConfigChangeEvent{
        Key:       key,
        OldValue:  getValue(oldItem),
        NewValue:  nil,
        EventType: "DELETE",
        Timestamp: time.Now(),
    })
    
    return nil
}

func (cm *ConfigManager) Watch(ctx context.Context, key string, listener ConfigListener) error {
    cm.mutex.Lock()
    cm.listeners[key] = append(cm.listeners[key], listener)
    cm.mutex.Unlock()
    
    return cm.configCenter.Watch(ctx, key, cm)
}

func (cm *ConfigManager) OnChange(event *ConfigChangeEvent) {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    if listeners, exists := cm.listeners[event.Key]; exists {
        for _, listener := range listeners {
            go listener.OnChange(event)
        }
    }
}

func (cm *ConfigManager) getCached(key string) *ConfigItem {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    if item, exists := cm.cache[key]; exists {
        // 检查缓存是否过期
        if time.Since(item.UpdatedAt) < cm.cacheTTL {
            return item
        }
    }
    
    return nil
}

func (cm *ConfigManager) setCache(key string, item *ConfigItem) {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    cm.cache[key] = item
}

func (cm *ConfigManager) clearCache(key string) {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    delete(cm.cache, key)
}

func (cm *ConfigManager) notifyListeners(event *ConfigChangeEvent) {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    if listeners, exists := cm.listeners[event.Key]; exists {
        for _, listener := range listeners {
            go listener.OnChange(event)
        }
    }
}

func getValue(item *ConfigItem) interface{} {
    if item == nil {
        return nil
    }
    return item.Value
}

// 配置客户端实现
type ConfigClientImpl struct {
    configManager *ConfigManager
    localCache    map[string]interface{}
    watchers      map[string][]func(interface{})
    mutex         sync.RWMutex
}

func NewConfigClient(configManager *ConfigManager) *ConfigClientImpl {
    client := &ConfigClientImpl{
        configManager: configManager,
        localCache:    make(map[string]interface{}),
        watchers:      make(map[string][]func(interface{})),
    }
    
    return client
}

func (cc *ConfigClientImpl) GetConfig(key string, defaultValue interface{}) interface{} {
    ctx := context.Background()
    
    item, err := cc.configManager.Get(ctx, key)
    if err != nil {
        return defaultValue
    }
    
    cc.mutex.Lock()
    cc.localCache[key] = item.Value
    cc.mutex.Unlock()
    
    return item.Value
}

func (cc *ConfigClientImpl) GetString(key string, defaultValue string) string {
    value := cc.GetConfig(key, defaultValue)
    if str, ok := value.(string); ok {
        return str
    }
    return defaultValue
}

func (cc *ConfigClientImpl) GetInt(key string, defaultValue int) int {
    value := cc.GetConfig(key, defaultValue)
    if num, ok := value.(float64); ok {
        return int(num)
    }
    if num, ok := value.(int); ok {
        return num
    }
    return defaultValue
}

func (cc *ConfigClientImpl) GetBool(key string, defaultValue bool) bool {
    value := cc.GetConfig(key, defaultValue)
    if b, ok := value.(bool); ok {
        return b
    }
    return defaultValue
}

func (cc *ConfigClientImpl) GetFloat64(key string, defaultValue float64) float64 {
    value := cc.GetConfig(key, defaultValue)
    if num, ok := value.(float64); ok {
        return num
    }
    return defaultValue
}

func (cc *ConfigClientImpl) Watch(key string, callback func(interface{})) {
    cc.mutex.Lock()
    cc.watchers[key] = append(cc.watchers[key], callback)
    cc.mutex.Unlock()
    
    // 启动监听
    go cc.startWatching(key)
}

func (cc *ConfigClientImpl) startWatching(key string) {
    ctx := context.Background()
    
    listener := &configChangeListener{
        key:      key,
        callback: cc.handleConfigChange,
    }
    
    cc.configManager.Watch(ctx, key, listener)
}

func (cc *ConfigClientImpl) handleConfigChange(key string, value interface{}) {
    cc.mutex.RLock()
    defer cc.mutex.RUnlock()
    
    if callbacks, exists := cc.watchers[key]; exists {
        for _, callback := range callbacks {
            go callback(value)
        }
    }
}

type configChangeListener struct {
    key      string
    callback func(string, interface{})
}

func (ccl *configChangeListener) OnChange(event *ConfigChangeEvent) {
    ccl.callback(event.Key, event.NewValue)
}

// 配置验证器
type ConfigValidator struct {
    rules map[string]ValidationRule
}

type ValidationRule struct {
    Type        string      `json:"type"`
    Required    bool        `json:"required"`
    Min         interface{} `json:"min,omitempty"`
    Max         interface{} `json:"max,omitempty"`
    Pattern     string      `json:"pattern,omitempty"`
    Description string      `json:"description,omitempty"`
}

func NewConfigValidator() *ConfigValidator {
    return &ConfigValidator{
        rules: make(map[string]ValidationRule),
    }
}

func (cv *ConfigValidator) AddRule(key string, rule ValidationRule) {
    cv.rules[key] = rule
}

func (cv *ConfigValidator) Validate(key string, value interface{}) error {
    rule, exists := cv.rules[key]
    if !exists {
        return nil // 没有验证规则
    }
    
    // 必填验证
    if rule.Required && value == nil {
        return fmt.Errorf("config %s is required", key)
    }
    
    if value == nil {
        return nil
    }
    
    // 类型验证
    switch rule.Type {
    case "string":
        if _, ok := value.(string); !ok {
            return fmt.Errorf("config %s must be string", key)
        }
    case "int":
        if _, ok := value.(int); !ok {
            if _, ok := value.(float64); !ok {
                return fmt.Errorf("config %s must be integer", key)
            }
        }
    case "bool":
        if _, ok := value.(bool); !ok {
            return fmt.Errorf("config %s must be boolean", key)
        }
    case "float":
        if _, ok := value.(float64); !ok {
            return fmt.Errorf("config %s must be float", key)
        }
    }
    
    // 范围验证
    if rule.Min != nil || rule.Max != nil {
        if err := cv.validateRange(key, value, rule.Min, rule.Max); err != nil {
            return err
        }
    }
    
    // 正则表达式验证
    if rule.Pattern != "" {
        if err := cv.validatePattern(key, value, rule.Pattern); err != nil {
            return err
        }
    }
    
    return nil
}

func (cv *ConfigValidator) validateRange(key string, value interface{}, min, max interface{}) error {
    switch v := value.(type) {
    case int:
        if min != nil {
            if minVal, ok := min.(int); ok && v < minVal {
                return fmt.Errorf("config %s value %d is less than minimum %d", key, v, minVal)
            }
        }
        if max != nil {
            if maxVal, ok := max.(int); ok && v > maxVal {
                return fmt.Errorf("config %s value %d is greater than maximum %d", key, v, maxVal)
            }
        }
    case float64:
        if min != nil {
            if minVal, ok := min.(float64); ok && v < minVal {
                return fmt.Errorf("config %s value %f is less than minimum %f", key, v, minVal)
            }
        }
        if max != nil {
            if maxVal, ok := max.(float64); ok && v > maxVal {
                return fmt.Errorf("config %s value %f is greater than maximum %f", key, v, maxVal)
            }
        }
    }
    return nil
}

func (cv *ConfigValidator) validatePattern(key string, value interface{}, pattern string) error {
    if str, ok := value.(string); ok {
        matched, err := regexp.MatchString(pattern, str)
        if err != nil {
            return fmt.Errorf("invalid pattern for config %s: %v", key, err)
        }
        if !matched {
            return fmt.Errorf("config %s value %s does not match pattern %s", key, str, pattern)
        }
    }
    return nil
}

// 配置快照管理
type ConfigSnapshot struct {
    ID        string                           `json:"id"`
    Name      string                           `json:"name"`
    Configs   map[string]*ConfigItem           `json:"configs"`
    CreatedAt time.Time                        `json:"created_at"`
    CreatedBy string                           `json:"created_by"`
    Metadata  map[string]interface{}           `json:"metadata,omitempty"`
}

type SnapshotManager struct {
    configCenter ConfigCenter
    snapshots    map[string]*ConfigSnapshot
    mutex        sync.RWMutex
}

func NewSnapshotManager(configCenter ConfigCenter) *SnapshotManager {
    return &SnapshotManager{
        configCenter: configCenter,
        snapshots:    make(map[string]*ConfigSnapshot),
    }
}

func (sm *SnapshotManager) CreateSnapshot(ctx context.Context, name, createdBy string) (*ConfigSnapshot, error) {
    configs, err := sm.configCenter.Export(ctx)
    if err != nil {
        return nil, err
    }
    
    snapshot := &ConfigSnapshot{
        ID:        generateSnapshotID(),
        Name:      name,
        Configs:   configs,
        CreatedAt: time.Now(),
        CreatedBy: createdBy,
        Metadata:  make(map[string]interface{}),
    }
    
    sm.mutex.Lock()
    sm.snapshots[snapshot.ID] = snapshot
    sm.mutex.Unlock()
    
    return snapshot, nil
}

func (sm *SnapshotManager) GetSnapshot(id string) (*ConfigSnapshot, error) {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    if snapshot, exists := sm.snapshots[id]; exists {
        return snapshot, nil
    }
    
    return nil, fmt.Errorf("snapshot %s not found", id)
}

func (sm *SnapshotManager) ListSnapshots() []*ConfigSnapshot {
    sm.mutex.RLock()
    defer sm.mutex.RUnlock()
    
    var result []*ConfigSnapshot
    for _, snapshot := range sm.snapshots {
        result = append(result, snapshot)
    }
    
    return result
}

func (sm *SnapshotManager) RestoreSnapshot(ctx context.Context, id string) error {
    snapshot, err := sm.GetSnapshot(id)
    if err != nil {
        return err
    }
    
    return sm.configCenter.Import(ctx, snapshot.Configs)
}

func generateSnapshotID() string {
    return fmt.Sprintf("snapshot_%d", time.Now().UnixNano())
}
```

### Consul配置管理

```go
// Consul配置管理实现
package consul

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "path"
    "strings"
    "time"

    consul "github.com/hashicorp/consul/api"
    "your-project/config"
)

// Consul配置中心实现
type ConsulConfigCenter struct {
    client   *consul.Client
    config   *consul.Config
    rootPath string
    validator *config.ConfigValidator
}

func NewConsulConfigCenter(address, rootPath string) (*ConsulConfigCenter, error) {
    config := consul.DefaultConfig()
    config.Address = address
    
    client, err := consul.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConsulConfigCenter{
        client:    client,
        config:    config,
        rootPath:  rootPath,
        validator: config.NewConfigValidator(),
    }, nil
}

func (ccc *ConsulConfigCenter) Get(ctx context.Context, key string) (*config.ConfigItem, error) {
    configPath := path.Join(ccc.rootPath, key)
    
    kvPair, _, err := ccc.client.KV().Get(configPath, nil)
    if err != nil {
        return nil, err
    }
    
    if kvPair == nil {
        return nil, fmt.Errorf("config %s not found", key)
    }
    
    var item config.ConfigItem
    if err := json.Unmarshal(kvPair.Value, &item); err != nil {
        // 如果不是JSON格式，尝试作为字符串处理
        item = config.ConfigItem{
            Key:       key,
            Value:     string(kvPair.Value),
            Version:   kvPair.ModifyIndex,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        }
    }
    
    return &item, nil
}

func (ccc *ConsulConfigCenter) Set(ctx context.Context, key string, value interface{}) error {
    // 验证配置
    if err := ccc.validator.Validate(key, value); err != nil {
        return fmt.Errorf("config validation failed: %v", err)
    }
    
    configPath := path.Join(ccc.rootPath, key)
    
    // 获取当前配置用于比较
    oldItem, _ := ccc.Get(ctx, key)
    
    item := &config.ConfigItem{
        Key:       key,
        Value:     value,
        Version:   time.Now().UnixNano(),
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
    
    if oldItem != nil {
        item.CreatedAt = oldItem.CreatedAt
    }
    
    data, err := json.Marshal(item)
    if err != nil {
        return err
    }
    
    kvPair := &consul.KVPair{
        Key:   configPath,
        Value: data,
    }
    
    _, err = ccc.client.KV().Put(kvPair, nil)
    return err
}

func (ccc *ConsulConfigCenter) Delete(ctx context.Context, key string) error {
    configPath := path.Join(ccc.rootPath, key)
    _, err := ccc.client.KV().Delete(configPath, nil)
    return err
}

func (ccc *ConsulConfigCenter) GetBatch(ctx context.Context, keys []string) (map[string]*config.ConfigItem, error) {
    result := make(map[string]*config.ConfigItem)
    
    for _, key := range keys {
        item, err := ccc.Get(ctx, key)
        if err != nil {
            log.Printf("Failed to get config %s: %v", key, err)
            continue
        }
        result[key] = item
    }
    
    return result, nil
}

func (ccc *ConsulConfigCenter) GetByPrefix(ctx context.Context, prefix string) (map[string]*config.ConfigItem, error) {
    configPath := path.Join(ccc.rootPath, prefix)
    
    kvPairs, _, err := ccc.client.KV().List(configPath, nil)
    if err != nil {
        return nil, err
    }
    
    result := make(map[string]*config.ConfigItem)
    for _, kvPair := range kvPairs {
        // 移除根路径前缀
        key := strings.TrimPrefix(kvPair.Key, ccc.rootPath+"/")
        
        var item config.ConfigItem
        if err := json.Unmarshal(kvPair.Value, &item); err != nil {
            // 处理非JSON格式的配置
            item = config.ConfigItem{
                Key:       key,
                Value:     string(kvPair.Value),
                Version:   kvPair.ModifyIndex,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
            }
        }
        
        result[key] = &item
    }
    
    return result, nil
}

func (ccc *ConsulConfigCenter) Watch(ctx context.Context, key string, listener config.ConfigListener) error {
    configPath := path.Join(ccc.rootPath, key)
    
    go func() {
        var lastIndex uint64
        
        for {
            select {
            case <-ctx.Done():
                return
            default:
                kvPair, meta, err := ccc.client.KV().Get(configPath, &consul.QueryOptions{
                    WaitIndex: lastIndex,
                })
                if err != nil {
                    log.Printf("Failed to watch config %s: %v", key, err)
                    time.Sleep(5 * time.Second)
                    continue
                }
                
                if meta.LastIndex != lastIndex {
                    lastIndex = meta.LastIndex
                    
                    if kvPair != nil {
                        var item config.ConfigItem
                        if err := json.Unmarshal(kvPair.Value, &item); err != nil {
                            item = config.ConfigItem{
                                Key:       key,
                                Value:     string(kvPair.Value),
                                Version:   kvPair.ModifyIndex,
                                UpdatedAt: time.Now(),
                            }
                        }
                        
                        listener.OnChange(&config.ConfigChangeEvent{
                            Key:       key,
                            NewValue:  item.Value,
                            EventType: "UPDATE",
                            Timestamp: time.Now(),
                        })
                    } else {
                        listener.OnChange(&config.ConfigChangeEvent{
                            Key:       key,
                            EventType: "DELETE",
                            Timestamp: time.Now(),
                        })
                    }
                }
            }
        }
    }()
    
    return nil
}

func (ccc *ConsulConfigCenter) WatchPrefix(ctx context.Context, prefix string, listener config.ConfigListener) error {
    configPath := path.Join(ccc.rootPath, prefix)
    
    go func() {
        var lastIndex uint64
        
        for {
            select {
            case <-ctx.Done():
                return
            default:
                kvPairs, meta, err := ccc.client.KV().List(configPath, &consul.QueryOptions{
                    WaitIndex: lastIndex,
                })
                if err != nil {
                    log.Printf("Failed to watch prefix %s: %v", prefix, err)
                    time.Sleep(5 * time.Second)
                    continue
                }
                
                if meta.LastIndex != lastIndex {
                    lastIndex = meta.LastIndex
                    
                    for _, kvPair := range kvPairs {
                        key := strings.TrimPrefix(kvPair.Key, ccc.rootPath+"/")
                        
                        var item config.ConfigItem
                        if err := json.Unmarshal(kvPair.Value, &item); err != nil {
                            item = config.ConfigItem{
                                Key:       key,
                                Value:     string(kvPair.Value),
                                Version:   kvPair.ModifyIndex,
                                UpdatedAt: time.Now(),
                            }
                        }
                        
                        listener.OnChange(&config.ConfigChangeEvent{
                            Key:       key,
                            NewValue:  item.Value,
                            EventType: "UPDATE",
                            Timestamp: time.Now(),
                        })
                    }
                }
            }
        }
    }()
    
    return nil
}

func (ccc *ConsulConfigCenter) Export(ctx context.Context) (map[string]*config.ConfigItem, error) {
    return ccc.GetByPrefix(ctx, "")
}

func (ccc *ConsulConfigCenter) Import(ctx context.Context, configs map[string]*config.ConfigItem) error {
    for key, item := range configs {
        if err := ccc.Set(ctx, key, item.Value); err != nil {
            return fmt.Errorf("failed to import config %s: %v", key, err)
        }
    }
    return nil
}

// Consul配置客户端
type ConsulConfigClient struct {
    center *ConsulConfigCenter
    client *config.ConfigClientImpl
}

func NewConsulConfigClient(address, rootPath string) (*ConsulConfigClient, error) {
    center, err := NewConsulConfigCenter(address, rootPath)
    if err != nil {
        return nil, err
    }
    
    manager := config.NewConfigManager(center, 30*time.Second)
    client := config.NewConfigClient(manager)
    
    return &ConsulConfigClient{
        center: center,
        client: client,
    }, nil
}

func (ccc *ConsulConfigClient) GetConfig(key string, defaultValue interface{}) interface{} {
    return ccc.client.GetConfig(key, defaultValue)
}

func (ccc *ConsulConfigClient) GetString(key string, defaultValue string) string {
    return ccc.client.GetString(key, defaultValue)
}

func (ccc *ConsulConfigClient) GetInt(key string, defaultValue int) int {
    return ccc.client.GetInt(key, defaultValue)
}

func (ccc *ConsulConfigClient) GetBool(key string, defaultValue bool) bool {
    return ccc.client.GetBool(key, defaultValue)
}

func (ccc *ConsulConfigClient) GetFloat64(key string, defaultValue float64) float64 {
    return ccc.client.GetFloat64(key, defaultValue)
}

func (ccc *ConsulConfigClient) Watch(key string, callback func(interface{})) {
    ccc.client.Watch(key, callback)
}

func (ccc *ConsulConfigClient) Close() error {
    return nil
}

// 使用示例
func main() {
    // 创建Consul配置客户端
    client, err := NewConsulConfigClient("localhost:8500", "/config/myapp")
    if err != nil {
        log.Fatalf("Failed to create Consul config client: %v", err)
    }
    defer client.Close()
    
    // 设置配置
    ctx := context.Background()
    center := client.center
    
    // 设置一些配置项
    center.Set(ctx, "database.host", "localhost")
    center.Set(ctx, "database.port", 5432)
    center.Set(ctx, "cache.ttl", 300)
    center.Set(ctx, "feature.enabled", true)
    center.Set(ctx, "app.name", "MyApplication")
    
    // 获取配置
    dbHost := client.GetString("database.host", "localhost")
    dbPort := client.GetInt("database.port", 3306)
    cacheTTL := client.GetInt("cache.ttl", 60)
    featureEnabled := client.GetBool("feature.enabled", false)
    
    log.Printf("Database: %s:%d", dbHost, dbPort)
    log.Printf("Cache TTL: %d seconds", cacheTTL)
    log.Printf("Feature enabled: %t", featureEnabled)
    
    // 监听配置变化
    client.Watch("database.host", func(value interface{}) {
        log.Printf("Database host changed to: %v", value)
    })
    
    client.Watch("feature.enabled", func(value interface{}) {
        log.Printf("Feature enabled changed to: %v", value)
    })
    
    // 保持程序运行
    select {}
}
```

### etcd配置管理

```go
// etcd配置管理实现
package etcd

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "path"
    "strings"
    "time"

    "go.etcd.io/etcd/clientv3"
    "go.etcd.io/etcd/mvcc/mvccpb"
    "your-project/config"
)

// etcd配置中心实现
type EtcdConfigCenter struct {
    client    *clientv3.Client
    config    clientv3.Config
    rootPath  string
    validator *config.ConfigValidator
}

func NewEtcdConfigCenter(endpoints []string, rootPath string) (*EtcdConfigCenter, error) {
    config := clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    }
    
    client, err := clientv3.New(config)
    if err != nil {
        return nil, err
    }
    
    return &EtcdConfigCenter{
        client:    client,
        config:    config,
        rootPath:  rootPath,
        validator: config.NewConfigValidator(),
    }, nil
}

func (ecc *EtcdConfigCenter) Get(ctx context.Context, key string) (*config.ConfigItem, error) {
    configPath := path.Join(ecc.rootPath, key)
    
    resp, err := ecc.client.Get(ctx, configPath)
    if err != nil {
        return nil, err
    }
    
    if len(resp.Kvs) == 0 {
        return nil, fmt.Errorf("config %s not found", key)
    }
    
    kv := resp.Kvs[0]
    
    var item config.ConfigItem
    if err := json.Unmarshal(kv.Value, &item); err != nil {
        // 如果不是JSON格式，尝试作为字符串处理
        item = config.ConfigItem{
            Key:       key,
            Value:     string(kv.Value),
            Version:   kv.ModRevision,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        }
    } else {
        item.Version = kv.ModRevision
    }
    
    return &item, nil
}

func (ecc *EtcdConfigCenter) Set(ctx context.Context, key string, value interface{}) error {
    // 验证配置
    if err := ecc.validator.Validate(key, value); err != nil {
        return fmt.Errorf("config validation failed: %v", err)
    }
    
    configPath := path.Join(ecc.rootPath, key)
    
    // 获取当前配置用于比较
    oldItem, _ := ecc.Get(ctx, key)
    
    item := &config.ConfigItem{
        Key:       key,
        Value:     value,
        Version:   time.Now().UnixNano(),
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
    
    if oldItem != nil {
        item.CreatedAt = oldItem.CreatedAt
    }
    
    data, err := json.Marshal(item)
    if err != nil {
        return err
    }
    
    _, err = ecc.client.Put(ctx, configPath, string(data))
    return err
}

func (ecc *EtcdConfigCenter) Delete(ctx context.Context, key string) error {
    configPath := path.Join(ecc.rootPath, key)
    _, err := ecc.client.Delete(ctx, configPath)
    return err
}

func (ecc *EtcdConfigCenter) GetBatch(ctx context.Context, keys []string) (map[string]*config.ConfigItem, error) {
    result := make(map[string]*config.ConfigItem)
    
    var ops []clientv3.Op
    for _, key := range keys {
        configPath := path.Join(ecc.rootPath, key)
        ops = append(ops, clientv3.OpGet(configPath))
    }
    
    resp, err := ecc.client.Txn(ctx).Then(ops...).Commit()
    if err != nil {
        return nil, err
    }
    
    for i, response := range resp.Responses {
        if response.GetResponseRange().Kvs != nil {
            kv := response.GetResponseRange().Kvs[0]
            key := keys[i]
            
            var item config.ConfigItem
            if err := json.Unmarshal(kv.Value, &item); err != nil {
                item = config.ConfigItem{
                    Key:       key,
                    Value:     string(kv.Value),
                    Version:   kv.ModRevision,
                    UpdatedAt: time.Now(),
                }
            } else {
                item.Version = kv.ModRevision
            }
            
            result[key] = &item
        }
    }
    
    return result, nil
}

func (ecc *EtcdConfigCenter) GetByPrefix(ctx context.Context, prefix string) (map[string]*config.ConfigItem, error) {
    configPath := path.Join(ecc.rootPath, prefix)
    
    resp, err := ecc.client.Get(ctx, configPath, clientv3.WithPrefix())
    if err != nil {
        return nil, err
    }
    
    result := make(map[string]*config.ConfigItem)
    for _, kv := range resp.Kvs {
        // 移除根路径前缀
        key := strings.TrimPrefix(string(kv.Key), ecc.rootPath+"/")
        
        var item config.ConfigItem
        if err := json.Unmarshal(kv.Value, &item); err != nil {
            // 处理非JSON格式的配置
            item = config.ConfigItem{
                Key:       key,
                Value:     string(kv.Value),
                Version:   kv.ModRevision,
                UpdatedAt: time.Now(),
            }
        } else {
            item.Version = kv.ModRevision
        }
        
        result[key] = &item
    }
    
    return result, nil
}

func (ecc *EtcdConfigCenter) Watch(ctx context.Context, key string, listener config.ConfigListener) error {
    configPath := path.Join(ecc.rootPath, key)
    
    watchChan := ecc.client.Watch(ctx, configPath)
    
    go func() {
        for watchResp := range watchChan {
            for _, event := range watchResp.Events {
                switch event.Type {
                case mvccpb.PUT:
                    var item config.ConfigItem
                    if err := json.Unmarshal(event.Kv.Value, &item); err != nil {
                        item = config.ConfigItem{
                            Key:       key,
                            Value:     string(event.Kv.Value),
                            Version:   event.Kv.ModRevision,
                            UpdatedAt: time.Now(),
                        }
                    }
                    
                    listener.OnChange(&config.ConfigChangeEvent{
                        Key:       key,
                        NewValue:  item.Value,
                        EventType: "UPDATE",
                        Timestamp: time.Now(),
                    })
                    
                case mvccpb.DELETE:
                    listener.OnChange(&config.ConfigChangeEvent{
                        Key:       key,
                        EventType: "DELETE",
                        Timestamp: time.Now(),
                    })
                }
            }
        }
    }()
    
    return nil
}

func (ecc *EtcdConfigCenter) WatchPrefix(ctx context.Context, prefix string, listener config.ConfigListener) error {
    configPath := path.Join(ecc.rootPath, prefix)
    
    watchChan := ecc.client.Watch(ctx, configPath, clientv3.WithPrefix())
    
    go func() {
        for watchResp := range watchChan {
            for _, event := range watchResp.Events {
                key := strings.TrimPrefix(string(event.Kv.Key), ecc.rootPath+"/")
                
                switch event.Type {
                case mvccpb.PUT:
                    var item config.ConfigItem
                    if err := json.Unmarshal(event.Kv.Value, &item); err != nil {
                        item = config.ConfigItem{
                            Key:       key,
                            Value:     string(event.Kv.Value),
                            Version:   event.Kv.ModRevision,
                            UpdatedAt: time.Now(),
                        }
                    }
                    
                    listener.OnChange(&config.ConfigChangeEvent{
                        Key:       key,
                        NewValue:  item.Value,
                        EventType: "UPDATE",
                        Timestamp: time.Now(),
                    })
                    
                case mvccpb.DELETE:
                    listener.OnChange(&config.ConfigChangeEvent{
                        Key:       key,
                        EventType: "DELETE",
                        Timestamp: time.Now(),
                    })
                }
            }
        }
    }()
    
    return nil
}

func (ecc *EtcdConfigCenter) Export(ctx context.Context) (map[string]*config.ConfigItem, error) {
    return ecc.GetByPrefix(ctx, "")
}

func (ecc *EtcdConfigCenter) Import(ctx context.Context, configs map[string]*config.ConfigItem) error {
    for key, item := range configs {
        if err := ecc.Set(ctx, key, item.Value); err != nil {
            return fmt.Errorf("failed to import config %s: %v", key, err)
        }
    }
    return nil
}

// etcd配置客户端
type EtcdConfigClient struct {
    center *EtcdConfigCenter
    client *config.ConfigClientImpl
}

func NewEtcdConfigClient(endpoints []string, rootPath string) (*EtcdConfigClient, error) {
    center, err := NewEtcdConfigCenter(endpoints, rootPath)
    if err != nil {
        return nil, err
    }
    
    manager := config.NewConfigManager(center, 30*time.Second)
    clientImpl := config.NewConfigClient(manager)
    
    return &EtcdConfigClient{
        center: center,
        client: clientImpl,
    }, nil
}

func (ecc *EtcdConfigClient) GetConfig(key string, defaultValue interface{}) interface{} {
    return ecc.client.GetConfig(key, defaultValue)
}

func (ecc *EtcdConfigClient) GetString(key string, defaultValue string) string {
    return ecc.client.GetString(key, defaultValue)
}

func (ecc *EtcdConfigClient) GetInt(key string, defaultValue int) int {
    return ecc.client.GetInt(key, defaultValue)
}

func (ecc *EtcdConfigClient) GetBool(key string, defaultValue bool) bool {
    return ecc.client.GetBool(key, defaultValue)
}

func (ecc *EtcdConfigClient) GetFloat64(key string, defaultValue float64) float64 {
    return ecc.client.GetFloat64(key, defaultValue)
}

func (ecc *EtcdConfigClient) Watch(key string, callback func(interface{})) {
    ecc.client.Watch(key, callback)
}

func (ecc *EtcdConfigClient) WatchMultiple(keys []string, callback func(map[string]interface{})) {
    go func() {
        for _, key := range keys {
            ecc.client.Watch(key, func(value interface{}) {
                // 这里需要更复杂的逻辑来收集多个配置的变化
                // 简化处理
                result := make(map[string]interface{})
                result[key] = value
                callback(result)
            })
        }
    }()
}

func (ecc *EtcdConfigClient) Close() error {
    return ecc.center.client.Close()
}

// 配置迁移工具
type ConfigMigration struct {
    source ConfigCenter
    target ConfigCenter
}

func NewConfigMigration(source, target ConfigCenter) *ConfigMigration {
    return &ConfigMigration{
        source: source,
        target: target,
    }
}

func (cm *ConfigMigration) Migrate(ctx context.Context) error {
    configs, err := cm.source.Export(ctx)
    if err != nil {
        return fmt.Errorf("failed to export from source: %v", err)
    }
    
    return cm.target.Import(ctx, configs)
}

// 配置备份恢复
type ConfigBackup struct {
    center ConfigCenter
}

func NewConfigBackup(center ConfigCenter) *ConfigBackup {
    return &ConfigBackup{center: center}
}

func (cb *ConfigBackup) Backup(ctx context.Context, filename string) error {
    configs, err := cb.center.Export(ctx)
    if err != nil {
        return err
    }
    
    data, err := json.MarshalIndent(configs, "", "  ")
    if err != nil {
        return err
    }
    
    return ioutil.WriteFile(filename, data, 0644)
}

func (cb *ConfigBackup) Restore(ctx context.Context, filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return err
    }
    
    var configs map[string]*config.ConfigItem
    if err := json.Unmarshal(data, &configs); err != nil {
        return err
    }
    
    return cb.center.Import(ctx, configs)
}

// 使用示例
func main() {
    // 创建etcd配置客户端
    client, err := NewEtcdConfigClient([]string{"localhost:2379"}, "/config/myapp")
    if err != nil {
        log.Fatalf("Failed to create etcd config client: %v", err)
    }
    defer client.Close()
    
    // 设置配置
    ctx := context.Background()
    center := client.center
    
    // 设置一些配置项
    center.Set(ctx, "database.host", "localhost")
    center.Set(ctx, "database.port", 5432)
    center.Set(ctx, "cache.ttl", 300)
    center.Set(ctx, "feature.enabled", true)
    center.Set(ctx, "app.name", "MyApplication")
    center.Set(ctx, "app.version", "1.0.0")
    
    // 获取配置
    dbHost := client.GetString("database.host", "localhost")
    dbPort := client.GetInt("database.port", 3306)
    cacheTTL := client.GetInt("cache.ttl", 60)
    featureEnabled := client.GetBool("feature.enabled", false)
    appName := client.GetString("app.name", "DefaultApp")
    appVersion := client.GetString("app.version", "0.0.0")
    
    log.Printf("Database: %s:%d", dbHost, dbPort)
    log.Printf("Cache TTL: %d seconds", cacheTTL)
    log.Printf("Feature enabled: %t", featureEnabled)
    log.Printf("App: %s v%s", appName, appVersion)
    
    // 监听配置变化
    client.Watch("database.host", func(value interface{}) {
        log.Printf("Database host changed to: %v", value)
    })
    
    client.Watch("feature.enabled", func(value interface{}) {
        log.Printf("Feature enabled changed to: %v", value)
    })
    
    // 批量获取配置
    batchKeys := []string{"database.host", "database.port", "cache.ttl"}
    batchConfigs, err := center.GetBatch(ctx, batchKeys)
    if err != nil {
        log.Printf("Failed to get batch configs: %v", err)
    } else {
        log.Printf("Batch configs: %+v", batchConfigs)
    }
    
    // 前缀匹配获取配置
    prefixConfigs, err := center.GetByPrefix(ctx, "database")
    if err != nil {
        log.Printf("Failed to get prefix configs: %v", err)
    } else {
        log.Printf("Database configs: %+v", prefixConfigs)
    }
    
    // 配置验证示例
    validator := config.NewConfigValidator()
    validator.AddRule("database.port", config.ValidationRule{
        Type:     "int",
        Required: true,
        Min:      1,
        Max:      65535,
        Description: "Database port must be between 1 and 65535",
    })
    
    validator.AddRule("cache.ttl", config.ValidationRule{
        Type:     "int",
        Required: true,
        Min:      1,
        Max:      86400,
        Description: "Cache TTL must be between 1 second and 1 day",
    })
    
    // 验证配置
    if err := validator.Validate("database.port", 5432); err != nil {
        log.Printf("Validation failed: %v", err)
    } else {
        log.Println("Configuration validation passed")
    }
    
    // 保持程序运行
    select {}
}
```

### 配置动态更新

```go
// 配置动态更新实现
package dynamic

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "reflect"
    "sync"
    "time"
    "your-project/config"
)

// 动态配置结构
type DynamicConfig struct {
    configCenter config.ConfigCenter
    configClient config.ConfigClient
    watchers     map[string][]ConfigWatcher
    mutex        sync.RWMutex
    updateQueue  chan *config.ConfigChangeEvent
    stopCh       chan struct{}
}

// 配置观察者接口
type ConfigWatcher interface {
    OnConfigUpdate(key string, value interface{})
    OnConfigDelete(key string)
}

// 配置观察者函数类型
type ConfigWatcherFunc func(key string, value interface{})

func (f ConfigWatcherFunc) OnConfigUpdate(key string, value interface{}) {
    f(key, value)
}

func (f ConfigWatcherFunc) OnConfigDelete(key string) {
    // 空实现
}

// 结构体配置绑定
type StructConfigBinder struct {
    target       interface{}
    fieldMapping map[string]string // configKey -> structField
    mutex        sync.RWMutex
}

func NewStructConfigBinder(target interface{}) *StructConfigBinder {
    return &StructConfigBinder{
        target:       target,
        fieldMapping: make(map[string]string),
    }
}

func (scb *StructConfigBinder) BindField(configKey, structField string) {
    scb.mutex.Lock()
    defer scb.mutex.Unlock()
    
    scb.fieldMapping[configKey] = structField
}

func (scb *StructConfigBinder) OnConfigUpdate(key string, value interface{}) {
    scb.mutex.RLock()
    defer scb.mutex.RUnlock()
    
    if fieldName, exists := scb.fieldMapping[key]; exists {
        scb.updateStructField(fieldName, value)
    }
}

func (scb *StructConfigBinder) OnConfigDelete(key string) {
    // 配置删除时的处理
}

func (scb *StructConfigBinder) updateStructField(fieldName string, value interface{}) {
    v := reflect.ValueOf(scb.target)
    if v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    
    if v.Kind() != reflect.Struct {
        return
    }
    
    field := v.FieldByName(fieldName)
    if !field.IsValid() || !field.CanSet() {
        return
    }
    
    // 类型转换
    if !field.Type().AssignableTo(reflect.TypeOf(value)) {
        convertedValue := scb.convertValue(value, field.Type())
        if convertedValue.IsValid() {
            field.Set(convertedValue)
        }
    } else {
        field.Set(reflect.ValueOf(value))
    }
    
    log.Printf("Updated struct field %s to %v", fieldName, value)
}

func (scb *StructConfigBinder) convertValue(value interface{}, targetType reflect.Type) reflect.Value {
    switch targetType.Kind() {
    case reflect.String:
        if str, ok := value.(string); ok {
            return reflect.ValueOf(str)
        }
    case reflect.Int, reflect.Int64:
        if num, ok := value.(float64); ok {
            return reflect.ValueOf(int(num)).Convert(targetType)
        }
        if num, ok := value.(int); ok {
            return reflect.ValueOf(num).Convert(targetType)
        }
    case reflect.Bool:
        if b, ok := value.(bool); ok {
            return reflect.ValueOf(b)
        }
    case reflect.Float64:
        if num, ok := value.(float64); ok {
            return reflect.ValueOf(num)
        }
    }
    
    return reflect.Value{}
}

// 配置热更新管理器
type HotReloadManager struct {
    dynamicConfig *DynamicConfig
    binders       map[string]*StructConfigBinder
    mutex         sync.RWMutex
}

func NewHotReloadManager(configCenter config.ConfigCenter) *HotReloadManager {
    dynamicConfig := &DynamicConfig{
        configCenter: configCenter,
        watchers:     make(map[string][]ConfigWatcher),
        updateQueue:  make(chan *config.ConfigChangeEvent, 100),
        stopCh:       make(chan struct{}),
    }
    
    manager := &HotReloadManager{
        dynamicConfig: dynamicConfig,
        binders:       make(map[string]*StructConfigBinder),
    }
    
    // 启动更新处理
    go manager.processUpdates()
    
    return manager
}

func (hrm *HotReloadManager) processUpdates() {
    for {
        select {
        case event := <-hrm.dynamicConfig.updateQueue:
            hrm.handleConfigEvent(event)
        case <-hrm.dynamicConfig.stopCh:
            return
        }
    }
}

func (hrm *HotReloadManager) handleConfigEvent(event *config.ConfigChangeEvent) {
    hrm.mutex.RLock()
    defer hrm.mutex.RUnlock()
    
    switch event.EventType {
    case "UPDATE":
        if watchers, exists := hrm.dynamicConfig.watchers[event.Key]; exists {
            for _, watcher := range watchers {
                watcher.OnConfigUpdate(event.Key, event.NewValue)
            }
        }
    case "DELETE":
        if watchers, exists := hrm.dynamicConfig.watchers[event.Key]; exists {
            for _, watcher := range watchers {
                watcher.OnConfigDelete(event.Key)
            }
        }
    }
}

func (hrm *HotReloadManager) Watch(key string, watcher ConfigWatcher) {
    hrm.mutex.Lock()
    defer hrm.mutex.Unlock()
    
    hrm.dynamicConfig.watchers[key] = append(hrm.dynamicConfig.watchers[key], watcher)
    
    // 启动监听
    go hrm.startWatching(key)
}

func (hrm *HotReloadManager) startWatching(key string) {
    ctx := context.Background()
    
    listener := &configChangeListener{
        key:      key,
        callback: hrm.handleEvent,
    }
    
    hrm.dynamicConfig.configCenter.Watch(ctx, key, listener)
}

func (hrm *HotReloadManager) handleEvent(event *config.ConfigChangeEvent) {
    select {
    case hrm.dynamicConfig.updateQueue <- event:
    default:
        log.Printf("Update queue is full, dropping event for key %s", event.Key)
    }
}

func (hrm *HotReloadManager) BindStruct(configKeys []string, binder *StructConfigBinder) {
    hrm.mutex.Lock()
    defer hrm.mutex.Unlock()
    
    for _, key := range configKeys {
        hrm.binders[key] = binder
        hrm.Watch(key, binder)
    }
}

type configChangeListener struct {
    key      string
    callback func(*config.ConfigChangeEvent)
}

func (ccl *configChangeListener) OnChange(event *config.ConfigChangeEvent) {
    ccl.callback(event)
}

// 配置版本管理
type ConfigVersionManager struct {
    configCenter config.ConfigCenter
    versions     map[string][]*config.ConfigItem
    mutex        sync.RWMutex
    maxVersions  int
}

func NewConfigVersionManager(configCenter config.ConfigCenter, maxVersions int) *ConfigVersionManager {
    return &ConfigVersionManager{
        configCenter: configCenter,
        versions:     make(map[string][]*config.ConfigItem),
        maxVersions:  maxVersions,
    }
}

func (cvm *ConfigVersionManager) OnChange(event *config.ConfigChangeEvent) {
    if event.EventType == "UPDATE" {
        cvm.saveVersion(event.Key, event.NewValue)
    }
}

func (cvm *ConfigVersionManager) saveVersion(key string, value interface{}) {
    cvm.mutex.Lock()
    defer cvm.mutex.Unlock()
    
    item := &config.ConfigItem{
        Key:       key,
        Value:     value,
        Version:   time.Now().UnixNano(),
        UpdatedAt: time.Now(),
    }
    
    versions := cvm.versions[key]
    versions = append(versions, item)
    
    // 限制版本数量
    if len(versions) > cvm.maxVersions {
        versions = versions[len(versions)-cvm.maxVersions:]
    }
    
    cvm.versions[key] = versions
}

func (cvm *ConfigVersionManager) GetVersions(key string) []*config.ConfigItem {
    cvm.mutex.RLock()
    defer cvm.mutex.RUnlock()
    
    if versions, exists := cvm.versions[key]; exists {
        // 返回副本
        result := make([]*config.ConfigItem, len(versions))
        copy(result, versions)
        return result
    }
    
    return nil
}

func (cvm *ConfigVersionManager) Rollback(key string, versionIndex int) error {
    cvm.mutex.RLock()
    versions := cvm.versions[key]
    cvm.mutex.RUnlock()
    
    if versions == nil || versionIndex >= len(versions) {
        return fmt.Errorf("version not found")
    }
    
    item := versions[versionIndex]
    ctx := context.Background()
    
    return cvm.configCenter.Set(ctx, key, item.Value)
}

// 配置变更历史记录
type ConfigHistory struct {
    Key       string                 `json:"key"`
    Value     interface{}            `json:"value"`
    Version   int64                  `json:"version"`
    Timestamp time.Time              `json:"timestamp"`
    User      string                 `json:"user,omitempty"`
    Comment   string                 `json:"comment,omitempty"`
    Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

type ConfigHistoryManager struct {
    history map[string][]*ConfigHistory
    mutex   sync.RWMutex
    maxSize int
}

func NewConfigHistoryManager(maxSize int) *ConfigHistoryManager {
    return &ConfigHistoryManager{
        history: make(map[string][]*ConfigHistory),
        maxSize: maxSize,
    }
}

func (chm *ConfigHistoryManager) RecordChange(key string, value interface{}, user, comment string) {
    chm.mutex.Lock()
    defer chm.mutex.Unlock()
    
    record := &ConfigHistory{
        Key:       key,
        Value:     value,
        Version:   time.Now().UnixNano(),
        Timestamp: time.Now(),
        User:      user,
        Comment:   comment,
    }
    
    history := chm.history[key]
    history = append(history, record)
    
    // 限制历史记录数量
    if len(history) > chm.maxSize {
        history = history[len(history)-chm.maxSize:]
    }
    
    chm.history[key] = history
}

func (chm *ConfigHistoryManager) GetHistory(key string) []*ConfigHistory {
    chm.mutex.RLock()
    defer chm.mutex.RUnlock()
    
    if history, exists := chm.history[key]; exists {
        // 返回副本
        result := make([]*ConfigHistory, len(history))
        copy(result, history)
        return result
    }
    
    return nil
}

func (chm *ConfigHistoryManager) ExportHistory() (map[string][]*ConfigHistory, error) {
    chm.mutex.RLock()
    defer chm.mutex.RUnlock()
    
    result := make(map[string][]*ConfigHistory)
    for key, history := range chm.history {
        result[key] = make([]*ConfigHistory, len(history))
        copy(result[key], history)
    }
    
    return result, nil
}

// 使用示例
func main() {
    // 假设已经有了配置中心实例
    // configCenter := ...
    
    // 创建热更新管理器
    hotReloadManager := NewHotReloadManager(configCenter)
    
    // 定义应用配置结构
    type AppConfig struct {
        DatabaseHost string `json:"database_host"`
        DatabasePort int    `json:"database_port"`
        CacheTTL     int    `json:"cache_ttl"`
        FeatureFlag  bool   `json:"feature_flag"`
        AppName      string `json:"app_name"`
    }
    
    appConfig := &AppConfig{}
    
    // 创建结构体绑定器
    binder := NewStructConfigBinder(appConfig)
    binder.BindField("database.host", "DatabaseHost")
    binder.BindField("database.port", "DatabasePort")
    binder.BindField("cache.ttl", "CacheTTL")
    binder.BindField("feature.enabled", "FeatureFlag")
    binder.BindField("app.name", "AppName")
    
    // 绑定配置
    configKeys := []string{
        "database.host",
        "database.port",
        "cache.ttl",
        "feature.enabled",
        "app.name",
    }
    
    hotReloadManager.BindStruct(configKeys, binder)
    
    // 添加配置观察者
    hotReloadManager.Watch("database.host", ConfigWatcherFunc(func(key string, value interface{}) {
        log.Printf("Database host updated to: %v", value)
    }))
    
    hotReloadManager.Watch("feature.enabled", ConfigWatcherFunc(func(key string, value interface{}) {
        log.Printf("Feature flag updated to: %v", value)
        // 根据配置变化执行相应逻辑
        if enabled, ok := value.(bool); ok && enabled {
            log.Println("Feature is now enabled")
        } else {
            log.Println("Feature is now disabled")
        }
    }))
    
    // 配置版本管理
    versionManager := NewConfigVersionManager(configCenter, 10)
    
    // 配置历史记录
    historyManager := NewConfigHistoryManager(100)
    
    // 模拟配置更新
    ctx := context.Background()
    
    // 更新配置并记录历史
    configCenter.Set(ctx, "database.host", "new-host.example.com")
    historyManager.RecordChange("database.host", "new-host.example.com", "admin", "Updated database host")
    
    configCenter.Set(ctx, "feature.enabled", true)
    historyManager.RecordChange("feature.enabled", true, "admin", "Enabled new feature")
    
    // 查看配置历史
    history := historyManager.GetHistory("database.host")
    log.Printf("Configuration history for database.host: %+v", history)
    
    // 保持程序运行
    select {}
}
```

### 配置加密

```go
// 配置加密实现
package encryption

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha256"
    "crypto/x509"
    "encoding/base64"
    "encoding/pem"
    "fmt"
    "io"
    "your-project/config"
)

// 加密配置项
type EncryptedConfigItem struct {
    Key          string `json:"key"`
    EncryptedValue string `json:"encrypted_value"`
    Algorithm    string `json:"algorithm"`
    Nonce        string `json:"nonce,omitempty"`
    CreatedAt    int64  `json:"created_at"`
    UpdatedAt    int64  `json:"updated_at"`
}

// 加密器接口
type Encryptor interface {
    Encrypt(plaintext []byte) ([]byte, error)
    Decrypt(ciphertext []byte) ([]byte, error)
    Algorithm() string
}

// AES-GCM加密器
type AESGCMEncryptor struct {
    key []byte
}

func NewAESGCMEncryptor(key []byte) (*AESGCMEncryptor, error) {
    if len(key) != 16 && len(key) != 24 && len(key) != 32 {
        return nil, fmt.Errorf("invalid key size: %d", len(key))
    }
    
    return &AESGCMEncryptor{key: key}, nil
}

func (a *AESGCMEncryptor) Encrypt(plaintext []byte) ([]byte, error) {
    block, err := aes.NewCipher(a.key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}

func (a *AESGCMEncryptor) Decrypt(ciphertext []byte) ([]byte, error) {
    block, err := aes.NewCipher(a.key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, fmt.Errorf("ciphertext too short")
    }
    
    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }
    
    return plaintext, nil
}

func (a *AESGCMEncryptor) Algorithm() string {
    return "AES-GCM"
}

// RSA加密器
type RSAEncryptor struct {
    publicKey  *rsa.PublicKey
    privateKey *rsa.PrivateKey
}

func NewRSAEncryptor(publicKey *rsa.PublicKey, privateKey *rsa.PrivateKey) *RSAEncryptor {
    return &RSAEncryptor{
        publicKey:  publicKey,
        privateKey: privateKey,
    }
}

func (r *RSAEncryptor) Encrypt(plaintext []byte) ([]byte, error) {
    if r.publicKey == nil {
        return nil, fmt.Errorf("public key not set")
    }
    
    label := []byte("")
    hash := sha256.New()
    
    return rsa.EncryptOAEP(hash, rand.Reader, r.publicKey, plaintext, label)
}

func (r *RSAEncryptor) Decrypt(ciphertext []byte) ([]byte, error) {
    if r.privateKey == nil {
        return nil, fmt.Errorf("private key not set")
    }
    
    label := []byte("")
    hash := sha256.New()
    
    return rsa.DecryptOAEP(hash, rand.Reader, r.privateKey, ciphertext, label)
}

func (r *RSAEncryptor) Algorithm() string {
    return "RSA-OAEP"
}

// 加密配置中心
type EncryptedConfigCenter struct {
    delegate  config.ConfigCenter
    encryptor Encryptor
}

func NewEncryptedConfigCenter(delegate config.ConfigCenter, encryptor Encryptor) *EncryptedConfigCenter {
    return &EncryptedConfigCenter{
        delegate:  delegate,
        encryptor: encryptor,
    }
}

func (ecc *EncryptedConfigCenter) Get(ctx context.Context, key string) (*config.ConfigItem, error) {
    item, err := ecc.delegate.Get(ctx, key)
    if err != nil {
        return nil, err
    }
    
    // 检查是否为加密配置
    if encryptedItem, ok := item.Value.(map[string]interface{}); ok {
        if algorithm, exists := encryptedItem["algorithm"]; exists && algorithm == ecc.encryptor.Algorithm() {
            encryptedValue := encryptedItem["encrypted_value"].(string)
            
            ciphertext, err := base64.StdEncoding.DecodeString(encryptedValue)
            if err != nil {
                return nil, fmt.Errorf("failed to decode encrypted value: %v", err)
            }
            
            plaintext, err := ecc.encryptor.Decrypt(ciphertext)
            if err != nil {
                return nil, fmt.Errorf("failed to decrypt value: %v", err)
            }
            
            item.Value = string(plaintext)
        }
    }
    
    return item, nil
}

func (ecc *EncryptedConfigCenter) Set(ctx context.Context, key string, value interface{}) error {
    // 检查是否需要加密的配置
    if ecc.shouldEncrypt(key) {
        plaintext := []byte(fmt.Sprintf("%v", value))
        
        ciphertext, err := ecc.encryptor.Encrypt(plaintext)
        if err != nil {
            return fmt.Errorf("failed to encrypt value: %v", err)
        }
        
        encryptedValue := base64.StdEncoding.EncodeToString(ciphertext)
        
        encryptedItem := &EncryptedConfigItem{
            Key:          key,
            EncryptedValue: encryptedValue,
            Algorithm:    ecc.encryptor.Algorithm(),
            CreatedAt:    time.Now().Unix(),
            UpdatedAt:    time.Now().Unix(),
        }
        
        return ecc.delegate.Set(ctx, key, encryptedItem)
    }
    
    return ecc.delegate.Set(ctx, key, value)
}

func (ecc *EncryptedConfigCenter) shouldEncrypt(key string) bool {
    // 定义需要加密的配置键
    sensitiveKeys := map[string]bool{
        "database.password": true,
        "api.secret_key":    true,
        "jwt.secret":        true,
        "encryption.key":    true,
    }
    
    return sensitiveKeys[key]
}

func (ecc *EncryptedConfigCenter) Delete(ctx context.Context, key string) error {
    return ecc.delegate.Delete(ctx, key)
}

func (ecc *EncryptedConfigCenter) GetBatch(ctx context.Context, keys []string) (map[string]*config.ConfigItem, error) {
    return ecc.delegate.GetBatch(ctx, keys)
}

func (ecc *EncryptedConfigCenter) GetByPrefix(ctx context.Context, prefix string) (map[string]*config.ConfigItem, error) {
    return ecc.delegate.GetByPrefix(ctx, prefix)
}

func (ecc *EncryptedConfigCenter) Watch(ctx context.Context, key string, listener config.ConfigListener) error {
    return ecc.delegate.Watch(ctx, key, listener)
}

func (ecc *EncryptedConfigCenter) WatchPrefix(ctx context.Context, prefix string, listener config.ConfigListener) error {
    return ecc.delegate.WatchPrefix(ctx, prefix, listener)
}

func (ecc *EncryptedConfigCenter) Export(ctx context.Context) (map[string]*config.ConfigItem, error) {
    return ecc.delegate.Export(ctx)
}

func (ecc *EncryptedConfigCenter) Import(ctx context.Context, configs map[string]*config.ConfigItem) error {
    return ecc.delegate.Import(ctx, configs)
}

// 密钥管理器
type KeyManager struct {
    masterKey []byte
    keys      map[string][]byte
    mutex     sync.RWMutex
}

func NewKeyManager(masterKey []byte) *KeyManager {
    return &KeyManager{
        masterKey: masterKey,
        keys:      make(map[string][]byte),
    }
}

func (km *KeyManager) GenerateKey(keyID string, size int) ([]byte, error) {
    km.mutex.Lock()
    defer km.mutex.Unlock()
    
    key := make([]byte, size)
    if _, err := rand.Read(key); err != nil {
        return nil, err
    }
    
    km.keys[keyID] = key
    return key, nil
}

func (km *KeyManager) GetKey(keyID string) ([]byte, error) {
    km.mutex.RLock()
    defer km.mutex.RUnlock()
    
    if key, exists := km.keys[keyID]; exists {
        return key, nil
    }
    
    return nil, fmt.Errorf("key %s not found", keyID)
}

func (km *KeyManager) RotateKey(keyID string, newSize int) ([]byte, error) {
    return km.GenerateKey(keyID, newSize)
}

// 配置加密客户端
type EncryptedConfigClient struct {
    center *EncryptedConfigCenter
    client *config.ConfigClientImpl
}

func NewEncryptedConfigClient(delegate config.ConfigCenter, encryptor Encryptor) *EncryptedConfigClient {
    center := NewEncryptedConfigCenter(delegate, encryptor)
    manager := config.NewConfigManager(center, 30*time.Second)
    clientImpl := config.NewConfigClient(manager)
    
    return &EncryptedConfigClient{
        center: center,
        client: clientImpl,
    }
}

func (ecc *EncryptedConfigClient) GetConfig(key string, defaultValue interface{}) interface{} {
    return ecc.client.GetConfig(key, defaultValue)
}

func (ecc *EncryptedConfigClient) GetString(key string, defaultValue string) string {
    return ecc.client.GetString(key, defaultValue)
}

func (ecc *EncryptedConfigClient) GetInt(key string, defaultValue int) int {
    return ecc.client.GetInt(key, defaultValue)
}

func (ecc *EncryptedConfigClient) GetBool(key string, defaultValue bool) bool {
    return ecc.client.GetBool(key, defaultValue)
}

func (ecc *EncryptedConfigClient) GetFloat64(key string, defaultValue float64) float64 {
    return ecc.client.GetFloat64(key, defaultValue)
}

func (ecc *EncryptedConfigClient) Watch(key string, callback func(interface{})) {
    ecc.client.Watch(key, callback)
}

func (ecc *EncryptedConfigClient) Close() error {
    return nil
}

// 密钥生成和管理工具
type KeyTool struct {
    keyManager *KeyManager
}

func NewKeyTool(masterKey []byte) *KeyTool {
    return &KeyTool{
        keyManager: NewKeyManager(masterKey),
    }
}

func (kt *KeyTool) GenerateAESKey(keyID string) ([]byte, error) {
    return kt.keyManager.GenerateKey(keyID, 32) // 256-bit key
}

func (kt *KeyTool) GenerateRSAKeyPair(bits int) (*rsa.PrivateKey, *rsa.PublicKey, error) {
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return nil, nil, err
    }
    
    return privateKey, &privateKey.PublicKey, nil
}

func (kt *KeyTool) SaveKeyToFile(key []byte, filename string) error {
    return ioutil.WriteFile(filename, key, 0600)
}

func (kt *KeyTool) LoadKeyFromFile(filename string) ([]byte, error) {
    return ioutil.ReadFile(filename)
}

func (kt *KeyTool) SaveRSAKeyToFile(privateKey *rsa.PrivateKey, filename string) error {
    privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
    privateKeyPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: privateKeyBytes,
    })
    
    return ioutil.WriteFile(filename, privateKeyPEM, 0600)
}

func (kt *KeyTool) LoadRSAKeyFromFile(filename string) (*rsa.PrivateKey, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    
    block, _ := pem.Decode(data)
    if block == nil {
        return nil, fmt.Errorf("failed to decode PEM block")
    }
    
    return x509.ParsePKCS1PrivateKey(block.Bytes)
}

// 使用示例
func main() {
    // 生成AES密钥
    key := make([]byte, 32) // 256-bit key
    if _, err := rand.Read(key); err != nil {
        log.Fatalf("Failed to generate key: %v", err)
    }
    
    // 创建AES加密器
    encryptor, err := NewAESGCMEncryptor(key)
    if err != nil {
        log.Fatalf("Failed to create encryptor: %v", err)
    }
    
    // 假设有一个基础配置中心
    // baseCenter := ...
    
    // 创建加密配置中心
    encryptedCenter := NewEncryptedConfigCenter(baseCenter, encryptor)
    
    // 创建加密配置客户端
    client := NewEncryptedConfigClient(baseCenter, encryptor)
    
    // 设置敏感配置
    ctx := context.Background()
    encryptedCenter.Set(ctx, "database.password", "super-secret-password")
    encryptedCenter.Set(ctx, "api.secret_key", "very-secret-api-key")
    encryptedCenter.Set(ctx, "jwt.secret", "jwt-signing-secret")
    
    // 获取加密配置（自动解密）
    dbPassword := client.GetString("database.password", "")
    apiSecret := client.GetString("api.secret_key", "")
    jwtSecret := client.GetString("jwt.secret", "")
    
    log.Printf("Database password: %s", dbPassword)
    log.Printf("API secret: %s", apiSecret)
    log.Printf("JWT secret: %s", jwtSecret)
    
    // 密钥管理示例
    keyTool := NewKeyTool(key)
    
    // 生成新的AES密钥
    newKey, err := keyTool.GenerateAESKey("app-key-2023")
    if err != nil {
        log.Printf("Failed to generate key: %v", err)
    } else {
        log.Printf("Generated new key: %x", newKey)
    }
    
    // 生成RSA密钥对
    rsaPrivateKey, rsaPublicKey, err := keyTool.GenerateRSAKeyPair(2048)
    if err != nil {
        log.Printf("Failed to generate RSA key pair: %v", err)
    } else {
        log.Println("Generated RSA key pair")
        
        // 保存私钥
        if err := keyTool.SaveRSAKeyToFile(rsaPrivateKey, "private.key"); err != nil {
            log.Printf("Failed to save private key: %v", err)
        }
        
        // 创建RSA加密器
        rsaEncryptor := NewRSAEncryptor(rsaPublicKey, rsaPrivateKey)
        
        // 使用RSA加密测试
        plaintext := []byte("This is a secret message")
        ciphertext, err := rsaEncryptor.Encrypt(plaintext)
        if err != nil {
            log.Printf("Failed to encrypt: %v", err)
        } else {
            decrypted, err := rsaEncryptor.Decrypt(ciphertext)
            if err != nil {
                log.Printf("Failed to decrypt: %v", err)
            } else {
                log.Printf("Decrypted message: %s", string(decrypted))
            }
        }
    }
    
    // 配置监听示例
    client.Watch("database.password", func(value interface{}) {
        log.Printf("Database password updated (encrypted value will be automatically decrypted)")
    })
    
    // 保持程序运行
    select {}
}
```