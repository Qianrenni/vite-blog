## 10.3 服务发现

### Consul

```go
// Consul服务发现实现
import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"

    consul "github.com/hashicorp/consul/api"
)

// Consul客户端封装
type ConsulClient struct {
    client *consul.Client
    config *consul.Config
}

func NewConsulClient(address string) (*ConsulClient, error) {
    config := consul.DefaultConfig()
    config.Address = address
    
    client, err := consul.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ConsulClient{
        client: client,
        config: config,
    }, nil
}

// 服务注册
func (c *ConsulClient) RegisterService(service *ServiceRegistration) error {
    registration := &consul.AgentServiceRegistration{
        ID:      service.ID,
        Name:    service.Name,
        Address: service.Address,
        Port:    service.Port,
        Tags:    service.Tags,
        Meta:    service.Meta,
        Check: &consul.AgentServiceCheck{
            HTTP:                           fmt.Sprintf("http://%s:%d/health", service.Address, service.Port),
            Interval:                       "10s",
            Timeout:                        "5s",
            DeregisterCriticalServiceAfter: "1m",
        },
    }
    
    return c.client.Agent().ServiceRegister(registration)
}

// 服务注销
func (c *ConsulClient) DeregisterService(serviceID string) error {
    return c.client.Agent().ServiceDeregister(serviceID)
}

// 服务发现
func (c *ConsulClient) DiscoverServices(serviceName string, tag string) ([]*ServiceInstance, error) {
    var queryOptions *consul.QueryOptions
    if tag != "" {
        queryOptions = &consul.QueryOptions{
            Tag: tag,
        }
    }
    
    services, _, err := c.client.Health().Service(serviceName, tag, true, queryOptions)
    if err != nil {
        return nil, err
    }
    
    var instances []*ServiceInstance
    for _, serviceEntry := range services {
        instance := &ServiceInstance{
            ID:      serviceEntry.Service.ID,
            Name:    serviceEntry.Service.Service,
            Address: serviceEntry.Service.Address,
            Port:    serviceEntry.Service.Port,
            Tags:    serviceEntry.Service.Tags,
            Meta:    serviceEntry.Service.Meta,
        }
        instances = append(instances, instance)
    }
    
    return instances, nil
}

// 健康检查
func (c *ConsulClient) UpdateTTLCheck(checkID, status, output string) error {
    return c.client.Agent().UpdateTTL(checkID, output, status)
}

// KV存储
func (c *ConsulClient) PutKV(key string, value []byte) error {
    kvPair := &consul.KVPair{
        Key:   key,
        Value: value,
    }
    
    _, err := c.client.KV().Put(kvPair, nil)
    return err
}

func (c *ConsulClient) GetKV(key string) ([]byte, error) {
    kvPair, _, err := c.client.KV().Get(key, nil)
    if err != nil {
        return nil, err
    }
    
    if kvPair == nil {
        return nil, nil
    }
    
    return kvPair.Value, nil
}

func (c *ConsulClient) DeleteKV(key string) error {
    _, err := c.client.KV().Delete(key, nil)
    return err
}

// 服务注册结构
type ServiceRegistration struct {
    ID      string            `json:"id"`
    Name    string            `json:"name"`
    Address string            `json:"address"`
    Port    int               `json:"port"`
    Tags    []string          `json:"tags,omitempty"`
    Meta    map[string]string `json:"meta,omitempty"`
}

type ServiceInstance struct {
    ID      string            `json:"id"`
    Name    string            `json:"name"`
    Address string            `json:"address"`
    Port    int               `json:"port"`
    Tags    []string          `json:"tags,omitempty"`
    Meta    map[string]string `json:"meta,omitempty"`
}

// 服务注册器
type ServiceRegistrar struct {
    consulClient *ConsulClient
    serviceID    string
    serviceName  string
    stopCh       chan struct{}
}

func NewServiceRegistrar(consulClient *ConsulClient, registration *ServiceRegistration) *ServiceRegistrar {
    return &ServiceRegistrar{
        consulClient: consulClient,
        serviceID:    registration.ID,
        serviceName:  registration.Name,
        stopCh:       make(chan struct{}),
    }
}

func (sr *ServiceRegistrar) Start() error {
    // 注册服务
    registration := &ServiceRegistration{
        ID:      sr.serviceID,
        Name:    sr.serviceName,
        Address: "localhost", // 实际应用中应该是服务的实际地址
        Port:    8080,        // 实际应用中应该是服务的实际端口
        Tags:    []string{"microservice", "golang"},
        Meta: map[string]string{
            "version": "1.0.0",
            "env":     "production",
        },
    }
    
    if err := sr.consulClient.RegisterService(registration); err != nil {
        return fmt.Errorf("failed to register service: %v", err)
    }
    
    log.Printf("Service %s registered with ID %s", sr.serviceName, sr.serviceID)
    
    // 启动健康检查
    go sr.runHealthChecks()
    
    return nil
}

func (sr *ServiceRegistrar) Stop() {
    close(sr.stopCh)
    
    // 注销服务
    if err := sr.consulClient.DeregisterService(sr.serviceID); err != nil {
        log.Printf("Failed to deregister service: %v", err)
    }
    
    log.Printf("Service %s deregistered", sr.serviceID)
}

func (sr *ServiceRegistrar) runHealthChecks() {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-sr.stopCh:
            return
        case <-ticker.C:
            // 执行健康检查
            if sr.isHealthy() {
                // 更新TTL检查为passing
                checkID := fmt.Sprintf("service:%s", sr.serviceID)
                sr.consulClient.UpdateTTLCheck(checkID, "passing", "Service is healthy")
            } else {
                // 更新TTL检查为critical
                checkID := fmt.Sprintf("service:%s", sr.serviceID)
                sr.consulClient.UpdateTTLCheck(checkID, "critical", "Service is unhealthy")
            }
        }
    }
}

func (sr *ServiceRegistrar) isHealthy() bool {
    // 实现具体的健康检查逻辑
    // 例如：检查数据库连接、缓存连接等
    
    // 简化示例：总是返回健康
    return true
}

// 服务发现客户端
type ServiceDiscoveryClient struct {
    consulClient *ConsulClient
    cache        map[string][]*ServiceInstance
    mutex        sync.RWMutex
    cacheTimeout time.Duration
}

func NewServiceDiscoveryClient(consulClient *ConsulClient) *ServiceDiscoveryClient {
    return &ServiceDiscoveryClient{
        consulClient: consulClient,
        cache:        make(map[string][]*ServiceInstance),
        cacheTimeout: 30 * time.Second,
    }
}

func (sdc *ServiceDiscoveryClient) Discover(serviceName string) ([]*ServiceInstance, error) {
    // 先检查缓存
    if instances := sdc.getCachedInstances(serviceName); instances != nil {
        return instances, nil
    }
    
    // 从Consul获取服务实例
    instances, err := sdc.consulClient.DiscoverServices(serviceName, "")
    if err != nil {
        return nil, err
    }
    
    // 缓存结果
    sdc.cacheInstances(serviceName, instances)
    
    return instances, nil
}

func (sdc *ServiceDiscoveryClient) getCachedInstances(serviceName string) []*ServiceInstance {
    sdc.mutex.RLock()
    defer sdc.mutex.RUnlock()
    
    if instances, exists := sdc.cache[serviceName]; exists {
        return instances
    }
    
    return nil
}

func (sdc *ServiceDiscoveryClient) cacheInstances(serviceName string, instances []*ServiceInstance) {
    sdc.mutex.Lock()
    defer sdc.mutex.Unlock()
    
    sdc.cache[serviceName] = instances
}

// 负载均衡器集成Consul
type ConsulLoadBalancer struct {
    discoveryClient *ServiceDiscoveryClient
    balancer        LoadBalancer
}

func NewConsulLoadBalancer(discoveryClient *ServiceDiscoveryClient) *ConsulLoadBalancer {
    return &ConsulLoadBalancer{
        discoveryClient: discoveryClient,
        balancer:        &RoundRobinLoadBalancer{},
    }
}

func (clb *ConsulLoadBalancer) Select(serviceName string) (*ServiceInstance, error) {
    instances, err := clb.discoveryClient.Discover(serviceName)
    if err != nil {
        return nil, err
    }
    
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances found for service %s", serviceName)
    }
    
    // 过滤健康的实例
    var healthyInstances []*ServiceInstance
    for _, instance := range instances {
        if clb.isInstanceHealthy(instance) {
            healthyInstances = append(healthyInstances, instance)
        }
    }
    
    if len(healthyInstances) == 0 {
        return nil, fmt.Errorf("no healthy instances found for service %s", serviceName)
    }
    
    // 使用负载均衡算法选择实例
    // 这里简化处理，实际应用中应该使用具体的负载均衡器
    return healthyInstances[0], nil
}

func (clb *ConsulLoadBalancer) isInstanceHealthy(instance *ServiceInstance) bool {
    // 可以通过Consul的健康检查API来验证实例健康状态
    // 这里简化处理
    return true
}

// 使用示例
func main() {
    // 创建Consul客户端
    consulClient, err := NewConsulClient("localhost:8500")
    if err != nil {
        log.Fatalf("Failed to create Consul client: %v", err)
    }
    
    // 创建服务注册器
    registrar := NewServiceRegistrar(consulClient, &ServiceRegistration{
        ID:      "user-service-1",
        Name:    "user-service",
        Address: "localhost",
        Port:    8080,
    })
    
    // 启动服务注册
    if err := registrar.Start(); err != nil {
        log.Fatalf("Failed to start service registrar: %v", err)
    }
    defer registrar.Stop()
    
    // 创建服务发现客户端
    discoveryClient := NewServiceDiscoveryClient(consulClient)
    
    // 发现服务
    instances, err := discoveryClient.Discover("user-service")
    if err != nil {
        log.Printf("Failed to discover services: %v", err)
    } else {
        log.Printf("Found %d instances", len(instances))
        for _, instance := range instances {
            log.Printf("Instance: %s - %s:%d", instance.ID, instance.Address, instance.Port)
        }
    }
    
    // 保持服务运行
    select {}
}
```

### etcd

```go
// etcd服务发现实现
import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "time"

    "go.etcd.io/etcd/clientv3"
    "go.etcd.io/etcd/clientv3/concurrency"
    "go.etcd.io/etcd/mvcc/mvccpb"
)

// etcd客户端封装
type EtcdClient struct {
    client *clientv3.Client
    config clientv3.Config
}

func NewEtcdClient(endpoints []string) (*EtcdClient, error) {
    config := clientv3.Config{
        Endpoints:   endpoints,
        DialTimeout: 5 * time.Second,
    }
    
    client, err := clientv3.New(config)
    if err != nil {
        return nil, err
    }
    
    return &EtcdClient{
        client: client,
        config: config,
    }, nil
}

// 服务注册
func (e *EtcdClient) RegisterService(service *ServiceRegistration) error {
    serviceKey := fmt.Sprintf("/services/%s/%s", service.Name, service.ID)
    
    // 序列化服务信息
    serviceData, err := json.Marshal(service)
    if err != nil {
        return err
    }
    
    // 注册服务，设置租约
    leaseResp, err := e.client.Grant(context.Background(), 30) // 30秒租约
    if err != nil {
        return err
    }
    
    _, err = e.client.Put(context.Background(), serviceKey, string(serviceData), 
        clientv3.WithLease(leaseResp.ID))
    if err != nil {
        return err
    }
    
    // 保持租约活跃
    go e.keepAlive(leaseResp.ID)
    
    return nil
}

// 保持租约活跃
func (e *EtcdClient) keepAlive(leaseID clientv3.LeaseID) {
    ch, err := e.client.KeepAlive(context.Background(), leaseID)
    if err != nil {
        log.Printf("Failed to keep alive lease: %v", err)
        return
    }
    
    for {
        select {
        case resp := <-ch:
            if resp == nil {
                log.Printf("Lease keep alive channel closed")
                return
            }
        case <-time.After(35 * time.Second):
            log.Printf("Lease keep alive timeout")
            return
        }
    }
}

// 服务注销
func (e *EtcdClient) DeregisterService(serviceName, serviceID string) error {
    serviceKey := fmt.Sprintf("/services/%s/%s", serviceName, serviceID)
    _, err := e.client.Delete(context.Background(), serviceKey)
    return err
}

// 服务发现
func (e *EtcdClient) DiscoverServices(serviceName string) ([]*ServiceInstance, error) {
    prefix := fmt.Sprintf("/services/%s/", serviceName)
    
    resp, err := e.client.Get(context.Background(), prefix, clientv3.WithPrefix())
    if err != nil {
        return nil, err
    }
    
    var instances []*ServiceInstance
    for _, kv := range resp.Kvs {
        var service ServiceRegistration
        if err := json.Unmarshal(kv.Value, &service); err != nil {
            log.Printf("Failed to unmarshal service data: %v", err)
            continue
        }
        
        instance := &ServiceInstance{
            ID:      service.ID,
            Name:    service.Name,
            Address: service.Address,
            Port:    service.Port,
            Tags:    service.Tags,
            Meta:    service.Meta,
        }
        
        instances = append(instances, instance)
    }
    
    return instances, nil
}

// 监听服务变化
func (e *EtcdClient) WatchServices(serviceName string, handler func([]*ServiceInstance)) error {
    prefix := fmt.Sprintf("/services/%s/", serviceName)
    
    watchChan := e.client.Watch(context.Background(), prefix, clientv3.WithPrefix())
    
    go func() {
        for watchResp := range watchChan {
            for _, event := range watchResp.Events {
                switch event.Type {
                case mvccpb.PUT, mvccpb.DELETE:
                    // 重新获取服务列表
                    instances, err := e.DiscoverServices(serviceName)
                    if err != nil {
                        log.Printf("Failed to discover services: %v", err)
                        continue
                    }
                    
                    handler(instances)
                }
            }
        }
    }()
    
    return nil
}

// 分布式锁
type DistributedLock struct {
    session *concurrency.Session
    mutex   *concurrency.Mutex
}

func (e *EtcdClient) NewDistributedLock(lockName string) (*DistributedLock, error) {
    session, err := concurrency.NewSession(e.client)
    if err != nil {
        return nil, err
    }
    
    mutex := concurrency.NewMutex(session, lockName)
    
    return &DistributedLock{
        session: session,
        mutex:   mutex,
    }, nil
}

func (dl *DistributedLock) Lock(ctx context.Context) error {
    return dl.mutex.Lock(ctx)
}

func (dl *DistributedLock) Unlock(ctx context.Context) error {
    return dl.mutex.Unlock(ctx)
}

func (dl *DistributedLock) Close() error {
    return dl.session.Close()
}

// 配置管理
func (e *EtcdClient) PutConfig(key string, value interface{}) error {
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    _, err = e.client.Put(context.Background(), key, string(data))
    return err
}

func (e *EtcdClient) GetConfig(key string, value interface{}) error {
    resp, err := e.client.Get(context.Background(), key)
    if err != nil {
        return err
    }
    
    if len(resp.Kvs) == 0 {
        return fmt.Errorf("key not found: %s", key)
    }
    
    return json.Unmarshal(resp.Kvs[0].Value, value)
}

func (e *EtcdClient) WatchConfig(key string, handler func(interface{})) error {
    watchChan := e.client.Watch(context.Background(), key)
    
    go func() {
        for watchResp := range watchChan {
            for _, event := range watchResp.Events {
                if event.Type == mvccpb.PUT {
                    // 解析配置并调用处理函数
                    // 这里需要知道具体的配置类型
                    handler(event.Kv.Value)
                }
            }
        }
    }()
    
    return nil
}

// 选举
type LeaderElection struct {
    election *concurrency.Election
    session  *concurrency.Session
}

func (e *EtcdClient) NewLeaderElection(electionName string) (*LeaderElection, error) {
    session, err := concurrency.NewSession(e.client)
    if err != nil {
        return nil, err
    }
    
    election := concurrency.NewElection(session, electionName)
    
    return &LeaderElection{
        election: election,
        session:  session,
    }, nil
}

func (le *LeaderElection) Campaign(ctx context.Context, candidateID string) error {
    return le.election.Campaign(ctx, candidateID)
}

func (le *LeaderElection) IsLeader() (bool, error) {
    return le.election.IsLeader()
}

func (le *LeaderElection) Observe(ctx context.Context) (<-chan string, error) {
    return le.election.Observe(ctx)
}

func (le *LeaderElection) Resign(ctx context.Context) error {
    return le.election.Resign(ctx)
}

func (le *LeaderElection) Close() error {
    return le.session.Close()
}

// 使用示例
func main() {
    // 创建etcd客户端
    etcdClient, err := NewEtcdClient([]string{"localhost:2379"})
    if err != nil {
        log.Fatalf("Failed to create etcd client: %v", err)
    }
    defer etcdClient.client.Close()
    
    // 服务注册
    serviceReg := &ServiceRegistration{
        ID:      "user-service-1",
        Name:    "user-service",
        Address: "localhost",
        Port:    8080,
        Tags:    []string{"microservice", "golang"},
        Meta: map[string]string{
            "version": "1.0.0",
            "env":     "production",
        },
    }
    
    if err := etcdClient.RegisterService(serviceReg); err != nil {
        log.Fatalf("Failed to register service: %v", err)
    }
    
    log.Println("Service registered successfully")
    
    // 服务发现
    instances, err := etcdClient.DiscoverServices("user-service")
    if err != nil {
        log.Printf("Failed to discover services: %v", err)
    } else {
        log.Printf("Found %d instances", len(instances))
        for _, instance := range instances {
            log.Printf("Instance: %s - %s:%d", instance.ID, instance.Address, instance.Port)
        }
    }
    
    // 监听服务变化
    etcdClient.WatchServices("user-service", func(instances []*ServiceInstance) {
        log.Printf("Service instances changed, now have %d instances", len(instances))
    })
    
    // 配置管理示例
    config := map[string]interface{}{
        "database_url": "postgres://localhost:5432/mydb",
        "cache_ttl":    300,
        "debug":        true,
    }
    
    if err := etcdClient.PutConfig("/config/myapp", config); err != nil {
        log.Printf("Failed to put config: %v", err)
    }
    
    var retrievedConfig map[string]interface{}
    if err := etcdClient.GetConfig("/config/myapp", &retrievedConfig); err != nil {
        log.Printf("Failed to get config: %v", err)
    } else {
        log.Printf("Retrieved config: %+v", retrievedConfig)
    }
    
    // 分布式锁示例
    lock, err := etcdClient.NewDistributedLock("/locks/mylock")
    if err != nil {
        log.Printf("Failed to create lock: %v", err)
    } else {
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        
        if err := lock.Lock(ctx); err != nil {
            log.Printf("Failed to acquire lock: %v", err)
        } else {
            log.Println("Lock acquired successfully")
            // 执行需要互斥的操作
            time.Sleep(5 * time.Second)
            
            if err := lock.Unlock(ctx); err != nil {
                log.Printf("Failed to release lock: %v", err)
            } else {
                log.Println("Lock released successfully")
            }
        }
        
        lock.Close()
    }
    
    // 保持程序运行
    select {}
}
```

### Zookeeper

```go
// Zookeeper服务发现实现
import (
    "encoding/json"
    "fmt"
    "log"
    "path"
    "strings"
    "time"

    "github.com/samuel/go-zookeeper/zk"
)

// Zookeeper客户端封装
type ZkClient struct {
    conn     *zk.Conn
    servers  []string
    session  <-chan zk.Event
    rootPath string
}

func NewZkClient(servers []string, rootPath string) (*ZkClient, error) {
    conn, session, err := zk.Connect(servers, 5*time.Second)
    if err != nil {
        return nil, err
    }
    
    client := &ZkClient{
        conn:     conn,
        servers:  servers,
        session:  session,
        rootPath: rootPath,
    }
    
    // 确保根路径存在
    if err := client.ensurePath(rootPath); err != nil {
        return nil, err
    }
    
    return client, nil
}

func (z *ZkClient) ensurePath(p string) error {
    exists, _, err := z.conn.Exists(p)
    if err != nil {
        return err
    }
    
    if !exists {
        parts := strings.Split(p, "/")
        currentPath := ""
        for _, part := range parts {
            if part == "" {
                continue
            }
            currentPath += "/" + part
            exists, _, err := z.conn.Exists(currentPath)
            if err != nil {
                return err
            }
            if !exists {
                _, err := z.conn.Create(currentPath, []byte{}, 0, zk.WorldACL(zk.PermAll))
                if err != nil && err != zk.ErrNodeExists {
                    return err
                }
            }
        }
    }
    
    return nil
}

// 服务注册
func (z *ZkClient) RegisterService(service *ServiceRegistration) error {
    servicePath := path.Join(z.rootPath, service.Name)
    
    // 确保服务路径存在
    if err := z.ensurePath(servicePath); err != nil {
        return err
    }
    
    // 序列化服务信息
    serviceData, err := json.Marshal(service)
    if err != nil {
        return err
    }
    
    // 创建临时节点
    nodePath := path.Join(servicePath, service.ID)
    _, err = z.conn.Create(nodePath, serviceData, zk.FlagEphemeral, zk.WorldACL(zk.PermAll))
    if err != nil {
        return err
    }
    
    log.Printf("Service registered: %s/%s", service.Name, service.ID)
    return nil
}

// 服务注销
func (z *ZkClient) DeregisterService(serviceName, serviceID string) error {
    nodePath := path.Join(z.rootPath, serviceName, serviceID)
    return z.conn.Delete(nodePath, -1)
}

// 服务发现
func (z *ZkClient) DiscoverServices(serviceName string) ([]*ServiceInstance, error) {
    servicePath := path.Join(z.rootPath, serviceName)
    
    children, _, err := z.conn.Children(servicePath)
    if err != nil {
        if err == zk.ErrNoNode {
            return []*ServiceInstance{}, nil
        }
        return nil, err
    }
    
    var instances []*ServiceInstance
    for _, child := range children {
        nodePath := path.Join(servicePath, child)
        data, _, err := z.conn.Get(nodePath)
        if err != nil {
            log.Printf("Failed to get node data: %v", err)
            continue
        }
        
        var service ServiceRegistration
        if err := json.Unmarshal(data, &service); err != nil {
            log.Printf("Failed to unmarshal service data: %v", err)
            continue
        }
        
        instance := &ServiceInstance{
            ID:      service.ID,
            Name:    service.Name,
            Address: service.Address,
            Port:    service.Port,
            Tags:    service.Tags,
            Meta:    service.Meta,
        }
        
        instances = append(instances, instance)
    }
    
    return instances, nil
}

// 监听服务变化
func (z *ZkClient) WatchServices(serviceName string, handler func([]*ServiceInstance)) error {
    servicePath := path.Join(z.rootPath, serviceName)
    
    // 确保路径存在
    if err := z.ensurePath(servicePath); err != nil {
        return err
    }
    
    go func() {
        for {
            // 监听子节点变化
            children, _, childCh, err := z.conn.ChildrenW(servicePath)
            if err != nil {
                log.Printf("Failed to watch children: %v", err)
                time.Sleep(5 * time.Second)
                continue
            }
            
            // 获取当前服务实例
            instances, err := z.DiscoverServices(serviceName)
            if err != nil {
                log.Printf("Failed to discover services: %v", err)
            } else {
                handler(instances)
            }
            
            // 等待变化事件
            select {
            case event := <-childCh:
                log.Printf("Service change event: %v", event)
                if event.Type == zk.EventNodeChildrenChanged {
                    // 重新获取服务实例
                    instances, err := z.DiscoverServices(serviceName)
                    if err != nil {
                        log.Printf("Failed to discover services: %v", err)
                    } else {
                        handler(instances)
                    }
                }
            case <-time.After(30 * time.Second):
                // 超时重新监听
            }
        }
    }()
    
    return nil
}

// 分布式锁
type ZkLock struct {
    conn     *zk.Conn
    lockPath string
    lockNode string
}

func (z *ZkClient) NewDistributedLock(lockName string) (*ZkLock, error) {
    lockPath := path.Join(z.rootPath, "locks", lockName)
    
    // 确保锁路径存在
    if err := z.ensurePath(lockPath); err != nil {
        return nil, err
    }
    
    return &ZkLock{
        conn:     z.conn,
        lockPath: lockPath,
    }, nil
}

func (zl *ZkLock) Lock() error {
    // 创建临时顺序节点
    nodePath := path.Join(zl.lockPath, "lock-")
    lockNode, err := zl.conn.CreateProtectedEphemeralSequential(nodePath, []byte{}, zk.WorldACL(zk.PermAll))
    if err != nil {
        return err
    }
    
    zl.lockNode = lockNode
    
    // 竞争锁
    for {
        children, _, err := zl.conn.Children(zl.lockPath)
        if err != nil {
            return err
        }
        
        // 排序子节点
        mySeq := getSequenceNumber(path.Base(zl.lockNode))
        var lessThanMe []string
        for _, child := range children {
            seq := getSequenceNumber(child)
            if seq < mySeq {
                lessThanMe = append(lessThanMe, child)
            }
        }
        
        if len(lessThanMe) == 0 {
            // 获得锁
            return nil
        }
        
        // 等待前一个节点删除
        prevNode := ""
        for _, child := range children {
            seq := getSequenceNumber(child)
            if seq < mySeq && (prevNode == "" || getSequenceNumber(prevNode) < seq) {
                prevNode = child
            }
        }
        
        if prevNode != "" {
            prevPath := path.Join(zl.lockPath, prevNode)
            _, _, ch, err := zl.conn.GetW(prevPath)
            if err != nil {
                continue
            }
            
            select {
            case event := <-ch:
                if event.Type == zk.EventNodeDeleted {
                    continue
                }
            case <-time.After(10 * time.Second):
                // 超时重试
                continue
            }
        }
    }
}

func (zl *ZkLock) Unlock() error {
    if zl.lockNode != "" {
        return zl.conn.Delete(zl.lockNode, -1)
    }
    return nil
}

func getSequenceNumber(nodeName string) int {
    // 从节点名称中提取序列号
    // 例如: lock-0000000001 -> 1
    // 实现省略...
    return 0
}

// 配置管理
func (z *ZkClient) PutConfig(key string, value interface{}) error {
    configPath := path.Join(z.rootPath, "config", key)
    
    // 确保配置路径存在
    if err := z.ensurePath(path.Dir(configPath)); err != nil {
        return err
    }
    
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    exists, _, err := z.conn.Exists(configPath)
    if err != nil {
        return err
    }
    
    if exists {
        _, err = z.conn.Set(configPath, data, -1)
    } else {
        _, err = z.conn.Create(configPath, data, 0, zk.WorldACL(zk.PermAll))
    }
    
    return err
}

func (z *ZkClient) GetConfig(key string, value interface{}) error {
    configPath := path.Join(z.rootPath, "config", key)
    
    data, _, err := z.conn.Get(configPath)
    if err != nil {
        return err
    }
    
    return json.Unmarshal(data, value)
}

func (z *ZkClient) WatchConfig(key string, handler func(interface{})) error {
    configPath := path.Join(z.rootPath, "config", key)
    
    go func() {
        for {
            data, _, ch, err := z.conn.GetW(configPath)
            if err != nil {
                log.Printf("Failed to watch config: %v", err)
                time.Sleep(5 * time.Second)
                continue
            }
            
            // 处理当前配置
            handler(data)
            
            // 等待配置变化
            select {
            case event := <-ch:
                if event.Type == zk.EventNodeDataChanged {
                    data, _, err := z.conn.Get(configPath)
                    if err != nil {
                        log.Printf("Failed to get updated config: %v", err)
                        continue
                    }
                    handler(data)
                }
            case <-time.After(30 * time.Second):
                // 超时重新监听
            }
        }
    }()
    
    return nil
}

// 使用示例
func main() {
    // 创建Zookeeper客户端
    zkClient, err := NewZkClient([]string{"localhost:2181"}, "/microservices")
    if err != nil {
        log.Fatalf("Failed to create Zookeeper client: %v", err)
    }
    defer zkClient.conn.Close()
    
    // 服务注册
    serviceReg := &ServiceRegistration{
        ID:      "user-service-1",
        Name:    "user-service",
        Address: "localhost",
        Port:    8080,
        Tags:    []string{"microservice", "golang"},
        Meta: map[string]string{
            "version": "1.0.0",
            "env":     "production",
        },
    }
    
    if err := zkClient.RegisterService(serviceReg); err != nil {
        log.Fatalf("Failed to register service: %v", err)
    }
    
    log.Println("Service registered successfully")
    
    // 服务发现
    instances, err := zkClient.DiscoverServices("user-service")
    if err != nil {
        log.Printf("Failed to discover services: %v", err)
    } else {
        log.Printf("Found %d instances", len(instances))
        for _, instance := range instances {
            log.Printf("Instance: %s - %s:%d", instance.ID, instance.Address, instance.Port)
        }
    }
    
    // 监听服务变化
    zkClient.WatchServices("user-service", func(instances []*ServiceInstance) {
        log.Printf("Service instances changed, now have %d instances", len(instances))
    })
    
    // 分布式锁示例
    lock, err := zkClient.NewDistributedLock("mylock")
    if err != nil {
        log.Printf("Failed to create lock: %v", err)
    } else {
        if err := lock.Lock(); err != nil {
            log.Printf("Failed to acquire lock: %v", err)
        } else {
            log.Println("Lock acquired successfully")
            // 执行需要互斥的操作
            time.Sleep(5 * time.Second)
            
            if err := lock.Unlock(); err != nil {
                log.Printf("Failed to release lock: %v", err)
            } else {
                log.Println("Lock released successfully")
            }
        }
    }
    
    // 保持程序运行
    select {}
}
```

### 服务注册与发现

```go
// 通用服务注册与发现接口
type ServiceDiscovery interface {
    Register(service *ServiceRegistration) error
    Deregister(serviceName, serviceID string) error
    Discover(serviceName string) ([]*ServiceInstance, error)
    Watch(serviceName string, handler func([]*ServiceInstance)) error
}

type ServiceRegistry interface {
    Register(service *ServiceRegistration) error
    Deregister(serviceName, serviceID string) error
}

// 统一的服务注册发现客户端
type UnifiedServiceDiscovery struct {
    registry    ServiceRegistry
    discovery   ServiceDiscovery
    cache       map[string][]*ServiceInstance
    cacheMutex  sync.RWMutex
    cacheExpiry time.Duration
}

func NewUnifiedServiceDiscovery(registry ServiceRegistry, discovery ServiceDiscovery) *UnifiedServiceDiscovery {
    return &UnifiedServiceDiscovery{
        registry:    registry,
        discovery:   discovery,
        cache:       make(map[string][]*ServiceInstance),
        cacheExpiry: 30 * time.Second,
    }
}

func (usd *UnifiedServiceDiscovery) Register(service *ServiceRegistration) error {
    return usd.registry.Register(service)
}

func (usd *UnifiedServiceDiscovery) Deregister(serviceName, serviceID string) error {
    return usd.registry.Deregister(serviceName, serviceID)
}

func (usd *UnifiedServiceDiscovery) Discover(serviceName string) ([]*ServiceInstance, error) {
    // 检查缓存
    if cached := usd.getCachedInstances(serviceName); cached != nil {
        return cached, nil
    }
    
    // 从服务发现获取
    instances, err := usd.discovery.Discover(serviceName)
    if err != nil {
        return nil, err
    }
    
    // 缓存结果
    usd.cacheInstances(serviceName, instances)
    
    return instances, nil
}

func (usd *UnifiedServiceDiscovery) Watch(serviceName string, handler func([]*ServiceInstance)) error {
    return usd.discovery.Watch(serviceName, func(instances []*ServiceInstance) {
        // 更新缓存
        usd.cacheInstances(serviceName, instances)
        // 调用处理函数
        handler(instances)
    })
}

func (usd *UnifiedServiceDiscovery) getCachedInstances(serviceName string) []*ServiceInstance {
    usd.cacheMutex.RLock()
    defer usd.cacheMutex.RUnlock()
    
    if instances, exists := usd.cache[serviceName]; exists {
        return instances
    }
    
    return nil
}

func (usd *UnifiedServiceDiscovery) cacheInstances(serviceName string, instances []*ServiceInstance) {
    usd.cacheMutex.Lock()
    defer usd.cacheMutex.Unlock()
    
    usd.cache[serviceName] = instances
}

// 服务发现中间件
type DiscoveryMiddleware struct {
    discovery ServiceDiscovery
}

func NewDiscoveryMiddleware(discovery ServiceDiscovery) *DiscoveryMiddleware {
    return &DiscoveryMiddleware{discovery: discovery}
}

func (dm *DiscoveryMiddleware) GetServiceInstance(serviceName string) (*ServiceInstance, error) {
    instances, err := dm.discovery.Discover(serviceName)
    if err != nil {
        return nil, err
    }
    
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances found for service %s", serviceName)
    }
    
    // 简单的负载均衡：随机选择
    index := rand.Intn(len(instances))
    return instances[index], nil
}

// 服务调用器
type ServiceCaller struct {
    discovery ServiceDiscovery
    client    *http.Client
}

func NewServiceCaller(discovery ServiceDiscovery) *ServiceCaller {
    return &ServiceCaller{
        discovery: discovery,
        client:    &http.Client{Timeout: 30 * time.Second},
    }
}

func (sc *ServiceCaller) CallService(serviceName, endpoint string, method string, body interface{}) ([]byte, error) {
    // 获取服务实例
    instance, err := sc.discovery.Discover(serviceName)
    if err != nil {
        return nil, err
    }
    
    if len(instance) == 0 {
        return nil, fmt.Errorf("no instances found for service %s", serviceName)
    }
    
    // 负载均衡选择实例
    selectedInstance := instance[0] // 简化处理
    
    // 构造URL
    url := fmt.Sprintf("http://%s:%d%s", selectedInstance[0].Address, selectedInstance[0].Port, endpoint)
    
    // 构造请求
    var reqBody []byte
    if body != nil {
        reqBody, err = json.Marshal(body)
        if err != nil {
            return nil, err
        }
    }
    
    req, err := http.NewRequest(method, url, bytes.NewBuffer(reqBody))
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    // 发送请求
    resp, err := sc.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    return ioutil.ReadAll(resp.Body)
}

// 服务健康检查
type HealthChecker struct {
    discovery ServiceDiscovery
    timeout   time.Duration
}

func NewHealthChecker(discovery ServiceDiscovery) *HealthChecker {
    return &HealthChecker{
        discovery: discovery,
        timeout:   5 * time.Second,
    }
}

func (hc *HealthChecker) CheckService(serviceName string) error {
    instances, err := hc.discovery.Discover(serviceName)
    if err != nil {
        return err
    }
    
    if len(instances) == 0 {
        return fmt.Errorf("no instances found for service %s", serviceName)
    }
    
    // 检查所有实例的健康状态
    var unhealthyInstances []string
    for _, instance := range instances {
        if !hc.isInstanceHealthy(instance) {
            unhealthyInstances = append(unhealthyInstances, instance.ID)
        }
    }
    
    if len(unhealthyInstances) > 0 {
        return fmt.Errorf("unhealthy instances: %v", unhealthyInstances)
    }
    
    return nil
}

func (hc *HealthChecker) isInstanceHealthy(instance *ServiceInstance) bool {
    url := fmt.Sprintf("http://%s:%d/health", instance.Address, instance.Port)
    
    client := &http.Client{Timeout: hc.timeout}
    resp, err := client.Get(url)
    if err != nil {
        return false
    }
    defer resp.Body.Close()
    
    return resp.StatusCode == http.StatusOK
}

// 服务注册发现配置
type DiscoveryConfig struct {
    Type     string            `json:"type"`     // consul, etcd, zookeeper
    Address  string            `json:"address"`  // 服务地址
    RootPath string            `json:"rootPath"` // 根路径
    Options  map[string]string `json:"options"`  // 其他选项
}

// 工厂方法创建服务发现客户端
func NewServiceDiscovery(config *DiscoveryConfig) (ServiceDiscovery, error) {
    switch config.Type {
    case "consul":
        consulClient, err := NewConsulClient(config.Address)
        if err != nil {
            return nil, err
        }
        return &ConsulDiscoveryAdapter{client: consulClient}, nil
        
    case "etcd":
        endpoints := strings.Split(config.Address, ",")
        etcdClient, err := NewEtcdClient(endpoints)
        if err != nil {
            return nil, err
        }
        return &EtcdDiscoveryAdapter{client: etcdClient}, nil
        
    case "zookeeper":
        servers := strings.Split(config.Address, ",")
        zkClient, err := NewZkClient(servers, config.RootPath)
        if err != nil {
            return nil, err
        }
        return &ZkDiscoveryAdapter{client: zkClient}, nil
        
    default:
        return nil, fmt.Errorf("unsupported discovery type: %s", config.Type)
    }
}

// 适配器模式实现
type ConsulDiscoveryAdapter struct {
    client *ConsulClient
}

func (cda *ConsulDiscoveryAdapter) Discover(serviceName string) ([]*ServiceInstance, error) {
    return cda.client.DiscoverServices(serviceName, "")
}

func (cda *ConsulDiscoveryAdapter) Watch(serviceName string, handler func([]*ServiceInstance)) error {
    // Consul的Watch实现
    return nil
}

type EtcdDiscoveryAdapter struct {
    client *EtcdClient
}

func (eda *EtcdDiscoveryAdapter) Discover(serviceName string) ([]*ServiceInstance, error) {
    return eda.client.DiscoverServices(serviceName)
}

func (eda *EtcdDiscoveryAdapter) Watch(serviceName string, handler func([]*ServiceInstance)) error {
    return eda.client.WatchServices(serviceName, handler)
}

type ZkDiscoveryAdapter struct {
    client *ZkClient
}

func (zda *ZkDiscoveryAdapter) Discover(serviceName string) ([]*ServiceInstance, error) {
    return zda.client.DiscoverServices(serviceName)
}

func (zda *ZkDiscoveryAdapter) Watch(serviceName string, handler func([]*ServiceInstance)) error {
    return zda.client.WatchServices(serviceName, handler)
}

// 使用示例
func main() {
    // 配置服务发现
    config := &DiscoveryConfig{
        Type:    "consul",
        Address: "localhost:8500",
    }
    
    discovery, err := NewServiceDiscovery(config)
    if err != nil {
        log.Fatalf("Failed to create service discovery: %v", err)
    }
    
    // 创建统一服务发现客户端
    unifiedDiscovery := NewUnifiedServiceDiscovery(discovery, discovery)
    
    // 服务注册
    serviceReg := &ServiceRegistration{
        ID:      "user-service-1",
        Name:    "user-service",
        Address: "localhost",
        Port:    8080,
    }
    
    if err := unifiedDiscovery.Register(serviceReg); err != nil {
        log.Fatalf("Failed to register service: %v", err)
    }
    
    // 服务发现
    instances, err := unifiedDiscovery.Discover("user-service")
    if err != nil {
        log.Printf("Failed to discover services: %v", err)
    } else {
        log.Printf("Found %d instances", len(instances))
        for _, instance := range instances {
            log.Printf("Instance: %s - %s:%d", instance.ID, instance.Address, instance.Port)
        }
    }
    
    // 服务调用
    caller := NewServiceCaller(unifiedDiscovery)
    resp, err := caller.CallService("user-service", "/api/users", "GET", nil)
    if err != nil {
        log.Printf("Failed to call service: %v", err)
    } else {
        log.Printf("Service response: %s", string(resp))
    }
    
    // 健康检查
    healthChecker := NewHealthChecker(unifiedDiscovery)
    if err := healthChecker.CheckService("user-service"); err != nil {
        log.Printf("Service health check failed: %v", err)
    } else {
        log.Println("Service is healthy")
    }
    
    // 保持程序运行
    select {}
}
```

### 负载均衡策略

```go
// 负载均衡策略接口
type LoadBalancer interface {
    Select(instances []*ServiceInstance) (*ServiceInstance, error)
}

// 轮询负载均衡
type RoundRobinLoadBalancer struct {
    currentIndex int
    mutex        sync.Mutex
}

func (rr *RoundRobinLoadBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    rr.mutex.Lock()
    defer rr.mutex.Unlock()
    
    instance := instances[rr.currentIndex%len(instances)]
    rr.currentIndex++
    
    return instance, nil
}

// 随机负载均衡
type RandomLoadBalancer struct{}

func (r *RandomLoadBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    index := rand.Intn(len(instances))
    return instances[index], nil
}

// 加权轮询负载均衡
type WeightedRoundRobinLoadBalancer struct {
    currentIndex int
    currentWeight int
    mutex        sync.Mutex
}

func (wrr *WeightedRoundRobinLoadBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    wrr.mutex.Lock()
    defer wrr.mutex.Unlock()
    
    // 获取最大权重
    maxWeight := 0
    for _, instance := range instances {
        weight := wrr.getInstanceWeight(instance)
        if weight > maxWeight {
            maxWeight = weight
        }
    }
    
    if maxWeight == 0 {
        // 如果没有权重，使用普通轮询
        index := wrr.currentIndex % len(instances)
        wrr.currentIndex++
        return instances[index], nil
    }
    
    // 加权轮询算法
    for {
        wrr.currentIndex = (wrr.currentIndex + 1) % len(instances)
        if wrr.currentIndex == 0 {
            wrr.currentWeight = wrr.currentWeight - 1
            if wrr.currentWeight <= 0 {
                wrr.currentWeight = maxWeight
                if wrr.currentWeight == 0 {
                    return instances[0], nil
                }
            }
        }
        
        instance := instances[wrr.currentIndex]
        weight := wrr.getInstanceWeight(instance)
        if weight >= wrr.currentWeight {
            return instance, nil
        }
    }
}

func (wrr *WeightedRoundRobinLoadBalancer) getInstanceWeight(instance *ServiceInstance) int {
    if instance.Meta != nil {
        if weightStr, exists := instance.Meta["weight"]; exists {
            if weight, err := strconv.Atoi(weightStr); err == nil {
                return weight
            }
        }
    }
    return 1 // 默认权重
}

// 最少连接负载均衡
type LeastConnectionsLoadBalancer struct {
    connections map[string]int
    mutex       sync.RWMutex
}

func NewLeastConnectionsLoadBalancer() *LeastConnectionsLoadBalancer {
    return &LeastConnectionsLoadBalancer{
        connections: make(map[string]int),
    }
}

func (lc *LeastConnectionsLoadBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    lc.mutex.RLock()
    defer lc.mutex.RUnlock()
    
    var minInstance *ServiceInstance
    minConnections := -1
    
    for _, instance := range instances {
        connections := lc.connections[instance.ID]
        if minConnections == -1 || connections < minConnections {
            minConnections = connections
            minInstance = instance
        }
    }
    
    return minInstance, nil
}

func (lc *LeastConnectionsLoadBalancer) AddConnection(instanceID string) {
    lc.mutex.Lock()
    defer lc.mutex.Unlock()
    
    lc.connections[instanceID]++
}

func (lc *LeastConnectionsLoadBalancer) RemoveConnection(instanceID string) {
    lc.mutex.Lock()
    defer lc.mutex.Unlock()
    
    if connections, exists := lc.connections[instanceID]; exists && connections > 0 {
        lc.connections[instanceID] = connections - 1
    }
}

// 哈希负载均衡
type HashLoadBalancer struct {
    hashFunc func(string) uint32
}

func NewHashLoadBalancer(hashFunc func(string) uint32) *HashLoadBalancer {
    if hashFunc == nil {
        hashFunc = func(s string) uint32 {
            h := fnv.New32a()
            h.Write([]byte(s))
            return h.Sum32()
        }
    }
    
    return &HashLoadBalancer{hashFunc: hashFunc}
}

func (h *HashLoadBalancer) Select(instances []*ServiceInstance, key string) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    hash := h.hashFunc(key)
    index := int(hash) % len(instances)
    
    return instances[index], nil
}

// 响应时间加权负载均衡
type ResponseTimeLoadBalancer struct {
    responseTimes map[string]*movingAverage
    mutex         sync.RWMutex
}

type movingAverage struct {
    values []float64
    sum    float64
    size   int
    maxSize int
}

func newMovingAverage(maxSize int) *movingAverage {
    return &movingAverage{
        values:  make([]float64, 0, maxSize),
        maxSize: maxSize,
    }
}

func (ma *movingAverage) Add(value float64) {
    if len(ma.values) >= ma.maxSize {
        // 移除最旧的值
        ma.sum -= ma.values[0]
        ma.values = ma.values[1:]
    }
    
    ma.values = append(ma.values, value)
    ma.sum += value
}

func (ma *movingAverage) Average() float64 {
    if len(ma.values) == 0 {
        return 0
    }
    return ma.sum / float64(len(ma.values))
}

func NewResponseTimeLoadBalancer() *ResponseTimeLoadBalancer {
    return &ResponseTimeLoadBalancer{
        responseTimes: make(map[string]*movingAverage),
    }
}

func (rt *ResponseTimeLoadBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    rt.mutex.RLock()
    defer rt.mutex.RUnlock()
    
    var bestInstance *ServiceInstance
    bestTime := -1.0
    
    for _, instance := range instances {
        if avgTime, exists := rt.responseTimes[instance.ID]; exists {
            currentAvg := avgTime.Average()
            if bestTime == -1.0 || currentAvg < bestTime {
                bestTime = currentAvg
                bestInstance = instance
            }
        } else {
            // 如果没有历史数据，优先选择
            return instance, nil
        }
    }
    
    if bestInstance != nil {
        return bestInstance, nil
    }
    
    // 如果所有实例都没有历史数据，随机选择
    index := rand.Intn(len(instances))
    return instances[index], nil
}

func (rt *ResponseTimeLoadBalancer) RecordResponseTime(instanceID string, responseTime time.Duration) {
    rt.mutex.Lock()
    defer rt.mutex.Unlock()
    
    avgTime, exists := rt.responseTimes[instanceID]
    if !exists {
        avgTime = newMovingAverage(10) // 保存最近10次的数据
        rt.responseTimes[instanceID] = avgTime
    }
    
    avgTime.Add(float64(responseTime.Milliseconds()))
}

// 自适应负载均衡器
type AdaptiveLoadBalancer struct {
    strategy LoadBalancer
    metrics  MetricsCollector
    mutex    sync.RWMutex
}

func NewAdaptiveLoadBalancer(strategy LoadBalancer, metrics MetricsCollector) *AdaptiveLoadBalancer {
    return &AdaptiveLoadBalancer{
        strategy: strategy,
        metrics:  metrics,
    }
}

func (alb *AdaptiveLoadBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available")
    }
    
    // 根据指标动态调整策略
    alb.mutex.RLock()
    defer alb.mutex.RUnlock()
    
    // 过滤不健康的实例
    var healthyInstances []*ServiceInstance
    for _, instance := range instances {
        if alb.isInstanceHealthy(instance) {
            healthyInstances = append(healthyInstances, instance)
        }
    }
    
    if len(healthyInstances) == 0 {
        return nil, fmt.Errorf("no healthy instances available")
    }
    
    return alb.strategy.Select(healthyInstances)
}

func (alb *AdaptiveLoadBalancer) isInstanceHealthy(instance *ServiceInstance) bool {
    // 检查实例健康状态
    // 可以结合服务发现的健康检查结果
    return true // 简化处理
}

// 负载均衡器工厂
type LoadBalancerFactory struct {
    config map[string]interface{}
}

func NewLoadBalancerFactory(config map[string]interface{}) *LoadBalancerFactory {
    return &LoadBalancerFactory{config: config}
}

func (lf *LoadBalancerFactory) CreateLoadBalancer(strategy string) (LoadBalancer, error) {
    switch strategy {
    case "round_robin":
        return &RoundRobinLoadBalancer{}, nil
    case "random":
        return &RandomLoadBalancer{}, nil
    case "weighted_round_robin":
        return &WeightedRoundRobinLoadBalancer{}, nil
    case "least_connections":
        return NewLeastConnectionsLoadBalancer(), nil
    case "response_time":
        return NewResponseTimeLoadBalancer(), nil
    default:
        return &RoundRobinLoadBalancer{}, nil
    }
}

// 使用示例
func main() {
    // 创建不同的负载均衡器
    roundRobin := &RoundRobinLoadBalancer{}
    random := &RandomLoadBalancer{}
    weighted := &WeightedRoundRobinLoadBalancer{}
    leastConn := NewLeastConnectionsLoadBalancer()
    responseTime := NewResponseTimeLoadBalancer()
    
    // 模拟服务实例
    instances := []*ServiceInstance{
        {ID: "instance-1", Address: "192.168.1.10", Port: 8080},
        {ID: "instance-2", Address: "192.168.1.11", Port: 8080},
        {ID: "instance-3", Address: "192.168.1.12", Port: 8080},
    }
    
    // 设置实例权重
    instances[0].Meta = map[string]string{"weight": "3"}
    instances[1].Meta = map[string]string{"weight": "2"}
    instances[2].Meta = map[string]string{"weight": "1"}
    
    // 测试不同的负载均衡策略
    log.Println("Testing Round Robin:")
    for i := 0; i < 6; i++ {
        instance, _ := roundRobin.Select(instances)
        log.Printf("Selected: %s", instance.ID)
    }
    
    log.Println("\nTesting Random:")
    for i := 0; i < 6; i++ {
        instance, _ := random.Select(instances)
        log.Printf("Selected: %s", instance.ID)
    }
    
    log.Println("\nTesting Weighted Round Robin:")
    for i := 0; i < 6; i++ {
        instance, _ := weighted.Select(instances)
        log.Printf("Selected: %s", instance.ID)
    }
    
    // 测试最少连接
    leastConn.AddConnection("instance-1")
    leastConn.AddConnection("instance-1")
    leastConn.AddConnection("instance-2")
    
    log.Println("\nTesting Least Connections:")
    for i := 0; i < 3; i++ {
        instance, _ := leastConn.Select(instances)
        log.Printf("Selected: %s", instance.ID)
        leastConn.AddConnection(instance.ID)
    }
    
    // 测试响应时间
    responseTime.RecordResponseTime("instance-1", 100*time.Millisecond)
    responseTime.RecordResponseTime("instance-2", 200*time.Millisecond)
    responseTime.RecordResponseTime("instance-3", 50*time.Millisecond)
    
    log.Println("\nTesting Response Time:")
    for i := 0; i < 3; i++ {
        instance, _ := responseTime.Select(instances)
        log.Printf("Selected: %s", instance.ID)
    }
}
```

### 健康检查机制

```go
// 健康检查机制实现
import (
    "context"
    "fmt"
    "log"
    "net/http"
    "sync"
    "time"
)

// 健康检查接口
type HealthChecker interface {
    Name() string
    Check(ctx context.Context) error
}

// 健康检查结果
type HealthCheckResult struct {
    Name      string
    Status    HealthStatus
    Error     error
    Timestamp time.Time
}

type HealthStatus string

const (
    StatusHealthy   HealthStatus = "healthy"
    StatusUnhealthy HealthStatus = "unhealthy"
    StatusUnknown   HealthStatus = "unknown"
)

// HTTP健康检查器
type HTTPHealthChecker struct {
    name     string
    url      string
    timeout  time.Duration
    client   *http.Client
}

func NewHTTPHealthChecker(name, url string, timeout time.Duration) *HTTPHealthChecker {
    return &HTTPHealthChecker{
        name:    name,
        url:     url,
        timeout: timeout,
        client: &http.Client{
            Timeout: timeout,
        },
    }
}

func (hhc *HTTPHealthChecker) Name() string {
    return hhc.name
}

func (hhc *HTTPHealthChecker) Check(ctx context.Context) error {
    req, err := http.NewRequestWithContext(ctx, "GET", hhc.url, nil)
    if err != nil {
        return err
    }
    
    resp, err := hhc.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode >= 200 && resp.StatusCode < 300 {
        return nil
    }
    
    return fmt.Errorf("HTTP status: %d", resp.StatusCode)
}

// TCP健康检查器
type TCPHealthChecker struct {
    name    string
    address string
    timeout time.Duration
}

func NewTCPHealthChecker(name, address string, timeout time.Duration) *TCPHealthChecker {
    return &TCPHealthChecker{
        name:    name,
        address: address,
        timeout: timeout,
    }
}

func (thc *TCPHealthChecker) Name() string {
    return thc.name
}

func (thc *TCPHealthChecker) Check(ctx context.Context) error {
    conn, err := net.DialTimeout("tcp", thc.address, thc.timeout)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    return nil
}

// 数据库健康检查器
type DatabaseHealthChecker struct {
    name string
    db   *sql.DB
}

func NewDatabaseHealthChecker(name string, db *sql.DB) *DatabaseHealthChecker {
    return &DatabaseHealthChecker{
        name: name,
        db:   db,
    }
}

func (dhc *DatabaseHealthChecker) Name() string {
    return dhc.name
}

func (dhc *DatabaseHealthChecker) Check(ctx context.Context) error {
    return dhc.db.PingContext(ctx)
}

// Redis健康检查器
type RedisHealthChecker struct {
    name   string
    client *redis.Client
}

func NewRedisHealthChecker(name string, client *redis.Client) *RedisHealthChecker {
    return &RedisHealthChecker{
        name:   name,
        client: client,
    }
}

func (rhc *RedisHealthChecker) Name() string {
    return rhc.name
}

func (rhc *RedisHealthChecker) Check(ctx context.Context) error {
    return rhc.client.Ping(ctx).Err()
}

// 自定义健康检查器
type CustomHealthChecker struct {
    name string
    fn   func(context.Context) error
}

func NewCustomHealthChecker(name string, fn func(context.Context) error) *CustomHealthChecker {
    return &CustomHealthChecker{
        name: name,
        fn:   fn,
    }
}

func (chc *CustomHealthChecker) Name() string {
    return chc.name
}

func (chc *CustomHealthChecker) Check(ctx context.Context) error {
    return chc.fn(ctx)
}

// 健康检查管理器
type HealthCheckManager struct {
    checkers []HealthChecker
    results  map[string]*HealthCheckResult
    mutex    sync.RWMutex
    interval time.Duration
    stopCh   chan struct{}
}

func NewHealthCheckManager(interval time.Duration) *HealthCheckManager {
    return &HealthCheckManager{
        checkers: make([]HealthChecker, 0),
        results:  make(map[string]*HealthCheckResult),
        interval: interval,
        stopCh:   make(chan struct{}),
    }
}

func (hcm *HealthCheckManager) AddChecker(checker HealthChecker) {
    hcm.mutex.Lock()
    defer hcm.mutex.Unlock()
    
    hcm.checkers = append(hcm.checkers, checker)
}

func (hcm *HealthCheckManager) RemoveChecker(name string) {
    hcm.mutex.Lock()
    defer hcm.mutex.Unlock()
    
    for i, checker := range hcm.checkers {
        if checker.Name() == name {
            hcm.checkers = append(hcm.checkers[:i], hcm.checkers[i+1:]...)
            delete(hcm.results, name)
            break
        }
    }
}

func (hcm *HealthCheckManager) Start() {
    go hcm.runChecks()
}

func (hcm *HealthCheckManager) Stop() {
    close(hcm.stopCh)
}

func (hcm *HealthCheckManager) runChecks() {
    ticker := time.NewTicker(hcm.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-hcm.stopCh:
            return
        case <-ticker.C:
            hcm.performChecks()
        }
    }
}

func (hcm *HealthCheckManager) performChecks() {
    hcm.mutex.RLock()
    checkers := make([]HealthChecker, len(hcm.checkers))
    copy(checkers, hcm.checkers)
    hcm.mutex.RUnlock()
    
    var wg sync.WaitGroup
    results := make(chan *HealthCheckResult, len(checkers))
    
    // 并行执行健康检查
    for _, checker := range checkers {
        wg.Add(1)
        go func(c HealthChecker) {
            defer wg.Done()
            
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
            defer cancel()
            
            start := time.Now()
            err := c.Check(ctx)
            duration := time.Since(start)
            
            result := &HealthCheckResult{
                Name:      c.Name(),
                Timestamp: time.Now(),
            }
            
            if err != nil {
                result.Status = StatusUnhealthy
                result.Error = err
                log.Printf("Health check failed for %s: %v (duration: %v)", c.Name(), err, duration)
            } else {
                result.Status = StatusHealthy
                log.Printf("Health check passed for %s (duration: %v)", c.Name(), duration)
            }
            
            results <- result
        }(checker)
    }
    
    // 等待所有检查完成
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // 收集结果
    hcm.mutex.Lock()
    for result := range results {
        hcm.results[result.Name] = result
    }
    hcm.mutex.Unlock()
}

func (hcm *HealthCheckManager) GetResult(name string) *HealthCheckResult {
    hcm.mutex.RLock()
    defer hcm.mutex.RUnlock()
    
    if result, exists := hcm.results[name]; exists {
        return result
    }
    
    return nil
}

func (hcm *HealthCheckManager) GetAllResults() map[string]*HealthCheckResult {
    hcm.mutex.RLock()
    defer hcm.mutex.RUnlock()
    
    results := make(map[string]*HealthCheckResult)
    for name, result := range hcm.results {
        results[name] = result
    }
    
    return results
}

func (hcm *HealthCheckManager) IsHealthy(name string) bool {
    result := hcm.GetResult(name)
    return result != nil && result.Status == StatusHealthy
}

func (hcm *HealthCheckManager) OverallHealth() HealthStatus {
    hcm.mutex.RLock()
    defer hcm.mutex.RUnlock()
    
    if len(hcm.results) == 0 {
        return StatusUnknown
    }
    
    for _, result := range hcm.results {
        if result.Status != StatusHealthy {
            return StatusUnhealthy
        }
    }
    
    return StatusHealthy
}

// 健康检查HTTP端点
func (hcm *HealthCheckManager) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    results := hcm.GetAllResults()
    
    response := struct {
        Status   HealthStatus                    `json:"status"`
        Checks   map[string]*HealthCheckResult   `json:"checks"`
        Timestamp time.Time                      `json:"timestamp"`
    }{
        Status:    hcm.OverallHealth(),
        Checks:    results,
        Timestamp: time.Now(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    
    if response.Status == StatusHealthy {
        w.WriteHeader(http.StatusOK)
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
    }
    
    json.NewEncoder(w).Encode(response)
}

// 健康检查通知器
type HealthNotifier struct {
    handlers []HealthNotificationHandler
    mutex    sync.RWMutex
}

type HealthNotificationHandler func(*HealthCheckResult)

func NewHealthNotifier() *HealthNotifier {
    return &HealthNotifier{
        handlers: make([]HealthNotificationHandler, 0),
    }
}

func (hn *HealthNotifier) AddHandler(handler HealthNotificationHandler) {
    hn.mutex.Lock()
    defer hn.mutex.Unlock()
    
    hn.handlers = append(hn.handlers, handler)
}

func (hn *HealthNotifier) RemoveHandler(handler HealthNotificationHandler) {
    hn.mutex.Lock()
    defer hn.mutex.Unlock()
    
    for i, h := range hn.handlers {
        if fmt.Sprintf("%p", h) == fmt.Sprintf("%p", handler) {
            hn.handlers = append(hn.handlers[:i], hn.handlers[i+1:]...)
            break
        }
    }
}

func (hn *HealthNotifier) Notify(result *HealthCheckResult) {
    hn.mutex.RLock()
    defer hn.mutex.RUnlock()
    
    for _, handler := range hn.handlers {
        go handler(result) // 异步通知
    }
}

// 邮件通知处理器
type EmailNotifier struct {
    smtpServer string
    from       string
    to         []string
    subject    string
}

func NewEmailNotifier(smtpServer, from string, to []string, subject string) *EmailNotifier {
    return &EmailNotifier{
        smtpServer: smtpServer,
        from:       from,
        to:         to,
        subject:    subject,
    }
}

func (en *EmailNotifier) Handle(result *HealthCheckResult) {
    if result.Status == StatusUnhealthy {
        // 发送告警邮件
        message := fmt.Sprintf("Service %s is unhealthy: %v", result.Name, result.Error)
        // 实际邮件发送逻辑...
        log.Printf("Sending alert email: %s", message)
    }
}

// Slack通知处理器
type SlackNotifier struct {
    webhookURL string
}

func NewSlackNotifier(webhookURL string) *SlackNotifier {
    return &SlackNotifier{webhookURL: webhookURL}
}

func (sn *SlackNotifier) Handle(result *HealthCheckResult) {
    if result.Status == StatusUnhealthy {
        // 发送Slack通知
        message := fmt.Sprintf("Service %s is unhealthy: %v", result.Name, result.Error)
        // 实际Slack发送逻辑...
        log.Printf("Sending Slack alert: %s", message)
    }
}

// 健康检查指标收集器
type HealthMetricsCollector struct {
    metrics MetricsCollector
}

func NewHealthMetricsCollector(metrics MetricsCollector) *HealthMetricsCollector {
    return &HealthMetricsCollector{metrics: metrics}
}

func (hmc *HealthMetricsCollector) Handle(result *HealthCheckResult) {
    labels := map[string]string{
        "service": result.Name,
        "status":  string(result.Status),
    }
    
    // 记录健康检查次数
    hmc.metrics.IncCounter("health_checks_total", labels)
    
    if result.Status == StatusUnhealthy {
        // 记录失败次数
        hmc.metrics.IncCounter("health_check_failures_total", labels)
    }
}

// 使用示例
func main() {
    // 创建健康检查管理器
    manager := NewHealthCheckManager(30 * time.Second)
    
    // 添加各种健康检查器
    manager.AddChecker(NewHTTPHealthChecker("user-service", "http://localhost:8080/health", 5*time.Second))
    manager.AddChecker(NewTCPHealthChecker("database", "localhost:5432", 3*time.Second))
    manager.AddChecker(NewHTTPHealthChecker("redis", "http://localhost:6379/ping", 2*time.Second))
    
    // 添加自定义健康检查
    manager.AddChecker(NewCustomHealthChecker("disk-space", func(ctx context.Context) error {
        // 检查磁盘空间
        // 实际实现...
        return nil
    }))
    
    // 创建通知器
    notifier := NewHealthNotifier()
    
    // 添加通知处理器
    emailNotifier := NewEmailNotifier("smtp.example.com:587", "alert@example.com", 
        []string{"admin@example.com"}, "Service Health Alert")
    notifier.AddHandler(emailNotifier.Handle)
    
    slackNotifier := NewSlackNotifier("https://hooks.slack.com/services/...")
    notifier.AddHandler(slackNotifier.Handle)
    
    // 添加指标收集
    metricsCollector := NewHealthMetricsCollector(NewPrometheusMetricsCollector())
    notifier.AddHandler(metricsCollector.Handle)
    
    // 启动健康检查
    manager.Start()
    defer manager.Stop()
    
    // 创建HTTP服务器提供健康检查端点
    http.Handle("/health", manager)
    http.HandleFunc("/health/details", func(w http.ResponseWriter, r *http.Request) {
        results := manager.GetAllResults()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(results)
    })
    
    log.Println("Health check server starting on :8081")
    if err := http.ListenAndServe(":8081", nil); err != nil {
        log.Fatalf("Failed to start health check server: %v", err)
    }
}
```