## 8.5 构建和部署

### 编译选项

```go
// build.go
package main

import (
    "fmt"
    "runtime"
)

var (
    Version   = "dev"
    Commit    = "none"
    Date      = "unknown"
    BuildUser = "unknown"
)

func main() {
    fmt.Printf("Version: %s\n", Version)
    fmt.Printf("Commit: %s\n", Commit)
    fmt.Printf("Build Date: %s\n", Date)
    fmt.Printf("Build User: %s\n", BuildUser)
    fmt.Printf("Go Version: %s\n", runtime.Version())
    fmt.Printf("OS/Arch: %s/%s\n", runtime.GOOS, runtime.GOARCH)
}
```

```bash
# 基本编译
go build -o myapp main.go

# 带版本信息编译
go build -ldflags "-X main.Version=1.0.0 -X main.Commit=$(git rev-parse HEAD) -X main.Date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" -o myapp main.go

# 优化编译
go build -ldflags="-s -w" -o myapp main.go

# 静态链接编译
CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-extldflags "-static"' -o myapp main.go

# 编译选项说明
# -ldflags: 链接器标志
# -s: 去除符号表
# -w: 去除调试信息
# -X: 设置变量值
# -a: 强制重新编译所有包
# -extldflags: 传递给外部链接器的标志
```

### 交叉编译

```bash
# 交叉编译脚本
#!/bin/bash

# 设置编译环境
export CGO_ENABLED=0
export GOOS=linux
export GOARCH=amd64

# 编译不同平台的版本
platforms=(
    "darwin/amd64"
    "darwin/arm64"
    "linux/amd64"
    "linux/arm64"
    "windows/amd64"
    "windows/386"
)

for platform in "${platforms[@]}"
do
    platform_split=(${platform//\// })
    GOOS=${platform_split[0]}
    GOARCH=${platform_split[1]}
    
    output_name="myapp-${GOOS}-${GOARCH}"
    if [ $GOOS = "windows" ]; then
        output_name+=".exe"
    fi
    
    echo "编译 $GOOS/$GOARCH..."
    env GOOS=$GOOS GOARCH=$GOARCH go build -o $output_name
    if [ $? -ne 0 ]; then
        echo "编译失败 $GOOS/$GOARCH"
        exit 1
    fi
done

echo "所有平台编译完成"
```

### 构建脚本编写

```bash
#!/bin/bash
# build.sh

set -e

# 配置变量
APP_NAME="myapp"
VERSION=${1:-"dev"}
COMMIT=$(git rev-parse HEAD)
DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
BUILD_USER=$(whoami)

# 构建函数
build() {
    local os=$1
    local arch=$2
    local output_name=$3
    
    echo "构建 $os/$arch..."
    
    env CGO_ENABLED=0 GOOS=$os GOARCH=$arch go build \
        -ldflags "-X main.Version=$VERSION -X main.Commit=$COMMIT -X main.Date=$DATE -X main.BuildUser=$BUILD_USER -s -w" \
        -o $output_name \
        .
}

# 清理函数
clean() {
    rm -f myapp-*
    rm -f myapp
}

# 主构建流程
main() {
    clean
    
    # 构建当前平台
    go build -ldflags "-X main.Version=$VERSION -X main.Commit=$COMMIT -X main.Date=$DATE -X main.BuildUser=$BUILD_USER" -o $APP_NAME .
    
    # 构建多平台版本
    build linux amd64 "${APP_NAME}-linux-amd64"
    build linux arm64 "${APP_NAME}-linux-arm64"
    build darwin amd64 "${APP_NAME}-darwin-amd64"
    build darwin arm64 "${APP_NAME}-darwin-arm64"
    build windows amd64 "${APP_NAME}-windows-amd64.exe"
    
    echo "构建完成"
    ls -la myapp*
}

# 运行主函数
main
```

### Docker容器化部署

```dockerfile
# Dockerfile
FROM golang:1.19-alpine AS builder

# 设置工作目录
WORKDIR /app

# 复制go.mod和go.sum
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-extldflags "-static"' -o myapp .

# 生产阶段
FROM alpine:latest

# 安装ca-certificates
RUN apk --no-cache add ca-certificates

# 创建非root用户
RUN adduser -D -s /bin/sh appuser

# 设置工作目录
WORKDIR /app

# 从builder阶段复制二进制文件
COPY --from=builder /app/myapp .

# 复制配置文件
COPY --from=builder /app/config/ ./config/

# 更改文件所有者
RUN chown -R appuser:appuser /app

# 切换到非root用户
USER appuser

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 启动命令
CMD ["./myapp"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - PORT=8080
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app

volumes:
  postgres_data:
  redis_data:
```

### CI/CD集成

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.19
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download dependencies
      run: go mod download
    
    - name: Run tests
      run: |
        go test -v -race -coverprofile=coverage.out ./...
        go tool cover -func=coverage.out
    
    - name: Build
      run: go build -v ./...

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.19
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ secrets.DOCKER_USERNAME }}/myapp
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push
      uses: docker/build-push-action@v4
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Deploy to Kubernetes
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl set image deployment/myapp myapp=${{ secrets.DOCKER_USERNAME }}/myapp:${{ github.sha }}
```

### 镜像优化

```dockerfile
# 多阶段构建优化
FROM golang:1.19-alpine AS base
RUN apk add --no-cache ca-certificates tzdata
WORKDIR /app

FROM base AS builder
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-s -w -extldflags "-static"' -o myapp .

# 最小运行时镜像
FROM scratch
COPY --from=base /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=base /usr/share/zoneinfo /usr/share/zoneinfo
COPY --from=builder /app/myapp /myapp

# 创建必要的目录和用户
COPY --from=builder /etc/passwd /etc/passwd
COPY --from=builder /etc/group /etc/group

USER nobody:nobody
EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/myapp", "--health-check"]

ENTRYPOINT ["/myapp"]
```

### 部署策略

```yaml
# kubernetes/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8080
        env:
        - name: PORT
          value: "8080"
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
```

### 监控告警

```go
// monitoring/metrics.go
package monitoring

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    httpRequestDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
        Name: "http_request_duration_seconds",
        Help: "Duration of HTTP requests",
    }, []string{"method", "endpoint", "status"})

    httpRequestTotal = promauto.NewCounterVec(prometheus.CounterOpts{
        Name: "http_requests_total",
        Help: "Total number of HTTP requests",
    }, []string{"method", "endpoint", "status"})

    activeConnections = promauto.NewGauge(prometheus.GaugeOpts{
        Name: "active_connections",
        Help: "Number of active connections",
    })

    databaseQueryDuration = promauto.NewHistogram(prometheus.HistogramOpts{
        Name: "database_query_duration_seconds",
        Help: "Duration of database queries",
    })
)

// 使用示例
func RecordHTTPRequest(method, endpoint, status string, duration float64) {
    httpRequestDuration.WithLabelValues(method, endpoint, status).Observe(duration)
    httpRequestTotal.WithLabelValues(method, endpoint, status).Inc()
}

func SetActiveConnections(count float64) {
    activeConnections.Set(count)
}

func RecordDatabaseQuery(duration float64) {
    databaseQueryDuration.Observe(duration)
}
```

```yaml
# prometheus/alerts.yml
groups:
- name: app-alerts
  rules:
  - alert: HighErrorRate
    expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: "High error rate on {{ $labels.endpoint }}"
      description: "{{ $value }}% of requests are failing"

  - alert: HighLatency
    expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High latency on {{ $labels.endpoint }}"
      description: "95th percentile latency is {{ $value }} seconds"
```