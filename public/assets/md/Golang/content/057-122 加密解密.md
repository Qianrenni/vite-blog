## 12.2 加密解密

### 哈希算法

#### 哈希算法实现
```go
package main

import (
    "crypto/hmac"
    "crypto/md5"
    "crypto/sha1"
    "crypto/sha256"
    "crypto/sha512"
    "encoding/base64"
    "encoding/hex"
    "fmt"
    "hash"
    "time"
    
    "golang.org/x/crypto/argon2"
    "golang.org/x/crypto/bcrypt"
    "golang.org/x/crypto/pbkdf2"
    "golang.org/x/crypto/scrypt"
)

// 哈希算法接口
type Hasher interface {
    Hash(data []byte) ([]byte, error)
    Verify(data, hash []byte) bool
}

// MD5哈希
type MD5Hasher struct{}

func (m *MD5Hasher) Hash(data []byte) ([]byte, error) {
    hash := md5.Sum(data)
    return hash[:], nil
}

func (m *MD5Hasher) Verify(data, hash []byte) bool {
    computedHash, _ := m.Hash(data)
    return hmac.Equal(computedHash, hash)
}

// SHA1哈希
type SHA1Hasher struct{}

func (s *SHA1Hasher) Hash(data []byte) ([]byte, error) {
    hash := sha1.Sum(data)
    return hash[:], nil
}

func (s *SHA1Hasher) Verify(data, hash []byte) bool {
    computedHash, _ := s.Hash(data)
    return hmac.Equal(computedHash, hash)
}

// SHA256哈希
type SHA256Hasher struct{}

func (s *SHA256Hasher) Hash(data []byte) ([]byte, error) {
    hash := sha256.Sum256(data)
    return hash[:], nil
}

func (s *SHA256Hasher) Verify(data, hash []byte) bool {
    computedHash, _ := s.Hash(data)
    return hmac.Equal(computedHash, hash)
}

// HMAC-SHA256
type HMACSHA256Hasher struct {
    key []byte
}

func NewHMACSHA256Hasher(key []byte) *HMACSHA256Hasher {
    return &HMACSHA256Hasher{key: key}
}

func (h *HMACSHA256Hasher) Hash(data []byte) ([]byte, error) {
    mac := hmac.New(sha256.New, h.key)
    mac.Write(data)
    return mac.Sum(nil), nil
}

func (h *HMACSHA256Hasher) Verify(data, hash []byte) bool {
    computedHash, _ := h.Hash(data)
    return hmac.Equal(computedHash, hash)
}

// PBKDF2密码哈希
type PBKDF2Hasher struct {
    salt     []byte
    iterations int
    keyLen   int
    hashFunc func() hash.Hash
}

func NewPBKDF2Hasher(salt []byte, iterations, keyLen int, hashFunc func() hash.Hash) *PBKDF2Hasher {
    return &PBKDF2Hasher{
        salt:       salt,
        iterations: iterations,
        keyLen:     keyLen,
        hashFunc:   hashFunc,
    }
}

func (p *PBKDF2Hasher) Hash(password []byte) ([]byte, error) {
    return pbkdf2.Key(password, p.salt, p.iterations, p.keyLen, p.hashFunc), nil
}

func (p *PBKDF2Hasher) Verify(password, hash []byte) bool {
    computedHash, _ := p.Hash(password)
    return hmac.Equal(computedHash, hash)
}

// Scrypt密码哈希
type ScryptHasher struct {
    salt       []byte
    n, r, p    int
    keyLen     int
}

func NewScryptHasher(salt []byte, n, r, p, keyLen int) *ScryptHasher {
    return &ScryptHasher{
        salt:   salt,
        n:      n,
        r:      r,
        p:      p,
        keyLen: keyLen,
    }
}

func (s *ScryptHasher) Hash(password []byte) ([]byte, error) {
    return scrypt.Key(password, s.salt, s.n, s.r, s.p, s.keyLen)
}

func (s *ScryptHasher) Verify(password, hash []byte) bool {
    computedHash, _ := s.Hash(password)
    return hmac.Equal(computedHash, hash)
}

// Argon2密码哈希
type Argon2Hasher struct {
    salt        []byte
    time, memory uint32
    threads     uint8
    keyLen      uint32
}

func NewArgon2Hasher(salt []byte, time, memory uint32, threads uint8, keyLen uint32) *Argon2Hasher {
    return &Argon2Hasher{
        salt:    salt,
        time:    time,
        memory:  memory,
        threads: threads,
        keyLen:  keyLen,
    }
}

func (a *Argon2Hasher) Hash(password []byte) ([]byte, error) {
    return argon2.IDKey(password, a.salt, a.time, a.memory, a.threads, a.keyLen), nil
}

func (a *Argon2Hasher) Verify(password, hash []byte) bool {
    computedHash, _ := a.Hash(password)
    return hmac.Equal(computedHash, hash)
}

// 密码哈希管理器
type PasswordHasher struct {
    hasher Hasher
}

func NewPasswordHasher() *PasswordHasher {
    return &PasswordHasher{}
}

// 使用bcrypt哈希密码
func (ph *PasswordHasher) HashPassword(password string) (string, error) {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(hashedPassword), nil
}

// 验证密码
func (ph *PasswordHasher) VerifyPassword(password, hashedPassword string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
    return err == nil
}

// 文件完整性校验
type FileIntegrityChecker struct {
    hasher Hasher
}

func NewFileIntegrityChecker(hasher Hasher) *FileIntegrityChecker {
    return &FileIntegrityChecker{hasher: hasher}
}

func (fic *FileIntegrityChecker) CalculateFileHash(filePath string) (string, error) {
    // 模拟文件读取
    fileData := []byte("sample file content")
    hash, err := fic.hasher.Hash(fileData)
    if err != nil {
        return "", err
    }
    return hex.EncodeToString(hash), nil
}

func (fic *FileIntegrityChecker) VerifyFileIntegrity(filePath, expectedHash string) (bool, error) {
    calculatedHash, err := fic.CalculateFileHash(filePath)
    if err != nil {
        return false, err
    }
    return calculatedHash == expectedHash, nil
}

// 哈希算法性能测试
func BenchmarkHashAlgorithms() {
    testData := []byte("This is test data for hashing algorithms performance comparison")
    
    algorithms := map[string]Hasher{
        "MD5":        &MD5Hasher{},
        "SHA1":       &SHA1Hasher{},
        "SHA256":     &SHA256Hasher{},
        "PBKDF2":     NewPBKDF2Hasher([]byte("salt"), 10000, 32, sha256.New),
        "Scrypt":     NewScryptHasher([]byte("salt"), 16384, 8, 1, 32),
        "Argon2":     NewArgon2Hasher([]byte("salt"), 1, 64*1024, 4, 32),
    }
    
    fmt.Println("哈希算法性能测试:")
    for name, hasher := range algorithms {
        start := time.Now()
        for i := 0; i < 1000; i++ {
            hasher.Hash(testData)
        }
        duration := time.Since(start)
        fmt.Printf("%s: %v (1000 iterations)\n", name, duration)
    }
}

// 哈希算法安全性比较
func HashSecurityComparison() {
    fmt.Println("\n哈希算法安全性比较:")
    securityInfo := map[string]struct {
        SecurityLevel string
        UseCase       string
        Performance   string
    }{
        "MD5": {
            SecurityLevel: "不安全（已破解）",
            UseCase:       "文件校验（非安全场景）",
            Performance:   "非常快",
        },
        "SHA1": {
            SecurityLevel: "不安全（已发现碰撞）",
            UseCase:       "遗留系统兼容",
            Performance:   "快",
        },
        "SHA256": {
            SecurityLevel: "安全",
            UseCase:       "数字签名、证书",
            Performance:   "中等",
        },
        "bcrypt": {
            SecurityLevel: "非常安全",
            UseCase:       "密码存储",
            Performance:   "慢（故意设计）",
        },
        "Argon2": {
            SecurityLevel: "最安全（推荐）",
            UseCase:       "现代密码存储",
            Performance:   "可配置",
        },
    }
    
    for algorithm, info := range securityInfo {
        fmt.Printf("%s:\n", algorithm)
        fmt.Printf("  安全级别: %s\n", info.SecurityLevel)
        fmt.Printf("  适用场景: %s\n", info.UseCase)
        fmt.Printf("  性能特点: %s\n\n", info.Performance)
    }
}

// 哈希算法示例应用
func HashAlgorithmsExample() {
    // 密码哈希示例
    passwordHasher := NewPasswordHasher()
    password := "mySecurePassword123"
    
    // 哈希密码
    hashedPassword, err := passwordHasher.HashPassword(password)
    if err != nil {
        fmt.Printf("密码哈希失败: %v\n", err)
        return
    }
    fmt.Printf("原始密码: %s\n", password)
    fmt.Printf("哈希密码: %s\n", hashedPassword)
    
    // 验证密码
    isValid := passwordHasher.VerifyPassword(password, hashedPassword)
    fmt.Printf("密码验证结果: %t\n", isValid)
    
    // HMAC示例
    hmacKey := []byte("secret-key-for-hmac")
    hmacHasher := NewHMACSHA256Hasher(hmacKey)
    message := []byte("This is a message to sign")
    
    signature, err := hmacHasher.Hash(message)
    if err != nil {
        fmt.Printf("HMAC签名失败: %v\n", err)
        return
    }
    fmt.Printf("消息: %s\n", message)
    fmt.Printf("HMAC签名: %s\n", base64.StdEncoding.EncodeToString(signature))
    
    // 验证签名
    isSignatureValid := hmacHasher.Verify(message, signature)
    fmt.Printf("签名验证结果: %t\n", isSignatureValid)
    
    // 性能测试
    BenchmarkHashAlgorithms()
    
    // 安全性比较
    HashSecurityComparison()
}
```

### 对称加密

#### 对称加密实现
```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "io"
    
    "golang.org/x/crypto/chacha20poly1305"
)

// 对称加密接口
type SymmetricEncryptor interface {
    Encrypt(plaintext []byte) ([]byte, error)
    Decrypt(ciphertext []byte) ([]byte, error)
}

// AES-GCM加密器
type AESGCMEncryptor struct {
    key []byte
}

func NewAESGCMEncryptor(key []byte) (*AESGCMEncryptor, error) {
    if len(key) != 16 && len(key) != 24 && len(key) != 32 {
        return nil, fmt.Errorf("invalid key size: %d bytes", len(key))
    }
    
    return &AESGCMEncryptor{key: key}, nil
}

func (a *AESGCMEncryptor) Encrypt(plaintext []byte) ([]byte, error) {
    block, err := aes.NewCipher(a.key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}

func (a *AESGCMEncryptor) Decrypt(ciphertext []byte) ([]byte, error) {
    block, err := aes.NewCipher(a.key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, fmt.Errorf("ciphertext too short")
    }
    
    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }
    
    return plaintext, nil
}

// ChaCha20-Poly1305加密器
type ChaCha20Poly1305Encryptor struct {
    key []byte
}

func NewChaCha20Poly1305Encryptor(key []byte) (*ChaCha20Poly1305Encryptor, error) {
    if len(key) != chacha20poly1305.KeySize {
        return nil, fmt.Errorf("invalid key size: %d bytes", len(key))
    }
    
    return &ChaCha20Poly1305Encryptor{key: key}, nil
}

func (c *ChaCha20Poly1305Encryptor) Encrypt(plaintext []byte) ([]byte, error) {
    aead, err := chacha20poly1305.New(c.key)
    if err != nil {
        return nil, err
    }
    
    nonce := make([]byte, aead.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }
    
    ciphertext := aead.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}

func (c *ChaCha20Poly1305Encryptor) Decrypt(ciphertext []byte) ([]byte, error) {
    aead, err := chacha20poly1305.New(c.key)
    if err != nil {
        return nil, err
    }
    
    nonceSize := aead.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, fmt.Errorf("ciphertext too short")
    }
    
    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
    plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }
    
    return plaintext, nil
}

// AES-CBC加密器（不推荐用于新项目，仅作演示）
type AESCBCEncryptor struct {
    key []byte
}

func NewAESCBCEncryptor(key []byte) (*AESCBCEncryptor, error) {
    if len(key) != 16 && len(key) != 24 && len(key) != 32 {
        return nil, fmt.Errorf("invalid key size: %d bytes", len(key))
    }
    
    return &AESCBCEncryptor{key: key}, nil
}

func (a *AESCBCEncryptor) Encrypt(plaintext []byte) ([]byte, error) {
    block, err := aes.NewCipher(a.key)
    if err != nil {
        return nil, err
    }
    
    // PKCS#7填充
    blockSize := block.BlockSize()
    padding := blockSize - len(plaintext)%blockSize
    padtext := make([]byte, len(plaintext)+padding)
    copy(padtext, plaintext)
    for i := len(plaintext); i < len(padtext); i++ {
        padtext[i] = byte(padding)
    }
    
    ciphertext := make([]byte, blockSize+len(padtext))
    iv := ciphertext[:blockSize]
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return nil, err
    }
    
    mode := cipher.NewCBCEncrypter(block, iv)
    mode.CryptBlocks(ciphertext[blockSize:], padtext)
    
    return ciphertext, nil
}

func (a *AESCBCEncryptor) Decrypt(ciphertext []byte) ([]byte, error) {
    block, err := aes.NewCipher(a.key)
    if err != nil {
        return nil, err
    }
    
    blockSize := block.BlockSize()
    if len(ciphertext) < blockSize {
        return nil, fmt.Errorf("ciphertext too short")
    }
    
    iv := ciphertext[:blockSize]
    ciphertext = ciphertext[blockSize:]
    
    if len(ciphertext)%blockSize != 0 {
        return nil, fmt.Errorf("ciphertext is not a multiple of the block size")
    }
    
    mode := cipher.NewCBCDecrypter(block, iv)
    mode.CryptBlocks(ciphertext, ciphertext)
    
    // PKCS#7去填充
    padding := int(ciphertext[len(ciphertext)-1])
    if padding > len(ciphertext) || padding > aes.BlockSize {
        return nil, fmt.Errorf("invalid padding")
    }
    
    for i := len(ciphertext) - padding; i < len(ciphertext); i++ {
        if int(ciphertext[i]) != padding {
            return nil, fmt.Errorf("invalid padding")
        }
    }
    
    return ciphertext[:len(ciphertext)-padding], nil
}

// 加密管理器
type EncryptionManager struct {
    encryptor SymmetricEncryptor
}

func NewEncryptionManager(encryptor SymmetricEncryptor) *EncryptionManager {
    return &EncryptionManager{encryptor: encryptor}
}

func (em *EncryptionManager) EncryptString(plaintext string) (string, error) {
    ciphertext, err := em.encryptor.Encrypt([]byte(plaintext))
    if err != nil {
        return "", err
    }
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (em *EncryptionManager) DecryptString(ciphertext string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    plaintext, err := em.encryptor.Decrypt(data)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}

// 密钥管理器
type KeyManager struct {
    keys map[string][]byte
}

func NewKeyManager() *KeyManager {
    return &KeyManager{
        keys: make(map[string][]byte),
    }
}

func (km *KeyManager) GenerateKey(keyID string, size int) error {
    key := make([]byte, size)
    if _, err := rand.Read(key); err != nil {
        return err
    }
    
    km.keys[keyID] = key
    return nil
}

func (km *KeyManager) GetKey(keyID string) ([]byte, bool) {
    key, exists := km.keys[keyID]
    return key, exists
}

func (km *KeyManager) RotateKey(keyID string, newSize int) error {
    return km.GenerateKey(keyID, newSize)
}

// 加密数据结构
type EncryptedData struct {
    Algorithm string `json:"algorithm"`
    KeyID     string `json:"key_id"`
    Data      string `json:"data"`
    Timestamp int64  `json:"timestamp"`
}

// 加密服务
type EncryptionService struct {
    keyManager *KeyManager
    encryptors map[string]SymmetricEncryptor
}

func NewEncryptionService() *EncryptionService {
    km := NewKeyManager()
    km.GenerateKey("default-aes", 32)  // 256位AES密钥
    km.GenerateKey("default-chacha", 32) // 256位ChaCha20密钥
    
    // 初始化加密器
    aesKey, _ := km.GetKey("default-aes")
    chachaKey, _ := km.GetKey("default-chacha")
    
    aesEncryptor, _ := NewAESGCMEncryptor(aesKey)
    chachaEncryptor, _ := NewChaCha20Poly1305Encryptor(chachaKey)
    
    return &EncryptionService{
        keyManager: km,
        encryptors: map[string]SymmetricEncryptor{
            "AES-GCM":           aesEncryptor,
            "ChaCha20-Poly1305": chachaEncryptor,
        },
    }
}

func (es *EncryptionService) Encrypt(algorithm, keyID, plaintext string) (*EncryptedData, error) {
    encryptor, exists := es.encryptors[algorithm]
    if !exists {
        return nil, fmt.Errorf("unsupported algorithm: %s", algorithm)
    }
    
    key, exists := es.keyManager.GetKey(keyID)
    if !exists {
        return nil, fmt.Errorf("key not found: %s", keyID)
    }
    
    // 更新加密器的密钥
    var err error
    switch algorithm {
    case "AES-GCM":
        encryptor, err = NewAESGCMEncryptor(key)
    case "ChaCha20-Poly1305":
        encryptor, err = NewChaCha20Poly1305Encryptor(key)
    }
    
    if err != nil {
        return nil, err
    }
    
    manager := NewEncryptionManager(encryptor)
    encrypted, err := manager.EncryptString(plaintext)
    if err != nil {
        return nil, err
    }
    
    return &EncryptedData{
        Algorithm: algorithm,
        KeyID:     keyID,
        Data:      encrypted,
        Timestamp: time.Now().Unix(),
    }, nil
}

func (es *EncryptionService) Decrypt(encryptedData *EncryptedData) (string, error) {
    encryptor, exists := es.encryptors[encryptedData.Algorithm]
    if !exists {
        return "", fmt.Errorf("unsupported algorithm: %s", encryptedData.Algorithm)
    }
    
    key, exists := es.keyManager.GetKey(encryptedData.KeyID)
    if !exists {
        return "", fmt.Errorf("key not found: %s", encryptedData.KeyID)
    }
    
    // 更新加密器的密钥
    var err error
    switch encryptedData.Algorithm {
    case "AES-GCM":
        encryptor, err = NewAESGCMEncryptor(key)
    case "ChaCha20-Poly1305":
        encryptor, err = NewChaCha20Poly1305Encryptor(key)
    }
    
    if err != nil {
        return "", err
    }
    
    manager := NewEncryptionManager(encryptor)
    return manager.DecryptString(encryptedData.Data)
}

// 对称加密示例应用
func SymmetricEncryptionExample() {
    // 创建加密服务
    encryptionService := NewEncryptionService()
    
    // 测试数据
    plaintext := "This is a secret message that needs to be encrypted!"
    fmt.Printf("原始文本: %s\n", plaintext)
    
    // AES-GCM加密
    fmt.Println("\n=== AES-GCM 加密 ===")
    encryptedAES, err := encryptionService.Encrypt("AES-GCM", "default-aes", plaintext)
    if err != nil {
        fmt.Printf("AES加密失败: %v\n", err)
        return
    }
    fmt.Printf("加密后数据: %+v\n", encryptedAES)
    
    decryptedAES, err := encryptionService.Decrypt(encryptedAES)
    if err != nil {
        fmt.Printf("AES解密失败: %v\n", err)
        return
    }
    fmt.Printf("解密后文本: %s\n", decryptedAES)
    
    // ChaCha20-Poly1305加密
    fmt.Println("\n=== ChaCha20-Poly1305 加密 ===")
    encryptedChaCha, err := encryptionService.Encrypt("ChaCha20-Poly1305", "default-chacha", plaintext)
    if err != nil {
        fmt.Printf("ChaCha20加密失败: %v\n", err)
        return
    }
    fmt.Printf("加密后数据: %+v\n", encryptedChaCha)
    
    decryptedChaCha, err := encryptionService.Decrypt(encryptedChaCha)
    if err != nil {
        fmt.Printf("ChaCha20解密失败: %v\n", err)
        return
    }
    fmt.Printf("解密后文本: %s\n", decryptedChaCha)
    
    // 性能测试
    fmt.Println("\n=== 性能测试 ===")
    testPerformance()
}

func testPerformance() {
    testData := make([]byte, 1024) // 1KB测试数据
    rand.Read(testData)
    
    // AES-GCM性能测试
    aesKey := make([]byte, 32)
    rand.Read(aesKey)
    aesEncryptor, _ := NewAESGCMEncryptor(aesKey)
    
    start := time.Now()
    for i := 0; i < 1000; i++ {
        aesEncryptor.Encrypt(testData)
    }
    aesDuration := time.Since(start)
    
    // ChaCha20-Poly1305性能测试
    chachaKey := make([]byte, 32)
    rand.Read(chachaKey)
    chachaEncryptor, _ := NewChaCha20Poly1305Encryptor(chachaKey)
    
    start = time.Now()
    for i := 0; i < 1000; i++ {
        chachaEncryptor.Encrypt(testData)
    }
    chachaDuration := time.Since(start)
    
    fmt.Printf("AES-GCM加密1KB数据1000次耗时: %v\n", aesDuration)
    fmt.Printf("ChaCha20-Poly1305加密1KB数据1000次耗时: %v\n", chachaDuration)
}
```

### 非对称加密

#### 非对称加密实现
```go
package main

import (
    "crypto"
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha256"
    "crypto/x509"
    "encoding/base64"
    "encoding/pem"
    "fmt"
    "math/big"
    "time"
)

// 非对称加密接口
type AsymmetricEncryptor interface {
    Encrypt(plaintext []byte) ([]byte, error)
    Decrypt(ciphertext []byte) ([]byte, error)
}

// 非对称签名接口
type AsymmetricSigner interface {
    Sign(data []byte) ([]byte, error)
    Verify(data, signature []byte) bool
}

// RSA加密器
type RSAEncryptor struct {
    publicKey  *rsa.PublicKey
    privateKey *rsa.PrivateKey
}

func NewRSAEncryptor(publicKey *rsa.PublicKey, privateKey *rsa.PrivateKey) *RSAEncryptor {
    return &RSAEncryptor{
        publicKey:  publicKey,
        privateKey: privateKey,
    }
}

func (r *RSAEncryptor) Encrypt(plaintext []byte) ([]byte, error) {
    if r.publicKey == nil {
        return nil, fmt.Errorf("public key not set")
    }
    
    // RSA加密有长度限制，通常为密钥长度-11字节
    maxLen := r.publicKey.Size() - 11
    if len(plaintext) > maxLen {
        return nil, fmt.Errorf("plaintext too long, max length: %d", maxLen)
    }
    
    return rsa.EncryptPKCS1v15(rand.Reader, r.publicKey, plaintext)
}

func (r *RSAEncryptor) Decrypt(ciphertext []byte) ([]byte, error) {
    if r.privateKey == nil {
        return nil, fmt.Errorf("private key not set")
    }
    
    return rsa.DecryptPKCS1v15(rand.Reader, r.privateKey, ciphertext)
}

// RSA签名器
type RSASigner struct {
    publicKey  *rsa.PublicKey
    privateKey *rsa.PrivateKey
}

func NewRSASigner(publicKey *rsa.PublicKey, privateKey *rsa.PrivateKey) *RSASigner {
    return &RSASigner{
        publicKey:  publicKey,
        privateKey: privateKey,
    }
}

func (r *RSASigner) Sign(data []byte) ([]byte, error) {
    if r.privateKey == nil {
        return nil, fmt.Errorf("private key not set")
    }
    
    hash := sha256.Sum256(data)
    return rsa.SignPKCS1v15(rand.Reader, r.privateKey, crypto.SHA256, hash[:])
}

func (r *RSASigner) Verify(data, signature []byte) bool {
    if r.publicKey == nil {
        return false
    }
    
    hash := sha256.Sum256(data)
    err := rsa.VerifyPKCS1v15(r.publicKey, crypto.SHA256, hash[:], signature)
    return err == nil
}

// RSA密钥管理器
type RSAKeyManager struct {
    keySize int
}

func NewRSAKeyManager(keySize int) *RSAKeyManager {
    return &RSAKeyManager{keySize: keySize}
}

func (rkm *RSAKeyManager) GenerateKeyPair() (*rsa.PrivateKey, *rsa.PublicKey, error) {
    privateKey, err := rsa.GenerateKey(rand.Reader, rkm.keySize)
    if err != nil {
        return nil, nil, err
    }
    
    return privateKey, &privateKey.PublicKey, nil
}

func (rkm *RSAKeyManager) SavePrivateKey(privateKey *rsa.PrivateKey, filename string) error {
    privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
    privateKeyPEM := &pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: privateKeyBytes,
    }
    
    // 这里应该保存到文件，简化处理
    fmt.Printf("Private key saved to %s\n", filename)
    return nil
}

func (rkm *RSAKeyManager) SavePublicKey(publicKey *rsa.PublicKey, filename string) error {
    publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
    if err != nil {
        return err
    }
    
    publicKeyPEM := &pem.Block{
        Type:  "PUBLIC KEY",
        Bytes: publicKeyBytes,
    }
    
    // 这里应该保存到文件，简化处理
    fmt.Printf("Public key saved to %s\n", filename)
    return nil
}

func (rkm *RSAKeyManager) LoadPrivateKey(filename string) (*rsa.PrivateKey, error) {
    // 这里应该从文件加载，简化处理
    privateKey, _, err := rkm.GenerateKeyPair()
    return privateKey, err
}

func (rkm *RSAKeyManager) LoadPublicKey(filename string) (*rsa.PublicKey, error) {
    // 这里应该从文件加载，简化处理
    _, publicKey, err := rkm.GenerateKeyPair()
    return publicKey, err
}

// 混合加密系统（RSA + AES）
type HybridEncryption struct {
    rsaEncryptor *RSAEncryptor
    aesKey       []byte
}

func NewHybridEncryption(rsaEncryptor *RSAEncryptor) *HybridEncryption {
    aesKey := make([]byte, 32) // 256位AES密钥
    rand.Read(aesKey)
    
    return &HybridEncryption{
        rsaEncryptor: rsaEncryptor,
        aesKey:       aesKey,
    }
}

func (he *HybridEncryption) Encrypt(plaintext []byte) ([]byte, error) {
    // 使用AES加密数据
    aesEncryptor, err := NewAESGCMEncryptor(he.aesKey)
    if err != nil {
        return nil, err
    }
    
    encryptedData, err := aesEncryptor.Encrypt(plaintext)
    if err != nil {
        return nil, err
    }
    
    // 使用RSA加密AES密钥
    encryptedKey, err := he.rsaEncryptor.Encrypt(he.aesKey)
    if err != nil {
        return nil, err
    }
    
    // 组合加密数据和加密密钥
    result := append(encryptedKey, encryptedData...)
    return result, nil
}

func (he *HybridEncryption) Decrypt(ciphertext []byte) ([]byte, error) {
    // RSA密钥长度（通常是256字节）
    rsaKeySize := he.rsaEncryptor.publicKey.Size()
    
    if len(ciphertext) < rsaKeySize {
        return nil, fmt.Errorf("ciphertext too short")
    }
    
    // 分离加密的AES密钥和加密的数据
    encryptedKey := ciphertext[:rsaKeySize]
    encryptedData := ciphertext[rsaKeySize:]
    
    // 解密AES密钥
    aesKey, err := he.rsaEncryptor.Decrypt(encryptedKey)
    if err != nil {
        return nil, err
    }
    
    // 使用AES密钥解密数据
    aesEncryptor, err := NewAESGCMEncryptor(aesKey)
    if err != nil {
        return nil, err
    }
    
    return aesEncryptor.Decrypt(encryptedData)
}

// 数字证书管理
type CertificateManager struct {
    certificates map[string]*x509.Certificate
}

func NewCertificateManager() *CertificateManager {
    return &CertificateManager{
        certificates: make(map[string]*x509.Certificate),
    }
}

func (cm *CertificateManager) AddCertificate(cert *x509.Certificate) {
    cm.certificates[cert.Subject.CommonName] = cert
}

func (cm *CertificateManager) GetCertificate(commonName string) (*x509.Certificate, bool) {
    cert, exists := cm.certificates[commonName]
    return cert, exists
}

func (cm *CertificateManager) VerifyCertificate(cert *x509.Certificate, caCert *x509.Certificate) bool {
    roots := x509.NewCertPool()
    roots.AddCert(caCert)
    
    opts := x509.VerifyOptions{
        Roots: roots,
    }
    
    _, err := cert.Verify(opts)
    return err == nil
}

// 非对称加密服务
type AsymmetricEncryptionService struct {
    keyManager       *RSAKeyManager
    certificateManager *CertificateManager
}

func NewAsymmetricEncryptionService() *AsymmetricEncryptionService {
    return &AsymmetricEncryptionService{
        keyManager:       NewRSAKeyManager(2048),
        certificateManager: NewCertificateManager(),
    }
}

func (aes *AsymmetricEncryptionService) GenerateKeyPair(commonName string) error {
    privateKey, publicKey, err := aes.keyManager.GenerateKeyPair()
    if err != nil {
        return err
    }
    
    // 保存密钥对
    aes.keyManager.SavePrivateKey(privateKey, commonName+"_private.pem")
    aes.keyManager.SavePublicKey(publicKey, commonName+"_public.pem")
    
    return nil
}

func (aes *AsymmetricEncryptionService) EncryptWithPublicKey(publicKey *rsa.PublicKey, plaintext string) (string, error) {
    encryptor := NewRSAEncryptor(publicKey, nil)
    ciphertext, err := encryptor.Encrypt([]byte(plaintext))
    if err != nil {
        return "", err
    }
    
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (aes *AsymmetricEncryptionService) DecryptWithPrivateKey(privateKey *rsa.PrivateKey, ciphertext string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    encryptor := NewRSAEncryptor(&privateKey.PublicKey, privateKey)
    plaintext, err := encryptor.Decrypt(data)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}

func (aes *AsymmetricEncryptionService) SignWithPrivateKey(privateKey *rsa.PrivateKey, data string) (string, error) {
    signer := NewRSASigner(&privateKey.PublicKey, privateKey)
    signature, err := signer.Sign([]byte(data))
    if err != nil {
        return "", err
    }
    
    return base64.StdEncoding.EncodeToString(signature), nil
}

func (aes *AsymmetricEncryptionService) VerifyWithPublicKey(publicKey *rsa.PublicKey, data, signature string) bool {
    sigBytes, err := base64.StdEncoding.DecodeString(signature)
    if err != nil {
        return false
    }
    
    signer := NewRSASigner(publicKey, nil)
    return signer.Verify([]byte(data), sigBytes)
}

// 非对称加密示例应用
func AsymmetricEncryptionExample() {
    // 创建非对称加密服务
    encryptionService := NewAsymmetricEncryptionService()
    
    // 生成密钥对
    fmt.Println("=== 生成RSA密钥对 ===")
    err := encryptionService.GenerateKeyPair("test-user")
    if err != nil {
        fmt.Printf("生成密钥对失败: %v\n", err)
        return
    }
    
    // 模拟加载密钥
    privateKey, publicKey, err := encryptionService.keyManager.GenerateKeyPair()
    if err != nil {
        fmt.Printf("加载密钥失败: %v\n", err)
        return
    }
    
    // 测试数据
    plaintext := "This is a secret message for asymmetric encryption!"
    fmt.Printf("原始文本: %s\n", plaintext)
    
    // RSA加密
    fmt.Println("\n=== RSA加密 ===")
    encrypted, err := encryptionService.EncryptWithPublicKey(publicKey, plaintext)
    if err != nil {
        fmt.Printf("RSA加密失败: %v\n", err)
        return
    }
    fmt.Printf("加密后数据: %s\n", encrypted)
    
    decrypted, err := encryptionService.DecryptWithPrivateKey(privateKey, encrypted)
    if err != nil {
        fmt.Printf("RSA解密失败: %v\n", err)
        return
    }
    fmt.Printf("解密后文本: %s\n", decrypted)
    
    // RSA签名
    fmt.Println("\n=== RSA签名 ===")
    message := "This is a message to be signed"
    signature, err := encryptionService.SignWithPrivateKey(privateKey, message)
    if err != nil {
        fmt.Printf("签名失败: %v\n", err)
        return
    }
    fmt.Printf("签名: %s\n", signature)
    
    isValid := encryptionService.VerifyWithPublicKey(publicKey, message, signature)
    fmt.Printf("签名验证结果: %t\n", isValid)
    
    // 混合加密
    fmt.Println("\n=== 混合加密 ===")
    rsaEncryptor := NewRSAEncryptor(publicKey, privateKey)
    hybrid := NewHybridEncryption(rsaEncryptor)
    
    largeData := make([]byte, 1024) // 1KB数据
    rand.Read(largeData)
    
    encryptedHybrid, err := hybrid.Encrypt(largeData)
    if err != nil {
        fmt.Printf("混合加密失败: %v\n", err)
        return
    }
    
    decryptedHybrid, err := hybrid.Decrypt(encryptedHybrid)
    if err != nil {
        fmt.Printf("混合解密失败: %v\n", err)
        return
    }
    
    fmt.Printf("混合加密成功，原始数据长度: %d, 加密后长度: %d\n", 
        len(largeData), len(encryptedHybrid))
    fmt.Printf("解密验证: %t\n", string(largeData) == string(decryptedHybrid))
    
    // 性能测试
    fmt.Println("\n=== 性能测试 ===")
    performanceTest()
}

func performanceTest() {
    // 生成密钥对
    keyManager := NewRSAKeyManager(2048)
    privateKey, publicKey, err := keyManager.GenerateKeyPair()
    if err != nil {
        fmt.Printf("生成密钥对失败: %v\n", err)
        return
    }
    
    // RSA加密性能测试
    smallData := []byte("small data for encryption")
    rsaEncryptor := NewRSAEncryptor(publicKey, privateKey)
    
    start := time.Now()
    for i := 0; i < 1000; i++ {
        rsaEncryptor.Encrypt(smallData)
    }
    rsaDuration := time.Since(start)
    
    // RSA签名性能测试
    rsaSigner := NewRSASigner(publicKey, privateKey)
    
    start = time.Now()
    for i := 0; i < 1000; i++ {
        rsaSigner.Sign(smallData)
    }
    signDuration := time.Since(start)
    
    fmt.Printf("RSA加密1000次耗时: %v\n", rsaDuration)
    fmt.Printf("RSA签名1000次耗时: %v\n", signDuration)
}
```

### 数字签名

#### 数字签名实现
```go
package main

import (
    "crypto"
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/rand"
    "crypto/rsa"
    "crypto/sha256"
    "crypto/x509"
    "encoding/base64"
    "encoding/pem"
    "fmt"
    "time"
)

// 数字签名接口
type DigitalSigner interface {
    Sign(data []byte) ([]byte, error)
    Verify(data, signature []byte) bool
    GetAlgorithm() string
}

// RSA数字签名器
type RSADigitalSigner struct {
    privateKey *rsa.PrivateKey
    publicKey  *rsa.PublicKey
}

func NewRSADigitalSigner(privateKey *rsa.PrivateKey, publicKey *rsa.PublicKey) *RSADigitalSigner {
    return &RSADigitalSigner{
        privateKey: privateKey,
        publicKey:  publicKey,
    }
}

func (rds *RSADigitalSigner) Sign(data []byte) ([]byte, error) {
    if rds.privateKey == nil {
        return nil, fmt.Errorf("private key not set")
    }
    
    hash := sha256.Sum256(data)
    return rsa.SignPKCS1v15(rand.Reader, rds.privateKey, crypto.SHA256, hash[:])
}

func (rds *RSADigitalSigner) Verify(data, signature []byte) bool {
    if rds.publicKey == nil {
        return false
    }
    
    hash := sha256.Sum256(data)
    err := rsa.VerifyPKCS1v15(rds.publicKey, crypto.SHA256, hash[:], signature)
    return err == nil
}

func (rds *RSADigitalSigner) GetAlgorithm() string {
    return "RSA-SHA256"
}

// ECDSA数字签名器
type ECDSADigitalSigner struct {
    privateKey *ecdsa.PrivateKey
    publicKey  *ecdsa.PublicKey
}

func NewECDSADigitalSigner(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey) *ECDSADigitalSigner {
    return &ECDSADigitalSigner{
        privateKey: privateKey,
        publicKey:  publicKey,
    }
}

func (eds *ECDSADigitalSigner) Sign(data []byte) ([]byte, error) {
    if eds.privateKey == nil {
        return nil, fmt.Errorf("private key not set")
    }
    
    hash := sha256.Sum256(data)
    r, s, err := ecdsa.Sign(rand.Reader, eds.privateKey, hash[:])
    if err != nil {
        return nil, err
    }
    
    // 将r和s连接成字节序列
    signature := append(r.Bytes(), s.Bytes()...)
    return signature, nil
}

func (eds *ECDSADigitalSigner) Verify(data, signature []byte) bool {
    if eds.publicKey == nil {
        return false
    }
    
    hash := sha256.Sum256(data)
    
    // 分离r和s
    sigLen := len(signature)
    if sigLen%2 != 0 {
        return false
    }
    
    r := new(big.Int).SetBytes(signature[:sigLen/2])
    s := new(big.Int).SetBytes(signature[sigLen/2:])
    
    return ecdsa.Verify(eds.publicKey, hash[:], r, s)
}

func (eds *ECDSADigitalSigner) GetAlgorithm() string {
    return "ECDSA-SHA256"
}

// 签名管理器
type SignatureManager struct {
    signers map[string]DigitalSigner
}

func NewSignatureManager() *SignatureManager {
    return &SignatureManager{
        signers: make(map[string]DigitalSigner),
    }
}

func (sm *SignatureManager) AddSigner(name string, signer DigitalSigner) {
    sm.signers[name] = signer
}

func (sm *SignatureManager) Sign(signerName string, data []byte) ([]byte, error) {
    signer, exists := sm.signers[signerName]
    if !exists {
        return nil, fmt.Errorf("signer %s not found", signerName)
    }
    
    return signer.Sign(data)
}

func (sm *SignatureManager) Verify(signerName string, data, signature []byte) bool {
    signer, exists := sm.signers[signerName]
    if !exists {
        return false
    }
    
    return signer.Verify(data, signature)
}

func (sm *SignatureManager) GetAlgorithm(signerName string) string {
    signer, exists := sm.signers[signerName]
    if !exists {
        return ""
    }
    
    return signer.GetAlgorithm()
}

// 签名数据结构
type SignedData struct {
    Data      []byte `json:"data"`
    Signature string `json:"signature"`
    Algorithm string `json:"algorithm"`
    Signer    string `json:"signer"`
    Timestamp int64  `json:"timestamp"`
}

// 签名服务
type SignatureService struct {
    signatureManager *SignatureManager
}

func NewSignatureService() *SignatureService {
    return &SignatureService{
        signatureManager: NewSignatureManager(),
    }
}

func (ss *SignatureService) InitializeSigners() error {
    // 初始化RSA签名器
    rsaPrivateKey, rsaPublicKey, err := generateRSAKeyPair(2048)
    if err != nil {
        return err
    }
    rsaSigner := NewRSADigitalSigner(rsaPrivateKey, rsaPublicKey)
    ss.signatureManager.AddSigner("rsa", rsaSigner)
    
    // 初始化ECDSA签名器
    ecdsaPrivateKey, ecdsaPublicKey, err := generateECDSAKeyPair()
    if err != nil {
        return err
    }
    ecdsaSigner := NewECDSADigitalSigner(ecdsaPrivateKey, ecdsaPublicKey)
    ss.signatureManager.AddSigner("ecdsa", ecdsaSigner)
    
    return nil
}

func (ss *SignatureService) SignData(signerName string, data []byte) (*SignedData, error) {
    signature, err := ss.signatureManager.Sign(signerName, data)
    if err != nil {
        return nil, err
    }
    
    algorithm := ss.signatureManager.GetAlgorithm(signerName)
    if algorithm == "" {
        return nil, fmt.Errorf("unknown signer: %s", signerName)
    }
    
    return &SignedData{
        Data:      data,
        Signature: base64.StdEncoding.EncodeToString(signature),
        Algorithm: algorithm,
        Signer:    signerName,
        Timestamp: time.Now().Unix(),
    }, nil
}

func (ss *SignatureService) VerifySignedData(signedData *SignedData) bool {
    signature, err := base64.StdEncoding.DecodeString(signedData.Signature)
    if err != nil {
        return false
    }
    
    return ss.signatureManager.Verify(signedData.Signer, signedData.Data, signature)
}

// 辅助函数
func generateRSAKeyPair(bits int) (*rsa.PrivateKey, *rsa.PublicKey, error) {
    privateKey, err := rsa.GenerateKey(rand.Reader, bits)
    if err != nil {
        return nil, nil, err
    }
    
    return privateKey, &privateKey.PublicKey, nil
}

func generateECDSAKeyPair() (*ecdsa.PrivateKey, *ecdsa.PublicKey, error) {
    privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    if err != nil {
        return nil, nil, err
    }
    
    return privateKey, &privateKey.PublicKey, nil
}

// 签名验证器
type SignatureValidator struct {
    trustedSigners map[string]DigitalSigner
}

func NewSignatureValidator() *SignatureValidator {
    return &SignatureValidator{
        trustedSigners: make(map[string]DigitalSigner),
    }
}

func (sv *SignatureValidator) AddTrustedSigner(name string, signer DigitalSigner) {
    sv.trustedSigners[name] = signer
}

func (sv *SignatureValidator) ValidateSignature(signedData *SignedData) (bool, error) {
    // 检查签名者是否可信
    signer, exists := sv.trustedSigners[signedData.Signer]
    if !exists {
        return false, fmt.Errorf("untrusted signer: %s", signedData.Signer)
    }
    
    // 验证签名
    signature, err := base64.StdEncoding.DecodeString(signedData.Signature)
    if err != nil {
        return false, fmt.Errorf("invalid signature format: %v", err)
    }
    
    isValid := signer.Verify(signedData.Data, signature)
    if !isValid {
        return false, fmt.Errorf("signature verification failed")
    }
    
    // 检查时间戳（可选）
    if signedData.Timestamp > time.Now().Add(time.Hour).Unix() {
        return false, fmt.Errorf("signature timestamp is in the future")
    }
    
    return true, nil
}

// 多重签名
type MultiSignature struct {
    Data        []byte                   `json:"data"`
    Signatures  []SingleSignature        `json:"signatures"`
    Timestamp   int64                    `json:"timestamp"`
}

type SingleSignature struct {
    Signature string `json:"signature"`
    Algorithm string `json:"algorithm"`
    Signer    string `json:"signer"`
}

type MultiSignatureManager struct {
    signers map[string]DigitalSigner
}

func NewMultiSignatureManager() *MultiSignatureManager {
    return &MultiSignatureManager{
        signers: make(map[string]DigitalSigner),
    }
}

func (msm *MultiSignatureManager) AddSigner(name string, signer DigitalSigner) {
    msm.signers[name] = signer
}

func (msm *MultiSignatureManager) CreateMultiSignature(data []byte, signerNames []string) (*MultiSignature, error) {
    var signatures []SingleSignature
    
    for _, signerName := range signerNames {
        signer, exists := msm.signers[signerName]
        if !exists {
            return nil, fmt.Errorf("signer %s not found", signerName)
        }
        
        signature, err := signer.Sign(data)
        if err != nil {
            return nil, fmt.Errorf("failed to sign with %s: %v", signerName, err)
        }
        
        signatures = append(signatures, SingleSignature{
            Signature: base64.StdEncoding.EncodeToString(signature),
            Algorithm: signer.GetAlgorithm(),
            Signer:    signerName,
        })
    }
    
    return &MultiSignature{
        Data:       data,
        Signatures: signatures,
        Timestamp:  time.Now().Unix(),
    }, nil
}

func (msm *MultiSignatureManager) VerifyMultiSignature(multiSig *MultiSignature) (int, error) {
    validCount := 0
    
    for _, sig := range multiSig.Signatures {
        signer, exists := msm.signers[sig.Signer]
        if !exists {
            continue
        }
        
        signature, err := base64.StdEncoding.DecodeString(sig.Signature)
        if err != nil {
            continue
        }
        
        if signer.Verify(multiSig.Data, signature) {
            validCount++
        }
    }
    
    return validCount, nil
}

// 数字签名示例应用
func DigitalSignatureExample() {
    // 创建签名服务
    signatureService := NewSignatureService()
    if err := signatureService.InitializeSigners(); err != nil {
        fmt.Printf("初始化签名器失败: %v\n", err)
        return
    }
    
    // 测试数据
    data := []byte("This is important data that needs to be signed")
    fmt.Printf("原始数据: %s\n", string(data))
    
    // RSA签名
    fmt.Println("\n=== RSA签名 ===")
    rsaSignedData, err := signatureService.SignData("rsa", data)
    if err != nil {
        fmt.Printf("RSA签名失败: %v\n", err)
        return
    }
    fmt.Printf("RSA签名数据: %+v\n", rsaSignedData)
    
    isRSASignatureValid := signatureService.VerifySignedData(rsaSignedData)
    fmt.Printf("RSA签名验证结果: %t\n", isRSASignatureValid)
    
    // ECDSA签名
    fmt.Println("\n=== ECDSA签名 ===")
    ecdsaSignedData, err := signatureService.SignData("ecdsa", data)
    if err != nil {
        fmt.Printf("ECDSA签名失败: %v\n", err)
        return
    }
    fmt.Printf("ECDSA签名数据: %+v\n", ecdsaSignedData)
    
    isECDSASignatureValid := signatureService.VerifySignedData(ecdsaSignedData)
    fmt.Printf("ECDSA签名验证结果: %t\n", isECDSASignatureValid)
    
    // 签名验证器
    fmt.Println("\n=== 签名验证器 ===")
    validator := NewSignatureValidator()
    
    // 添加可信签名者
    rsaPrivateKey, rsaPublicKey, _ := generateRSAKeyPair(2048)
    trustedRSASigner := NewRSADigitalSigner(rsaPrivateKey, rsaPublicKey)
    validator.AddTrustedSigner("trusted-rsa", trustedRSASigner)
    
    // 验证签名
    trustedSignedData := &SignedData{
        Data:      data,
        Signature: rsaSignedData.Signature,
        Algorithm: "RSA-SHA256",
        Signer:    "trusted-rsa",
        Timestamp: time.Now().Unix(),
    }
    
    isValid, err := validator.ValidateSignature(trustedSignedData)
    if err != nil {
        fmt.Printf("签名验证失败: %v\n", err)
    } else {
        fmt.Printf("可信签名验证结果: %t\n", isValid)
    }
    
    // 多重签名
    fmt.Println("\n=== 多重签名 ===")
    multiSigManager := NewMultiSignatureManager()
    multiSigManager.AddSigner("rsa", trustedRSASigner)
    
    ecdsaPrivateKey, ecdsaPublicKey, _ := generateECDSAKeyPair()
    ecdsaSigner := NewECDSADigitalSigner(ecdsaPrivateKey, ecdsaPublicKey)
    multiSigManager.AddSigner("ecdsa", ecdsaSigner)
    
    multiSignature, err := multiSigManager.CreateMultiSignature(data, []string{"rsa", "ecdsa"})
    if err != nil {
        fmt.Printf("创建多重签名失败: %v\n", err)
        return
    }
    
    fmt.Printf("多重签名创建成功，签名数量: %d\n", len(multiSignature.Signatures))
    
    validCount, err := multiSigManager.VerifyMultiSignature(multiSignature)
    if err != nil {
        fmt.Printf("验证多重签名失败: %v\n", err)
    } else {
        fmt.Printf("有效签名数量: %d/%d\n", validCount, len(multiSignature.Signatures))
    }
    
    // 性能测试
    fmt.Println("\n=== 性能测试 ===")
    performanceTest()
}

func performanceTest() {
    // 生成测试数据
    testData := make([]byte, 1024) // 1KB数据
    rand.Read(testData)
    
    // RSA签名性能测试
    rsaPrivateKey, rsaPublicKey, _ := generateRSAKeyPair(2048)
    rsaSigner := NewRSADigitalSigner(rsaPrivateKey, rsaPublicKey)
    
    start := time.Now()
    for i := 0; i < 1000; i++ {
        rsaSigner.Sign(testData)
    }
    rsaSignDuration := time.Since(start)
    
    // ECDSA签名性能测试
    ecdsaPrivateKey, ecdsaPublicKey, _ := generateECDSAKeyPair()
    ecdsaSigner := NewECDSADigitalSigner(ecdsaPrivateKey, ecdsaPublicKey)
    
    start = time.Now()
    for i := 0; i < 1000; i++ {
        ecdsaSigner.Sign(testData)
    }
    ecdsaSignDuration := time.Since(start)
    
    fmt.Printf("RSA签名1KB数据1000次耗时: %v\n", rsaSignDuration)
    fmt.Printf("ECDSA签名1KB数据1000次耗时: %v\n", ecdsaSignDuration)
}
```

### TLS/SSL配置

#### TLS/SSL配置实现
```go
package main

import (
    "crypto/tls"
    "crypto/x509"
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
)

// TLS配置管理器
type TLSConfigManager struct {
    config *tls.Config
}

func NewTLSConfigManager() *TLSConfigManager {
    return &TLSConfigManager{
        config: &tls.Config{
            MinVersion: tls.VersionTLS12,
            MaxVersion: tls.VersionTLS13,
            // 推荐的加密套件
            CipherSuites: []uint16{
                tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
                tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
                tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
            },
            PreferServerCipherSuites: true,
            // 启用HTTP/2
            NextProtos: []string{"h2", "http/1.1"},
        },
    }
}

// 加载证书和私钥
func (tcm *TLSConfigManager) LoadCertificate(certFile, keyFile string) error {
    cert, err := tls.LoadX509KeyPair(certFile, keyFile)
    if err != nil {
        return fmt.Errorf("failed to load certificate: %v", err)
    }
    
    tcm.config.Certificates = append(tcm.config.Certificates, cert)
    return nil
}

// 加载客户端CA证书
func (tcm *TLSConfigManager) LoadClientCA(caFile string) error {
    caCert, err := ioutil.ReadFile(caFile)
    if err != nil {
        return fmt.Errorf("failed to read CA certificate: %v", err)
    }
    
    caCertPool := x509.NewCertPool()
    if !caCertPool.AppendCertsFromPEM(caCert) {
        return fmt.Errorf("failed to parse CA certificate")
    }
    
    tcm.config.ClientCAs = caCertPool
    tcm.config.ClientAuth = tls.RequireAndVerifyClientCert
    return nil
}

// 设置客户端认证
func (tcm *TLSConfigManager) SetClientAuth(authType tls.ClientAuthType) {
    tcm.config.ClientAuth = authType
}

// 启用会话恢复
func (tcm *TLSConfigManager) EnableSessionResumption() {
    tcm.config.SessionTicketsDisabled = false
    tcm.config.SessionTicketKey = [32]byte{} // 使用默认会话票证密钥
}

// 设置超时
func (tcm *TLSConfigManager) SetTimeouts(handshakeTimeout, connectionTimeout time.Duration) {
    // 这些超时通常在HTTP服务器中设置
}

// 获取TLS配置
func (tcm *TLSConfigManager) GetConfig() *tls.Config {
    return tcm.config
}

// 安全TLS配置
func SecureTLSConfig() *tls.Config {
    return &tls.Config{
        MinVersion: tls.VersionTLS12,
        MaxVersion: tls.VersionTLS13,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
            tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
            tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
        },
        PreferServerCipherSuites: true,
        CurvePreferences: []tls.CurveID{
            tls.X25519,
            tls.CurveP256,
        },
        // 禁用不安全特性
        InsecureSkipVerify: false,
        SessionTicketsDisabled: false,
        // 启用HTTP/2
        NextProtos: []string{"h2", "http/1.1"},
    }
}

// HTTP服务器配置
type HTTPServerConfig struct {
    Addr         string
    TLSConfig    *tls.Config
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
    IdleTimeout  time.Duration
}

func NewHTTPServerConfig(addr string) *HTTPServerConfig {
    return &HTTPServerConfig{
        Addr:         addr,
        TLSConfig:    SecureTLSConfig(),
        ReadTimeout:  30 * time.Second,
        WriteTimeout: 30 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
}

// 创建安全HTTP服务器
func CreateSecureHTTPServer(config *HTTPServerConfig, handler http.Handler) *http.Server {
    return &http.Server{
        Addr:         config.Addr,
        Handler:      handler,
        TLSConfig:    config.TLSConfig,
        ReadTimeout:  config.ReadTimeout,
        WriteTimeout: config.WriteTimeout,
        IdleTimeout:  config.IdleTimeout,
        // 启用HTTP/2
        TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),
    }
}

// 证书管理器
type CertificateManager struct {
    certificates map[string]*tls.Certificate
}

func NewCertificateManager() *CertificateManager {
    return &CertificateManager{
        certificates: make(map[string]*tls.Certificate),
    }
}

func (cm *CertificateManager) AddCertificate(domain, certFile, keyFile string) error {
    cert, err := tls.LoadX509KeyPair(certFile, keyFile)
    if err != nil {
        return fmt.Errorf("failed to load certificate for %s: %v", domain, err)
    }
    
    cm.certificates[domain] = &cert
    return nil
}

func (cm *CertificateManager) GetCertificate(clientHello *tls.ClientHelloInfo) (*tls.Certificate, error) {
    // 根据SNI选择证书
    if cert, exists := cm.certificates[clientHello.ServerName]; exists {
        return cert, nil
    }
    
    // 返回默认证书
    for _, cert := range cm.certificates {
        return cert, nil
    }
    
    return nil, fmt.Errorf("no certificate available")
}

// TLS中间件
func TLSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 检查是否为HTTPS
        if c.Request.TLS == nil && c.GetHeader("X-Forwarded-Proto") != "https" {
            // 重定向到HTTPS
            httpsURL := fmt.Sprintf("https://%s%s", c.Request.Host, c.Request.URL.RequestURI())
            c.Redirect(http.StatusMovedPermanently, httpsURL)
            c.Abort()
            return
        }
        
        // 设置安全头
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-Content-Type-Options", "nosniff")
        
        c.Next()
    }
}

// 客户端TLS配置
func ClientTLSConfig() *tls.Config {
    return &tls.Config{
        MinVersion: tls.VersionTLS12,
        MaxVersion: tls.VersionTLS13,
        // 验证服务器证书
        InsecureSkipVerify: false,
        // 设置客户端支持的加密套件
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        },
    }
}

// 创建安全HTTP客户端
func CreateSecureHTTPClient() *http.Client {
    return &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: ClientTLSConfig(),
            // 连接池配置
            MaxIdleConns:        100,
            IdleConnTimeout:     90 * time.Second,
            TLSHandshakeTimeout: 10 * time.Second,
        },
        Timeout: 30 * time.Second,
    }
}

// TLS健康检查
type TLSHealthChecker struct {
    endpoints []string
}

func NewTLSHealthChecker(endpoints []string) *TLSHealthChecker {
    return &TLSHealthChecker{endpoints: endpoints}
}

func (thc *TLSHealthChecker) CheckHealth() map[string]error {
    results := make(map[string]error)
    
    client := CreateSecureHTTPClient()
    
    for _, endpoint := range thc.endpoints {
        resp, err := client.Get(endpoint)
        if err != nil {
            results[endpoint] = err
            continue
        }
        resp.Body.Close()
        
        results[endpoint] = nil
    }
    
    return results
}

// TLS配置示例应用
func TLSExample() {
    // 创建Gin路由器
    r := gin.Default()
    
    // 使用TLS中间件
    r.Use(TLSMiddleware())
    
    // 路由
    r.GET("/", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "Secure HTTPS API",
            "protocol": "TLS 1.2/1.3",
        })
    })
    
    r.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "healthy",
            "tls":    c.Request.TLS != nil,
        })
    })
    
    // TLS配置管理器
    tlsManager := NewTLSConfigManager()
    
    // 加载证书（需要实际的证书文件）
    // err := tlsManager.LoadCertificate("server.crt", "server.key")
    // if err != nil {
    //     fmt.Printf("加载证书失败: %v\n", err)
    //     return
    // }
    
    // HTTP服务器配置
    serverConfig := NewHTTPServerConfig(":8443")
    serverConfig.TLSConfig = tlsManager.GetConfig()
    
    // 创建服务器
    server := CreateSecureHTTPServer(serverConfig, r)
    
    fmt.Println("启动安全HTTPS服务器在 :8443")
    
    // 启动服务器（需要证书文件才能正常运行）
    // err = server.ListenAndServeTLS("server.crt", "server.key")
    // if err != nil {
    //     fmt.Printf("服务器启动失败: %v\n", err)
    // }
    
    // 演示客户端配置
    client := CreateSecureHTTPClient()
    fmt.Printf("创建安全HTTP客户端: %+v\n", client)
    
    // 健康检查
    healthChecker := NewTLSHealthChecker([]string{
        "https://httpbin.org/get",
        "https://www.google.com",
    })
    
    results := healthChecker.CheckHealth()
    fmt.Println("TLS健康检查结果:")
    for endpoint, err := range results {
        if err != nil {
            fmt.Printf("  %s: 失败 - %v\n", endpoint, err)
        } else {
            fmt.Printf("  %s: 成功\n", endpoint)
        }
    }
    
    // TLS配置最佳实践
    tlsBestPractices()
}

func tlsBestPractices() {
    fmt.Println("\n=== TLS配置最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "使用TLS 1.2+",
            "禁用TLS 1.0和1.1，使用TLS 1.2或更高版本",
        },
        {
            "强加密套件",
            "使用前向安全的加密套件，如ECDHE",
        },
        {
            "定期更新证书",
            "使用Let's Encrypt等免费CA，自动更新证书",
        },
        {
            "HSTS头",
            "设置Strict-Transport-Security头强制HTTPS",
        },
        {
            "证书固定",
            "在客户端固定服务器证书公钥",
        },
        {
            "OCSP装订",
            "启用OCSP装订减少证书吊销检查延迟",
        },
        {
            "会话恢复",
            "启用TLS会话恢复提高性能",
        },
        {
            "HTTP/2",
            "启用HTTP/2获得更好的性能",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}
```

### 证书管理

#### 证书管理实现
```go
package main

import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/tls"
    "crypto/x509"
    "crypto/x509/pkix"
    "encoding/pem"
    "fmt"
    "math/big"
    "net"
    "os"
    "time"
)

// 证书管理器
type CertificateManager struct {
    certificates map[string]*tls.Certificate
    caCert       *x509.Certificate
    caKey        *rsa.PrivateKey
}

func NewCertificateManager() *CertificateManager {
    return &CertificateManager{
        certificates: make(map[string]*tls.Certificate),
    }
}

// 生成自签名CA证书
func (cm *CertificateManager) GenerateCACertificate(commonName string, years int) error {
    // 生成私钥
    privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
    if err != nil {
        return fmt.Errorf("failed to generate private key: %v", err)
    }
    
    // 创建证书模板
    template := x509.Certificate{
        SerialNumber: big.NewInt(1),
        Subject: pkix.Name{
            CommonName:   commonName,
            Organization: []string{"My CA"},
        },
        NotBefore:             time.Now(),
        NotAfter:              time.Now().AddDate(years, 0, 0),
        KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
        BasicConstraintsValid: true,
        IsCA:                  true,
        MaxPathLen:            1,
        MaxPathLenZero:        false,
    }
    
    // 创建自签名证书
    derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
    if err != nil {
        return fmt.Errorf("failed to create certificate: %v", err)
    }
    
    // 保存证书和私钥
    certOut, err := os.Create("ca.crt")
    if err != nil {
        return fmt.Errorf("failed to open ca.crt for writing: %v", err)
    }
    pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
    certOut.Close()
    
    keyOut, err := os.Create("ca.key")
    if err != nil {
        return fmt.Errorf("failed to open ca.key for writing: %v", err)
    }
    pem.Encode(keyOut, &pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
    })
    keyOut.Close()
    
    // 保存到内存
    cm.caCert, _ = x509.ParseCertificate(derBytes)
    cm.caKey = privateKey
    
    fmt.Printf("CA证书已生成: ca.crt 和 ca.key\n")
    return nil
}

// 生成服务器证书
func (cm *CertificateManager) GenerateServerCertificate(commonName string, hosts []string, years int) error {
    if cm.caCert == nil || cm.caKey == nil {
        return fmt.Errorf("CA certificate not available")
    }
    
    // 生成私钥
    privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
    if err != nil {
        return fmt.Errorf("failed to generate private key: %v", err)
    }
    
    // 生成序列号
    serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
    serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
    if err != nil {
        return fmt.Errorf("failed to generate serial number: %v", err)
    }
    
    // 创建证书模板
    template := x509.Certificate{
        SerialNumber: serialNumber,
        Subject: pkix.Name{
            CommonName:   commonName,
            Organization: []string{"My Organization"},
        },
        NotBefore:             time.Now(),
        NotAfter:              time.Now().AddDate(years, 0, 0),
        KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
        BasicConstraintsValid: true,
    }
    
    // 添加主机名
    for _, h := range hosts {
        if ip := net.ParseIP(h); ip != nil {
            template.IPAddresses = append(template.IPAddresses, ip)
        } else {
            template.DNSNames = append(template.DNSNames, h)
        }
    }
    
    // 创建证书
    derBytes, err := x509.CreateCertificate(rand.Reader, &template, cm.caCert, &privateKey.PublicKey, cm.caKey)
    if err != nil {
        return fmt.Errorf("failed to create certificate: %v", err)
    }
    
    // 保存证书和私钥
    certOut, err := os.Create("server.crt")
    if err != nil {
        return fmt.Errorf("failed to open server.crt for writing: %v", err)
    }
    pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
    certOut.Close()
    
    keyOut, err := os.Create("server.key")
    if err != nil {
        return fmt.Errorf("failed to open server.key for writing: %v", err)
    }
    pem.Encode(keyOut, &pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
    })
    keyOut.Close()
    
    // 加载到证书管理器
    cert, err := tls.LoadX509KeyPair("server.crt", "server.key")
    if err != nil {
        return fmt.Errorf("failed to load certificate: %v", err)
    }
    
    cm.certificates[commonName] = &cert
    
    fmt.Printf("服务器证书已生成: server.crt 和 server.key\n")
    return nil
}

// 加载现有证书
func (cm *CertificateManager) LoadCertificate(certFile, keyFile string) (*tls.Certificate, error) {
    cert, err := tls.LoadX509KeyPair(certFile, keyFile)
    if err != nil {
        return nil, fmt.Errorf("failed to load certificate: %v", err)
    }
    
    return &cert, nil
}

// 保存证书到文件
func (cm *CertificateManager) SaveCertificate(cert *tls.Certificate, certFile, keyFile string) error {
    // 保存证书
    certOut, err := os.Create(certFile)
    if err != nil {
        return fmt.Errorf("failed to open %s for writing: %v", certFile, err)
    }
    for _, certBytes := range cert.Certificate {
        pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: certBytes})
    }
    certOut.Close()
    
    // 保存私钥
    keyOut, err := os.Create(keyFile)
    if err != nil {
        return fmt.Errorf("failed to open %s for writing: %v", keyFile, err)
    }
    pem.Encode(keyOut, &pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: x509.MarshalPKCS1PrivateKey(cert.PrivateKey.(*rsa.PrivateKey)),
    })
    keyOut.Close()
    
    return nil
}

// 证书验证器
type CertificateValidator struct {
    caPool *x509.CertPool
}

func NewCertificateValidator(caCert *x509.Certificate) *CertificateValidator {
    pool := x509.NewCertPool()
    pool.AddCert(caCert)
    
    return &CertificateValidator{caPool: pool}
}

func (cv *CertificateValidator) ValidateCertificate(cert *x509.Certificate) error {
    opts := x509.VerifyOptions{
        Roots:         cv.caPool,
        Intermediates: nil,
        KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
    }
    
    _, err := cert.Verify(opts)
    return err
}

// 证书信息提取器
type CertificateInfoExtractor struct{}

func NewCertificateInfoExtractor() *CertificateInfoExtractor {
    return &CertificateInfoExtractor{}
}

func (cie *CertificateInfoExtractor) ExtractInfo(certFile string) (*CertificateInfo, error) {
    certData, err := os.ReadFile(certFile)
    if err != nil {
        return nil, fmt.Errorf("failed to read certificate file: %v", err)
    }
    
    block, _ := pem.Decode(certData)
    if block == nil {
        return nil, fmt.Errorf("failed to parse certificate PEM")
    }
    
    cert, err := x509.ParseCertificate(block.Bytes)
    if err != nil {
        return nil, fmt.Errorf("failed to parse certificate: %v", err)
    }
    
    return &CertificateInfo{
        Subject:      cert.Subject.CommonName,
        Issuer:       cert.Issuer.CommonName,
        SerialNumber: cert.SerialNumber.String(),
        NotBefore:    cert.NotBefore,
        NotAfter:     cert.NotAfter,
        DNSNames:     cert.DNSNames,
        IPAddresses:  cert.IPAddresses,
        KeyUsage:     cert.KeyUsage,
        ExtKeyUsage:  cert.ExtKeyUsage,
    }, nil
}

type CertificateInfo struct {
    Subject      string
    Issuer       string
    SerialNumber string
    NotBefore    time.Time
    NotAfter     time.Time
    DNSNames     []string
    IPAddresses  []net.IP
    KeyUsage     x509.KeyUsage
    ExtKeyUsage  []x509.ExtKeyUsage
}

// 证书轮换管理器
type CertificateRotator struct {
    certManager *CertificateManager
    rotationInterval time.Duration
    stopChan    chan struct{}
}

func NewCertificateRotator(certManager *CertificateManager, interval time.Duration) *CertificateRotator {
    return &CertificateRotator{
        certManager:      certManager,
        rotationInterval: interval,
        stopChan:         make(chan struct{}),
    }
}

func (cr *CertificateRotator) StartRotation() {
    ticker := time.NewTicker(cr.rotationInterval)
    go func() {
        for {
            select {
            case <-ticker.C:
                cr.rotateCertificates()
            case <-cr.stopChan:
                ticker.Stop()
                return
            }
        }
    }()
}

func (cr *CertificateRotator) StopRotation() {
    close(cr.stopChan)
}

func (cr *CertificateRotator) rotateCertificates() {
    fmt.Println("开始证书轮换...")
    // 实现证书轮换逻辑
    fmt.Println("证书轮换完成")
}

// Let's Encrypt客户端模拟
type LetsEncryptClient struct {
    email      string
    domains    []string
    production bool
}

func NewLetsEncryptClient(email string, domains []string, production bool) *LetsEncryptClient {
    return &LetsEncryptClient{
        email:      email,
        domains:    domains,
        production: production,
    }
}

func (lec *LetsEncryptClient) ObtainCertificate() error {
    fmt.Printf("从Let's Encrypt获取证书: %v\n", lec.domains)
    // 这里应该实现实际的ACME协议交互
    fmt.Println("证书获取成功")
    return nil
}

func (lec *LetsEncryptClient) RenewCertificate() error {
    fmt.Printf("续期Let's Encrypt证书: %v\n", lec.domains)
    // 实现证书续期逻辑
    fmt.Println("证书续期成功")
    return nil
}

// 证书管理示例应用
func CertificateManagementExample() {
    // 创建证书管理器
    certManager := NewCertificateManager()
    
    // 生成CA证书
    fmt.Println("=== 生成CA证书 ===")
    err := certManager.GenerateCACertificate("My Root CA", 10)
    if err != nil {
        fmt.Printf("生成CA证书失败: %v\n", err)
        return
    }
    
    // 生成服务器证书
    fmt.Println("\n=== 生成服务器证书 ===")
    hosts := []string{"localhost", "127.0.0.1", "example.com"}
    err = certManager.GenerateServerCertificate("My Server", hosts, 2)
    if err != nil {
        fmt.Printf("生成服务器证书失败: %v\n", err)
        return
    }
    
    // 证书信息提取
    fmt.Println("\n=== 证书信息提取 ===")
    extractor := NewCertificateInfoExtractor()
    certInfo, err := extractor.ExtractInfo("server.crt")
    if err != nil {
        fmt.Printf("提取证书信息失败: %v\n", err)
    } else {
        fmt.Printf("证书主题: %s\n", certInfo.Subject)
        fmt.Printf("证书颁发者: %s\n", certInfo.Issuer)
        fmt.Printf("有效期: %s 到 %s\n", certInfo.NotBefore, certInfo.NotAfter)
        fmt.Printf("DNS名称: %v\n", certInfo.DNSNames)
        fmt.Printf("IP地址: %v\n", certInfo.IPAddresses)
    }
    
    // 证书验证
    fmt.Println("\n=== 证书验证 ===")
    if certManager.caCert != nil {
        validator := NewCertificateValidator(certManager.caCert)
        
        // 读取服务器证书进行验证
        certData, err := os.ReadFile("server.crt")
        if err != nil {
            fmt.Printf("读取服务器证书失败: %v\n", err)
        } else {
            block, _ := pem.Decode(certData)
            if block != nil {
                serverCert, err := x509.ParseCertificate(block.Bytes)
                if err != nil {
                    fmt.Printf("解析服务器证书失败: %v\n", err)
                } else {
                    err = validator.ValidateCertificate(serverCert)
                    if err != nil {
                        fmt.Printf("证书验证失败: %v\n", err)
                    } else {
                        fmt.Println("证书验证成功")
                    }
                }
            }
        }
    }
    
    // Let's Encrypt客户端示例
    fmt.Println("\n=== Let's Encrypt客户端 ===")
    leClient := NewLetsEncryptClient("admin@example.com", []string{"example.com", "www.example.com"}, true)
    err = leClient.ObtainCertificate()
    if err != nil {
        fmt.Printf("获取Let's Encrypt证书失败: %v\n", err)
    }
    
    // 证书轮换示例
    fmt.Println("\n=== 证书轮换 ===")
    rotator := NewCertificateRotator(certManager, 24*time.Hour)
    rotator.StartRotation()
    defer rotator.StopRotation()
    fmt.Println("证书轮换服务已启动")
    
    // 证书管理最佳实践
    certificateBestPractices()
}

func certificateBestPractices() {
    fmt.Println("\n=== 证书管理最佳实践 ===")
    practices := []struct {
        Practice string
        Description string
    }{
        {
            "使用强私钥",
            "使用至少2048位RSA密钥或256位ECC密钥",
        },
        {
            "定期轮换",
            "服务器证书每年轮换，CA证书每5-10年轮换",
        },
        {
            "限制证书权限",
            "只授予必要的KeyUsage和ExtKeyUsage",
        },
        {
            "使用SAN证书",
            "为多个域名使用Subject Alternative Name证书",
        },
        {
            "自动化管理",
            "使用Let's Encrypt等自动化证书管理工具",
        },
        {
            "监控过期",
            "设置证书过期提醒和自动续期",
        },
        {
            "安全存储",
            "私钥文件设置适当权限，避免泄露",
        },
        {
            "备份策略",
            "定期备份证书和私钥文件",
        },
    }
    
    for _, practice := range practices {
        fmt.Printf("• %s: %s\n", practice.Practice, practice.Description)
    }
}
```