# 代码原理示范
```javascript
let activeEffect = null;
const targetMap = new WeakMap();

function track(target, key) {
  if (activeEffect) {
    // 依赖字典
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      depsMap = new Map();
      targetMap.set(target, depsMap);
    }
    let dep = depsMap.get(key);
    if (!dep) {
      dep = new Set();
      depsMap.set(key, dep);
    }
    dep.add(activeEffect);
  }
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

const reactiveMap = new WeakMap(); // 缓存已代理的对象，避免重复代理

function reactive(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;

  // 如果已经代理过，直接返回
  if (reactiveMap.has(obj)) {
    return reactiveMap.get(obj);
  }

  const proxy = new Proxy(obj, {
    get(target, key, receiver) {
      track(target, key);
      //使用reflect.get，避免被代理对象属性的 getter 函数被调用,指定this为初始发起的对象receiver
      const result = Reflect.get(target, key, receiver);

      // 如果读取的是对象，递归使其响应式
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }

      return result;
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      trigger(target, key);
      return result;
    }
  });

  reactiveMap.set(obj, proxy);
  return proxy;
}


function ref(value) {
  const r = {
    _value: value,
    get value() {
      track(r, 'value');
      return this._value;
    },
    set value(newVal) {
      this._value = newVal;
      trigger(r, 'value');
    }
  };
  return r;
}

function computed(getter) {
  let _value;
  let _dirty = true;

  // 用于在依赖变化时标记为 dirty
  const effectRunner = () => {
    if (!_dirty) {
      _dirty = true;
      trigger(computedRef, 'value');
    }
  };

  // 包装 getter，使其依赖收集指向 effectRunner
  const wrappedGetter = () => {
    const prevEffect = activeEffect;
    activeEffect = effectRunner;
    try {
      return getter();
    } finally {
      activeEffect = prevEffect;
    }
  };

  const computedRef = {
    get value() {
      // 1. 收集当前 activeEffect（如果有）对这个 computed 的依赖
      track(computedRef, 'value');

      // 2. 如果 dirty，重新计算
      if (_dirty) {
        _value = wrappedGetter();
        _dirty = false;
      }

      return _value;
    }
  };

  return computedRef;
}
function effect(fn) {
  activeEffect = fn;
  fn(); // 立即执行一次，触发 track
  activeEffect = null;
}
let  a =  ref(1)
let b = computed(() => a.value + 1)
console.log(b.value)
a.value = 2
console.log(b.value)

a = reactive({ count: 1 })
let c = ref(1)
b = computed(() => a.count+c.value+ 1)
console.log(b.value)
a.count = 2
c.value = 7
console.log(b.value)
```