## 13.2 测试策略

### 1. 单元测试概念（Unit Testing）

单元测试是针对**最小可测试单元**（通常是函数或类）的测试，目的是验证其行为是否符合预期。

#### 核心原则：

- **独立性**：每个测试用例独立，不依赖外部状态
- **可重复性**：相同输入总是得到相同结果
- **自动化**：可由 CI/CD 自动执行

#### 常用工具：

- **Jest**：最流行的 JS 测试框架，内置断言、Mock、覆盖率
- **Mocha + Chai**：经典组合，灵活但需搭配更多工具
- **Vitest**：Vite 生态的现代测试框架，速度快

#### 示例：Jest 测试一个函数

```js
// math.js
export function add(a, b) {
    return a + b;
}

// math.test.js
import { add } from './math';

test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
});

test('handles negative numbers', () => {
    expect(add(-1, 1)).toBe(0);
});
```

#### 断言（Assertions）常用方法：

| 方法 | 说明 |
|------|------|
| `expect(value).toBe(expected)` | 严格相等（===） |
| `expect(value).toEqual(object)` | 深度相等 |
| `expect(fn).toThrow()` | 函数抛出错误 |
| `expect(value).toBeDefined()` | 不是 undefined |
| `expect(value).toContain(item)` | 数组包含某元素 |

#### Mocking（模拟）

用于隔离外部依赖，如 API 调用、定时器。

```js
// 模拟 API
jest.spyOn(global, 'fetch').mockResolvedValue({
    json: () => Promise.resolve({ data: 'mock' })
});

// 模拟 setTimeout
jest.useFakeTimers();
setTimeout(callback, 1000);
jest.runAllTimers();
```

---

### 2. 集成测试方法（Integration Testing）

集成测试验证**多个模块协同工作**是否正常，介于单元测试和端到端测试之间。

#### 适用场景：

- 多个函数组合调用
- 组件间通信（React/Vue 组件）
- 服务层与数据层交互

#### 示例：测试 React 组件交互

```jsx
// LoginForm.jsx
function LoginForm({ onLogin }) {
    const [user, setUser] = useState('');
    return (
        <div>
            <input value={user} onChange={e => setUser(e.target.value)} />
            <button onClick={() => onLogin(user)}>登录</button>
        </div>
    );
}

// LoginForm.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';

test('calls onLogin with username', () => {
    const mockLogin = jest.fn();
    render(<LoginForm onLogin={mockLogin} />);
    
    fireEvent.change(screen.getByRole('textbox'), { target: { value: 'alice' } });
    fireEvent.click(screen.getByRole('button'));
    
    expect(mockLogin).toHaveBeenCalledWith('alice');
});
```

✅ 优势：
- 比单元测试更贴近真实使用场景
- 比 E2E 更快、更稳定

---

### 3. 端到端测试（End-to-End Testing, E2E）

E2E 测试模拟真实用户操作，从用户角度验证整个应用流程。

#### 常用工具：

- **Cypress**：语法简洁，自带 UI，适合中小型项目
- **Playwright**：支持多浏览器（Chromium、Firefox、WebKit），功能强大
- **Puppeteer**：底层控制 Chrome，适合爬虫和复杂自动化

#### 示例：Cypress 测试登录流程

```js
// cypress/e2e/login.cy.js
describe('Login Flow', () => {
    it('should login successfully', () => {
        cy.visit('/login');
        cy.get('input[name="username"]').type('testuser');
        cy.get('input[name="password"]').type('password123');
        cy.get('button[type="submit"]').click();
        cy.url().should('include', '/dashboard');
        cy.contains('欢迎回来');
    });
});
```

#### E2E 测试特点：

| 优点 | 缺点 |
|------|------|
| 最接近真实用户行为 | 执行慢（秒级） |
| 覆盖完整业务流程 | 容易受网络、环境影响 |
| 发现集成问题 | 维护成本高 |

✅ 建议：
- 用 E2E 测试核心路径（如注册、支付）
- 不要测试所有分支逻辑

---

### 4. 测试驱动开发（Test-Driven Development, TDD）

TDD 是一种开发方法论，遵循 **“红-绿-重构”** 循环：

1. **Red（红）**：先写一个失败的测试
2. **Green（绿）**：编写最简代码让测试通过
3. **Refactor（重构）**：优化代码结构，保持测试通过

#### TDD 流程示例：

```js
// 1. 写测试（红）
test('should validate email format', () => {
    expect(validateEmail('not-email')).toBe(false);
    expect(validateEmail('user@example.com')).toBe(true);
});

// 2. 写实现（绿）
function validateEmail(email) {
    return email.includes('@');
}

// 3. 重构（如增加更严格的正则）
function validateEmail(email) {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
}
```

#### TDD 的优势：

- 确保代码可测试
- 避免过度设计
- 提供即时反馈
- 形成完整的测试套件

#### 挑战：

- 学习曲线陡峭
- 初期开发速度变慢
- 不适合探索性开发

✅ 适用场景：
- 核心业务逻辑
- 工具库、SDK 开发
- 团队协作项目

---