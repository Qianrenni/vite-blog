## 15.2 Node.js 核心模块

### fs 模块文件操作

**基本文件操作：**
```javascript
const fs = require('fs');
const path = require('path');

// 同步操作
try {
    const data = fs.readFileSync('example.txt', 'utf8');
    console.log(data);
} catch (err) {
    console.error(err);
}

// 异步操作
fs.readFile('example.txt', 'utf8', (err, data) => {
    if (err) throw err;
    console.log(data);
});

// Promise 方式
const fsPromises = require('fs').promises;

async function readFileAsync() {
    try {
        const data = await fsPromises.readFile('example.txt', 'utf8');
        console.log(data);
    } catch (err) {
        console.error(err);
    }
}
```

**文件系统操作：**
```javascript
// 文件写入
fs.writeFile('output.txt', 'Hello World', (err) => {
    if (err) throw err;
    console.log('文件写入成功');
});

// 文件追加
fs.appendFile('log.txt', '新日志内容\n', (err) => {
    if (err) throw err;
});

// 文件信息
fs.stat('example.txt', (err, stats) => {
    if (err) throw err;
    console.log(`文件大小: ${stats.size} bytes`);
    console.log(`是否为文件: ${stats.isFile()}`);
    console.log(`修改时间: ${stats.mtime}`);
});

// 目录操作
fs.readdir('./', (err, files) => {
    if (err) throw err;
    console.log('目录内容:', files);
});

// 创建目录
fs.mkdir('./newDir', { recursive: true }, (err) => {
    if (err) throw err;
});
```

### path 模路径处理

**路径操作：**
```javascript
const path = require('path');

// 路径拼接
const fullPath = path.join(__dirname, 'public', 'index.html');
console.log(fullPath);

// 路径解析
const parsedPath = path.parse('/users/node/app.js');
console.log(parsedPath);
// {
//   root: '/',
//   dir: '/users/node',
//   base: 'app.js',
//   ext: '.js',
//   name: 'app'
// }

// 路径规范化
console.log(path.normalize('/users//node/../node/app.js'));
// 输出: /users/node/app.js

// 相对路径
console.log(path.relative('/users/node', '/users/admin'));
// 输出: ../admin

// 路径分隔符
console.log(path.sep); // Windows: \, Unix: /
```

### http/https 网络模块

**HTTP 服务器：**
```javascript
const http = require('http');
const url = require('url');

const server = http.createServer((req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const path = parsedUrl.pathname;
    const query = parsedUrl.query;
    
    // 设置响应头
    res.writeHead(200, {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
    });
    
    // 路由处理
    if (path === '/api/users' && req.method === 'GET') {
        res.end(JSON.stringify({ users: [] }));
    } else if (path === '/api/users' && req.method === 'POST') {
        let body = '';
        req.on('data', chunk => {
            body += chunk.toString();
        });
        req.on('end', () => {
            const userData = JSON.parse(body);
            res.end(JSON.stringify({ id: 1, ...userData }));
        });
    } else {
        res.writeHead(404);
        res.end('Not Found');
    }
});

server.listen(3000, () => {
    console.log('服务器运行在 http://localhost:3000');
});
```

**HTTP 客户端：**
```javascript
const http = require('http');

// 发送 GET 请求
const options = {
    hostname: 'jsonplaceholder.typicode.com',
    port: 80,
    path: '/posts/1',
    method: 'GET'
};

const req = http.request(options, (res) => {
    let data = '';
    
    res.on('data', (chunk) => {
        data += chunk;
    });
    
    res.on('end', () => {
        console.log(JSON.parse(data));
    });
});

req.on('error', (error) => {
    console.error(error);
});

req.end();
```

### events 事件系统

**事件发射器：**
```javascript
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

// 监听事件
myEmitter.on('event', (data) => {
    console.log('事件触发:', data);
});

// 监听一次
myEmitter.once('startup', () => {
    console.log('应用启动');
});

// 发射事件
myEmitter.emit('event', { message: 'Hello World' });
myEmitter.emit('startup');
myEmitter.emit('startup'); // 不会再次触发

// 移除监听器
const listener = (data) => console.log('监听器:', data);
myEmitter.on('test', listener);
myEmitter.removeListener('test', listener);

// 错误处理
myEmitter.on('error', (err) => {
    console.error('发生错误:', err.message);
});
```

### stream 流处理

**可读流：**
```javascript
const fs = require('fs');

// 创建可读流
const readableStream = fs.createReadStream('large-file.txt');

readableStream.on('data', (chunk) => {
    console.log(`接收到 ${chunk.length} 字节的数据`);
});

readableStream.on('end', () => {
    console.log('数据读取完成');
});

readableStream.on('error', (err) => {
    console.error('读取错误:', err);
});
```

**可写流：**
```javascript
const fs = require('fs');

// 创建可写流
const writableStream = fs.createWriteStream('output.txt');

writableStream.write('第一行数据\n');
writableStream.write('第二行数据\n');
writableStream.end('最后一行数据');

writableStream.on('finish', () => {
    console.log('写入完成');
});
```

**管道流：**
```javascript
const fs = require('fs');
const zlib = require('zlib');

// 文件压缩
const readStream = fs.createReadStream('input.txt');
const writeStream = fs.createWriteStream('input.txt.gz');
const gzip = zlib.createGzip();

readStream.pipe(gzip).pipe(writeStream);

// 链式处理
readStream
    .pipe(zlib.createGzip())
    .pipe(fs.createWriteStream('output.txt.gz'));
```

### buffer 缓冲区操作

**Buffer 基本操作：**
```javascript
// 创建 Buffer
const buf1 = Buffer.alloc(10); // 创建长度为10的零填充Buffer
const buf2 = Buffer.allocUnsafe(10); // 创建未初始化的Buffer
const buf3 = Buffer.from([1, 2, 3, 4]); // 从数组创建
const buf4 = Buffer.from('Hello World', 'utf8'); // 从字符串创建

// Buffer 操作
console.log(buf4.length); // 11
console.log(buf4.toString()); // 'Hello World'
console.log(buf4.toString('hex')); // 十六进制表示

// Buffer 拼接
const bufA = Buffer.from('Hello ');
const bufB = Buffer.from('World');
const bufC = Buffer.concat([bufA, bufB]);
console.log(bufC.toString()); // 'Hello World'

// Buffer 比较
const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('ABCD');
console.log(buf1.compare(buf2)); // -1
```