## 4.1 函数定义和调用

### 函数声明和函数表达式的区别

#### 函数声明（Function Declaration）

```javascript
// 函数声明
function greet(name) {
    return `Hello, ${name}!`;
}

// 函数声明具有提升（hoisting）特性
console.log(greet("Alice")); // 正常工作，输出: Hello, Alice!

function greet(name) {
    return `Hello, ${name}!`;
}
```

#### 函数表达式（Function Expression）

```javascript
// 函数表达式
const greet = function(name) {
    return `Hello, ${name}!`;
};

// 函数表达式没有提升
console.log(greet("Bob")); // TypeError: Cannot access 'greet' before initialization

const greet = function(name) {
    return `Hello, ${name}!`;
};

// 命名函数表达式
const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1); // 可以在函数内部调用自身
};

console.log(factorial(5)); // 120
console.log(fact(5)); // ReferenceError: fact is not defined
```

#### 主要区别对比

```javascript
// 1. 提升行为
// 函数声明会被完全提升
console.log(declaredFunction()); // "I'm declared"

function declaredFunction() {
    return "I'm declared";
}

// 函数表达式只有变量被提升，值为undefined
console.log(expressFunction); // undefined
console.log(expressFunction()); // TypeError: expressFunction is not a function

var expressFunction = function() {
    return "I'm expressed";
};

// 2. 调试友好性
// 函数声明在调试器中显示函数名
function debugFunction() {
    console.trace(); // 显示 "debugFunction"
}

// 匿名函数表达式显示为 "anonymous"
const debugExpression = function() {
    console.trace(); // 显示 "anonymous"
};
```

### 箭头函数的特性和限制

#### 基本语法

```javascript
// 基本箭头函数
const add = (a, b) => a + b;

// 单参数可以省略括号
const square = x => x * x;

// 多参数需要括号
const multiply = (a, b) => a * b;

// 无参数需要空括号
const getRandom = () => Math.random();

// 函数体多行需要大括号和return
const complexCalculation = (x, y) => {
    const result = x * y + x - y;
    return result > 0 ? result : 0;
};

// 返回对象字面量需要括号
const createUser = (name, age) => ({
    name: name,
    age: age,
    id: Math.random()
});
```

#### 箭头函数的关键特性

##### 1. this绑定

```javascript
// 普通函数 - this取决于调用方式
const person = {
    name: 'Alice',
    greet: function() {
        console.log(`Hello, I'm ${this.name}`);
        
        // 普通函数中的this指向全局对象
        setTimeout(function() {
            console.log(`Delayed greeting from ${this.name}`); // undefined
        }, 1000);
    }
};

// 箭头函数 - this继承自外层作用域
const person2 = {
    name: 'Bob',
    greet: function() {
        console.log(`Hello, I'm ${this.name}`);
        
        // 箭头函数中的this指向person2对象
        setTimeout(() => {
            console.log(`Delayed greeting from ${this.name}`); // Bob
        }, 1000);
    }
};

person.greet();
person2.greet();
```

##### 2. 不能用作构造函数

```javascript
// 普通函数可以作为构造函数
function Person(name) {
    this.name = name;
}

const alice = new Person('Alice');
console.log(alice.name); // Alice

// 箭头函数不能作为构造函数
const ArrowPerson = (name) => {
    this.name = name;
};

// const bob = new ArrowPerson('Bob'); // TypeError: ArrowPerson is not a constructor
```

##### 3. 没有arguments对象

```javascript
// 普通函数有arguments对象
function normalFunction() {
    console.log(arguments); // Arguments对象
    return Array.from(arguments).reduce((sum, num) => sum + num, 0);
}

console.log(normalFunction(1, 2, 3, 4)); // 10

// 箭头函数没有arguments，使用剩余参数
const arrowFunction = (...args) => {
    console.log(args); // 数组
    return args.reduce((sum, num) => sum + num, 0);
};

console.log(arrowFunction(1, 2, 3, 4)); // 10
```

#### 箭头函数的限制

```javascript
// 1. 不能使用yield（不能作为生成器函数）
// const generator = *() => {}; // SyntaxError

// 2. 不能使用await（除非在async箭头函数中）
// const asyncFn = () => await fetch('/api'); // SyntaxError

// 3. 不能绑定this、arguments、super或new.target
const obj = {
    method: () => {
        // this不指向obj
        console.log(this); // 全局对象或undefined（严格模式）
    }
};
```

### 立即执行函数表达式（IIFE）

#### 基本语法

```javascript
// 基本形式1：函数表达式后立即调用
(function() {
    console.log('IIFE executed');
})();

// 基本形式2：使用箭头函数
(() => {
    console.log('Arrow IIFE executed');
})();

// 带参数的IIFE
(function(name, age) {
    console.log(`Hello, ${name}! You are ${age} years old.`);
})('Alice', 25);

// 返回值的IIFE
const result = (function(a, b) {
    return a + b;
})(3, 4);
console.log(result); // 7
```

#### 实际应用场景

##### 1. 创建私有作用域

```javascript
// 避免全局变量污染
(function() {
    const privateVariable = 'This is private';
    const privateFunction = function() {
        return 'Private function result';
    };
    
    // 暴露公共接口
    window.MyModule = {
        publicMethod: function() {
            return privateFunction() + ' - ' + privateVariable;
        }
    };
})();

console.log(MyModule.publicMethod()); // Private function result - This is private
// console.log(privateVariable); // ReferenceError: privateVariable is not defined
```

##### 2. 模块模式

```javascript
const Calculator = (function() {
    let result = 0;
    
    return {
        add: function(x) {
            result += x;
            return this;
        },
        subtract: function(x) {
            result -= x;
            return this;
        },
        multiply: function(x) {
            result *= x;
            return this;
        },
        getResult: function() {
            return result;
        },
        reset: function() {
            result = 0;
            return this;
        }
    };
})();

// 链式调用
const finalResult = Calculator.add(10).subtract(3).multiply(2).getResult();
console.log(finalResult); // 14
```

##### 3. 避免闭包问题

```javascript
// 问题代码：所有回调函数都引用同一个i
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 输出: 3, 3, 3
    }, 100);
}

// 使用IIFE解决闭包问题
for (var i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(function() {
            console.log(index); // 输出: 0, 1, 2
        }, 100);
    })(i);
}

// 现代解决方案：使用let
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 输出: 0, 1, 2
    }, 100);
}
```

### 高阶函数的概念和应用

#### 高阶函数定义

高阶函数是满足以下条件之一的函数：

1. 接受一个或多个函数作为参数
2. 返回一个函数作为结果

#### 接受函数作为参数

```javascript
// 数组方法都是高阶函数
const numbers = [1, 2, 3, 4, 5];

// map接受函数作为参数
const doubled = numbers.map(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter接受函数作为参数
const evens = numbers.filter(x => x % 2 === 0);
console.log(evens); // [2, 4]

// reduce接受函数作为参数
const sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 15

// 自定义高阶函数
function createValidator(validatorFn, errorMessage) {
    return function(value) {
        if (!validatorFn(value)) {
            throw new Error(errorMessage);
        }
        return true;
    };
}

const emailValidator = createValidator(
    email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
    'Invalid email format'
);

const minLengthValidator = createValidator(
    value => value.length >= 6,
    'Value must be at least 6 characters long'
);

try {
    emailValidator('test@example.com'); // 验证通过
    minLengthValidator('password123'); // 验证通过
} catch (error) {
    console.log(error.message);
}
```

#### 返回函数作为结果

```javascript
// 创建特定功能的函数
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12

// 创建配置化的函数
function createGreeter(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeter('Hello');
const sayHi = createGreeter('Hi');

console.log(sayHello('Alice')); // Hello, Alice!
console.log(sayHi('Bob')); // Hi, Bob!
```

#### 实际应用示例

##### 1. 函数组合

```javascript
// 函数组合工具
function compose(...functions) {
    return function(value) {
        return functions.reduceRight((acc, fn) => fn(acc), value);
    };
}

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const addOneThenDoubleThenSquare = compose(square, double, addOne);
console.log(addOneThenDoubleThenSquare(3)); // ((3+1)*2)^2 = 64
```

##### 2. 函数柯里化

```javascript
// 柯里化函数
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...nextArgs) {
            return curried(...args, ...nextArgs);
        };
    };
}

function add(a, b, c) {
    return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

##### 3. 装饰器模式

```javascript
// 日志装饰器
function withLogging(fn) {
    return function(...args) {
        console.log(`Calling ${fn.name} with arguments:`, args);
        const result = fn.apply(this, args);
        console.log(`${fn.name} returned:`, result);
        return result;
    };
}

function calculate(a, b) {
    return a * b + a - b;
}

const loggedCalculate = withLogging(calculate);
loggedCalculate(5, 3);
// 输出:
// Calling calculate with arguments: [5, 3]
// calculate returned: 17
```