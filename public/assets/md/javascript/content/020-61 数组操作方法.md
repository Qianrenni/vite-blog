## 6.1 数组操作方法

### 1. 数组创建和初始化

```javascript
// 数组字面量
const arr1 = [1, 2, 3, 4, 5];
const arr2 = ['apple', 'banana', 'orange'];
const arr3 = [1, 'hello', true, null, {name: 'John'}]; // 混合类型数组

// Array 构造函数
const arr4 = new Array(5); // 创建长度为5的空数组 [empty × 5]
const arr5 = new Array(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
const arr6 = Array(1, 2, 3); // 不使用 new 也可以

// Array.of() - 创建指定元素的数组
const arr7 = Array.of(1); // [1]
const arr8 = Array.of(1, 2, 3); // [1, 2, 3]
const arr9 = Array.of(undefined); // [undefined]

// Array.from() - 从类数组对象或可迭代对象创建数组
const arr10 = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']
const arr11 = Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]

// 类数组对象转换
function example() {
    const args = Array.from(arguments);
    console.log(args); // 转换 arguments 为真正的数组
}
example(1, 2, 3); // [1, 2, 3]

// NodeList 转数组
const divs = Array.from(document.querySelectorAll('div'));

// 设置长度和填充
const arr12 = new Array(10).fill(0); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
const arr13 = new Array(5).fill('default'); // ['default', 'default', 'default', 'default', 'default']
```

### 2. 变异方法和非变异方法

#### 变异方法（修改原数组）

```javascript
const fruits = ['apple', 'banana', 'orange'];

// push() - 在末尾添加元素，返回新长度
const newLength = fruits.push('grape', 'kiwi');
console.log(fruits); // ['apple', 'banana', 'orange', 'grape', 'kiwi']
console.log(newLength); // 5

// pop() - 删除末尾元素，返回删除的元素
const lastFruit = fruits.pop();
console.log(fruits); // ['apple', 'banana', 'orange', 'grape']
console.log(lastFruit); // 'kiwi'

// shift() - 删除首元素，返回删除的元素
const firstFruit = fruits.shift();
console.log(fruits); // ['banana', 'orange', 'grape']
console.log(firstFruit); // 'apple'

// unshift() - 在开头添加元素，返回新长度
const newLength2 = fruits.unshift('mango', 'pear');
console.log(fruits); // ['mango', 'pear', 'banana', 'orange', 'grape']
console.log(newLength2); // 5

// splice() - 添加/删除元素，返回删除的元素数组
const removed = fruits.splice(1, 2, 'lemon', 'lime'); // 从索引1开始删除2个元素，并添加新元素
console.log(fruits); // ['mango', 'lemon', 'lime', 'orange', 'grape']
console.log(removed); // ['pear', 'banana']

// sort() - 排序
const numbers = [3, 1, 4, 1, 5, 9];
numbers.sort(); // 字典序排序（字符串比较）
console.log(numbers); // [1, 1, 3, 4, 5, 9]

// 数字排序需要比较函数
numbers.sort((a, b) => a - b); // 升序
numbers.sort((a, b) => b - a); // 降序

// reverse() - 反转数组
numbers.reverse();
console.log(numbers); // [9, 5, 4, 3, 1, 1]

// fill() - 填充数组
const arr = new Array(5);
arr.fill('x');
console.log(arr); // ['x', 'x', 'x', 'x', 'x']

arr.fill('y', 1, 3); // 从索引1到3（不包括3）填充'y'
console.log(arr); // ['x', 'y', 'y', 'x', 'x']

// copyWithin() - 浅复制数组的一部分到同一数组的另一位置
const arr2 = [1, 2, 3, 4, 5];
arr2.copyWithin(0, 3); // 从索引3开始复制到索引0
console.log(arr2); // [4, 5, 3, 4, 5]
```

#### 非变异方法（不修改原数组）

```javascript
const original = [1, 2, 3, 4, 5];

// concat() - 合并数组
const combined = original.concat([6, 7], [8, 9]);
console.log(combined); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(original); // [1, 2, 3, 4, 5] - 原数组不变

// slice() - 提取部分数组
const part1 = original.slice(1, 4); // 从索引1到4（不包括4）
console.log(part1); // [2, 3, 4]
const part2 = original.slice(2); // 从索引2到末尾
console.log(part2); // [3, 4, 5]
const part3 = original.slice(-2); // 倒数两个元素
console.log(part3); // [4, 5]

// join() - 数组转字符串
const str1 = original.join(); // 默认用逗号分隔
console.log(str1); // '1,2,3,4,5'
const str2 = original.join(' - ');
console.log(str2); // '1 - 2 - 3 - 4 - 5'

// toString() 和 toLocaleString()
console.log(original.toString()); // '1,2,3,4,5'
console.log(original.toLocaleString()); // '1,2,3,4,5'

// indexOf() 和 lastIndexOf()
const arr = [1, 2, 3, 2, 4];
console.log(arr.indexOf(2)); // 1 - 第一次出现的索引
console.log(arr.lastIndexOf(2)); // 3 - 最后一次出现的索引
console.log(arr.indexOf(10)); // -1 - 未找到返回-1

// includes() - 检查是否包含元素
console.log(arr.includes(2)); // true
console.log(arr.includes(10)); // false
console.log(arr.includes(2, 2)); // false - 从索引2开始查找

// find() 和 findIndex()
const people = [
    {name: 'Alice', age: 25},
    {name: 'Bob', age: 30},
    {name: 'Charlie', age: 35}
];

const found = people.find(person => person.age > 28);
console.log(found); // {name: 'Bob', age: 30}

const foundIndex = people.findIndex(person => person.name === 'Charlie');
console.log(foundIndex); // 2

// filter() - 过滤数组
const adults = people.filter(person => person.age >= 30);
console.log(adults); // [{name: 'Bob', age: 30}, {name: 'Charlie', age: 35}]

// map() - 转换数组元素
const names = people.map(person => person.name);
console.log(names); // ['Alice', 'Bob', 'Charlie']

const agesPlusTen = people.map(person => ({...person, age: person.age + 10}));
console.log(agesPlusTen); // [{name: 'Alice', age: 35}, ...]

// reduce() 和 reduceRight()
const numbers = [1, 2, 3, 4, 5];

// 求和
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // 15

// 求最大值
const max = numbers.reduce((max, current) => current > max ? current : max);
console.log(max); // 5

// 数组扁平化
const nested = [1, [2, 3], [4, [5, 6]]];
const flattened = nested.reduce((acc, val) => acc.concat(val), []);
console.log(flattened); // [1, 2, 3, 4, [5, 6]]
```

### 3. 数组迭代和遍历方法

```javascript
const numbers = [1, 2, 3, 4, 5];

// forEach() - 遍历数组
numbers.forEach((value, index, array) => {
    console.log(`Index ${index}: ${value}`);
});

// for...of 循环
for (const value of numbers) {
    console.log(value);
}

// entries(), keys(), values()
for (const [index, value] of numbers.entries()) {
    console.log(`${index}: ${value}`);
}

for (const index of numbers.keys()) {
    console.log(index);
}

for (const value of numbers.values()) {
    console.log(value);
}

// every() - 检查所有元素是否满足条件
const allPositive = numbers.every(num => num > 0);
console.log(allPositive); // true

// some() - 检查是否有元素满足条件
const hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true

// 实际应用示例
const products = [
    {name: 'Laptop', price: 1000, category: 'Electronics'},
    {name: 'Book', price: 20, category: 'Education'},
    {name: 'Phone', price: 800, category: 'Electronics'},
    {name: 'Desk', price: 300, category: 'Furniture'}
];

// 过滤电子产品
const electronics = products.filter(product => product.category === 'Electronics');

// 获取产品名称
const productNames = products.map(product => product.name);

// 计算总价
const totalPrice = products.reduce((sum, product) => sum + product.price, 0);

// 检查是否有昂贵商品
const hasExpensive = products.some(product => product.price > 500);

// 检查所有商品都有价格
const allHavePrice = products.every(product => product.price > 0);
```

### 4. 数组扁平化和转换

```javascript
// 数组扁平化方法

// flat() - 扁平化数组
const nestedArray = [1, [2, 3], [4, [5, 6]]];
console.log(nestedArray.flat()); // [1, 2, 3, 4, [5, 6]] - 默认扁平化一层
console.log(nestedArray.flat(2)); // [1, 2, 3, 4, 5, 6] - 指定扁平化深度

// 深度扁平化
const deepNested = [1, [2, [3, [4, [5]]]]];
console.log(deepNested.flat(Infinity)); // [1, 2, 3, 4, 5]

// flatMap() - 先映射再扁平化一层
const arr = [1, 2, 3];
const result = arr.flatMap(x => [x, x * 2]);
console.log(result); // [1, 2, 2, 4, 3, 6]

// 等价于
const result2 = arr.map(x => [x, x * 2]).flat();
console.log(result2); // [1, 2, 2, 4, 3, 6]

// 实际应用：处理嵌套数据
const sentences = ['Hello world', 'JavaScript is awesome', 'Arrays are useful'];
const words = sentences.flatMap(sentence => sentence.split(' '));
console.log(words); // ['Hello', 'world', 'JavaScript', 'is', 'awesome', 'Arrays', 'are', 'useful']

// 数组转换技巧

// 数组去重
const duplicates = [1, 2, 2, 3, 3, 4, 5, 5];
const unique = [...new Set(duplicates)];
console.log(unique); // [1, 2, 3, 4, 5]

// 数组分组
function groupBy(array, key) {
    return array.reduce((groups, item) => {
        const group = item[key];
        if (!groups[group]) {
            groups[group] = [];
        }
        groups[group].push(item);
        return groups;
    }, {});
}

const people = [
    {name: 'Alice', department: 'IT'},
    {name: 'Bob', department: 'HR'},
    {name: 'Charlie', department: 'IT'},
    {name: 'David', department: 'Finance'}
];

const grouped = groupBy(people, 'department');
console.log(grouped);
// {
//   IT: [{name: 'Alice', department: 'IT'}, {name: 'Charlie', department: 'IT'}],
//   HR: [{name: 'Bob', department: 'HR'}],
//   Finance: [{name: 'David', department: 'Finance'}]
// }

// 数组分块
function chunk(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
    }
    return chunks;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const chunked = chunk(numbers, 3);
console.log(chunked); // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// 数组交集、并集、差集
const arr1 = [1, 2, 3, 4];
const arr2 = [3, 4, 5, 6];

// 交集
const intersection = arr1.filter(x => arr2.includes(x));
console.log(intersection); // [3, 4]

// 并集
const union = [...new Set([...arr1, ...arr2])];
console.log(union); // [1, 2, 3, 4, 5, 6]

// 差集 (arr1 - arr2)
const difference = arr1.filter(x => !arr2.includes(x));
console.log(difference); // [1, 2]
```