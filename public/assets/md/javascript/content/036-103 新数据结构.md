## 10.3 新数据结构

### Set 集合特性

Set 是一个存储唯一值的集合。

```javascript
// 基本用法
const set = new Set([1, 2, 3, 4, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }

// 添加和删除元素
set.add(6);
set.add(1); // 重复值不会被添加
console.log(set.has(1)); // true
set.delete(1);
console.log(set.size); // 5

// 遍历 Set
for (const item of set) {
  console.log(item);
}

set.forEach(item => {
  console.log(item);
});

// 转换为数组
const array = [...set];
console.log(array); // [2, 3, 4, 5, 6]

// 实际应用：数组去重
const numbers = [1, 2, 2, 3, 3, 4, 5, 5];
const uniqueNumbers = [...new Set(numbers)];
console.log(uniqueNumbers); // [1, 2, 3, 4, 5]

// 实际应用：求交集、并集、差集
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([3, 4, 5, 6]);

// 并集
const union = new Set([...setA, ...setB]);
console.log(union); // Set { 1, 2, 3, 4, 5, 6 }

// 交集
const intersection = new Set([...setA].filter(x => setB.has(x)));
console.log(intersection); // Set { 3, 4 }

// 差集
const difference = new Set([...setA].filter(x => !setB.has(x)));
console.log(difference); // Set { 1, 2 }
```

### Map 映射结构

Map 是键值对的集合，键可以是任意类型。

```javascript
// 基本用法
const map = new Map();
map.set('name', 'Alice');
map.set(1, 'number one');
map.set(true, 'boolean key');

console.log(map.get('name')); // Alice
console.log(map.has(1)); // true
console.log(map.size); // 3

// 使用对象作为键
const user1 = { id: 1, name: 'Alice' };
const user2 = { id: 2, name: 'Bob' };
const userMap = new Map();
userMap.set(user1, 'Active');
userMap.set(user2, 'Inactive');

console.log(userMap.get(user1)); // Active

// 初始化时传入数组
const map2 = new Map([
  ['key1', 'value1'],
  ['key2', 'value2'],
  [1, 'number key']
]);

// 遍历 Map
for (const [key, value] of map2) {
  console.log(key, value);
}

map2.forEach((value, key) => {
  console.log(key, value);
});

// 转换为数组
const entries = [...map2];
console.log(entries); // [['key1', 'value1'], ['key2', 'value2'], [1, 'number key']]

// 实际应用：缓存
class SimpleCache {
  constructor() {
    this.cache = new Map();
  }
  
  get(key) {
    return this.cache.get(key);
  }
  
  set(key, value) {
    this.cache.set(key, value);
  }
  
  has(key) {
    return this.cache.has(key);
  }
  
  clear() {
    this.cache.clear();
  }
}

const cache = new SimpleCache();
cache.set('user:1', { name: 'Alice', age: 25 });
console.log(cache.get('user:1')); // { name: 'Alice', age: 25 }
```

### WeakSet 和 WeakMap

WeakSet 和 WeakMap 只能存储对象的弱引用，不会阻止垃圾回收。

```javascript
// WeakSet
const weakSet = new WeakSet();
const obj1 = {};
const obj2 = {};

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true

// WeakSet 不能遍历，也不能获取大小
// console.log(weakSet.size); // undefined
// for (const item of weakSet) // TypeError

// 实际应用：标记对象
const processedObjects = new WeakSet();

function processObject(obj) {
  if (processedObjects.has(obj)) {
    console.log('Object already processed');
    return;
  }
  
  // 处理对象
  console.log('Processing object');
  processedObjects.add(obj);
}

const obj = {};
processObject(obj); // Processing object
processObject(obj); // Object already processed

// WeakMap
const weakMap = new WeakMap();
const domElement = document.createElement('div');
const data = { clickCount: 0 };

weakMap.set(domElement, data);

console.log(weakMap.get(domElement)); // { clickCount: 0 }

// 实际应用：私有数据
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name });
  }
  
  getName() {
    return privateData.get(this).name;
  }
  
  setName(name) {
    privateData.get(this).name = name;
  }
}

const user = new User('Alice');
console.log(user.getName()); // Alice
// 无法直接访问 privateData
```

### 数据结构应用场景

```javascript
// 1. 使用 Set 进行快速查找和去重
class UniqueIdGenerator {
  constructor() {
    this.usedIds = new Set();
  }
  
  generateId() {
    let id;
    do {
      id = Math.random().toString(36).substr(2, 9);
    } while (this.usedIds.has(id));
    
    this.usedIds.add(id);
    return id;
  }
  
  isUsed(id) {
    return this.usedIds.has(id);
  }
}

// 2. 使用 Map 进行复杂键的映射
class Graph {
  constructor() {
    this.adjacencyList = new Map();
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, new Set());
    }
  }
  
  addEdge(vertex1, vertex2) {
    this.addVertex(vertex1);
    this.addVertex(vertex2);
    this.adjacencyList.get(vertex1).add(vertex2);
    this.adjacencyList.get(vertex2).add(vertex1);
  }
  
  getNeighbors(vertex) {
    return this.adjacencyList.get(vertex) || new Set();
  }
}

// 3. 使用 WeakMap 实现 DOM 元素数据绑定
const elementData = new WeakMap();

function bindData(element, data) {
  elementData.set(element, data);
}

function getData(element) {
  return elementData.get(element);
}

function removeData(element) {
  elementData.delete(element);
}

// 4. 综合应用：缓存系统
class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) {
      return undefined;
    }
    
    // 移动到最近使用位置
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }
  
  set(key, value) {
    // 如果已存在，先删除
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // 删除最久未使用的项
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
  
  has(key) {
    return this.cache.has(key);
  }
  
  delete(key) {
    return this.cache.delete(key);
  }
  
  clear() {
    this.cache.clear();
  }
}

// 使用示例
const cache = new LRUCache(3);
cache.set('a', 1);
cache.set('b', 2);
cache.set('c', 3);
console.log(cache.get('a')); // 1
cache.set('d', 4); // 会移除 'b'
console.log(cache.has('b')); // false
```