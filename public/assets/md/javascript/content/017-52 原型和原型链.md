## 5.2 原型和原型链

### 1. prototype 属性机制

每个函数都有一个 prototype 属性：

```javascript
function Animal(name) {
    this.name = name;
}

// 在原型上添加方法
Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

Animal.prototype.type = 'Animal';

const dog = new Animal('Dog');
dog.speak(); // Dog makes a sound
console.log(dog.type); // Animal

// 查看原型关系
console.log(dog.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.constructor === Animal); // true
```

### 2. 原型链继承原理

对象属性查找机制：

```javascript
function Parent() {
    this.parentProp = 'parent property';
}

Parent.prototype.parentMethod = function() {
    return 'parent method';
};

function Child() {
    this.childProp = 'child property';
}

// 建立原型链
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

Child.prototype.childMethod = function() {
    return 'child method';
};

const child = new Child();

// 属性查找顺序：实例 -> Child.prototype -> Parent.prototype -> Object.prototype -> null
console.log(child.childProp); // child property
console.log(child.parentProp); // undefined (在Parent构造函数中定义)
console.log(child.childMethod()); // child method
console.log(child.parentMethod()); // parent method
console.log(child.toString()); // [object Object] (来自Object.prototype)
```

### 3. instanceof 运算符

检查对象是否是某个构造函数的实例：

```javascript
function A() {}
function B() {}

B.prototype = Object.create(A.prototype);

const b = new B();

console.log(b instanceof B); // true
console.log(b instanceof A); // true (通过原型链)
console.log(B instanceof A); // false
console.log(B instanceof Function); // true
console.log(b instanceof Object); // true

// 自定义 instanceof 实现
function myInstanceof(obj, constructor) {
    let proto = Object.getPrototypeOf(obj);
    
    while (proto !== null) {
        if (proto === constructor.prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    
    return false;
}

console.log(myInstanceof(b, B)); // true
console.log(myInstanceof(b, A)); // true
```

### 4. 原型污染安全问题

恶意修改原型对象可能导致安全问题：

```javascript
// 危险示例：原型污染
function processUserInput(input) {
    const user = {};
    
    // 不安全的属性设置
    for (let key in input) {
        user[key] = input[key]; // 如果 key 是 '__proto__'，可能污染原型
    }
    
    return user;
}

// 恶意输入
const maliciousInput = {
    name: 'Alice',
    __proto__: {
        isAdmin: true // 污染 Object.prototype
    }
};

const user = processUserInput(maliciousInput);

// 所有对象都可能受到影响
const anotherObject = {};
console.log(anotherObject.isAdmin); // true (被污染了！)

// 安全的处理方式
function safeProcessUserInput(input) {
    const user = {};
    
    for (let key in input) {
        // 防止原型污染
        if (key !== '__proto__' && key !== 'constructor' && key !== 'prototype') {
            user[key] = input[key];
        }
    }
    
    return user;
}
```