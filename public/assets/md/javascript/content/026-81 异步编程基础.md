## 8.1 异步编程基础

### 1. 同步和异步的区别

```javascript
// 同步编程 - 阻塞执行
console.log('1. 开始执行');

function syncOperation() {
    console.log('2. 同步操作开始');
    // 模拟耗时操作
    for (let i = 0; i < 1000000000; i++) {
        // 耗时计算
    }
    console.log('3. 同步操作结束');
    return '同步结果';
}

console.log('4. 调用同步函数');
const result = syncOperation();
console.log('5. 同步结果:', result);
console.log('6. 结束执行');

// 输出顺序：
// 1. 开始执行
// 4. 调用同步函数
// 2. 同步操作开始
// 3. 同步操作结束
// 5. 同步结果: 同步结果
// 6. 结束执行

// 异步编程 - 非阻塞执行
console.log('1. 开始执行');

function asyncOperation(callback) {
    console.log('2. 异步操作开始');
    
    // 使用 setTimeout 模拟异步操作
    setTimeout(() => {
        console.log('3. 异步操作结束');
        callback('异步结果');
    }, 1000);
    
    console.log('4. 异步操作已启动');
}

console.log('5. 调用异步函数');
asyncOperation((result) => {
    console.log('6. 异步回调执行:', result);
});
console.log('7. 异步函数调用结束');
console.log('8. 结束执行');

// 输出顺序：
// 1. 开始执行
// 5. 调用异步函数
// 2. 异步操作开始
// 4. 异步操作已启动
// 7. 异步函数调用结束
// 8. 结束执行
// (1秒后)
// 3. 异步操作结束
// 6. 异步回调执行: 异步结果

// 实际应用示例：文件读取对比
// 同步读取（阻塞）
const fs = require('fs');
console.log('开始同步读取');
try {
    const data = fs.readFileSync('large-file.txt', 'utf8');
    console.log('同步读取完成:', data.length);
} catch (error) {
    console.error('同步读取失败:', error);
}
console.log('继续执行');

// 异步读取（非阻塞）
console.log('开始异步读取');
fs.readFile('large-file.txt', 'utf8', (err, data) => {
    if (err) {
        console.error('异步读取失败:', err);
    } else {
        console.log('异步读取完成:', data.length);
    }
});
console.log('继续执行，不等待文件读取');
```

### 2. 回调函数模式

```javascript
// 基本回调函数
function fetchData(callback) {
    setTimeout(() => {
        const data = { id: 1, name: 'John' };
        callback(null, data); // Node.js 风格：error-first callback
    }, 1000);
}

fetchData((error, data) => {
    if (error) {
        console.error('获取数据失败:', error);
    } else {
        console.log('获取数据成功:', data);
    }
});

// 回调地狱示例
function getUser(userId, callback) {
    setTimeout(() => {
        callback(null, { id: userId, name: `User${userId}` });
    }, 100);
}

function getPosts(userId, callback) {
    setTimeout(() => {
        callback(null, [`Post1 by User${userId}`, `Post2 by User${userId}`]);
    }, 200);
}

function getComments(postId, callback) {
    setTimeout(() => {
        callback(null, [`Comment1 on ${postId}`, `Comment2 on ${postId}`]);
    }, 150);
}

// 回调地狱 - 嵌套过多，难以维护
getUser(1, (error, user) => {
    if (error) {
        console.error('获取用户失败:', error);
        return;
    }
    
    console.log('用户:', user);
    
    getPosts(user.id, (error, posts) => {
        if (error) {
            console.error('获取帖子失败:', error);
            return;
        }
        
        console.log('帖子:', posts);
        
        if (posts.length > 0) {
            getComments(posts[0], (error, comments) => {
                if (error) {
                    console.error('获取评论失败:', error);
                    return;
                }
                
                console.log('评论:', comments);
            });
        }
    });
});

// 回调函数错误处理
function riskyOperation(callback) {
    setTimeout(() => {
        try {
            // 模拟可能出错的操作
            const random = Math.random();
            if (random < 0.5) {
                throw new Error('随机错误');
            }
            callback(null, '操作成功');
        } catch (error) {
            callback(error, null);
        }
    }, 500);
}

riskyOperation((error, result) => {
    if (error) {
        console.error('操作失败:', error.message);
    } else {
        console.log('操作成功:', result);
    }
});

// 回调函数工具函数
class CallbackUtils {
    // 并行执行多个异步操作
    static parallel(tasks, callback) {
        const results = [];
        let completed = 0;
        let hasError = false;
        
        if (tasks.length === 0) {
            callback(null, []);
            return;
        }
        
        tasks.forEach((task, index) => {
            task((error, result) => {
                if (hasError) return;
                
                if (error) {
                    hasError = true;
                    callback(error, null);
                    return;
                }
                
                results[index] = result;
                completed++;
                
                if (completed === tasks.length) {
                    callback(null, results);
                }
            });
        });
    }
    
    // 串行执行多个异步操作
    static series(tasks, callback) {
        const results = [];
        
        function executeTask(index) {
            if (index >= tasks.length) {
                callback(null, results);
                return;
            }
            
            tasks[index]((error, result) => {
                if (error) {
                    callback(error, null);
                    return;
                }
                
                results.push(result);
                executeTask(index + 1);
            });
        }
        
        executeTask(0);
    }
    
    // 限制并发数量
    static parallelLimit(tasks, limit, callback) {
        const results = [];
        let running = 0;
        let completed = 0;
        let index = 0;
        
        function runNext() {
            if (index >= tasks.length && running === 0) {
                callback(null, results);
                return;
            }
            
            while (running < limit && index < tasks.length) {
                const currentIndex = index++;
                const task = tasks[currentIndex];
                
                running++;
                task((error, result) => {
                    running--;
                    completed++;
                    
                    if (error) {
                        callback(error, null);
                        return;
                    }
                    
                    results[currentIndex] = result;
                    runNext();
                });
            }
        }
        
        runNext();
    }
}

// 使用示例
const tasks = [
    (cb) => setTimeout(() => cb(null, 'Task 1'), 100),
    (cb) => setTimeout(() => cb(null, 'Task 2'), 200),
    (cb) => setTimeout(() => cb(null, 'Task 3'), 150)
];

CallbackUtils.parallel(tasks, (error, results) => {
    console.log('并行执行结果:', results);
});

CallbackUtils.series(tasks, (error, results) => {
    console.log('串行执行结果:', results);
});

CallbackUtils.parallelLimit(tasks, 2, (error, results) => {
    console.log('限制并发执行结果:', results);
});
```

### 3. 事件循环机制

```javascript
// 事件循环详解
console.log('1. 同步代码');

setTimeout(() => {
    console.log('2. setTimeout 0ms');
}, 0);

setImmediate(() => {
    console.log('3. setImmediate');
});

process.nextTick(() => {
    console.log('4. process.nextTick');
});

Promise.resolve().then(() => {
    console.log('5. Promise then');
});

console.log('6. 同步代码结束');

// 输出顺序：
// 1. 同步代码
// 6. 同步代码结束
// 4. process.nextTick
// 5. Promise then
// 2. setTimeout 0ms
// 3. setImmediate

// 事件循环阶段详解
// 1. timers: 执行 setTimeout, setInterval 回调
// 2. pending callbacks: 执行系统操作回调
// 3. idle, prepare: 内部使用
// 4. poll: 检索新的 I/O 事件，执行 I/O 回调
// 5. check: 执行 setImmediate 回调
// 6. close callbacks: 执行 close 事件回调

// 详细示例
console.log('同步代码开始');

// timers 阶段
setTimeout(() => {
    console.log('timer1');
}, 0);

setTimeout(() => {
    console.log('timer2');
}, 0);

// check 阶段
setImmediate(() => {
    console.log('immediate1');
});

setImmediate(() => {
    console.log('immediate2');
});

// microtask 队列
process.nextTick(() => {
    console.log('nextTick1');
});

Promise.resolve().then(() => {
    console.log('promise1');
});

Promise.resolve().then(() => {
    console.log('promise2');
});

process.nextTick(() => {
    console.log('nextTick2');
});

console.log('同步代码结束');

// 执行顺序分析：
// 1. 同步代码执行
// 2. nextTick 队列清空
// 3. Promise 微任务队列清空
// 4. timers 阶段
// 5. check 阶段

// 事件循环实际应用
class EventLoopDemo {
    constructor() {
        this.queue = [];
        this.running = false;
    }
    
    // 模拟事件循环
    addTask(task) {
        this.queue.push(task);
        if (!this.running) {
            this.run();
        }
    }
    
    run() {
        this.running = true;
        
        const execute = () => {
            if (this.queue.length > 0) {
                const task = this.queue.shift();
                try {
                    task();
                } catch (error) {
                    console.error('任务执行错误:', error);
                }
                
                // 使用 setImmediate 确保非阻塞
                setImmediate(execute);
            } else {
                this.running = false;
            }
        };
        
        setImmediate(execute);
    }
}

const demo = new EventLoopDemo();
demo.addTask(() => console.log('任务1'));
demo.addTask(() => console.log('任务2'));
demo.addTask(() => console.log('任务3'));
```

### 4. 宏任务和微任务

```javascript
// 宏任务 (Macro Task) 和微任务 (Micro Task)

// 宏任务包括：
// - setTimeout, setInterval
// - setImmediate (Node.js)
// - I/O 操作
// - UI 渲染 (浏览器)

// 微任务包括：
// - Promise.then/catch/finally
// - process.nextTick (Node.js)
// - queueMicrotask
// - MutationObserver (浏览器)

console.log('1. 同步代码');

// 宏任务
setTimeout(() => {
    console.log('2. setTimeout');
}, 0);

// 微任务
Promise.resolve().then(() => {
    console.log('3. Promise then');
});

Promise.resolve().then(() => {
    console.log('4. Promise then 2');
});

// 宏任务
setTimeout(() => {
    console.log('5. setTimeout 2');
}, 0);

console.log('6. 同步代码结束');

// 输出顺序：
// 1. 同步代码
// 6. 同步代码结束
// 3. Promise then
// 4. Promise then 2
// 2. setTimeout
// 5. setTimeout 2

// 复杂示例：宏任务和微任务的嵌套
console.log('Start');

setTimeout(() => {
    console.log('setTimeout 1');
    Promise.resolve().then(() => {
        console.log('Promise in setTimeout 1');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 1');
    setTimeout(() => {
        console.log('setTimeout in Promise 1');
    }, 0);
});

Promise.resolve().then(() => {
    console.log('Promise 2');
});

setTimeout(() => {
    console.log('setTimeout 2');
}, 0);

console.log('End');

// 输出顺序：
// Start
// End
// Promise 1
// Promise 2
// setTimeout 1
// Promise in setTimeout 1
// setTimeout 2
// setTimeout in Promise 1

// process.nextTick 的特殊性 (Node.js)
console.log('1. Start');

setTimeout(() => {
    console.log('2. setTimeout');
}, 0);

process.nextTick(() => {
    console.log('3. nextTick 1');
});

Promise.resolve().then(() => {
    console.log('4. Promise');
});

process.nextTick(() => {
    console.log('5. nextTick 2');
});

console.log('6. End');

// 输出顺序：
// 1. Start
// 6. End
// 3. nextTick 1
// 5. nextTick 2
// 4. Promise
// 2. setTimeout

// 实际应用：任务调度器
class TaskScheduler {
    constructor() {
        this.microTasks = [];
        this.macroTasks = [];
    }
    
    // 添加微任务
    addMicroTask(task) {
        this.microTasks.push(task);
        if (this.microTasks.length === 1) {
            this.flushMicroTasks();
        }
    }
    
    // 添加宏任务
    addMacroTask(task) {
        this.macroTasks.push(task);
        if (this.macroTasks.length === 1) {
            this.scheduleMacroTask();
        }
    }
    
    // 执行微任务
    flushMicroTasks() {
        Promise.resolve().then(() => {
            while (this.microTasks.length > 0) {
                const task = this.microTasks.shift();
                try {
                    task();
                } catch (error) {
                    console.error('微任务执行错误:', error);
                }
            }
        });
    }
    
    // 调度宏任务
    scheduleMacroTask() {
        setTimeout(() => {
            while (this.macroTasks.length > 0) {
                const task = this.macroTasks.shift();
                try {
                    task();
                } catch (error) {
                    console.error('宏任务执行错误:', error);
                }
            }
        }, 0);
    }
}

const scheduler = new TaskScheduler();

scheduler.addMacroTask(() => console.log('宏任务1'));
scheduler.addMicroTask(() => console.log('微任务1'));
scheduler.addMacroTask(() => console.log('宏任务2'));
scheduler.addMicroTask(() => console.log('微任务2'));
```