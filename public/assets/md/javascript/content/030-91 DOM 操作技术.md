## 9.1 DOM 操作技术

### 1. DOM 节点选择和遍历

```javascript
// DOM 节点选择方法

// 基本选择方法
// getElementById - 通过 ID 选择单个元素
const elementById = document.getElementById('myId');

// getElementsByClassName - 通过类名选择元素集合
const elementsByClass = document.getElementsByClassName('myClass');

// getElementsByTagName - 通过标签名选择元素集合
const elementsByTag = document.getElementsByTagName('div');

// getElementsByName - 通过 name 属性选择元素集合
const elementsByName = document.getElementsByName('myName');

// 现代选择器方法 (返回 NodeList 或单个元素)
// querySelector - 选择第一个匹配的元素
const firstElement = document.querySelector('.myClass'); // CSS 选择器
const specificElement = document.querySelector('#myId .childClass');

// querySelectorAll - 选择所有匹配的元素
const allElements = document.querySelectorAll('.myClass');
const complexSelection = document.querySelectorAll('div[data-role="button"]');

// NodeList 和 HTMLCollection 的区别
const nodeList = document.querySelectorAll('.item'); // 静态 NodeList
const htmlCollection = document.getElementsByClassName('item'); // 动态 HTMLCollection

// NodeList 遍历
nodeList.forEach(element => {
    console.log(element.textContent);
});

// HTMLCollection 遍历
for (let i = 0; i < htmlCollection.length; i++) {
    console.log(htmlCollection[i].textContent);
}

// 转换为数组以便使用数组方法
const elementsArray = Array.from(nodeList);
const filteredElements = elementsArray.filter(el => el.classList.contains('active'));

// 高级选择器示例
const advancedSelectors = {
    // 属性选择器
    attributeSelectors: [
        document.querySelector('[data-id]'), // 有 data-id 属性
        document.querySelector('[data-role="admin"]'), // data-role 等于 "admin"
        document.querySelector('[class*="btn"]'), // class 包含 "btn"
        document.querySelector('[id^="user"]'), // id 以 "user" 开头
        document.querySelector('[href$=".pdf"]') // href 以 ".pdf" 结尾
    ],
    
    // 伪类选择器
    pseudoSelectors: [
        document.querySelector('li:first-child'), // 第一个 li
        document.querySelector('li:last-child'), // 最后一个 li
        document.querySelector('li:nth-child(2n)'), // 偶数位置的 li
        document.querySelector('input:focus'), // 获得焦点的 input
        document.querySelector('a:hover') // 鼠标悬停的 a (实际中很少使用)
    ],
    
    // 组合选择器
    combinedSelectors: [
        document.querySelector('div.container > p'), // 直接子元素
        document.querySelector('ul ~ p'), // 兄弟元素
        document.querySelector('form input[type="text"]'), // 后代元素
        document.querySelectorAll('h1, h2, h3') // 多个选择器
    ]
};

// DOM 遍历方法

// 父节点遍历
function traverseParents(element) {
    const parents = [];
    let current = element.parentElement;
    
    while (current) {
        parents.push(current);
        current = current.parentElement;
    }
    
    return parents;
}

// 子节点遍历
function traverseChildren(element) {
    const children = [];
    
    // 所有子节点（包括文本节点）
    element.childNodes.forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
            children.push(node);
        }
    });
    
    // 只获取元素节点
    const elementChildren = Array.from(element.children);
    
    return { allChildren: children, elementChildren };
}

// 兄弟节点遍历
function traverseSiblings(element) {
    const siblings = [];
    let sibling = element.previousElementSibling;
    
    // 获取前面的兄弟节点
    while (sibling) {
        siblings.unshift(sibling); // 添加到数组开头
        sibling = sibling.previousElementSibling;
    }
    
    sibling = element.nextElementSibling;
    
    // 获取后面的兄弟节点
    while (sibling) {
        siblings.push(sibling);
        sibling = sibling.nextElementSibling;
    }
    
    return siblings;
}

// 深度遍历 DOM 树
function traverseDOMTree(root, callback) {
    callback(root);
    
    for (let child = root.firstElementChild; child; child = child.nextElementSibling) {
        traverseDOMTree(child, callback);
    }
}

// 广度遍历 DOM 树
function traverseDOMBreadth(root, callback) {
    const queue = [root];
    
    while (queue.length > 0) {
        const current = queue.shift();
        callback(current);
        
        for (let child = current.firstElementChild; child; child = child.nextElementSibling) {
            queue.push(child);
        }
    }
}

// 实际应用：查找特定元素
function findElementsByText(root, searchText) {
    const results = [];
    
    traverseDOMTree(root || document.body, element => {
        if (element.nodeType === Node.TEXT_NODE && 
            element.textContent.includes(searchText)) {
            results.push(element.parentElement);
        }
    });
    
    return results;
}

// 实际应用：构建 DOM 结构树
function buildDOMStructure(root) {
    const structure = {
        tag: root.tagName.toLowerCase(),
        id: root.id,
        classes: Array.from(root.classList),
        children: []
    };
    
    for (let child = root.firstElementChild; child; child = child.nextElementSibling) {
        structure.children.push(buildDOMStructure(child));
    }
    
    return structure;
}

// 性能优化的选择器使用
class OptimizedSelector {
    constructor() {
        this.cache = new Map();
    }
    
    // 缓存选择器结果
    select(selector, context = document) {
        const key = `${selector}_${context.tagName || 'document'}`;
        
        if (!this.cache.has(key)) {
            const result = context.querySelector(selector);
            this.cache.set(key, result);
        }
        
        return this.cache.get(key);
    }
    
    selectAll(selector, context = document) {
        const key = `all_${selector}_${context.tagName || 'document'}`;
        
        if (!this.cache.has(key)) {
            const result = context.querySelectorAll(selector);
            this.cache.set(key, result);
        }
        
        return this.cache.get(key);
    }
    
    clearCache() {
        this.cache.clear();
    }
}

// 使用示例
const selector = new OptimizedSelector();
const element = selector.select('#myId .child');
const elements = selector.selectAll('.myClass');
```

### 2. DOM 节点创建和修改

```javascript
// DOM 节点创建

// 创建元素节点
const newDiv = document.createElement('div');
const newSpan = document.createElement('span');
const newInput = document.createElement('input');

// 创建文本节点
const textNode = document.createTextNode('Hello World');

// 创建注释节点
const commentNode = document.createComment('This is a comment');

// 创建文档片段 (DocumentFragment)
const fragment = document.createDocumentFragment();

// 设置元素属性和内容
newDiv.id = 'myDiv';
newDiv.className = 'container';
newDiv.setAttribute('data-role', 'content');
newDiv.textContent = '这是内容';
newDiv.innerHTML = '<strong>这是 HTML 内容</strong>';

// 设置样式
newDiv.style.color = 'red';
newDiv.style.fontSize = '16px';
newDiv.style.backgroundColor = '#f0f0f0';

// 批量设置样式
Object.assign(newDiv.style, {
    padding: '10px',
    margin: '5px',
    border: '1px solid #ccc'
});

// DOM 节点插入

// 插入到父节点的末尾
const parent = document.getElementById('container');
parent.appendChild(newDiv);

// 插入到指定位置
const referenceNode = document.getElementById('reference');
parent.insertBefore(newDiv, referenceNode);

// 使用 insertAdjacentHTML 插入 HTML
parent.insertAdjacentHTML('beforeend', '<p>插入的段落</p>');
parent.insertAdjacentHTML('afterbegin', '<h2>插入的标题</h2>');

// insertAdjacentElement 和 insertAdjacentText
const newElement = document.createElement('strong');
newElement.textContent = '重要文本';
parent.insertAdjacentElement('beforeend', newElement);

// DOM 节点修改

// 修改文本内容
const element = document.getElementById('myElement');
element.textContent = '新文本内容'; // 安全，会转义 HTML
element.innerText = '新文本内容'; // 考虑样式，会触发重排
element.innerHTML = '<strong>新 HTML 内容</strong>'; // 可能存在 XSS 风险

// 修改属性
element.setAttribute('data-value', '123');
element.removeAttribute('data-value');
const value = element.getAttribute('data-value');

// 修改类名
element.className = 'newClass';
element.classList.add('active', 'highlight');
element.classList.remove('inactive');
element.classList.toggle('visible');
element.classList.contains('active'); // 检查是否包含类

// 修改样式
element.style.setProperty('color', 'blue');
element.style.removeProperty('background-color');

// 批量样式修改
element.style.cssText = 'color: red; font-size: 18px;';

// DOM 节点删除和替换

// 删除节点
const nodeToRemove = document.getElementById('toRemove');
nodeToRemove.remove(); // 现代方法

// 传统方法
if (nodeToRemove.parentNode) {
    nodeToRemove.parentNode.removeChild(nodeToRemove);
}

// 替换节点
const oldNode = document.getElementById('old');
const newNode = document.createElement('div');
newNode.textContent = '新节点';
oldNode.replaceWith(newNode); // 现代方法

// 传统方法
oldNode.parentNode.replaceChild(newNode, oldNode);

// 克隆节点
const original = document.getElementById('original');
const clone = original.cloneNode(true); // true 表示深克隆
const shallowClone = original.cloneNode(false); // false 表示浅克隆

// 高级 DOM 操作

// 创建复杂元素结构
function createCard(data) {
    const card = document.createElement('div');
    card.className = 'card';
    
    const header = document.createElement('div');
    header.className = 'card-header';
    header.textContent = data.title;
    
    const body = document.createElement('div');
    body.className = 'card-body';
    
    const content = document.createElement('p');
    content.textContent = data.content;
    
    const footer = document.createElement('div');
    footer.className = 'card-footer';
    
    const button = document.createElement('button');
    button.textContent = '查看详情';
    button.addEventListener('click', () => {
        console.log('查看详情:', data.id);
    });
    
    body.appendChild(content);
    footer.appendChild(button);
    card.appendChild(header);
    card.appendChild(body);
    card.appendChild(footer);
    
    return card;
}

// 使用模板字符串创建 HTML
function createHTMLCard(data) {
    const html = `
        <div class="card" data-id="${data.id}">
            <div class="card-header">${data.title}</div>
            <div class="card-body">
                <p>${data.content}</p>
            </div>
            <div class="card-footer">
                <button onclick="viewDetails(${data.id})">查看详情</button>
            </div>
        </div>
    `;
    
    const temp = document.createElement('div');
    temp.innerHTML = html.trim();
    return temp.firstChild;
}

// 批量 DOM 操作优化
class BatchDOMOperations {
    constructor() {
        this.fragment = document.createDocumentFragment();
    }
    
    // 批量添加元素
    addElements(elements) {
        elements.forEach(element => {
            this.fragment.appendChild(element);
        });
    }
    
    // 应用到 DOM
    applyTo(parent) {
        parent.appendChild(this.fragment);
    }
    
    // 清空片段
    clear() {
        while (this.fragment.firstChild) {
            this.fragment.removeChild(this.fragment.firstChild);
        }
    }
}

// 使用示例
const batchOps = new BatchDOMOperations();
const elements = [];

for (let i = 0; i < 100; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    elements.push(div);
}

batchOps.addElements(elements);
// batchOps.applyTo(document.getElementById('container'));

// DOM 操作工具类
class DOMUtils {
    // 创建元素的便捷方法
    static createElement(tag, attributes = {}, content = '') {
        const element = document.createElement(tag);
        
        // 设置属性
        Object.keys(attributes).forEach(key => {
            if (key === 'className') {
                element.className = attributes[key];
            } else if (key === 'textContent') {
                element.textContent = attributes[key];
            } else if (key === 'innerHTML') {
                element.innerHTML = attributes[key];
            } else {
                element.setAttribute(key, attributes[key]);
            }
        });
        
        // 设置内容
        if (content && !attributes.textContent && !attributes.innerHTML) {
            element.textContent = content;
        }
        
        return element;
    }
    
    // 批量设置样式
    static setStyles(element, styles) {
        Object.assign(element.style, styles);
    }
    
    // 批量添加类
    static addClasses(element, ...classes) {
        element.classList.add(...classes);
    }
    
    // 批量移除类
    static removeClasses(element, ...classes) {
        element.classList.remove(...classes);
    }
    
    // 切换类（支持条件）
    static toggleClass(element, className, condition) {
        if (condition !== undefined) {
            element.classList.toggle(className, condition);
        } else {
            element.classList.toggle(className);
        }
    }
    
    // 安全的 HTML 设置
    static setHTML(element, html) {
        // 简单的 XSS 防护（实际项目中需要更完善的方案）
        const sanitized = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
        element.innerHTML = sanitized;
    }
}

// 使用示例
const button = DOMUtils.createElement('button', {
    className: 'btn btn-primary',
    'data-action': 'submit'
}, '提交');

DOMUtils.setStyles(button, {
    padding: '10px 20px',
    backgroundColor: '#007bff',
    color: 'white',
    border: 'none',
    borderRadius: '4px'
});

DOMUtils.addClasses(button, 'active', 'hover-effect');
```

### 3. DOM 事件处理机制

```javascript
// DOM 事件处理基础

// 添加事件监听器
const button = document.getElementById('myButton');

// 传统方法
button.onclick = function(event) {
    console.log('按钮被点击');
};

// 现代方法 - addEventListener
button.addEventListener('click', function(event) {
    console.log('按钮被点击 - 现代方法');
});

// 使用箭头函数
button.addEventListener('click', (event) => {
    console.log('按钮被点击 - 箭头函数');
});

// 事件对象属性
button.addEventListener('click', (event) => {
    console.log('事件类型:', event.type);
    console.log('目标元素:', event.target);
    console.log('当前目标:', event.currentTarget);
    console.log('事件时间戳:', event.timeStamp);
    console.log('鼠标坐标:', event.clientX, event.clientY);
});

// 移除事件监听器
function handleClick(event) {
    console.log('处理点击事件');
}

button.addEventListener('click', handleClick);
// 移除监听器
button.removeEventListener('click', handleClick);

// 事件监听器选项
button.addEventListener('click', handleClick, {
    once: true, // 只执行一次
    passive: true, // 被动监听器，不会调用 preventDefault
    capture: false // 是否在捕获阶段执行
});

// 事件冒泡和捕获
const container = document.getElementById('container');
const child = document.getElementById('child');

// 捕获阶段
container.addEventListener('click', (event) => {
    console.log('容器 - 捕获阶段');
}, true); // true 表示捕获阶段

// 冒泡阶段
container.addEventListener('click', (event) => {
    console.log('容器 - 冒泡阶段');
}, false); // false 表示冒泡阶段

child.addEventListener('click', (event) => {
    console.log('子元素 - 冒泡阶段');
});

// 阻止事件传播
child.addEventListener('click', (event) => {
    console.log('子元素点击');
    event.stopPropagation(); // 阻止事件继续传播
    // event.stopImmediatePropagation(); // 阻止同级监听器执行
});

// 阻止默认行为
const link = document.getElementById('myLink');
link.addEventListener('click', (event) => {
    event.preventDefault(); // 阻止链接跳转
    console.log('链接点击被阻止');
});

// 键盘事件处理
document.addEventListener('keydown', (event) => {
    console.log('按键:', event.key);
    console.log('键码:', event.keyCode); // 已废弃，使用 event.key
    console.log('是否按下 Ctrl:', event.ctrlKey);
    console.log('是否按下 Alt:', event.altKey);
    console.log('是否按下 Shift:', event.shiftKey);
    
    // 特殊按键处理
    if (event.key === 'Escape') {
        console.log('按下 ESC 键');
    }
    
    if (event.ctrlKey && event.key === 's') {
        event.preventDefault(); // 阻止保存页面
        console.log('Ctrl+S 被按下');
    }
});

// 鼠标事件处理
const mouseArea = document.getElementById('mouseArea');

mouseArea.addEventListener('mousedown', (event) => {
    console.log('鼠标按下:', event.button); // 0: 左键, 1: 中键, 2: 右键
});

mouseArea.addEventListener('mouseup', (event) => {
    console.log('鼠标释放');
});

mouseArea.addEventListener('mousemove', (event) => {
    console.log('鼠标移动:', event.clientX, event.clientY);
});

mouseArea.addEventListener('mouseenter', (event) => {
    console.log('鼠标进入');
});

mouseArea.addEventListener('mouseleave', (event) => {
    console.log('鼠标离开');
});

// 表单事件处理
const form = document.getElementById('myForm');
const input = document.getElementById('myInput');

// 输入事件
input.addEventListener('input', (event) => {
    console.log('输入内容:', event.target.value);
});

// 变化事件
input.addEventListener('change', (event) => {
    console.log('值发生变化:', event.target.value);
});

// 焦点事件
input.addEventListener('focus', (event) => {
    console.log('获得焦点');
});

input.addEventListener('blur', (event) => {
    console.log('失去焦点');
});

// 表单提交
form.addEventListener('submit', (event) => {
    event.preventDefault(); // 阻止表单默认提交
    console.log('表单提交');
    
    // 表单验证
    const formData = new FormData(form);
    for (const [key, value] of formData.entries()) {
        console.log(`${key}: ${value}`);
    }
});

// 窗口事件
window.addEventListener('load', (event) => {
    console.log('页面加载完成');
});

window.addEventListener('resize', (event) => {
    console.log('窗口大小改变:', window.innerWidth, window.innerHeight);
});

window.addEventListener('scroll', (event) => {
    console.log('页面滚动:', window.scrollY);
});

// 自定义事件
const customEvent = new CustomEvent('myCustomEvent', {
    detail: { message: '自定义事件数据' },
    bubbles: true,
    cancelable: true
});

document.addEventListener('myCustomEvent', (event) => {
    console.log('自定义事件触发:', event.detail.message);
});

// 触发自定义事件
document.dispatchEvent(customEvent);

// 事件委托
class EventDelegation {
    constructor(container) {
        this.container = container;
        this.setupDelegation();
    }
    
    setupDelegation() {
        this.container.addEventListener('click', (event) => {
            const target = event.target;
            
            // 委托给按钮
            if (target.matches('.btn')) {
                this.handleButtonClick(target, event);
            }
            
            // 委托给链接
            if (target.matches('a[data-action]')) {
                this.handleLinkClick(target, event);
            }
            
            // 委托给列表项
            if (target.matches('li')) {
                this.handleListItemClick(target, event);
            }
        });
    }
    
    handleButtonClick(button, event) {
        const action = button.dataset.action;
        console.log('按钮点击:', action);
        
        switch (action) {
            case 'delete':
                this.deleteItem(button);
                break;
            case 'edit':
                this.editItem(button);
                break;
            default:
                console.log('未知操作:', action);
        }
    }
    
    handleLinkClick(link, event) {
        event.preventDefault();
        const action = link.dataset.action;
        console.log('链接点击:', action);
    }
    
    handleListItemClick(item, event) {
        console.log('列表项点击:', item.textContent);
    }
    
    deleteItem(button) {
        const item = button.closest('.item');
        if (item) {
            item.remove();
        }
    }
    
    editItem(button) {
        const item = button.closest('.item');
        if (item) {
            const text = item.querySelector('.text');
            if (text) {
                text.contentEditable = true;
                text.focus();
            }
        }
    }
}

// 使用事件委托
// const delegation = new EventDelegation(document.getElementById('container'));

// 事件管理器
class EventManager {
    constructor() {
        this.events = new Map();
    }
    
    // 添加事件监听器
    on(element, eventType, handler, options = {}) {
        const key = this.getEventKey(element, eventType, handler);
        
        if (!this.events.has(key)) {
            element.addEventListener(eventType, handler, options);
            this.events.set(key, { element, eventType, handler, options });
        }
    }
    
    // 移除事件监听器
    off(element, eventType, handler) {
        const key = this.getEventKey(element, eventType, handler);
        
        if (this.events.has(key)) {
            element.removeEventListener(eventType, handler);
            this.events.delete(key);
        }
    }
    
    // 一次性事件
    once(element, eventType, handler, options = {}) {
        const onceHandler = (event) => {
            handler(event);
            this.off(element, eventType, onceHandler);
        };
        
        this.on(element, eventType, onceHandler, options);
    }
    
    // 触发事件
    trigger(element, eventType, detail = {}) {
        const event = new CustomEvent(eventType, { detail });
        element.dispatchEvent(event);
    }
    
    // 移除所有事件监听器
    removeAll() {
        this.events.forEach(({ element, eventType, handler }) => {
            element.removeEventListener(eventType, handler);
        });
        this.events.clear();
    }
    
    // 获取事件键
    getEventKey(element, eventType, handler) {
        return `${element.tagName}_${eventType}_${handler.name}`;
    }
}

// 使用事件管理器
const eventManager = new EventManager();
const button = document.getElementById('myButton');

eventManager.on(button, 'click', (event) => {
    console.log('按钮点击');
});

eventManager.once(button, 'click', (event) => {
    console.log('只会执行一次');
});

// 事件节流和防抖
class EventUtils {
    // 防抖 - 限制函数执行频率
    static debounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }
    
    // 节流 - 固定时间间隔内只执行一次
    static throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    // 事件节流应用
    static setupThrottledScroll(callback, delay = 100) {
        const throttledCallback = this.throttle(callback, delay);
        window.addEventListener('scroll', throttledCallback);
        return throttledCallback;
    }
    
    // 事件防抖应用
    static setupDebouncedResize(callback, delay = 300) {
        const debouncedCallback = this.debounce(callback, delay);
        window.addEventListener('resize', debouncedCallback);
        return debouncedCallback;
    }
}

// 使用示例
const searchInput = document.getElementById('search');

// 防抖搜索
const debouncedSearch = EventUtils.debounce((event) => {
    console.log('执行搜索:', event.target.value);
}, 300);

searchInput.addEventListener('input', debouncedSearch);

// 节流滚动处理
const throttledScroll = EventUtils.throttle(() => {
    console.log('滚动位置:', window.scrollY);
}, 100);

window.addEventListener('scroll', throttledScroll);
```

### 4. DOM 性能优化

```javascript
// DOM 性能优化技术

// 1. 减少 DOM 操作次数

// 不好的做法 - 多次 DOM 操作
function badDOMUpdate() {
    const list = document.getElementById('list');
    for (let i = 0; i < 1000; i++) {
        const item = document.createElement('li');
        item.textContent = `Item ${i}`;
        list.appendChild(item); // 每次都触发重排
    }
}

// 好的做法 - 使用文档片段
function goodDOMUpdate() {
    const list = document.getElementById('list');
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < 1000; i++) {
        const item = document.createElement('li');
        item.textContent = `Item ${i}`;
        fragment.appendChild(item);
    }
    
    list.appendChild(fragment); // 只触发一次重排
}

// 2. 批量样式修改

// 不好的做法 - 多次修改样式
function badStyleUpdate(element) {
    element.style.color = 'red';
    element.style.fontSize = '16px';
    element.style.backgroundColor = 'yellow';
    // 每次修改都可能触发重排和重绘
}

// 好的做法 - 批量修改
function goodStyleUpdate(element) {
    // 方法1: 使用 cssText
    element.style.cssText = 'color: red; font-size: 16px; background-color: yellow;';
    
    // 方法2: 修改 class
    element.className = 'updated-style';
    
    // 方法3: 使用 CSS 类切换
    element.classList.add('highlight', 'large-text');
}

// 3. 虚拟滚动优化

class VirtualScroller {
    constructor(container, items, itemHeight = 50) {
        this.container = container;
        this.items = items;
        this.itemHeight = itemHeight;
        this.visibleCount = Math.ceil(container.clientHeight / itemHeight) + 2;
        this.startIndex = 0;
        
        this.setupContainer();
        this.render();
        this.setupScrollListener();
    }
    
    setupContainer() {
        this.container.style.height = `${this.items.length * this.itemHeight}px`;
        this.container.style.position = 'relative';
        this.container.style.overflow = 'auto';
    }
    
    render() {
        // 清空容器
        this.container.innerHTML = '';
        
        // 创建可见项
        const fragment = document.createDocumentFragment();
        
        for (let i = this.startIndex; i < Math.min(this.startIndex + this.visibleCount, this.items.length); i++) {
            const item = this.createItem(this.items[i], i);
            fragment.appendChild(item);
        }
        
        this.container.appendChild(fragment);
    }
    
    createItem(data, index) {
        const item = document.createElement('div');
        item.style.position = 'absolute';
        item.style.top = `${index * this.itemHeight}px`;
        item.style.height = `${this.itemHeight}px`;
        item.style.width = '100%';
        item.textContent = data;
        return item;
    }
    
    setupScrollListener() {
        this.container.addEventListener('scroll', () => {
            const scrollTop = this.container.scrollTop;
            const newStartIndex = Math.floor(scrollTop / this.itemHeight);
            
            if (newStartIndex !== this.startIndex) {
                this.startIndex = newStartIndex;
                this.render();
            }
        });
    }
}

// 4. DOM 查询优化

class OptimizedDOMQuery {
    constructor() {
        this.cache = new Map();
    }
    
    // 缓存查询结果
    query(selector, context = document) {
        const key = `${selector}_${context.tagName || 'document'}`;
        
        if (!this.cache.has(key)) {
            const result = context.querySelector(selector);
            this.cache.set(key, result);
        }
        
        return this.cache.get(key);
    }
    
    queryAll(selector, context = document) {
        const key = `all_${selector}_${context.tagName || 'document'}`;
        
        if (!this.cache.has(key)) {
            const result = context.querySelectorAll(selector);
            this.cache.set(key, result);
        }
        
        return this.cache.get(key);
    }
    
    // 预查询常用元素
    preloadSelectors(selectors) {
        selectors.forEach(selector => {
            this.query(selector);
        });
    }
    
    clearCache() {
        this.cache.clear();
    }
}

// 5. 事件处理优化

class OptimizedEventManager {
    constructor() {
        this.delegates = new Map();
    }
    
    // 事件委托优化
    delegate(container, eventType, selector, handler) {
        const key = `${container.tagName}_${eventType}_${selector}`;
        
        if (!this.delegates.has(key)) {
            container.addEventListener(eventType, (event) => {
                const target = event.target;
                if (target.matches && target.matches(selector)) {
                    handler.call(target, event);
                }
            });
            
            this.delegates.set(key, true);
        }
    }
    
    // 事件节流
    throttle(handler, delay) {
        let lastExecTime = 0;
        return function(...args) {
            const now = Date.now();
            if (now - lastExecTime >= delay) {
                handler.apply(this, args);
                lastExecTime = now;
            }
        };
    }
    
    // 事件防抖
    debounce(handler, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => handler.apply(this, args), delay);
        };
    }
}

// 6. 内存泄漏预防

class MemorySafeDOM {
    constructor() {
        this.eventListeners = new WeakMap();
    }
    
    // 安全添加事件监听器
    addEventListener(element, eventType, handler, options = {}) {
        element.addEventListener(eventType, handler, options);
        
        if (!this.eventListeners.has(element)) {
            this.eventListeners.set(element, []);
        }
        
        this.eventListeners.get(element).push({
            eventType,
            handler,
            options
        });
    }
    
    // 移除元素及其所有事件监听器
    removeElement(element) {
        if (this.eventListeners.has(element)) {
            const listeners = this.eventListeners.get(element);
            listeners.forEach(({ eventType, handler }) => {
                element.removeEventListener(eventType, handler);
            });
            this.eventListeners.delete(element);
        }
        
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
    
    // 清理所有监听器
    cleanup() {
        this.eventListeners.forEach((listeners, element) => {
            listeners.forEach(({ eventType, handler }) => {
                element.removeEventListener(eventType, handler);
            });
        });
        this.eventListeners.clear();
    }
}

// 7. 性能监控工具

class PerformanceMonitor {
    constructor() {
        this.measurements = [];
    }
    
    // 测量函数执行时间
    measure(name, fn) {
        const start = performance.now();
        const result = fn();
        const end = performance.now();
        
        const duration = end - start;
        this.measurements.push({ name, duration });
        
        console.log(`${name}: ${duration.toFixed(2)}ms`);
        return result;
    }
    
    // DOM 操作性能测试
    testDOMOperations() {
        // 测试创建元素性能
        this.measure('创建1000个元素', () => {
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < 1000; i++) {
                const div = document.createElement('div');
                div.textContent = `Item ${i}`;
                fragment.appendChild(div);
            }
            return fragment;
        });
        
        // 测试查询性能
        this.measure('查询100次元素', () => {
            for (let i = 0; i < 100; i++) {
                document.querySelector('.test-class');
            }
        });
        
        // 测试样式修改性能
        this.measure('修改100个元素样式', () => {
            const elements = document.querySelectorAll('.test-item');
            elements.forEach(el => {
                el.style.color = 'red';
            });
        });
    }
    
    // 获取性能报告
    getReport() {
        return this.measurements.map(m => ({
            operation: m.name,
            time: `${m.duration.toFixed(2)}ms`
        }));
    }
    
    // 清空测量数据
    clear() {
        this.measurements = [];
    }
}

// 8. 实际应用：高性能列表渲染

class HighPerformanceList {
    constructor(container, options = {}) {
        this.container = container;
        this.items = [];
        this.visibleItems = [];
        this.itemHeight = options.itemHeight || 50;
        this.buffer = options.buffer || 5;
        this.renderFunction = options.render || this.defaultRender;
        
        this.setupContainer();
        this.setupScrollHandler();
    }
    
    setupContainer() {
        this.container.style.overflow = 'auto';
        this.container.style.position = 'relative';
    }
    
    addItem(item) {
        this.items.push(item);
        this.updateContainerHeight();
        this.updateVisibleItems();
    }
    
    addItems(items) {
        this.items.push(...items);
        this.updateContainerHeight();
        this.updateVisibleItems();
    }
    
    updateContainerHeight() {
        this.container.style.height = `${this.items.length * this.itemHeight}px`;
    }
    
    setupScrollHandler() {
        let ticking = false;
        
        this.container.addEventListener('scroll', () => {
            if (!ticking) {
                requestAnimationFrame(() => {
                    this.updateVisibleItems();
                    ticking = false;
                });
                ticking = true;
            }
        });
    }
    
    updateVisibleItems() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        
        const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.buffer);
        const endIndex = Math.min(
            this.items.length,
            Math.ceil((scrollTop + containerHeight) / this.itemHeight) + this.buffer
        );
        
        this.renderVisibleItems(startIndex, endIndex);
    }
    
    renderVisibleItems(startIndex, endIndex) {
        // 清空容器
        this.container.innerHTML = '';
        
        const fragment = document.createDocumentFragment();
        
        for (let i = startIndex; i < endIndex; i++) {
            const itemElement = this.renderFunction(this.items[i], i);
            itemElement.style.position = 'absolute';
            itemElement.style.top = `${i * this.itemHeight}px`;
            itemElement.style.height = `${this.itemHeight}px`;
            itemElement.style.width = '100%';
            
            fragment.appendChild(itemElement);
        }
        
        this.container.appendChild(fragment);
    }
    
    defaultRender(item, index) {
        const element = document.createElement('div');
        element.textContent = typeof item === 'object' ? JSON.stringify(item) : String(item);
        return element;
    }
    
    // 更新特定项目
    updateItem(index, newItem) {
        this.items[index] = newItem;
        // 如果该项目当前可见，重新渲染
        this.updateVisibleItems();
    }
    
    // 移除项目
    removeItem(index) {
        this.items.splice(index, 1);
        this.updateContainerHeight();
        this.updateVisibleItems();
    }
}

// 使用示例
// const container = document.getElementById('list-container');
// const list = new HighPerformanceList(container, {
//     itemHeight: 60,
//     render: (item, index) => {
//         const div = document.createElement('div');
//         div.innerHTML = `<strong>${item.name}</strong><br>${item.description}`;
//         return div;
//     }
// });
//
// // 添加大量数据
// const data = Array.from({ length: 10000 }, (_, i) => ({
//     name: `Item ${i}`,
//     description: `Description for item ${i}`
// }));
// list.addItems(data);

// 9. CSS 动画优化

class OptimizedAnimations {
    // 使用 transform 和 opacity 进行动画（触发合成层）
    static animateWithTransform(element, animationProps, duration = 300) {
        element.style.transition = `transform ${duration}ms ease, opacity ${duration}ms ease`;
        
        Object.keys(animationProps).forEach(prop => {
            if (prop === 'x' || prop === 'y' || prop === 'scale') {
                const currentTransform = element.style.transform || '';
                let newTransform = currentTransform;
                
                if (prop === 'x') {
                    newTransform += ` translateX(${animationProps[prop]}px)`;
                } else if (prop === 'y') {
                    newTransform += ` translateY(${animationProps[prop]}px)`;
                } else if (prop === 'scale') {
                    newTransform += ` scale(${animationProps[prop]})`;
                }
                
                element.style.transform = newTransform;
            } else if (prop === 'opacity') {
                element.style.opacity = animationProps[prop];
            }
        });
    }
    
    // 使用 requestAnimationFrame 优化动画
    static smoothAnimation(element, from, to, duration, property) {
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 缓动函数
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentValue = from + (to - from) * easeProgress;
            
            element.style[property] = `${currentValue}px`;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    // 硬件加速提示
    static enableHardwareAcceleration(element) {
        element.style.transform = 'translateZ(0)';
        // 或者
        // element.style.willChange = 'transform';
    }
}

// 10. 性能测试工具

class DOMPerformanceTester {
    static testCreateElements(count) {
        console.time('创建元素');
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < count; i++) {
            const div = document.createElement('div');
            div.textContent = `Item ${i}`;
            fragment.appendChild(div);
        }
        console.timeEnd('创建元素');
        return fragment;
    }
    
    static testQuerySelectors(count, selector) {
        console.time('查询元素');
        for (let i = 0; i < count; i++) {
            document.querySelector(selector);
        }
        console.timeEnd('查询元素');
    }
    
    static testStyleUpdates(elements) {
        console.time('样式更新');
        elements.forEach(el => {
            el.style.color = 'red';
            el.style.fontSize = '16px';
        });
        console.timeEnd('样式更新');
    }
    
    static testEventHandling(elements, eventType) {
        console.time('事件处理');
        elements.forEach(el => {
            el.addEventListener(eventType, () => {});
        });
        console.timeEnd('事件处理');
    }
}

// 使用性能测试
// const testElements = Array.from({ length: 1000 }, (_, i) => {
//     const div = document.createElement('div');
//     div.className = 'test-item';
//     div.textContent = `Test ${i}`;
//     return div;
// });
//
// DOMPerformanceTester.testCreateElements(1000);
// DOMPerformanceTester.testQuerySelectors(100, '.test-item');
// DOMPerformanceTester.testStyleUpdates(testElements);
```