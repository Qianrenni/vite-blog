## 4.3 作用域和闭包

### 词法作用域原理

#### 作用域链

```javascript
// 全局作用域
const globalVar = 'I am global';

function outerFunction() {
    // outerFunction的作用域
    const outerVar = 'I am outer';
    
    function innerFunction() {
        // innerFunction的作用域
        const innerVar = 'I am inner';
        
        // 可以访问所有外层作用域的变量
        console.log(globalVar); // I am global
        console.log(outerVar);   // I am outer
        console.log(innerVar);   // I am inner
    }
    
    innerFunction();
    
    // 不能访问内层作用域的变量
    // console.log(innerVar); // ReferenceError
}

outerFunction();

// 不能访问函数内部的变量
// console.log(outerVar); // ReferenceError
```

#### 作用域查找规则

```javascript
const x = 1;

function function1() {
    const x = 2;
    
    function function2() {
        const x = 3;
        
        function function3() {
            // 从最近的作用域开始查找
            console.log(x); // 3 (function3作用域)
        }
        
        function3();
    }
    
    function2();
}

function1();

// 变量遮蔽
const name = 'Global';

function showName() {
    const name = 'Local';
    console.log(name); // Local (局部变量遮蔽全局变量)
}

showName();
console.log(name); // Global
```

#### 块级作用域

```javascript
// var没有块级作用域
if (true) {
    var blockVar = 'I am not block scoped';
}
console.log(blockVar); // I am not block scoped

// let和const有块级作用域
if (true) {
    let blockLet = 'I am block scoped';
    const blockConst = 'I am also block scoped';
    console.log(blockLet); // I am block scoped
    console.log(blockConst); // I am also block scoped
}
// console.log(blockLet); // ReferenceError
// console.log(blockConst); // ReferenceError

// 循环中的块级作用域
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i); // 0, 1, 2 (每次循环都有独立的i)
    }, 100);
}

// 使用var会有问题
for (var j = 0; j < 3; j++) {
    setTimeout(() => {
        console.log(j); // 3, 3, 3 (所有回调共享同一个j)
    }, 100);
}
```

### 闭包的形成和应用

#### 闭包基本概念

```javascript
// 闭包：内部函数可以访问外部函数的变量
function outerFunction(outerVariable) {
    return function innerFunction(innerVariable) {
        console.log('Outer:', outerVariable);
        console.log('Inner:', innerVariable);
    };
}

const closure = outerFunction('outside');
closure('inside');
// Outer: outside
// Inner: inside

// 闭包保持对外部变量的引用
function createCounter() {
    let count = 0;
    
    return function() {
        count++;
        return count;
    };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (独立的闭包环境)
console.log(counter1()); // 3
```

#### 闭包的实际应用

##### 1. 数据私有化

```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;
    
    return {
        deposit: function(amount) {
            if (amount > 0) {
                balance += amount;
                return balance;
            }
            throw new Error('Deposit amount must be positive');
        },
        withdraw: function(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                return balance;
            }
            throw new Error('Invalid withdrawal amount');
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(1000);
console.log(account.deposit(500)); // 1500
console.log(account.withdraw(200)); // 1300
console.log(account.getBalance()); // 1300
// console.log(account.balance); // undefined (私有变量)
```

##### 2. 函数工厂

```javascript
function createValidator(type) {
    switch (type) {
        case 'email':
            return function(value) {
                return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
            };
        case 'phone':
            return function(value) {
                return /^\d{10,11}$/.test(value.replace(/[-\s]/g, ''));
            };
        case 'password':
            return function(value) {
                return value.length >= 8 && /[A-Z]/.test(value) && /[0-9]/.test(value);
            };
        default:
            return function() {
                return true;
            };
    }
}

const emailValidator = createValidator('email');
const phoneValidator = createValidator('phone');

console.log(emailValidator('test@example.com')); // true
console.log(phoneValidator('123-456-7890')); // true
```

##### 3. 事件处理

```javascript
// 为多个元素添加事件监听器
function attachListeners() {
    const buttons = document.querySelectorAll('.button');
    
    buttons.forEach((button, index) => {
        // 闭包保存每个按钮的索引
        button.addEventListener('click', function() {
            console.log(`Button ${index} clicked`);
        });
    });
}

// 防抖函数
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        // 清除之前的定时器
        clearTimeout(timeoutId);
        // 设置新的定时器
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

const debouncedSearch = debounce(function(query) {
    console.log('Searching for:', query);
}, 300);
```

##### 4. 柯里化和偏函数应用

```javascript
// 柯里化函数利用闭包保存参数
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...nextArgs) {
            return curried(...args, ...nextArgs);
        };
    };
}

function multiply(a, b, c) {
    return a * b * c;
}

const curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4)); // 24
console.log(curriedMultiply(2, 3)(4)); // 24

// 偏函数应用
function partial(fn, ...fixedArgs) {
    return function(...remainingArgs) {
        const args = [...fixedArgs];
        let argIndex = 0;
        
        for (let i = 0; i < args.length; i++) {
            if (args[i] === undefined) {
                args[i] = remainingArgs[argIndex++];
            }
        }
        
        return fn.apply(this, args);
    };
}

function greet(greeting, name, punctuation) {
    return `${greeting}, ${name}${punctuation}`;
}

const sayHello = partial(greet, 'Hello', undefined, '!');
console.log(sayHello('Alice')); // Hello, Alice!
```

### 内存泄漏风险和防范

#### 常见内存泄漏场景

##### 1. 意外的全局变量

```javascript
// 错误示例
function leakingFunction() {
    // 忘记使用var/let/const
    globalVar = 'This becomes a global variable';
}

// 正确示例
function nonLeakingFunction() {
    const localVar = 'This stays local';
}
```

##### 2. 被遗忘的定时器

```javascript
// 可能导致内存泄漏
function startTimer() {
    const largeData = new Array(1000000).fill('data');
    
    setInterval(() => {
        console.log(largeData[0]); // 保持对largeData的引用
    }, 1000);
}

// 改进版本
function startTimerImproved() {
    const largeData = new Array(1000000).fill('data');
    let timerId;
    
    timerId = setInterval(() => {
        console.log(largeData[0]);
    }, 1000);
    
    // 提供清理方法
    return function cleanup() {
        clearInterval(timerId);
    };
}

const cleanup = startTimerImproved();
// 在适当时候调用cleanup()
```

##### 3. 闭包中的循环引用

```javascript
// 可能导致内存泄漏
function createCircularReference() {
    const obj = {};
    obj.self = obj; // 循环引用
    
    return function() {
        return obj;
    };
}

// DOM事件监听器泄漏
function attachEventListeners() {
    const button = document.getElementById('myButton');
    
    // 每次调用都会添加新的监听器
    button.addEventListener('click', function() {
        console.log('Button clicked');
    });
}

// 改进版本
function attachEventListenersImproved() {
    const button = document.getElementById('myButton');
    const handler = function() {
        console.log('Button clicked');
    };
    
    // 移除旧的监听器
    button.removeEventListener('click', handler);
    // 添加新的监听器
    button.addEventListener('click', handler);
    
    // 返回清理函数
    return function cleanup() {
        button.removeEventListener('click', handler);
    };
}
```

#### 内存泄漏防范策略

##### 1. 及时清理资源

```javascript
// 使用WeakMap避免内存泄漏
const privateData = new WeakMap();

function createSecureObject(data) {
    const obj = {};
    privateData.set(obj, data);
    
    obj.getData = function() {
        return privateData.get(obj);
    };
    
    return obj;
}

// 当obj被垃圾回收时，WeakMap中的对应条目也会被自动清理
```

##### 2. 合理使用闭包

```javascript
// 避免不必要的闭包
function createManyFunctions() {
    const functions = [];
    
    // 不好的做法：每个函数都创建闭包
    for (let i = 0; i < 1000; i++) {
        functions.push(function() {
            return i; // 每个函数都保持对i的引用
        });
    }
    
    return functions;
}

// 更好的做法
function createManyFunctionsImproved() {
    const functions = [];
    
    for (let i = 0; i < 1000; i++) {
        functions.push(createFunction(i));
    }
    
    return functions;
}

function createFunction(value) {
    return function() {
        return value;
    };
}
```

##### 3. 监控内存使用

```javascript
// 内存使用监控工具
function monitorMemory() {
    if (performance.memory) {
        console.log('Used:', performance.memory.usedJSHeapSize);
        console.log('Total:', performance.memory.totalJSHeapSize);
        console.log('Limit:', performance.memory.jsHeapSizeLimit);
    }
}

// 定期检查内存使用情况
setInterval(monitorMemory, 5000);
```

### 模块模式的实现

#### 基本模块模式

```javascript
// 基本模块模式
const MyModule = (function() {
    // 私有变量和函数
    let privateVariable = 0;
    
    function privateFunction() {
        return 'This is private';
    }
    
    // 返回公共接口
    return {
        publicVariable: 'This is public',
        
        publicMethod: function() {
            privateVariable++;
            return privateFunction() + ' - Counter: ' + privateVariable;
        },
        
        getPrivateVariable: function() {
            return privateVariable;
        }
    };
})();

console.log(MyModule.publicVariable); // This is public
console.log(MyModule.publicMethod()); // This is private - Counter: 1
console.log(MyModule.getPrivateVariable()); // 1
// MyModule.privateFunction(); // TypeError: MyModule.privateFunction is not a function
```

#### 增强模块模式

```javascript
// 增强模块模式 - 支持继承
const EnhancedModule = (function() {
    // 私有变量
    let instance;
    
    // 构造函数
    function Constructor(name) {
        this.name = name;
    }
    
    // 原型方法
    Constructor.prototype.getName = function() {
        return this.name;
    };
    
    // 工厂方法
    return function(name) {
        if (!instance) {
            instance = new Constructor(name);
        }
        return instance;
    };
})();

const module1 = EnhancedModule('First');
const module2 = EnhancedModule('Second');
console.log(module1.getName()); // First
console.log(module2.getName()); // First (单例)
console.log(module1 === module2); // true
```

#### 现代模块模式

```javascript
// ES6模块模式
const ModulePattern = (function() {
    // 私有状态
    const privateState = new Map();
    
    class Module {
        constructor(id) {
            this.id = id;
            privateState.set(this, {
                counter: 0,
                data: []
            });
        }
        
        increment() {
            const state = privateState.get(this);
            state.counter++;
            return state.counter;
        }
        
        addData(item) {
            const state = privateState.get(this);
            state.data.push(item);
            return state.data.length;
        }
        
        getData() {
            const state = privateState.get(this);
            return [...state.data]; // 返回副本
        }
    }
    
    // 静态方法
    Module.create = function(id) {
        return new Module(id);
    };
    
    return Module;
})();

const myModule = ModulePattern.create('test');
console.log(myModule.increment()); // 1
console.log(myModule.addData('item1')); // 1
console.log(myModule.getData()); // ['item1']
```

#### 实际应用示例

```javascript
// 配置管理模块
const ConfigManager = (function() {
    // 私有配置存储
    let config = {};
    let observers = [];
    
    // 私有方法
    function notifyObservers(key, oldValue, newValue) {
        observers.forEach(observer => {
            observer(key, oldValue, newValue);
        });
    }
    
    function validateConfig(newConfig) {
        // 配置验证逻辑
        return typeof newConfig === 'object' && newConfig !== null;
    }
    
    // 公共接口
    return {
        // 获取配置值
        get: function(key) {
            return key ? config[key] : { ...config };
        },
        
        // 设置配置值
        set: function(key, value) {
            if (typeof key === 'object') {
                // 批量设置
                const oldConfig = { ...config };
                Object.assign(config, key);
                notifyObservers('*', oldConfig, config);
            } else {
                // 单个设置
                const oldValue = config[key];
                config[key] = value;
                notifyObservers(key, oldValue, value);
            }
        },
        
        // 重置配置
        reset: function() {
            const oldConfig = { ...config };
            config = {};
            notifyObservers('*', oldConfig, {});
        },
        
        // 订阅配置变化
        subscribe: function(observer) {
            if (typeof observer === 'function') {
                observers.push(observer);
                return function unsubscribe() {
                    const index = observers.indexOf(observer);
                    if (index > -1) {
                        observers.splice(index, 1);
                    }
                };
            }
        },
        
        // 验证配置
        validate: function(newConfig) {
            return validateConfig(newConfig);
        }
    };
})();

// 使用示例
const unsubscribe = ConfigManager.subscribe((key, oldValue, newValue) => {
    console.log(`Config changed: ${key}`, oldValue, newValue);
});

ConfigManager.set('apiUrl', 'https://api.example.com');
ConfigManager.set('timeout', 5000);
console.log(ConfigManager.get()); // { apiUrl: 'https://api.example.com', timeout: 5000 }
```