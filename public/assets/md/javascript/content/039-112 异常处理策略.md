## 11.2 异常处理策略

### 1. `try...catch` 语句使用

`try...catch` 是 JavaScript 中最基本的同步异常捕获机制。

#### 基本语法：

```js
try {
    // 可能出错的代码
    riskyOperation();
} catch (err) {
    // 处理错误
    console.error("捕获到错误:", err.message);
} finally {
    // 可选，无论是否出错都会执行
}
```

#### 注意事项：

- `catch` 块中的 `err` 是错误对象
- 推荐使用 `err` 而不是 `error` 保持一致性
- 不要忽略错误（避免空 `catch {}`）

#### 捕获特定错误类型

```js
try {
    someOperation();
} catch (err) {
    if (err instanceof TypeError) {
        console.log("类型错误");
    } else if (err instanceof ReferenceError) {
        console.log("引用错误");
    } else {
        console.log("未知错误");
        throw err; // 重新抛出不处理的错误
    }
}
```

> ✅ 最佳实践：
> - 尽量只捕获你能处理的错误
> - 处理不了的错误应重新抛出
> - 避免使用 `catch (e)` 捕获所有异常而不做判断

---

### 2. `finally` 块执行机制

`finally` 块用于执行**无论是否发生异常都必须执行的清理操作**。

#### 基本行为：

```js
try {
    console.log("进入 try");
    throw new Error("出错了");
} catch (err) {
    console.log("进入 catch");
} finally {
    console.log("进入 finally");
}
// 输出：进入 try → 进入 catch → 进入 finally
```

#### `finally` 的执行优先级

即使 `try` 或 `catch` 中有 `return`，`finally` 也会执行：

```js
function test() {
    try {
        return "try";
    } catch (err) {
        return "catch";
    } finally {
        console.log("finally always runs");
    }
}
test(); // 输出: "finally always runs"，然后返回 "try"
```

#### 特殊情况：`finally` 中的 `return` 会覆盖前面的返回值

```js
function test() {
    try {
        return "try";
    } finally {
        return "finally"; // 覆盖前面的 return
    }
}
test(); // 返回 "finally"
```

> ⚠️ 警告：避免在 `finally` 中使用 `return`、`throw` 或改变控制流，容易造成逻辑混乱。

#### 典型应用场景：

- 关闭文件或连接
- 清理定时器
- 恢复状态
- 加载状态关闭（如 UI loading 动画）

```js
let loading = true;
try {
    showLoading();
    await fetchData();
} catch (err) {
    showError(err.message);
} finally {
    hideLoading(); // 无论成功失败都要关闭 loading
}
```

---

### 3. 异步错误处理

异步操作中的错误不能用普通的 `try...catch` 直接捕获，需特殊处理。

#### (1) Promise 错误处理

```js
// 方法一：.catch()
fetch('/api/data')
    .then(res => res.json())
    .then(data => console.log(data))
    .catch(err => console.error("请求失败:", err));

// 方法二：then 的第二个参数
promise.then(
    value => { /* 成功 */ },
    err => { /* 失败 */ }
);
```

#### (2) `async/await` 中使用 `try...catch`

```js
async function fetchData() {
    try {
        const res = await fetch('/api/data');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        return data;
    } catch (err) {
        console.error("获取数据失败:", err.message);
        // 可选择重新抛出
        throw err;
    }
}
```

#### (3) 并行异步任务的错误处理

```js
// Promise.all()：任一失败则整体失败
try {
    const [a, b] = await Promise.all([
        fetchA(),
        fetchB()
    ]);
} catch (err) {
    console.error("其中一个请求失败");
}

// Promise.allSettled()：始终成功，返回结果数组
const results = await Promise.allSettled([fetchA(), fetchB()]);
results.forEach((result, i) => {
    if (result.status === 'rejected') {
        console.error(`任务 ${i} 失败:`, result.reason);
    }
});
```

#### (4) 错误传播

```js
async function service() {
    try {
        return await apiCall();
    } catch (err) {
        throw new ServiceError("服务调用失败", { cause: err });
    }
}
```

---

### 4. 全局错误捕获

用于捕获未被处理的异常，防止程序崩溃，并收集错误日志。

#### (1) `window.onerror`（浏览器）

捕获全局同步错误、资源加载错误等。

```js
window.onerror = function(message, source, lineno, colno, error) {
    console.error("全局错误:", {
        message,
        source, // 错误文件
        lineno, // 行号
        colno,  // 列号
        error   // 错误对象
    });

    // 上报错误日志
    reportErrorToServer({ message, source, lineno, colno, stack: error?.stack });

    return true; // 阻止默认错误弹窗（可选）
};
```

> ⚠️ 注意：跨域脚本错误会显示为 `"Script error."`，需设置 CORS 和 `crossorigin` 属性。

#### (2) `window.addEventListener('error')`

更现代的方式，可捕获更多类型的错误（如资源加载失败）。

```js
window.addEventListener('error', (event) => {
    if (event.error) {
        console.error("JavaScript 错误:", event.error);
    } else {
        console.error("资源加载失败:", event.target.src || event.target.href);
    }
});
```

#### (3) `unhandledrejection`（未处理的 Promise 错误）

非常重要！未被 `.catch()` 的 Promise 会触发此事件。

```js
window.addEventListener('unhandledrejection', (event) => {
    console.error("未处理的 Promise 拒绝:", event.reason);
    event.preventDefault(); // 阻止控制台警告（谨慎使用）
});
```

#### (4) Node.js 中的全局错误处理

```js
// 未捕获异常
process.on('uncaughtException', (err) => {
    console.error('未捕获的异常:', err);
    // 通常建议记录日志后退出进程
    process.exit(1);
});

// 未处理的 Promise 拒绝
process.on('unhandledRejection', (reason, promise) => {
    console.error('未处理的 Promise 拒绝:', reason);
});
```

> ⚠️ 警告：`uncaughtException` 后程序处于不稳定状态，**不建议继续运行**，应记录日志后退出。

---