## 19.2 æ€§èƒ½ç›‘æŽ§

### åº”ç”¨æ€§èƒ½ç›‘æŽ§

**APM å·¥å…·é›†æˆï¼š**
```javascript
// New Relic é›†æˆ
const newrelic = require('newrelic');

const express = require('express');
const app = express();

// ä¸­é—´ä»¶ç›‘æŽ§
app.use(newrelic.getMiddleware());

app.get('/api/users', async (req, res) => {
    // è‡ªå®šä¹‰ç›‘æŽ§
    newrelic.setControllerName('UserController', 'getUsers');
    
    try {
        const users = await getUsers();
        res.json(users);
    } catch (error) {
        newrelic.noticeError(error);
        res.status(500).json({ error: error.message });
    }
});

// Datadog é›†æˆ
const tracer = require('dd-trace').init({
    service: 'myapp',
    env: process.env.NODE_ENV,
    version: '1.0.0'
});

// è‡ªå®šä¹‰æŒ‡æ ‡
const { DogStatsD } = require('hot-shots');
const statsd = new DogStatsD({ host: 'localhost', port: 8125 });

// æ•°æ®åº“æŸ¥è¯¢ç›‘æŽ§
async function getUsers() {
    const startTime = Date.now();
    
    try {
        const users = await db.query('SELECT * FROM users LIMIT 100');
        
        // è®°å½•æŸ¥è¯¢æ—¶é—´
        statsd.timing('db.query.users', Date.now() - startTime);
        statsd.increment('db.query.users.success');
        
        return users;
    } catch (error) {
        statsd.increment('db.query.users.error');
        throw error;
    }
}

// Prometheus æŒ‡æ ‡
const client = require('prom-client');
const collectDefaultMetrics = client.collectDefaultMetrics;
collectDefaultMetrics({ timeout: 5000 });

// è‡ªå®šä¹‰æŒ‡æ ‡
const httpRequestDuration = new client.Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code']
});

const httpRequestTotal = new client.Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code']
});

// ç›‘æŽ§ä¸­é—´ä»¶
app.use((req, res, next) => {
    const startTime = Date.now();
    
    res.on('finish', () => {
        const duration = (Date.now() - startTime) / 1000;
        
        httpRequestDuration.observe({
            method: req.method,
            route: req.route ? req.route.path : req.path,
            status_code: res.statusCode
        }, duration);
        
        httpRequestTotal.inc({
            method: req.method,
            route: req.route ? req.route.path : req.path,
            status_code: res.statusCode
        });
    });
    
    next();
});

// æŒ‡æ ‡ç«¯ç‚¹
app.get('/metrics', async (req, res) => {
    res.set('Content-Type', client.register.contentType);
    res.end(await client.register.metrics());
});
```

**æ€§èƒ½åˆ†æžå·¥å…·ï¼š**
```javascript
// å†…å­˜ä½¿ç”¨ç›‘æŽ§
const memwatch = require('@airbnb/node-memwatch');

// å†…å­˜æ³„æ¼æ£€æµ‹
memwatch.on('leak', (info) => {
    console.error('å†…å­˜æ³„æ¼æ£€æµ‹:', info);
    // å‘é€å‘Šè­¦
    sendAlert('Memory leak detected', info);
});

memwatch.on('stats', (stats) => {
    console.log('å†…å­˜ç»Ÿè®¡:', stats);
});

// CPU ä½¿ç”¨ç›‘æŽ§
const os = require('os');

function getSystemMetrics() {
    const cpuUsage = os.loadavg();
    const memoryUsage = process.memoryUsage();
    const uptime = os.uptime();
    
    return {
        cpu: {
            load1: cpuUsage[0],
            load5: cpuUsage[1],
            load15: cpuUsage[2]
        },
        memory: {
            rss: memoryUsage.rss,
            heapTotal: memoryUsage.heapTotal,
            heapUsed: memoryUsage.heapUsed,
            external: memoryUsage.external
        },
        uptime: uptime,
        platform: os.platform(),
        arch: os.arch()
    };
}

// å®šæœŸæŠ¥å‘Šç³»ç»ŸæŒ‡æ ‡
setInterval(() => {
    const metrics = getSystemMetrics();
    console.log('ç³»ç»ŸæŒ‡æ ‡:', JSON.stringify(metrics, null, 2));
    
    // å‘é€åˆ°ç›‘æŽ§ç³»ç»Ÿ
    sendMetrics(metrics);
}, 30000);

// æ€§èƒ½åŸºå‡†æµ‹è¯•
const Benchmark = require('benchmark');
const suite = new Benchmark.Suite;

suite
    .add('Array#forEach', function() {
        const arr = [1, 2, 3, 4, 5];
        arr.forEach(item => item * 2);
    })
    .add('for loop', function() {
        const arr = [1, 2, 3, 4, 5];
        for (let i = 0; i < arr.length; i++) {
            arr[i] * 2;
        }
    })
    .on('cycle', function(event) {
        console.log(String(event.target));
    })
    .on('complete', function() {
        console.log('Fastest is ' + this.filter('fastest').map('name'));
    })
    .run({ 'async': true });
```

### æ—¥å¿—ç®¡ç†ç­–ç•¥

**ç»“æž„åŒ–æ—¥å¿—ï¼š**
```javascript
const winston = require('winston');
const { format, transports } = winston;
const { combine, timestamp, label, printf, errors } = format;

// è‡ªå®šä¹‰æ—¥å¿—æ ¼å¼
const logFormat = printf(({ level, message, label, timestamp, stack, ...metadata }) => {
    let logObject = {
        timestamp,
        level,
        label,
        message
    };

    if (stack) {
        logObject.stack = stack;
    }

    if (metadata && Object.keys(metadata).length > 0) {
        logObject.metadata = metadata;
    }

    return JSON.stringify(logObject);
});

// æ—¥å¿—é…ç½®
const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: combine(
        label({ label: 'myapp' }),
        timestamp(),
        errors({ stack: true }),
        logFormat
    ),
    defaultMeta: { service: 'myapp' },
    transports: [
        // æŽ§åˆ¶å°è¾“å‡º
        new transports.Console({
            format: combine(
                format.colorize(),
                label({ label: 'myapp' }),
                timestamp(),
                printf(({ level, message, label, timestamp }) => {
                    return `${timestamp} [${label}] ${level}: ${message}`;
                })
            )
        }),
        
        // é”™è¯¯æ—¥å¿—æ–‡ä»¶
        new transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
            tailable: true
        }),
        
        // ç»¼åˆæ—¥å¿—æ–‡ä»¶
        new transports.File({
            filename: 'logs/combined.log',
            maxsize: 5242880,
            maxFiles: 10,
            tailable: true
        })
    ]
});

// ç”Ÿäº§çŽ¯å¢ƒæ·»åŠ è¿œç¨‹æ—¥å¿—ä¼ è¾“
if (process.env.NODE_ENV === 'production') {
    // æ·»åŠ  ELK æ ˆæ”¯æŒ
    const { ElasticsearchTransport } = require('winston-elasticsearch');
    
    logger.add(new ElasticsearchTransport({
        level: 'info',
        clientOpts: {
            node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200'
        },
        indexPrefix: 'myapp-logs',
        indexSuffixPattern: 'YYYY.MM.DD',
        messageType: 'log',
        transformer: (logData) => {
            return {
                '@timestamp': logData.timestamp,
                severity: logData.level,
                message: logData.message,
                fields: logData.meta
            };
        }
    }));
}

// è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
const requestLogger = (req, res, next) => {
    const startTime = Date.now();
    
    // è®°å½•è¯·æ±‚å¼€å§‹
    logger.info('HTTP Request', {
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        requestId: req.headers['x-request-id'] || require('crypto').randomBytes(16).toString('hex')
    });
    
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        
        // è®°å½•å“åº”
        logger.info('HTTP Response', {
            method: req.method,
            url: req.url,
            statusCode: res.statusCode,
            duration: duration,
            contentLength: res.get('Content-Length'),
            requestId: req.headers['x-request-id']
        });
    });
    
    next();
};

// é”™è¯¯æ—¥å¿—ä¸­é—´ä»¶
const errorLogger = (err, req, res, next) => {
    logger.error('Unhandled error', {
        error: err.message,
        stack: err.stack,
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        requestId: req.headers['x-request-id']
    });
    
    next(err);
};

// åœ¨åº”ç”¨ä¸­ä½¿ç”¨
app.use(requestLogger);
app.use(errorLogger);

// ä¸šåŠ¡é€»è¾‘ä¸­çš„æ—¥å¿—
class UserService {
    async createUser(userData) {
        const startTime = Date.now();
        
        try {
            logger.info('Creating user', { 
                email: userData.email,
                action: 'user.create'
            });
            
            const user = await this.db.create(userData);
            
            logger.info('User created successfully', {
                userId: user.id,
                email: user.email,
                duration: Date.now() - startTime,
                action: 'user.create.success'
            });
            
            return user;
        } catch (error) {
            logger.error('Failed to create user', {
                email: userData.email,
                error: error.message,
                stack: error.stack,
                duration: Date.now() - startTime,
                action: 'user.create.error'
            });
            
            throw error;
        }
    }
}
```

### é”™è¯¯è¿½è¸ªç³»ç»Ÿ

**é”™è¯¯å¤„ç†å’Œè¿½è¸ªï¼š**
```javascript
const Sentry = require('@sentry/node');
const Tracing = require('@sentry/tracing');

// Sentry åˆå§‹åŒ–
Sentry.init({
    dsn: process.env.SENTRY_DSN,
    integrations: [
        new Sentry.Integrations.Http({ tracing: true }),
        new Tracing.Integrations.Express({ app }),
        new Tracing.Integrations.Postgres()
    ],
    tracesSampleRate: 1.0,
    environment: process.env.NODE_ENV,
    release: process.env.RELEASE_VERSION || '1.0.0'
});

// å…¨å±€é”™è¯¯å¤„ç†
process.on('uncaughtException', (error) => {
    Sentry.captureException(error);
    console.error('æœªæ•èŽ·çš„å¼‚å¸¸:', error);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    Sentry.captureException(reason);
    console.error('æœªå¤„ç†çš„ Promise æ‹’ç»:', reason);
    process.exit(1);
});

// Express é”™è¯¯å¤„ç†ä¸­é—´ä»¶
app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());

// è‡ªå®šä¹‰é”™è¯¯ç±»
class AppError extends Error {
    constructor(message, statusCode, isOperational = true) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = isOperational;
        this.isAppError = true;
        
        Error.captureStackTrace(this, this.constructor);
    }
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
const globalErrorHandler = (err, req, res, next) => {
    let error = { ...err };
    error.message = err.message;
    
    // è®°å½•é”™è¯¯
    console.error(err);
    
    // æ“ä½œé”™è¯¯ï¼šå®¢æˆ·ç«¯é”™è¯¯
    if (err.isAppError) {
        return res.status(err.statusCode).json({
            status: 'error',
            message: err.message
        });
    }
    
    // ç¼–ç¨‹é”™è¯¯ï¼šæœåŠ¡å™¨é”™è¯¯
    if (process.env.NODE_ENV === 'development') {
        // å¼€å‘çŽ¯å¢ƒæ˜¾ç¤ºè¯¦ç»†é”™è¯¯
        res.status(500).json({
            status: 'error',
            message: err.message,
            stack: err.stack,
            error: err
        });
    } else {
        // ç”Ÿäº§çŽ¯å¢ƒéšè—è¯¦ç»†é”™è¯¯
        Sentry.captureException(err);
        
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
        });
    }
};

app.use(globalErrorHandler);

// API é”™è¯¯å¤„ç†
app.get('/api/users/:id', async (req, res, next) => {
    try {
        const user = await User.findById(req.params.id);
        
        if (!user) {
            return next(new AppError('ç”¨æˆ·æœªæ‰¾åˆ°', 404));
        }
        
        res.json(user);
    } catch (error) {
        next(new AppError('èŽ·å–ç”¨æˆ·å¤±è´¥', 500));
    }
});

// è‡ªå®šä¹‰é”™è¯¯è¿½è¸ª
class ErrorTracker {
    static trackError(error, context = {}) {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString(),
            context: context,
            environment: process.env.NODE_ENV,
            version: process.env.RELEASE_VERSION
        };
        
        // å‘é€åˆ°å¤šä¸ªç›‘æŽ§ç³»ç»Ÿ
        this.sendToSentry(error, context);
        this.sendToLog(errorInfo);
        this.sendToSlack(errorInfo);
    }
    
    static sendToSentry(error, context) {
        Sentry.withScope((scope) => {
            scope.setContext('context', context);
            Sentry.captureException(error);
        });
    }
    
    static sendToLog(errorInfo) {
        logger.error('Application Error', errorInfo);
    }
    
    static sendToSlack(errorInfo) {
        // å‘é€åˆ° Slack æˆ–å…¶ä»–é€šçŸ¥ç³»ç»Ÿ
        if (process.env.SLACK_WEBHOOK_URL) {
            const axios = require('axios');
            axios.post(process.env.SLACK_WEBHOOK_URL, {
                text: `ðŸš¨ åº”ç”¨é”™è¯¯: ${errorInfo.message}`,
                attachments: [{
                    color: 'danger',
                    fields: [
                        {
                            title: 'çŽ¯å¢ƒ',
                            value: errorInfo.environment,
                            short: true
                        },
                        {
                            title: 'æ—¶é—´',
                            value: errorInfo.timestamp,
                            short: true
                        },
                        {
                            title: 'ä¸Šä¸‹æ–‡',
                            value: JSON.stringify(errorInfo.context, null, 2),
                            short: false
                        }
                    ]
                }]
            }).catch(console.error);
        }
    }
}

// ä½¿ç”¨é”™è¯¯è¿½è¸ª
try {
    await someRiskyOperation();
} catch (error) {
    ErrorTracker.trackError(error, {
        userId: req.user?.id,
        operation: 'someRiskyOperation',
        params: req.body
    });
    throw error;
}
```

### èµ„æºä½¿ç”¨ç›‘æŽ§

**ç³»ç»Ÿèµ„æºç›‘æŽ§ï¼š**
```javascript
const os = require('os');
const fs = require('fs');
const si = require('systeminformation');

class SystemMonitor {
    constructor() {
        this.metrics = {
            cpu: {},
            memory: {},
            disk: {},
            network: {},
            process: {}
        };
    }

    async collectMetrics() {
        try {
            // CPU ä¿¡æ¯
            this.metrics.cpu = {
                usage: await this.getCpuUsage(),
                load: os.loadavg(),
                cores: os.cpus().length,
                model: os.cpus()[0]?.model
            };

            // å†…å­˜ä¿¡æ¯
            this.metrics.memory = {
                total: os.totalmem(),
                free: os.freemem(),
                used: os.totalmem() - os.freemem(),
                usagePercent: ((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)
            };

            // ç£ç›˜ä¿¡æ¯
            this.metrics.disk = await this.getDiskUsage();

            // ç½‘ç»œä¿¡æ¯
            this.metrics.network = await this.getNetworkUsage();

            // è¿›ç¨‹ä¿¡æ¯
            this.metrics.process = {
                pid: process.pid,
                memory: process.memoryUsage(),
                uptime: process.uptime(),
                cpuUsage: process.cpuUsage()
            };

            return this.metrics;
        } catch (error) {
            console.error('æ”¶é›†ç³»ç»ŸæŒ‡æ ‡å¤±è´¥:', error);
            return null;
        }
    }

    async getCpuUsage() {
        const start = this.getCpuTimes();
        await new Promise(resolve => setTimeout(resolve, 1000));
        const end = this.getCpuTimes();
        
        const idle = end.idle - start.idle;
        const total = end.total - start.total;
        const usage = 100 - ~~(100 * idle / total);
        
        return usage;
    }

    getCpuTimes() {
        const cpus = os.cpus();
        let idle = 0;
        let total = 0;
        
        cpus.forEach(cpu => {
            for (const type in cpu.times) {
                total += cpu.times[type];
            }
            idle += cpu.times.idle;
        });
        
        return { idle, total };
    }

    async getDiskUsage() {
        try {
            const diskInfo = await si.fsSize();
            return diskInfo.map(disk => ({
                fs: disk.fs,
                type: disk.type,
                size: disk.size,
                used: disk.used,
                available: disk.available,
                usePercent: disk.use.toFixed(2)
            }));
        } catch (error) {
            return [];
        }
    }

    async getNetworkUsage() {
        try {
            const networkStats = await si.networkStats();
            return networkStats.map(interface => ({
                interface: interface.iface,
                rxBytes: interface.rx_bytes,
                txBytes: interface.tx_bytes,
                rxErrors: interface.rx_errors,
                txErrors: interface.tx_errors
            }));
        } catch (error) {
            return [];
        }
    }

    async checkThresholds() {
        const metrics = await this.collectMetrics();
        if (!metrics) return;

        const alerts = [];

        // CPU ä½¿ç”¨çŽ‡æ£€æŸ¥
        if (metrics.cpu.usage > 80) {
            alerts.push({
                type: 'CPU_USAGE_HIGH',
                message: `CPU ä½¿ç”¨çŽ‡è¿‡é«˜: ${metrics.cpu.usage}%`,
                severity: 'warning'
            });
        }

        // å†…å­˜ä½¿ç”¨çŽ‡æ£€æŸ¥
        if (metrics.memory.usagePercent > 85) {
            alerts.push({
                type: 'MEMORY_USAGE_HIGH',
                message: `å†…å­˜ä½¿ç”¨çŽ‡è¿‡é«˜: ${metrics.memory.usagePercent}%`,
                severity: 'warning'
            });
        }

        // ç£ç›˜ä½¿ç”¨çŽ‡æ£€æŸ¥
        metrics.disk.forEach(disk => {
            if (disk.usePercent > 90) {
                alerts.push({
                    type: 'DISK_USAGE_HIGH',
                    message: `ç£ç›˜ ${disk.fs} ä½¿ç”¨çŽ‡è¿‡é«˜: ${disk.usePercent}%`,
                    severity: 'critical'
                });
            }
        });

        return alerts;
    }

    startMonitoring(interval = 30000) {
        setInterval(async () => {
            const alerts = await this.checkThresholds();
            if (alerts && alerts.length > 0) {
                this.sendAlerts(alerts);
            }
        }, interval);
    }

    sendAlerts(alerts) {
        alerts.forEach(alert => {
            console.warn(`[${alert.severity.toUpperCase()}] ${alert.message}`);
            
            // å‘é€åˆ°ç›‘æŽ§ç³»ç»Ÿ
            if (alert.severity === 'critical') {
                this.sendToPagerDuty(alert);
            }
            
            // è®°å½•åˆ°æ—¥å¿—
            logger.warn('System Alert', alert);
        });
    }

    sendToPagerDuty(alert) {
        // å®žçŽ° PagerDuty é›†æˆ
        if (process.env.PAGERDUTY_INTEGRATION_KEY) {
            const axios = require('axios');
            axios.post('https://events.pagerduty.com/v2/enqueue', {
                routing_key: process.env.PAGERDUTY_INTEGRATION_KEY,
                event_action: 'trigger',
                payload: {
                    summary: alert.message,
                    severity: alert.severity,
                    source: os.hostname()
                }
            }).catch(console.error);
        }
    }
}

// ä½¿ç”¨ç³»ç»Ÿç›‘æŽ§
const monitor = new SystemMonitor();
monitor.startMonitoring(60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

// æä¾›ç›‘æŽ§ API
app.get('/api/system/metrics', async (req, res) => {
    const metrics = await monitor.collectMetrics();
    res.json(metrics);
});

app.get('/api/system/health', async (req, res) => {
    const metrics = await monitor.collectMetrics();
    const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        metrics: metrics
    };
    
    // æ£€æŸ¥å…³é”®æŒ‡æ ‡
    if (metrics.cpu.usage > 90 || metrics.memory.usagePercent > 95) {
        health.status = 'degraded';
    }
    
    res.status(health.status === 'healthy' ? 200 : 503).json(health);
});
```