## 19.2 性能监控

### 应用性能监控

**APM 工具集成：**
```javascript
// New Relic 集成
const newrelic = require('newrelic');

const express = require('express');
const app = express();

// 中间件监控
app.use(newrelic.getMiddleware());

app.get('/api/users', async (req, res) => {
    // 自定义监控
    newrelic.setControllerName('UserController', 'getUsers');
    
    try {
        const users = await getUsers();
        res.json(users);
    } catch (error) {
        newrelic.noticeError(error);
        res.status(500).json({ error: error.message });
    }
});

// Datadog 集成
const tracer = require('dd-trace').init({
    service: 'myapp',
    env: process.env.NODE_ENV,
    version: '1.0.0'
});

// 自定义指标
const { DogStatsD } = require('hot-shots');
const statsd = new DogStatsD({ host: 'localhost', port: 8125 });

// 数据库查询监控
async function getUsers() {
    const startTime = Date.now();
    
    try {
        const users = await db.query('SELECT * FROM users LIMIT 100');
        
        // 记录查询时间
        statsd.timing('db.query.users', Date.now() - startTime);
        statsd.increment('db.query.users.success');
        
        return users;
    } catch (error) {
        statsd.increment('db.query.users.error');
        throw error;
    }
}

// Prometheus 指标
const client = require('prom-client');
const collectDefaultMetrics = client.collectDefaultMetrics;
collectDefaultMetrics({ timeout: 5000 });

// 自定义指标
const httpRequestDuration = new client.Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code']
});

const httpRequestTotal = new client.Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code']
});

// 监控中间件
app.use((req, res, next) => {
    const startTime = Date.now();
    
    res.on('finish', () => {
        const duration = (Date.now() - startTime) / 1000;
        
        httpRequestDuration.observe({
            method: req.method,
            route: req.route ? req.route.path : req.path,
            status_code: res.statusCode
        }, duration);
        
        httpRequestTotal.inc({
            method: req.method,
            route: req.route ? req.route.path : req.path,
            status_code: res.statusCode
        });
    });
    
    next();
});

// 指标端点
app.get('/metrics', async (req, res) => {
    res.set('Content-Type', client.register.contentType);
    res.end(await client.register.metrics());
});
```

**性能分析工具：**
```javascript
// 内存使用监控
const memwatch = require('@airbnb/node-memwatch');

// 内存泄漏检测
memwatch.on('leak', (info) => {
    console.error('内存泄漏检测:', info);
    // 发送告警
    sendAlert('Memory leak detected', info);
});

memwatch.on('stats', (stats) => {
    console.log('内存统计:', stats);
});

// CPU 使用监控
const os = require('os');

function getSystemMetrics() {
    const cpuUsage = os.loadavg();
    const memoryUsage = process.memoryUsage();
    const uptime = os.uptime();
    
    return {
        cpu: {
            load1: cpuUsage[0],
            load5: cpuUsage[1],
            load15: cpuUsage[2]
        },
        memory: {
            rss: memoryUsage.rss,
            heapTotal: memoryUsage.heapTotal,
            heapUsed: memoryUsage.heapUsed,
            external: memoryUsage.external
        },
        uptime: uptime,
        platform: os.platform(),
        arch: os.arch()
    };
}

// 定期报告系统指标
setInterval(() => {
    const metrics = getSystemMetrics();
    console.log('系统指标:', JSON.stringify(metrics, null, 2));
    
    // 发送到监控系统
    sendMetrics(metrics);
}, 30000);

// 性能基准测试
const Benchmark = require('benchmark');
const suite = new Benchmark.Suite;

suite
    .add('Array#forEach', function() {
        const arr = [1, 2, 3, 4, 5];
        arr.forEach(item => item * 2);
    })
    .add('for loop', function() {
        const arr = [1, 2, 3, 4, 5];
        for (let i = 0; i < arr.length; i++) {
            arr[i] * 2;
        }
    })
    .on('cycle', function(event) {
        console.log(String(event.target));
    })
    .on('complete', function() {
        console.log('Fastest is ' + this.filter('fastest').map('name'));
    })
    .run({ 'async': true });
```

### 日志管理策略

**结构化日志：**
```javascript
const winston = require('winston');
const { format, transports } = winston;
const { combine, timestamp, label, printf, errors } = format;

// 自定义日志格式
const logFormat = printf(({ level, message, label, timestamp, stack, ...metadata }) => {
    let logObject = {
        timestamp,
        level,
        label,
        message
    };

    if (stack) {
        logObject.stack = stack;
    }

    if (metadata && Object.keys(metadata).length > 0) {
        logObject.metadata = metadata;
    }

    return JSON.stringify(logObject);
});

// 日志配置
const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: combine(
        label({ label: 'myapp' }),
        timestamp(),
        errors({ stack: true }),
        logFormat
    ),
    defaultMeta: { service: 'myapp' },
    transports: [
        // 控制台输出
        new transports.Console({
            format: combine(
                format.colorize(),
                label({ label: 'myapp' }),
                timestamp(),
                printf(({ level, message, label, timestamp }) => {
                    return `${timestamp} [${label}] ${level}: ${message}`;
                })
            )
        }),
        
        // 错误日志文件
        new transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
            tailable: true
        }),
        
        // 综合日志文件
        new transports.File({
            filename: 'logs/combined.log',
            maxsize: 5242880,
            maxFiles: 10,
            tailable: true
        })
    ]
});

// 生产环境添加远程日志传输
if (process.env.NODE_ENV === 'production') {
    // 添加 ELK 栈支持
    const { ElasticsearchTransport } = require('winston-elasticsearch');
    
    logger.add(new ElasticsearchTransport({
        level: 'info',
        clientOpts: {
            node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200'
        },
        indexPrefix: 'myapp-logs',
        indexSuffixPattern: 'YYYY.MM.DD',
        messageType: 'log',
        transformer: (logData) => {
            return {
                '@timestamp': logData.timestamp,
                severity: logData.level,
                message: logData.message,
                fields: logData.meta
            };
        }
    }));
}

// 请求日志中间件
const requestLogger = (req, res, next) => {
    const startTime = Date.now();
    
    // 记录请求开始
    logger.info('HTTP Request', {
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        requestId: req.headers['x-request-id'] || require('crypto').randomBytes(16).toString('hex')
    });
    
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        
        // 记录响应
        logger.info('HTTP Response', {
            method: req.method,
            url: req.url,
            statusCode: res.statusCode,
            duration: duration,
            contentLength: res.get('Content-Length'),
            requestId: req.headers['x-request-id']
        });
    });
    
    next();
};

// 错误日志中间件
const errorLogger = (err, req, res, next) => {
    logger.error('Unhandled error', {
        error: err.message,
        stack: err.stack,
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        requestId: req.headers['x-request-id']
    });
    
    next(err);
};

// 在应用中使用
app.use(requestLogger);
app.use(errorLogger);

// 业务逻辑中的日志
class UserService {
    async createUser(userData) {
        const startTime = Date.now();
        
        try {
            logger.info('Creating user', { 
                email: userData.email,
                action: 'user.create'
            });
            
            const user = await this.db.create(userData);
            
            logger.info('User created successfully', {
                userId: user.id,
                email: user.email,
                duration: Date.now() - startTime,
                action: 'user.create.success'
            });
            
            return user;
        } catch (error) {
            logger.error('Failed to create user', {
                email: userData.email,
                error: error.message,
                stack: error.stack,
                duration: Date.now() - startTime,
                action: 'user.create.error'
            });
            
            throw error;
        }
    }
}
```

### 错误追踪系统

**错误处理和追踪：**
```javascript
const Sentry = require('@sentry/node');
const Tracing = require('@sentry/tracing');

// Sentry 初始化
Sentry.init({
    dsn: process.env.SENTRY_DSN,
    integrations: [
        new Sentry.Integrations.Http({ tracing: true }),
        new Tracing.Integrations.Express({ app }),
        new Tracing.Integrations.Postgres()
    ],
    tracesSampleRate: 1.0,
    environment: process.env.NODE_ENV,
    release: process.env.RELEASE_VERSION || '1.0.0'
});

// 全局错误处理
process.on('uncaughtException', (error) => {
    Sentry.captureException(error);
    console.error('未捕获的异常:', error);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    Sentry.captureException(reason);
    console.error('未处理的 Promise 拒绝:', reason);
    process.exit(1);
});

// Express 错误处理中间件
app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());

// 自定义错误类
class AppError extends Error {
    constructor(message, statusCode, isOperational = true) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = isOperational;
        this.isAppError = true;
        
        Error.captureStackTrace(this, this.constructor);
    }
}

// 错误处理中间件
const globalErrorHandler = (err, req, res, next) => {
    let error = { ...err };
    error.message = err.message;
    
    // 记录错误
    console.error(err);
    
    // 操作错误：客户端错误
    if (err.isAppError) {
        return res.status(err.statusCode).json({
            status: 'error',
            message: err.message
        });
    }
    
    // 编程错误：服务器错误
    if (process.env.NODE_ENV === 'development') {
        // 开发环境显示详细错误
        res.status(500).json({
            status: 'error',
            message: err.message,
            stack: err.stack,
            error: err
        });
    } else {
        // 生产环境隐藏详细错误
        Sentry.captureException(err);
        
        res.status(500).json({
            status: 'error',
            message: '服务器内部错误'
        });
    }
};

app.use(globalErrorHandler);

// API 错误处理
app.get('/api/users/:id', async (req, res, next) => {
    try {
        const user = await User.findById(req.params.id);
        
        if (!user) {
            return next(new AppError('用户未找到', 404));
        }
        
        res.json(user);
    } catch (error) {
        next(new AppError('获取用户失败', 500));
    }
});

// 自定义错误追踪
class ErrorTracker {
    static trackError(error, context = {}) {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString(),
            context: context,
            environment: process.env.NODE_ENV,
            version: process.env.RELEASE_VERSION
        };
        
        // 发送到多个监控系统
        this.sendToSentry(error, context);
        this.sendToLog(errorInfo);
        this.sendToSlack(errorInfo);
    }
    
    static sendToSentry(error, context) {
        Sentry.withScope((scope) => {
            scope.setContext('context', context);
            Sentry.captureException(error);
        });
    }
    
    static sendToLog(errorInfo) {
        logger.error('Application Error', errorInfo);
    }
    
    static sendToSlack(errorInfo) {
        // 发送到 Slack 或其他通知系统
        if (process.env.SLACK_WEBHOOK_URL) {
            const axios = require('axios');
            axios.post(process.env.SLACK_WEBHOOK_URL, {
                text: `🚨 应用错误: ${errorInfo.message}`,
                attachments: [{
                    color: 'danger',
                    fields: [
                        {
                            title: '环境',
                            value: errorInfo.environment,
                            short: true
                        },
                        {
                            title: '时间',
                            value: errorInfo.timestamp,
                            short: true
                        },
                        {
                            title: '上下文',
                            value: JSON.stringify(errorInfo.context, null, 2),
                            short: false
                        }
                    ]
                }]
            }).catch(console.error);
        }
    }
}

// 使用错误追踪
try {
    await someRiskyOperation();
} catch (error) {
    ErrorTracker.trackError(error, {
        userId: req.user?.id,
        operation: 'someRiskyOperation',
        params: req.body
    });
    throw error;
}
```

### 资源使用监控

**系统资源监控：**
```javascript
const os = require('os');
const fs = require('fs');
const si = require('systeminformation');

class SystemMonitor {
    constructor() {
        this.metrics = {
            cpu: {},
            memory: {},
            disk: {},
            network: {},
            process: {}
        };
    }

    async collectMetrics() {
        try {
            // CPU 信息
            this.metrics.cpu = {
                usage: await this.getCpuUsage(),
                load: os.loadavg(),
                cores: os.cpus().length,
                model: os.cpus()[0]?.model
            };

            // 内存信息
            this.metrics.memory = {
                total: os.totalmem(),
                free: os.freemem(),
                used: os.totalmem() - os.freemem(),
                usagePercent: ((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)
            };

            // 磁盘信息
            this.metrics.disk = await this.getDiskUsage();

            // 网络信息
            this.metrics.network = await this.getNetworkUsage();

            // 进程信息
            this.metrics.process = {
                pid: process.pid,
                memory: process.memoryUsage(),
                uptime: process.uptime(),
                cpuUsage: process.cpuUsage()
            };

            return this.metrics;
        } catch (error) {
            console.error('收集系统指标失败:', error);
            return null;
        }
    }

    async getCpuUsage() {
        const start = this.getCpuTimes();
        await new Promise(resolve => setTimeout(resolve, 1000));
        const end = this.getCpuTimes();
        
        const idle = end.idle - start.idle;
        const total = end.total - start.total;
        const usage = 100 - ~~(100 * idle / total);
        
        return usage;
    }

    getCpuTimes() {
        const cpus = os.cpus();
        let idle = 0;
        let total = 0;
        
        cpus.forEach(cpu => {
            for (const type in cpu.times) {
                total += cpu.times[type];
            }
            idle += cpu.times.idle;
        });
        
        return { idle, total };
    }

    async getDiskUsage() {
        try {
            const diskInfo = await si.fsSize();
            return diskInfo.map(disk => ({
                fs: disk.fs,
                type: disk.type,
                size: disk.size,
                used: disk.used,
                available: disk.available,
                usePercent: disk.use.toFixed(2)
            }));
        } catch (error) {
            return [];
        }
    }

    async getNetworkUsage() {
        try {
            const networkStats = await si.networkStats();
            return networkStats.map(interface => ({
                interface: interface.iface,
                rxBytes: interface.rx_bytes,
                txBytes: interface.tx_bytes,
                rxErrors: interface.rx_errors,
                txErrors: interface.tx_errors
            }));
        } catch (error) {
            return [];
        }
    }

    async checkThresholds() {
        const metrics = await this.collectMetrics();
        if (!metrics) return;

        const alerts = [];

        // CPU 使用率检查
        if (metrics.cpu.usage > 80) {
            alerts.push({
                type: 'CPU_USAGE_HIGH',
                message: `CPU 使用率过高: ${metrics.cpu.usage}%`,
                severity: 'warning'
            });
        }

        // 内存使用率检查
        if (metrics.memory.usagePercent > 85) {
            alerts.push({
                type: 'MEMORY_USAGE_HIGH',
                message: `内存使用率过高: ${metrics.memory.usagePercent}%`,
                severity: 'warning'
            });
        }

        // 磁盘使用率检查
        metrics.disk.forEach(disk => {
            if (disk.usePercent > 90) {
                alerts.push({
                    type: 'DISK_USAGE_HIGH',
                    message: `磁盘 ${disk.fs} 使用率过高: ${disk.usePercent}%`,
                    severity: 'critical'
                });
            }
        });

        return alerts;
    }

    startMonitoring(interval = 30000) {
        setInterval(async () => {
            const alerts = await this.checkThresholds();
            if (alerts && alerts.length > 0) {
                this.sendAlerts(alerts);
            }
        }, interval);
    }

    sendAlerts(alerts) {
        alerts.forEach(alert => {
            console.warn(`[${alert.severity.toUpperCase()}] ${alert.message}`);
            
            // 发送到监控系统
            if (alert.severity === 'critical') {
                this.sendToPagerDuty(alert);
            }
            
            // 记录到日志
            logger.warn('System Alert', alert);
        });
    }

    sendToPagerDuty(alert) {
        // 实现 PagerDuty 集成
        if (process.env.PAGERDUTY_INTEGRATION_KEY) {
            const axios = require('axios');
            axios.post('https://events.pagerduty.com/v2/enqueue', {
                routing_key: process.env.PAGERDUTY_INTEGRATION_KEY,
                event_action: 'trigger',
                payload: {
                    summary: alert.message,
                    severity: alert.severity,
                    source: os.hostname()
                }
            }).catch(console.error);
        }
    }
}

// 使用系统监控
const monitor = new SystemMonitor();
monitor.startMonitoring(60000); // 每分钟检查一次

// 提供监控 API
app.get('/api/system/metrics', async (req, res) => {
    const metrics = await monitor.collectMetrics();
    res.json(metrics);
});

app.get('/api/system/health', async (req, res) => {
    const metrics = await monitor.collectMetrics();
    const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        metrics: metrics
    };
    
    // 检查关键指标
    if (metrics.cpu.usage > 90 || metrics.memory.usagePercent > 95) {
        health.status = 'degraded';
    }
    
    res.status(health.status === 'healthy' ? 200 : 503).json(health);
});
```