## 18.3 实时应用

### Socket.IO 实时通信

**Socket.IO 服务器：**
```javascript
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const redis = require('redis');
const redisAdapter = require('socket.io-redis');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// Redis 适配器（用于多实例部署）
const pubClient = redis.createClient({ host: 'localhost', port: 6379 });
const subClient = redis.createClient({ host: 'localhost', port: 6379 });

io.adapter(redisAdapter({ pubClient, subClient }));

// 在线用户管理
const onlineUsers = new Map();
const rooms = new Map();

// Socket.IO 中间件
io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    if (token) {
        // 验证令牌
        try {
            const user = verifyToken(token);
            socket.userId = user.id;
            socket.username = user.username;
            next();
        } catch (error) {
            next(new Error('认证失败'));
        }
    } else {
        next(new Error('未提供认证令牌'));
    }
});

// 连接处理
io.on('connection', (socket) => {
    console.log('用户连接:', socket.userId);
    
    // 用户上线
    onlineUsers.set(socket.userId, {
        socketId: socket.id,
        username: socket.username,
        joinTime: new Date()
    });
    
    // 广播用户上线
    socket.broadcast.emit('user:joined', {
        userId: socket.userId,
        username: socket.username,
        time: new Date()
    });
    
    // 发送在线用户列表
    socket.emit('users:online', Array.from(onlineUsers.values()));
    
    // 房间相关事件
    socket.on('room:join', (roomId) => {
        socket.join(roomId);
        
        if (!rooms.has(roomId)) {
            rooms.set(roomId, {
                id: roomId,
                users: new Set(),
                createdAt: new Date()
            });
        }
        
        const room = rooms.get(roomId);
        room.users.add(socket.userId);
        
        // 通知房间内其他用户
        socket.to(roomId).emit('room:user:joined', {
            userId: socket.userId,
            username: socket.username,
            roomId: roomId
        });
        
        // 发送房间信息
        socket.emit('room:joined', {
            roomId: roomId,
            users: Array.from(room.users)
        });
    });
    
    socket.on('room:leave', (roomId) => {
        socket.leave(roomId);
        
        if (rooms.has(roomId)) {
            const room = rooms.get(roomId);
            room.users.delete(socket.userId);
            
            // 通知房间内其他用户
            socket.to(roomId).emit('room:user:left', {
                userId: socket.userId,
                username: socket.username,
                roomId: roomId
            });
            
            // 清理空房间
            if (room.users.size === 0) {
                rooms.delete(roomId);
            }
        }
    });
    
    // 聊天消息
    socket.on('chat:message', (data) => {
        const { roomId, message, type = 'text' } = data;
        
        const messageData = {
            id: Date.now(),
            userId: socket.userId,
            username: socket.username,
            message: message,
            type: type,
            timestamp: new Date(),
            roomId: roomId
        };
        
        // 存储消息到数据库（可选）
        saveMessage(messageData);
        
        // 广播消息到房间
        io.to(roomId).emit('chat:message', messageData);
        
        // 发送消息确认
        socket.emit('chat:message:sent', { messageId: messageData.id });
    });
    
    // 打字状态
    socket.on('typing:start', (data) => {
        const { roomId } = data;
        socket.to(roomId).emit('typing:start', {
            userId: socket.userId,
            username: socket.username,
            roomId: roomId
        });
    });
    
    socket.on('typing:stop', (data) => {
        const { roomId } = data;
        socket.to(roomId).emit('typing:stop', {
            userId: socket.userId,
            username: socket.username,
            roomId: roomId
        });
    });
    
    // 通知相关事件
    socket.on('notification:send', (data) => {
        const { targetUserId, type, content } = data;
        
        const notification = {
            id: Date.now(),
            fromUserId: socket.userId,
            toUserId: targetUserId,
            type: type,
            content: content,
            timestamp: new Date(),
            read: false
        };
        
        // 存储通知
        saveNotification(notification);
        
        // 发送实时通知
        const targetUser = onlineUsers.get(targetUserId);
        if (targetUser) {
            io.to(targetUser.socketId).emit('notification:received', notification);
        }
    });
    
    // 文件传输
    socket.on('file:upload:start', (data) => {
        const { roomId, fileName, fileSize } = data;
        
        const fileInfo = {
            id: Date.now(),
            userId: socket.userId,
            roomId: roomId,
            fileName: fileName,
            fileSize: fileSize,
            uploadId: generateUploadId(),
            timestamp: new Date()
        };
        
        // 广播文件上传开始
        socket.to(roomId).emit('file:upload:start', fileInfo);
        
        socket.emit('file:upload:ready', { uploadId: fileInfo.uploadId });
    });
    
    // 实时游戏事件
    socket.on('game:move', (data) => {
        const { roomId, move } = data;
        
        const gameData = {
            userId: socket.userId,
            move: move,
            timestamp: new Date()
        };
        
        socket.to(roomId).emit('game:move', gameData);
    });
    
    // 断开连接处理
    socket.on('disconnect', (reason) => {
        console.log('用户断开连接:', socket.userId, reason);
        
        // 用户下线
        onlineUsers.delete(socket.userId);
        
        // 通知其他用户
        socket.broadcast.emit('user:left', {
            userId: socket.userId,
            username: socket.username,
            time: new Date()
        });
        
        // 从所有房间移除用户
        rooms.forEach((room, roomId) => {
            if (room.users.has(socket.userId)) {
                room.users.delete(socket.userId);
                socket.to(roomId).emit('room:user:left', {
                    userId: socket.userId,
                    username: socket.username,
                    roomId: roomId
                });
                
                // 清理空房间
                if (room.users.size === 0) {
                    rooms.delete(roomId);
                }
            }
        });
    });
    
    // 错误处理
    socket.on('error', (error) => {
        console.error('Socket 错误:', error);
    });
});

// 工具函数
function verifyToken(token) {
    // 实现令牌验证逻辑
    return { id: 1, username: 'user' };
}

async function saveMessage(messageData) {
    // 实现消息存储逻辑
    console.log('保存消息:', messageData);
}

async function saveNotification(notification) {
    // 实现通知存储逻辑
    console.log('保存通知:', notification);
}

function generateUploadId() {
    return Math.random().toString(36).substr(2, 9);
}

// API 路由
app.get('/api/online-users', (req, res) => {
    res.json({
        count: onlineUsers.size,
        users: Array.from(onlineUsers.values()).map(user => ({
            userId: user.userId,
            username: user.username,
            joinTime: user.joinTime
        }))
    });
});

app.get('/api/rooms', (req, res) => {
    res.json({
        count: rooms.size,
        rooms: Array.from(rooms.values()).map(room => ({
            id: room.id,
            userCount: room.users.size,
            createdAt: room.createdAt
        }))
    });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Socket.IO 服务器运行在端口 ${PORT}`);
});
```

**Socket.IO 客户端：**
```javascript
// 客户端实现
class ChatClient {
    constructor() {
        this.socket = null;
        this.userId = null;
        this.username = null;
        this.currentRoom = null;
        this.isTyping = false;
    }

    connect(token) {
        this.socket = io('http://localhost:3000', {
            auth: { token }
        });

        this.setupEventListeners();
    }

    setupEventListeners() {
        // 连接事件
        this.socket.on('connect', () => {
            console.log('连接成功');
        });

        this.socket.on('disconnect', (reason) => {
            console.log('连接断开:', reason);
        });

        // 用户事件
        this.socket.on('user:joined', (data) => {
            this.onUserJoined(data);
        });

        this.socket.on('user:left', (data) => {
            this.onUserLeft(data);
        });

        this.socket.on('users:online', (users) => {
            this.onOnlineUsers(users);
        });

        // 房间事件
        this.socket.on('room:joined', (data) => {
            this.onRoomJoined(data);
        });

        this.socket.on('room:user:joined', (data) => {
            this.onRoomUserJoined(data);
        });

        this.socket.on('room:user:left', (data) => {
            this.onRoomUserLeft(data);
        });

        // 聊天事件
        this.socket.on('chat:message', (data) => {
            this.onChatMessage(data);
        });

        this.socket.on('chat:message:sent', (data) => {
            this.onMessageSent(data);
        });

        // 打字状态
        this.socket.on('typing:start', (data) => {
            this.onTypingStart(data);
        });

        this.socket.on('typing:stop', (data) => {
            this.onTypingStop(data);
        });

        // 通知事件
        this.socket.on('notification:received', (data) => {
            this.onNotificationReceived(data);
        });

        // 文件传输
        this.socket.on('file:upload:start', (data) => {
            this.onFileUploadStart(data);
        });

        this.socket.on('file:upload:ready', (data) => {
            this.onFileUploadReady(data);
        });

        // 错误处理
        this.socket.on('connect_error', (error) => {
            console.error('连接错误:', error);
        });

        this.socket.on('error', (error) => {
            console.error('Socket 错误:', error);
        });
    }

    // 用户操作方法
    joinRoom(roomId) {
        this.socket.emit('room:join', roomId);
    }

    leaveRoom(roomId) {
        this.socket.emit('room:leave', roomId);
    }

    sendMessage(roomId, message, type = 'text') {
        this.socket.emit('chat:message', {
            roomId: roomId,
            message: message,
            type: type
        });
    }

    startTyping(roomId) {
        if (!this.isTyping) {
            this.isTyping = true;
            this.socket.emit('typing:start', { roomId: roomId });
        }
    }

    stopTyping(roomId) {
        if (this.isTyping) {
            this.isTyping = false;
            this.socket.emit('typing:stop', { roomId: roomId });
        }
    }

    sendNotification(targetUserId, type, content) {
        this.socket.emit('notification:send', {
            targetUserId: targetUserId,
            type: type,
            content: content
        });
    }

    // 事件处理方法
    onUserJoined(data) {
        console.log('用户加入:', data);
        // 更新用户界面
    }

    onUserLeft(data) {
        console.log('用户离开:', data);
        // 更新用户界面
    }

    onOnlineUsers(users) {
        console.log('在线用户:', users);
        // 更新在线用户列表
    }

    onRoomJoined(data) {
        this.currentRoom = data.roomId;
        console.log('加入房间:', data);
        // 更新房间界面
    }

    onRoomUserJoined(data) {
        console.log('房间用户加入:', data);
        // 更新房间用户列表
    }

    onRoomUserLeft(data) {
        console.log('房间用户离开:', data);
        // 更新房间用户列表
    }

    onChatMessage(data) {
        console.log('收到消息:', data);
        // 显示消息
    }

    onMessageSent(data) {
        console.log('消息发送成功:', data);
        // 更新消息状态
    }

    onTypingStart(data) {
        console.log('用户开始打字:', data);
        // 显示打字状态
    }

    onTypingStop(data) {
        console.log('用户停止打字:', data);
        // 隐藏打字状态
    }

    onNotificationReceived(data) {
        console.log('收到通知:', data);
        // 显示通知
    }

    onFileUploadStart(data) {
        console.log('文件上传开始:', data);
        // 显示文件上传进度
    }

    onFileUploadReady(data) {
        console.log('文件上传准备就绪:', data);
        // 开始文件上传
    }

    // 断开连接
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
        }
    }
}

// 使用示例
const chatClient = new ChatClient();

// 连接
chatClient.connect('your-jwt-token');

// 加入房间
chatClient.joinRoom('room-123');

// 发送消息
chatClient.sendMessage('room-123', 'Hello World!');

// 打字状态
chatClient.startTyping('room-123');
setTimeout(() => {
    chatClient.stopTyping('room-123');
}, 2000);
```

### 事件驱动架构

**事件总线实现：**
```javascript
const EventEmitter = require('events');

// 事件总线
class EventBus extends EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(20);
    }

    // 发布事件
    publish(eventName, data) {
        this.emit(eventName, data);
        this.emit('*', { eventName, data }); // 通配符事件
    }

    // 订阅事件
    subscribe(eventName, handler) {
        this.on(eventName, handler);
        return () => this.unsubscribe(eventName, handler);
    }

    // 取消订阅
    unsubscribe(eventName, handler) {
        this.removeListener(eventName, handler);
    }

    // 订阅一次
    subscribeOnce(eventName, handler) {
        this.once(eventName, handler);
    }

    // 异步发布
    async publishAsync(eventName, data) {
        return new Promise((resolve) => {
            this.emit(eventName, data, resolve);
        });
    }

    // 获取事件统计
    getStats() {
        const eventNames = this.eventNames();
        const stats = {};
        
        eventNames.forEach(eventName => {
            stats[eventName] = this.listenerCount(eventName);
        });
        
        return stats;
    }
}

const eventBus = new EventBus();

// 领域事件
class UserRegisteredEvent {
    constructor(userId, email, registrationDate) {
        this.userId = userId;
        this.email = email;
        this.registrationDate = registrationDate;
        this.timestamp = new Date();
    }
}

class OrderCreatedEvent {
    constructor(orderId, userId, items, totalAmount) {
        this.orderId = orderId;
        this.userId = userId;
        this.items = items;
        this.totalAmount = totalAmount;
        this.timestamp = new Date();
    }
}

class PaymentProcessedEvent {
    constructor(paymentId, orderId, amount, status) {
        this.paymentId = paymentId;
        this.orderId = orderId;
        this.amount = amount;
        this.status = status;
        this.timestamp = new Date();
    }
}

// 事件处理器
class UserEventHandler {
    static handleUserRegistered(event) {
        console.log('处理用户注册事件:', event);
        
        // 发送欢迎邮件
        EmailService.sendWelcomeEmail(event.email);
        
        // 创建用户资料
        ProfileService.createProfile(event.userId);
        
        // 发布用户欢迎完成事件
        eventBus.publish('user.welcome.completed', {
            userId: event.userId,
            timestamp: new Date()
        });
    }

    static handleUserWelcomeCompleted(event) {
        console.log('用户欢迎完成:', event);
        
        // 记录日志
        Logger.info('User welcome completed', event);
        
        // 更新统计
        AnalyticsService.track('user_welcome_completed', event.userId);
    }
}

class OrderEventHandler {
    static handleOrderCreated(event) {
        console.log('处理订单创建事件:', event);
        
        // 更新库存
        InventoryService.updateStock(event.items);
        
        // 发送订单确认邮件
        EmailService.sendOrderConfirmation(event.userId, event.orderId);
        
        // 处理支付
        PaymentService.processPayment(event.orderId, event.totalAmount);
    }

    static handleOrderCancelled(event) {
        console.log('处理订单取消事件:', event);
        
        // 恢复库存
        InventoryService.restoreStock(event.items);
        
        // 发送取消通知
        EmailService.sendOrderCancellation(event.userId, event.orderId);
        
        // 退款处理
        PaymentService.processRefund(event.orderId);
    }
}

class PaymentEventHandler {
    static handlePaymentProcessed(event) {
        console.log('处理支付完成事件:', event);
        
        if (event.status === 'success') {
            // 更新订单状态
            OrderService.updateStatus(event.orderId, 'paid');
            
            // 发送支付成功通知
            NotificationService.sendPaymentSuccess(event.userId, event.amount);
            
            // 积分奖励
            LoyaltyService.addPoints(event.userId, event.amount);
        } else {
            // 处理支付失败
            OrderService.updateStatus(event.orderId, 'payment_failed');
            
            // 发送支付失败通知
            NotificationService.sendPaymentFailed(event.userId, event.amount);
        }
    }
}

// 服务类
class UserService {
    static async registerUser(userData) {
        try {
            // 创建用户
            const user = await this.createUser(userData);
            
            // 发布用户注册事件
            const event = new UserRegisteredEvent(
                user.id,
                user.email,
                new Date()
            );
            
            eventBus.publish('user.registered', event);
            
            return user;
        } catch (error) {
            console.error('用户注册失败:', error);
            throw error;
        }
    }

    static async createUser(userData) {
        // 实现用户创建逻辑
        return { id: 1, email: userData.email };
    }
}

class OrderService {
    static async createOrder(userId, items) {
        try {
            // 计算总金额
            const totalAmount = this.calculateTotal(items);
            
            // 创建订单
            const order = await this.createOrderRecord(userId, items, totalAmount);
            
            // 发布订单创建事件
            const event = new OrderCreatedEvent(
                order.id,
                userId,
                items,
                totalAmount
            );
            
            eventBus.publish('order.created', event);
            
            return order;
        } catch (error) {
            console.error('订单创建失败:', error);
            throw error;
        }
    }

    static async cancelOrder(orderId) {
        try {
            // 获取订单信息
            const order = await this.getOrderById(orderId);
            
            // 取消订单
            await this.updateOrderStatus(orderId, 'cancelled');
            
            // 发布订单取消事件
            eventBus.publish('order.cancelled', {
                orderId: orderId,
                userId: order.userId,
                items: order.items,
                timestamp: new Date()
            });
        } catch (error) {
            console.error('订单取消失败:', error);
            throw error;
        }
    }

    static calculateTotal(items) {
        return items.reduce((total, item) => total + item.price * item.quantity, 0);
    }

    static async createOrderRecord(userId, items, totalAmount) {
        // 实现订单创建逻辑
        return { id: 1, userId, items, totalAmount };
    }

    static async getOrderById(orderId) {
        // 实现订单查询逻辑
        return { id: orderId, userId: 1, items: [] };
    }

    static async updateOrderStatus(orderId, status) {
        // 实现订单状态更新逻辑
        console.log(`订单 ${orderId} 状态更新为 ${status}`);
    }

    static async updateStatus(orderId, status) {
        await this.updateOrderStatus(orderId, status);
    }
}

class PaymentService {
    static async processPayment(orderId, amount) {
        try {
            // 处理支付
            const payment = await this.chargePayment(orderId, amount);
            
            // 发布支付完成事件
            const event = new PaymentProcessedEvent(
                payment.id,
                orderId,
                amount,
                payment.status
            );
            
            eventBus.publish('payment.processed', event);
        } catch (error) {
            console.error('支付处理失败:', error);
            
            // 发布支付失败事件
            const event = new PaymentProcessedEvent(
                null,
                orderId,
                amount,
                'failed'
            );
            
            eventBus.publish('payment.processed', event);
        }
    }

    static async processRefund(orderId) {
        try {
            // 处理退款
            const refund = await this.refundPayment(orderId);
            
            // 发布退款完成事件
            eventBus.publish('payment.refunded', {
                orderId: orderId,
                refundId: refund.id,
                amount: refund.amount,
                timestamp: new Date()
            });
        } catch (error) {
            console.error('退款处理失败:', error);
            throw error;
        }
    }

    static async chargePayment(orderId, amount) {
        // 实现支付逻辑
        return { id: 1, status: 'success' };
    }

    static async refundPayment(orderId) {
        // 实现退款逻辑
        return { id: 1, amount: 100 };
    }
}

// 事件订阅
eventBus.subscribe('user.registered', UserEventHandler.handleUserRegistered);
eventBus.subscribe('user.welcome.completed', UserEventHandler.handleUserWelcomeCompleted);
eventBus.subscribe('order.created', OrderEventHandler.handleOrderCreated);
eventBus.subscribe('order.cancelled', OrderEventHandler.handleOrderCancelled);
eventBus.subscribe('payment.processed', PaymentEventHandler.handlePaymentProcessed);

// 使用示例
async function example() {
    // 注册用户
    await UserService.registerUser({
        email: 'user@example.com',
        password: 'password123'
    });

    // 创建订单
    await OrderService.createOrder(1, [
        { productId: 1, quantity: 2, price: 50 },
        { productId: 2, quantity: 1, price: 30 }
    ]);
}

example().catch(console.error);

// 事件监控
setInterval(() => {
    console.log('事件总线统计:', eventBus.getStats());
}, 10000);
```

### 消息队列集成

**RabbitMQ 集成：**
```javascript
const amqp = require('amqplib');
const { v4: uuidv4 } = require('uuid');

// RabbitMQ 连接管理器
class RabbitMQService {
    constructor(options = {}) {
        this.url = options.url || 'amqp://localhost';
        this.connection = null;
        this.channel = null;
        this.reconnectInterval = options.reconnectInterval || 5000;
        this.maxRetries = options.maxRetries || 5;
        this.retryCount = 0;
    }

    async connect() {
        try {
            this.connection = await amqp.connect(this.url);
            this.channel = await this.connection.createChannel();
            
            console.log('RabbitMQ 连接成功');
            this.retryCount = 0;
            
            // 设置连接事件监听
            this.setupConnectionEvents();
            
            return this.channel;
        } catch (error) {
            console.error('RabbitMQ 连接失败:', error);
            
            if (this.retryCount < this.maxRetries) {
                this.retryCount++;
                console.log(`第 ${this.retryCount} 次重连，${this.reconnectInterval}ms 后重试`);
                
                setTimeout(() => {
                    this.connect();
                }, this.reconnectInterval);
            } else {
                console.error('达到最大重连次数，停止重连');
            }
        }
    }

    setupConnectionEvents() {
        this.connection.on('error', (error) => {
            console.error('RabbitMQ 连接错误:', error);
            this.handleConnectionError();
        });

        this.connection.on('close', () => {
            console.log('RabbitMQ 连接关闭');
            this.handleConnectionError();
        });
    }

    handleConnectionError() {
        if (this.retryCount < this.maxRetries) {
            setTimeout(() => {
                this.connect();
            }, this.reconnectInterval);
        }
    }

    async disconnect() {
        try {
            if (this.channel) {
                await this.channel.close();
            }
            if (this.connection) {
                await this.connection.close();
            }
            console.log('RabbitMQ 连接已关闭');
        } catch (error) {
            console.error('关闭 RabbitMQ 连接时出错:', error);
        }
    }

    async createQueue(queueName, options = {}) {
        if (!this.channel) {
            throw new Error('Channel not available');
        }
        
        return await this.channel.assertQueue(queueName, {
            durable: options.durable !== false,
            ...options
        });
    }

    async createExchange(exchangeName, type, options = {}) {
        if (!this.channel) {
            throw new Error('Channel not available');
        }
        
        return await this.channel.assertExchange(exchangeName, type, {
            durable: options.durable !== false,
            ...options
        });
    }

    async bindQueue(queueName, exchangeName, pattern = '') {
        if (!this.channel) {
            throw new Error('Channel not available');
        }
        
        return await this.channel.bindQueue(queueName, exchangeName, pattern);
    }
}

// 消息生产者
class MessageProducer {
    constructor(rabbitMQService) {
        this.rabbitMQ = rabbitMQService;
    }

    async sendToQueue(queueName, message, options = {}) {
        if (!this.rabbitMQ.channel) {
            throw new Error('Channel not available');
        }

        const content = Buffer.from(JSON.stringify(message));
        
        return await this.rabbitMQ.channel.sendToQueue(queueName, content, {
            persistent: true,
            messageId: uuidv4(),
            timestamp: Date.now(),
            ...options
        });
    }

    async publishToExchange(exchangeName, routingKey, message, options = {}) {
        if (!this.rabbitMQ.channel) {
            throw new Error('Channel not available');
        }

        const content = Buffer.from(JSON.stringify(message));
        
        return await this.rabbitMQ.channel.publish(exchangeName, routingKey, content, {
            persistent: true,
            messageId: uuidv4(),
            timestamp: Date.now(),
            ...options
        });
    }

    async sendWithDelay(queueName, message, delayMs) {
        const delayQueue = `${queueName}_delay_${delayMs}`;
        
        // 创建延迟队列
        await this.rabbitMQ.channel.assertQueue(delayQueue, {
            durable: true,
            arguments: {
                'x-message-ttl': delayMs,
                'x-dead-letter-exchange': '',
                'x-dead-letter-routing-key': queueName
            }
        });
        
        return await this.sendToQueue(delayQueue, message);
    }
}

// 消息消费者
class MessageConsumer {
    constructor(rabbitMQService) {
        this.rabbitMQ = rabbitMQService;
    }

    async consumeQueue(queueName, handler, options = {}) {
        if (!this.rabbitMQ.channel) {
            throw new Error('Channel not available');
        }

        // 设置预取数量
        await this.rabbitMQ.channel.prefetch(options.prefetch || 1);
        
        return await this.rabbitMQ.channel.consume(queueName, async (msg) => {
            if (msg !== null) {
                try {
                    const content = JSON.parse(msg.content.toString());
                    const result = await handler(content, msg);
                    
                    // 确认消息
                    this.rabbitMQ.channel.ack(msg);
                    
                    return result;
                } catch (error) {
                    console.error('消息处理失败:', error);
                    
                    // 处理失败的消息
                    if (options.retryOnError) {
                        this.handleRetry(msg, error);
                    } else {
                        this.rabbitMQ.channel.nack(msg, false, false);
                    }
                }
            }
        }, { noAck: false });
    }

    handleRetry(msg, error) {
        const headers = msg.properties.headers || {};
        const retryCount = headers['x-retry-count'] || 0;
        const maxRetries = 3;
        
        if (retryCount < maxRetries) {
            // 重新入队
            const newHeaders = {
                ...headers,
                'x-retry-count': retryCount + 1,
                'x-last-error': error.message
            };
            
            this.rabbitMQ.channel.publish(
                '',
                msg.fields.routingKey,
                msg.content,
                {
                    ...msg.properties,
                    headers: newHeaders
                }
            );
            
            this.rabbitMQ.channel.ack(msg);
        } else {
            // 移到死信队列
            console.error('消息重试次数已达上限，移至死信队列:', error);
            this.rabbitMQ.channel.nack(msg, false, false);
        }
    }

    async consumeWithDLX(queueName, handler, dlxOptions = {}) {
        const dlxName = dlxOptions.name || `${queueName}_dlx`;
        const dlqName = dlxOptions.queue || `${queueName}_dlq`;
        
        // 创建死信交换机和队列
        await this.rabbitMQ.channel.assertExchange(dlxName, 'direct', { durable: true });
        await this.rabbitMQ.channel.assertQueue(dlqName, { durable: true });
        await this.rabbitMQ.channel.bindQueue(dlqName, dlxName, dlqName);
        
        // 创建主队列，绑定死信
        await this.rabbitMQ.channel.assertQueue(queueName, {
            durable: true,
            arguments: {
                'x-dead-letter-exchange': dlxName,
                'x-dead-letter-routing-key': dlqName
            }
        });
        
        return await this.consumeQueue(queueName, handler);
    }
}

// 具体业务消息处理器
class OrderMessageHandler {
    static async handleOrderCreated(message, msg) {
        console.log('处理订单创建消息:', message);
        
        try {
            // 处理订单创建逻辑
            await this.processOrder(message.orderId);
            
            // 发送通知
            await NotificationService.sendOrderConfirmation(message.userId, message.orderId);
            
            console.log('订单创建处理完成:', message.orderId);
        } catch (error) {
            console.error('订单创建处理失败:', error);
            throw error;
        }
    }

    static async handlePaymentProcessed(message, msg) {
        console.log('处理支付完成消息:', message);
        
        try {
            // 更新订单状态
            await OrderService.updateStatus(message.orderId, 'paid');
            
            // 处理库存
            await InventoryService.updateStock(message.items);
            
            console.log('支付处理完成:', message.orderId);
        } catch (error) {
            console.error('支付处理失败:', error);
            throw error;
        }
    }

    static async processOrder(orderId) {
        // 模拟订单处理
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log(`订单 ${orderId} 处理完成`);
    }
}

class EmailMessageHandler {
    static async handleSendEmail(message, msg) {
        console.log('处理邮件发送消息:', message);
        
        try {
            // 发送邮件
            await EmailService.send(message.to, message.subject, message.body);
            
            console.log('邮件发送完成:', message.to);
        } catch (error) {
            console.error('邮件发送失败:', error);
            throw error;
        }
    }
}

// 服务类
class OrderService {
    constructor(producer) {
        this.producer = producer;
    }

    async createOrder(orderData) {
        try {
            // 创建订单
            const order = await this.createOrderInDB(orderData);
            
            // 发送订单创建消息
            await this.producer.sendToQueue('order.created', {
                orderId: order.id,
                userId: order.userId,
                items: order.items,
                totalAmount: order.totalAmount,
                timestamp: new Date()
            });
            
            return order;
        } catch (error) {
            console.error('订单创建失败:', error);
            throw error;
        }
    }

    async processPayment(orderId, paymentData) {
        try {
            // 处理支付
            const payment = await this.processPaymentInDB(orderId, paymentData);
            
            // 发送支付完成消息
            await this.producer.sendToQueue('payment.processed', {
                orderId: orderId,
                paymentId: payment.id,
                amount: payment.amount,
                status: payment.status,
                timestamp: new Date()
            });
            
            return payment;
        } catch (error) {
            console.error('支付处理失败:', error);
            throw error;
        }
    }

    async createOrderInDB(orderData) {
        // 实现数据库操作
        return { id: 1, ...orderData };
    }

    async processPaymentInDB(orderId, paymentData) {
        // 实现数据库操作
        return { id: 1, orderId, ...paymentData };
    }

    static async updateStatus(orderId, status) {
        console.log(`更新订单 ${orderId} 状态为 ${status}`);
        // 实现数据库更新
    }
}

class NotificationService {
    constructor(producer) {
        this.producer = producer;
    }

    async sendOrderConfirmation(userId, orderId) {
        await this.producer.sendToQueue('email.send', {
            to: `user${userId}@example.com`,
            subject: '订单确认',
            body: `您的订单 ${orderId} 已创建成功`,
            type: 'order_confirmation'
        });
    }

    static async send(to, subject, body) {
        // 实现邮件发送逻辑
        console.log(`发送邮件到 ${to}: ${subject}`);
        await new Promise(resolve => setTimeout(resolve, 500));
    }
}

class InventoryService {
    static async updateStock(items) {
        console.log('更新库存:', items);
        // 实现库存更新逻辑
    }
}

// 应用启动
async function startApplication() {
    // 初始化 RabbitMQ 服务
    const rabbitMQ = new RabbitMQService({
        url: process.env.RABBITMQ_URL || 'amqp://localhost',
        reconnectInterval: 5000,
        maxRetries: 5
    });
    
    await rabbitMQ.connect();
    
    // 创建队列和交换机
    await rabbitMQ.createQueue('order.created', { durable: true });
    await rabbitMQ.createQueue('payment.processed', { durable: true });
    await rabbitMQ.createQueue('email.send', { durable: true });
    
    // 初始化生产者和消费者
    const producer = new MessageProducer(rabbitMQ);
    const consumer = new MessageConsumer(rabbitMQ);
    
    // 初始化服务
    const orderService = new OrderService(producer);
    
    // 启动消费者
    await consumer.consumeQueue('order.created', OrderMessageHandler.handleOrderCreated, {
        prefetch: 5,
        retryOnError: true
    });
    
    await consumer.consumeQueue('payment.processed', OrderMessageHandler.handlePaymentProcessed, {
        prefetch: 3
    });
    
    await consumer.consumeQueue('email.send', EmailMessageHandler.handleSendEmail, {
        prefetch: 10
    });
    
    // 示例：创建订单
    setTimeout(async () => {
        await orderService.createOrder({
            userId: 1,
            items: [{ productId: 1, quantity: 2, price: 50 }],
            totalAmount: 100
        });
    }, 2000);
    
    // 优雅关闭
    process.on('SIGTERM', async () => {
        console.log('接收到 SIGTERM 信号，正在关闭...');
        await rabbitMQ.disconnect();
        process.exit(0);
    });
    
    process.on('SIGINT', async () => {
        console.log('接收到 SIGINT 信号，正在关闭...');
        await rabbitMQ.disconnect();
        process.exit(0);
    });
}

startApplication().catch(console.error);
```

### 微服务架构

**微服务基础框架：**
```javascript
const express = require('express');
const axios = require('axios');
const redis = require('redis');
const { v4: uuidv4 } = require('uuid');

// 服务注册与发现
class ServiceRegistry {
    constructor(redisClient) {
        this.redis = redisClient;
        this.services = new Map();
    }

    async register(serviceName, serviceInfo) {
        const serviceId = `${serviceName}:${uuidv4()}`;
        const key = `service:${serviceName}:${serviceId}`;
        const ttl = 30; // 30秒TTL
        
        await this.redis.setex(key, ttl, JSON.stringify({
            ...serviceInfo,
            id: serviceId,
            registeredAt: Date.now()
        }));
        
        // 保持心跳
        const heartbeat = setInterval(async () => {
            try {
                await this.redis.expire(key, ttl);
            } catch (error) {
                console.error('心跳失败:', error);
                clearInterval(heartbeat);
            }
        }, (ttl - 5) * 1000);
        
        return serviceId;
    }

    async discover(serviceName) {
        const pattern = `service:${serviceName}:*`;
        const keys = await this.redis.keys(pattern);
        
        const services = [];
        for (const key of keys) {
            try {
                const serviceData = await this.redis.get(key);
                if (serviceData) {
                    services.push(JSON.parse(serviceData));
                }
            } catch (error) {
                console.error('发现服务失败:', error);
            }
        }
        
        return services;
    }

    async getService(serviceName) {
        const services = await this.discover(serviceName);
        if (services.length === 0) {
            throw new Error(`服务 ${serviceName} 未找到`);
        }
        
        // 简单的负载均衡（随机选择）
        return services[Math.floor(Math.random() * services.length)];
    }
}

// API 网关
class ApiGateway {
    constructor(serviceRegistry, redisClient) {
        this.serviceRegistry = serviceRegistry;
        this.redis = redisClient;
        this.app = express();
        this.setupMiddleware();
    }

    setupMiddleware() {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        
        // 限流中间件
        this.app.use('/api/', this.rateLimitMiddleware());
        
        // 缓存中间件
        this.app.use(this.cacheMiddleware());
    }

    rateLimitMiddleware() {
        const rateLimits = new Map();
        
        return (req, res, next) => {
            const ip = req.ip;
            const now = Date.now();
            const windowMs = 60000; // 1分钟
            const maxRequests = 100;
            
            if (!rateLimits.has(ip)) {
                rateLimits.set(ip, []);
            }
            
            const requests = rateLimits.get(ip);
            const validRequests = requests.filter(time => now - time < windowMs);
            validRequests.push(now);
            rateLimits.set(ip, validRequests);
            
            if (validRequests.length > maxRequests) {
                return res.status(429).json({ error: '请求过于频繁' });
            }
            
            next();
        };
    }

    cacheMiddleware() {
        return async (req, res, next) => {
            if (req.method !== 'GET') {
                return next();
            }
            
            const cacheKey = `cache:${req.originalUrl}`;
            const cached = await this.redis.get(cacheKey);
            
            if (cached) {
                res.set('X-Cache', 'HIT');
                return res.json(JSON.parse(cached));
            }
            
            // 重写 res.json 方法来缓存响应
            const originalJson = res.json;
            res.json = function(body) {
                res.set('X-Cache', 'MISS');
                this.redis.setex(cacheKey, 300, JSON.stringify(body)); // 缓存5分钟
                return originalJson.call(this, body);
            }.bind({ redis: this.redis, originalJson });
            
            next();
        };
    }

    async proxy(serviceName, req, res) {
        try {
            const service = await this.serviceRegistry.getService(serviceName);
            const url = `http://${service.host}:${service.port}${req.url}`;
            
            const response = await axios({
                method: req.method,
                url: url,
                data: req.body,
                headers: req.headers,
                timeout: 5000
            });
            
            res.status(response.status).json(response.data);
        } catch (error) {
            console.error('代理请求失败:', error);
            res.status(502).json({ error: '服务不可用' });
        }
    }

    setupRoutes() {
        // 用户服务路由
        this.app.use('/api/users', async (req, res) => {
            await this.proxy('user-service', req, res);
        });

        // 订单服务路由
        this.app.use('/api/orders', async (req, res) => {
            await this.proxy('order-service', req, res);
        });

        // 支付服务路由
        this.app.use('/api/payments', async (req, res) => {
            await this.proxy('payment-service', req, res);
        });

        // 健康检查
        this.app.get('/health', (req, res) => {
            res.json({ status: 'ok', timestamp: new Date().toISOString() });
        });

        // 服务发现
        this.app.get('/services', async (req, res) => {
            try {
                const services = await this.serviceRegistry.discover('*');
                res.json(services);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });
    }

    start(port) {
        this.setupRoutes();
        this.app.listen(port, () => {
            console.log(`API 网关运行在端口 ${port}`);
        });
    }
}

// 微服务基类
class MicroService {
    constructor(serviceName, options = {}) {
        this.serviceName = serviceName;
        this.port = options.port || 3000;
        this.host = options.host || 'localhost';
        this.app = express();
        this.setupMiddleware();
    }

    setupMiddleware() {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        
        // 健康检查中间件
        this.app.use('/health', (req, res) => {
            res.json({ 
                status: 'ok', 
                service: this.serviceName,
                timestamp: new Date().toISOString()
            });
        });
        
        // 错误处理中间件
        this.app.use((err, req, res, next) => {
            console.error(`${this.serviceName} 错误:`, err);
            res.status(500).json({ error: '内部服务器错误' });
        });
    }

    async registerService(registry) {
        this.serviceId = await registry.register(this.serviceName, {
            host: this.host,
            port: this.port,
            pid: process.pid
        });
        
        console.log(`${this.serviceName} 注册成功，ID: ${this.serviceId}`);
    }

    start() {
        this.app.listen(this.port, () => {
            console.log(`${this.serviceName} 运行在端口 ${this.port}`);
        });
    }
}

// 具体微服务实现
class UserService extends MicroService {
    constructor(options) {
        super('user-service', options);
        this.setupRoutes();
    }

    setupRoutes() {
        this.app.get('/users', async (req, res) => {
            try {
                const users = await this.getUsers();
                res.json(users);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.get('/users/:id', async (req, res) => {
            try {
                const user = await this.getUserById(req.params.id);
                if (!user) {
                    return res.status(404).json({ error: '用户未找到' });
                }
                res.json(user);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.post('/users', async (req, res) => {
            try {
                const user = await this.createUser(req.body);
                res.status(201).json(user);
            } catch (error) {
                res.status(400).json({ error: error.message });
            }
        });
    }

    async getUsers() {
        // 模拟数据库查询
        return [
            { id: 1, name: 'Alice', email: 'alice@example.com' },
            { id: 2, name: 'Bob', email: 'bob@example.com' }
        ];
    }

    async getUserById(id) {
        // 模拟数据库查询
        const users = await this.getUsers();
        return users.find(user => user.id == id);
    }

    async createUser(userData) {
        // 模拟数据库插入
        return {
            id: Date.now(),
            ...userData,
            createdAt: new Date().toISOString()
        };
    }
}

class OrderService extends MicroService {
    constructor(options) {
        super('order-service', options);
        this.setupRoutes();
    }

    setupRoutes() {
        this.app.get('/orders', async (req, res) => {
            try {
                const orders = await this.getOrders();
                res.json(orders);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.get('/orders/:id', async (req, res) => {
            try {
                const order = await this.getOrderById(req.params.id);
                if (!order) {
                    return res.status(404).json({ error: '订单未找到' });
                }
                res.json(order);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.post('/orders', async (req, res) => {
            try {
                const order = await this.createOrder(req.body);
                res.status(201).json(order);
            } catch (error) {
                res.status(400).json({ error: error.message });
            }
        });
    }

    async getOrders() {
        // 模拟数据库查询
        return [
            { id: 1, userId: 1, total: 100, status: 'pending' },
            { id: 2, userId: 2, total: 200, status: 'completed' }
        ];
    }

    async getOrderById(id) {
        // 模拟数据库查询
        const orders = await this.getOrders();
        return orders.find(order => order.id == id);
    }

    async createOrder(orderData) {
        // 模拟数据库插入
        return {
            id: Date.now(),
            ...orderData,
            status: 'pending',
            createdAt: new Date().toISOString()
        };
    }
}

// 服务启动
async function startServices() {
    // 初始化 Redis
    const redisClient = redis.createClient({
        host: 'localhost',
        port: 6379
    });
    
    await redisClient.connect();
    
    // 初始化服务注册中心
    const serviceRegistry = new ServiceRegistry(redisClient);
    
    // 启动微服务
    const userService = new UserService({ port: 3001 });
    const orderService = new OrderService({ port: 3002 });
    
    await userService.registerService(serviceRegistry);
    await orderService.registerService(serviceRegistry);
    
    userService.start();
    orderService.start();
    
    // 启动 API 网关
    const apiGateway = new ApiGateway(serviceRegistry, redisClient);
    apiGateway.start(3000);
    
    // 优雅关闭
    const shutdown = async () => {
        console.log('正在关闭服务...');
        await redisClient.quit();
        process.exit(0);
    };
    
    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);
}

startServices().catch(console.error);
```