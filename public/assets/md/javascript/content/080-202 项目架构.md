## 20.2 项目架构

### MVC 架构模式

**经典 MVC 实现：**
```javascript
// models/User.js
class User {
    constructor(data) {
        this.id = data.id;
        this.name = data.name;
        this.email = data.email;
        this.createdAt = data.createdAt || new Date();
    }

    // 验证方法
    static validate(userData) {
        const errors = [];
        
        if (!userData.name || userData.name.trim().length < 2) {
            errors.push('姓名至少需要2个字符');
        }
        
        if (!userData.email || !/\S+@\S+\.\S+/.test(userData.email)) {
            errors.push('请输入有效的邮箱地址');
        }
        
        return errors;
    }

    // 数据库操作方法
    static async findById(id, db) {
        const result = await db.query('SELECT * FROM users WHERE id = $1', [id]);
        return result.rows[0] ? new User(result.rows[0]) : null;
    }

    static async findAll(db, options = {}) {
        const { limit = 10, offset = 0, sortBy = 'id', sortOrder = 'ASC' } = options;
        const result = await db.query(
            `SELECT * FROM users ORDER BY ${sortBy} ${sortOrder} LIMIT $1 OFFSET $2`,
            [limit, offset]
        );
        return result.rows.map(row => new User(row));
    }

    static async create(userData, db) {
        const errors = this.validate(userData);
        if (errors.length > 0) {
            throw new Error(errors.join(', '));
        }

        const result = await db.query(
            'INSERT INTO users (name, email, created_at) VALUES ($1, $2, $3) RETURNING *',
            [userData.name, userData.email, new Date()]
        );
        
        return new User(result.rows[0]);
    }

    static async update(id, userData, db) {
        const updates = [];
        const values = [];
        let index = 1;

        Object.keys(userData).forEach(key => {
            if (key !== 'id' && userData[key] !== undefined) {
                updates.push(`${key} = $${index}`);
                values.push(userData[key]);
                index++;
            }
        });

        if (updates.length === 0) {
            throw new Error('没有要更新的数据');
        }

        values.push(id);
        const result = await db.query(
            `UPDATE users SET ${updates.join(', ')}, updated_at = $${index} WHERE id = $${index + 1} RETURNING *`,
            values
        );

        return result.rows[0] ? new User(result.rows[0]) : null;
    }

    static async delete(id, db) {
        const result = await db.query('DELETE FROM users WHERE id = $1 RETURNING *', [id]);
        return result.rowCount > 0;
    }
}

// views/userView.js
class UserView {
    static renderUser(user) {
        return {
            id: user.id,
            name: user.name,
            email: user.email,
            createdAt: user.createdAt.toISOString()
        };
    }

    static renderUsers(users) {
        return users.map(user => this.renderUser(user));
    }

    static renderError(error) {
        return {
            error: error.message,
            timestamp: new Date().toISOString()
        };
    }

    static renderSuccess(message, data = null) {
        const response = { message };
        if (data) {
            response.data = data;
        }
        return response;
    }
}

// controllers/userController.js
class UserController {
    constructor(userModel, userView) {
        this.User = userModel;
        this.UserView = userView;
    }

    async getAllUsers(req, res) {
        try {
            const { page = 1, limit = 10, sortBy = 'id', sortOrder = 'ASC' } = req.query;
            const offset = (page - 1) * limit;
            
            const users = await this.User.findAll(req.db, { limit, offset, sortBy, sortOrder });
            const totalCount = await this.User.count(req.db);
            
            res.json({
                data: this.UserView.renderUsers(users),
                pagination: {
                    page: parseInt(page),
                    limit: parseInt(limit),
                    total: totalCount,
                    pages: Math.ceil(totalCount / limit)
                }
            });
        } catch (error) {
            res.status(500).json(this.UserView.renderError(error));
        }
    }

    async getUserById(req, res) {
        try {
            const { id } = req.params;
            const user = await this.User.findById(id, req.db);
            
            if (!user) {
                return res.status(404).json(this.UserView.renderError(new Error('用户未找到')));
            }
            
            res.json(this.UserView.renderUser(user));
        } catch (error) {
            res.status(500).json(this.UserView.renderError(error));
        }
    }

    async createUser(req, res) {
        try {
            const user = await this.User.create(req.body, req.db);
            res.status(201).json(this.UserView.renderUser(user));
        } catch (error) {
            res.status(400).json(this.UserView.renderError(error));
        }
    }

    async updateUser(req, res) {
        try {
            const { id } = req.params;
            const user = await this.User.update(id, req.body, req.db);
            
            if (!user) {
                return res.status(404).json(this.UserView.renderError(new Error('用户未找到')));
            }
            
            res.json(this.UserView.renderUser(user));
        } catch (error) {
            res.status(400).json(this.UserView.renderError(error));
        }
    }

    async deleteUser(req, res) {
        try {
            const { id } = req.params;
            const deleted = await this.User.delete(id, req.db);
            
            if (!deleted) {
                return res.status(404).json(this.UserView.renderError(new Error('用户未找到')));
            }
            
            res.json(this.UserView.renderSuccess('用户删除成功'));
        } catch (error) {
            res.status(500).json(this.UserView.renderError(error));
        }
    }
}

// routes/userRoutes.js
const express = require('express');
const router = express.Router();

// 依赖注入
let userController;

function setUserController(controller) {
    userController = controller;
}

router.get('/', (req, res) => userController.getAllUsers(req, res));
router.get('/:id', (req, res) => userController.getUserById(req, res));
router.post('/', (req, res) => userController.createUser(req, res));
router.put('/:id', (req, res) => userController.updateUser(req, res));
router.delete('/:id', (req, res) => userController.deleteUser(req, res));

module.exports = { router, setUserController };

// app.js
const express = require('express');
const { Pool } = require('pg');
const { router, setUserController } = require('./routes/userRoutes');
const User = require('./models/User');
const UserView = require('./views/UserView');
const UserController = require('./controllers/UserController');

const app = express();
const pool = new Pool({
    user: 'postgres',
    host: 'localhost',
    database: 'myapp',
    password: 'password',
    port: 5432,
});

// 数据库连接中间件
app.use((req, res, next) => {
    req.db = pool;
    next();
});

app.use(express.json());

// 初始化控制器
const userController = new UserController(User, UserView);
setUserController(userController);

app.use('/api/users', router);

app.listen(3000, () => {
    console.log('服务器运行在端口 3000');
});
```

### 分层架构设计

**分层架构实现：**
```javascript
// layers/presentation/controllers/userController.js
class UserController {
    constructor(userService) {
        this.userService = userService;
    }

    async getAllUsers(req, res) {
        try {
            const { page, limit, sortBy, sortOrder } = req.query;
            const result = await this.userService.getUsers({
                page: parseInt(page) || 1,
                limit: parseInt(limit) || 10,
                sortBy: sortBy || 'id',
                sortOrder: sortOrder || 'ASC'
            });
            
            res.json(result);
        } catch (error) {
            this.handleError(res, error, 500);
        }
    }

    async getUserById(req, res) {
        try {
            const { id } = req.params;
            const user = await this.userService.getUserById(id);
            
            if (!user) {
                return this.handleError(res, new Error('用户未找到'), 404);
            }
            
            res.json(user);
        } catch (error) {
            this.handleError(res, error, 500);
        }
    }

    async createUser(req, res) {
        try {
            const user = await this.userService.createUser(req.body);
            res.status(201).json(user);
        } catch (error) {
            this.handleError(res, error, 400);
        }
    }

    handleError(res, error, statusCode) {
        console.error('Controller Error:', error);
        res.status(statusCode).json({
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
}

// layers/application/services/userService.js
class UserService {
    constructor(userRepository, eventPublisher) {
        this.userRepository = userRepository;
        this.eventPublisher = eventPublisher;
    }

    async getUsers(options) {
        // 业务逻辑验证
        if (options.page < 1) throw new Error('页码必须大于0');
        if (options.limit < 1 || options.limit > 100) throw new Error('每页数量必须在1-100之间');

        const users = await this.userRepository.findAll(options);
        const totalCount = await this.userRepository.count();
        
        return {
            data: users,
            pagination: {
                page: options.page,
                limit: options.limit,
                total: totalCount,
                pages: Math.ceil(totalCount / options.limit)
            }
        };
    }

    async getUserById(id) {
        if (!id || isNaN(id)) throw new Error('无效的用户ID');
        
        const user = await this.userRepository.findById(id);
        if (user) {
            // 业务逻辑处理
            user.lastAccessed = new Date();
            await this.userRepository.updateLastAccessed(id, user.lastAccessed);
        }
        
        return user;
    }

    async createUser(userData) {
        // 业务规则验证
        this.validateUserData(userData);
        
        // 检查邮箱是否已存在
        const existingUser = await this.userRepository.findByEmail(userData.email);
        if (existingUser) {
            throw new Error('邮箱已被使用');
        }

        // 创建用户
        const user = await this.userRepository.create(userData);
        
        // 发布用户创建事件
        await this.eventPublisher.publish('user.created', {
            userId: user.id,
            email: user.email,
            timestamp: new Date()
        });
        
        return user;
    }

    validateUserData(userData) {
        const errors = [];
        
        if (!userData.name || userData.name.trim().length < 2) {
            errors.push('姓名至少需要2个字符');
        }
        
        if (!userData.email || !this.isValidEmail(userData.email)) {
            errors.push('请输入有效的邮箱地址');
        }
        
        if (!userData.password || userData.password.length < 6) {
            errors.push('密码至少需要6个字符');
        }
        
        if (errors.length > 0) {
            throw new Error(errors.join(', '));
        }
    }

    isValidEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
}

// layers/domain/repositories/userRepository.js
class UserRepository {
    constructor(database) {
        this.db = database;
    }

    async findAll(options = {}) {
        const { page = 1, limit = 10, sortBy = 'id', sortOrder = 'ASC' } = options;
        const offset = (page - 1) * limit;
        
        const result = await this.db.query(
            `SELECT id, name, email, created_at, last_accessed 
             FROM users 
             ORDER BY ${sortBy} ${sortOrder} 
             LIMIT $1 OFFSET $2`,
            [limit, offset]
        );
        
        return result.rows;
    }

    async findById(id) {
        const result = await this.db.query(
            'SELECT id, name, email, created_at, last_accessed FROM users WHERE id = $1',
            [id]
        );
        
        return result.rows[0] || null;
    }

    async findByEmail(email) {
        const result = await this.db.query(
            'SELECT id, name, email, created_at FROM users WHERE email = $1',
            [email]
        );
        
        return result.rows[0] || null;
    }

    async create(userData) {
        const result = await this.db.query(
            `INSERT INTO users (name, email, password, created_at) 
             VALUES ($1, $2, $3, $4) 
             RETURNING id, name, email, created_at`,
            [userData.name, userData.email, userData.password, new Date()]
        );
        
        return result.rows[0];
    }

    async updateLastAccessed(id, lastAccessed) {
        await this.db.query(
            'UPDATE users SET last_accessed = $1 WHERE id = $2',
            [lastAccessed, id]
        );
    }

    async count() {
        const result = await this.db.query('SELECT COUNT(*) as count FROM users');
        return parseInt(result.rows[0].count);
    }
}

// layers/infrastructure/database/postgresql.js
const { Pool } = require('pg');

class PostgreSQLDatabase {
    constructor(config) {
        this.pool = new Pool(config);
    }

    async query(text, params) {
        const start = Date.now();
        const res = await this.pool.query(text, params);
        const duration = Date.now() - start;
        
        console.log('执行查询', { text, duration, rows: res.rowCount });
        return res;
    }

    async getClient() {
        return await this.pool.connect();
    }

    async close() {
        await this.pool.end();
    }
}

// layers/infrastructure/events/eventPublisher.js
const EventEmitter = require('events');

class EventPublisher extends EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(20);
    }

    async publish(eventName, eventData) {
        console.log(`发布事件: ${eventName}`, eventData);
        this.emit(eventName, eventData);
        
        // 异步处理事件
        setImmediate(() => {
            this.emit(`${eventName}.async`, eventData);
        });
    }

    subscribe(eventName, handler) {
        this.on(eventName, handler);
        return () => this.unsubscribe(eventName, handler);
    }

    unsubscribe(eventName, handler) {
        this.removeListener(eventName, this);
    }
}

// 应用启动配置
const express = require('express');
const app = express();

// 依赖注入容器
class DIContainer {
    constructor() {
        this.services = new Map();
    }

    register(name, factory) {
        this.services.set(name, factory);
    }

    resolve(name) {
        const factory = this.services.get(name);
        if (!factory) {
            throw new Error(`Service ${name} not found`);
        }
        return factory(this);
    }
}

// 配置依赖注入
const container = new DIContainer();

container.register('database', () => {
    return new PostgreSQLDatabase({
        user: 'postgres',
        host: 'localhost',
        database: 'myapp',
        password: 'password',
        port: 5432,
    });
});

container.register('eventPublisher', () => {
    return new EventPublisher();
});

container.register('userRepository', (container) => {
    return new UserRepository(container.resolve('database'));
});

container.register('userService', (container) => {
    return new UserService(
        container.resolve('userRepository'),
        container.resolve('eventPublisher')
    );
});

container.register('userController', (container) => {
    return new UserController(container.resolve('userService'));
});

// 初始化应用
const userController = container.resolve('userController');

app.use(express.json());
app.get('/api/users', (req, res) => userController.getAllUsers(req, res));
app.get('/api/users/:id', (req, res) => userController.getUserById(req, res));
app.post('/api/users', (req, res) => userController.createUser(req, res));

app.listen(3000, () => {
    console.log('分层架构应用启动在端口 3000');
});
```

### 微服务架构

**微服务基础框架：**
```javascript
// microservices/framework/service.js
const express = require('express');
const axios = require('axios');
const redis = require('redis');

class MicroService {
    constructor(name, options = {}) {
        this.name = name;
        this.port = options.port || 3000;
        this.app = express();
        this.dependencies = options.dependencies || [];
        this.setupMiddleware();
    }

    setupMiddleware() {
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        
        // 健康检查
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                service: this.name,
                timestamp: new Date().toISOString(),
                dependencies: this.dependencies
            });
        });
        
        // 请求追踪中间件
        this.app.use((req, res, next) => {
            req.requestId = req.headers['x-request-id'] || require('crypto').randomBytes(16).toString('hex');
            req.startTime = Date.now();
            
            res.on('finish', () => {
                const duration = Date.now() - req.startTime;
                console.log(`${this.name} - ${req.method} ${req.path} - ${res.statusCode} - ${duration}ms - ${req.requestId}`);
            });
            
            next();
        });
    }

    // 服务发现
    async discoverService(serviceName) {
        try {
            const response = await axios.get(`http://service-registry:3000/services/${serviceName}`);
            return response.data;
        } catch (error) {
            throw new Error(`无法发现服务 ${serviceName}: ${error.message}`);
        }
    }

    // 调用其他服务
    async callService(serviceName, path, options = {}) {
        try {
            const service = await this.discoverService(serviceName);
            const url = `http://${service.host}:${service.port}${path}`;
            
            const response = await axios({
                method: options.method || 'GET',
                url: url,
                data: options.data,
                headers: {
                    'x-request-id': options.requestId,
                    ...options.headers
                },
                timeout: options.timeout || 5000
            });
            
            return response.data;
        } catch (error) {
            console.error(`调用服务 ${serviceName} 失败:`, error.message);
            throw error;
        }
    }

    // 错误处理中间件
    setupErrorHandler() {
        this.app.use((err, req, res, next) => {
            console.error(`${this.name} 错误:`, err);
            
            res.status(err.status || 500).json({
                error: err.message || '内部服务器错误',
                requestId: req.requestId,
                service: this.name
            });
        });
    }

    start() {
        this.setupErrorHandler();
        this.app.listen(this.port, () => {
            console.log(`${this.name} 服务启动在端口 ${this.port}`);
        });
    }
}

// 用户服务
class UserService extends MicroService {
    constructor() {
        super('user-service', {
            port: 3001,
            dependencies: ['database-service', 'auth-service']
        });
        this.setupRoutes();
    }

    setupRoutes() {
        this.app.get('/users', async (req, res) => {
            try {
                const users = await this.getUsers();
                res.json(users);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.get('/users/:id', async (req, res) => {
            try {
                const user = await this.getUserById(req.params.id);
                if (!user) {
                    return res.status(404).json({ error: '用户未找到' });
                }
                res.json(user);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.post('/users', async (req, res) => {
            try {
                const user = await this.createUser(req.body);
                res.status(201).json(user);
            } catch (error) {
                res.status(400).json({ error: error.message });
            }
        });
    }

    async getUsers() {
        return [
            { id: 1, name: 'Alice', email: 'alice@example.com' },
            { id: 2, name: 'Bob', email: 'bob@example.com' }
        ];
    }

    async getUserById(id) {
        const users = await this.getUsers();
        return users.find(user => user.id == id);
    }

    async createUser(userData) {
        return {
            id: Date.now(),
            ...userData,
            createdAt: new Date().toISOString()
        };
    }
}

// 订单服务
class OrderService extends MicroService {
    constructor() {
        super('order-service', {
            port: 3002,
            dependencies: ['user-service', 'payment-service']
        });
        this.setupRoutes();
    }

    setupRoutes() {
        this.app.get('/orders', async (req, res) => {
            try {
                const orders = await this.getOrders();
                res.json(orders);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.get('/orders/:id', async (req, res) => {
            try {
                const order = await this.getOrderById(req.params.id);
                if (!order) {
                    return res.status(404).json({ error: '订单未找到' });
                }
                res.json(order);
            } catch (error) {
                res.status(500).json({ error: error.message });
            }
        });

        this.app.post('/orders', async (req, res) => {
            try {
                // 验证用户
                const user = await this.callService('user-service', `/users/${req.body.userId}`);
                
                const order = await this.createOrder(req.body);
                res.status(201).json(order);
            } catch (error) {
                res.status(400).json({ error: error.message });
            }
        });
    }

    async getOrders() {
        return [
            { id: 1, userId: 1, total: 100, status: 'pending' },
            { id: 2, userId: 2, total: 200, status: 'completed' }
        ];
    }

    async getOrderById(id) {
        const orders = await this.getOrders();
        return orders.find(order => order.id == id);
    }

    async createOrder(orderData) {
        return {
            id: Date.now(),
            ...orderData,
            status: 'pending',
            createdAt: new Date().toISOString()
        };
    }
}

// API 网关
class ApiGateway extends MicroService {
    constructor() {
        super('api-gateway', { port: 3000 });
        this.serviceRegistry = new Map();
        this.setupRoutes();
    }

    setupRoutes() {
        // 用户服务路由
        this.app.use('/api/users', async (req, res) => {
            await this.proxyToService('user-service', req, res);
        });

        // 订单服务路由
        this.app.use('/api/orders', async (req, res) => {
            await this.proxyToService('order-service', req, res);
        });
    }

    async proxyToService(serviceName, req, res) {
        try {
            const service = await this.discoverService(serviceName);
            const url = `http://${service.host}:${service.port}${req.url}`;
            
            const response = await axios({
                method: req.method,
                url: url,
                data: req.body,
                headers: req.headers,
                timeout: 10000
            });
            
            res.status(response.status).json(response.data);
        } catch (error) {
            console.error('代理请求失败:', error);
            res.status(502).json({ error: '服务不可用' });
        }
    }

    async discoverService(serviceName) {
        // 简单的服务发现实现
        const services = {
            'user-service': { host: 'localhost', port: 3001 },
            'order-service': { host: 'localhost', port: 3002 }
        };
        
        return services[serviceName];
    }
}

// 启动服务
async function startServices() {
    const userService = new UserService();
    const orderService = new OrderService();
    const apiGateway = new ApiGateway();
    
    userService.start();
    orderService.start();
    apiGateway.start();
}

startServices().catch(console.error);
```

### 无服务器架构

**Serverless 函数实现：**
```javascript
// serverless/functions/user/handler.js
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

class UserHandler {
    static async createUser(event) {
        try {
            const userData = JSON.parse(event.body);
            
            // 验证输入
            if (!userData.name || !userData.email) {
                return {
                    statusCode: 400,
                    headers: {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    },
                    body: JSON.stringify({
                        error: '姓名和邮箱是必填项'
                    })
                };
            }

            // 创建用户
            const user = {
                id: require('uuid').v4(),
                name: userData.name,
                email: userData.email,
                createdAt: new Date().toISOString()
            };

            await dynamodb.put({
                TableName: process.env.USERS_TABLE,
                Item: user
            }).promise();

            return {
                statusCode: 201,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify(user)
            };
        } catch (error) {
            console.error('创建用户失败:', error);
            
            return {
                statusCode: 500,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify({
                    error: '内部服务器错误'
                })
            };
        }
    }

    static async getUser(event) {
        try {
            const userId = event.pathParameters.id;
            
            const result = await dynamodb.get({
                TableName: process.env.USERS_TABLE,
                Key: { id: userId }
            }).promise();

            if (!result.Item) {
                return {
                    statusCode: 404,
                    headers: {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    },
                    body: JSON.stringify({
                        error: '用户未找到'
                    })
                };
            }

            return {
                statusCode: 200,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify(result.Item)
            };
        } catch (error) {
            console.error('获取用户失败:', error);
            
            return {
                statusCode: 500,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify({
                    error: '内部服务器错误'
                })
            };
        }
    }

    static async listUsers(event) {
        try {
            const result = await dynamodb.scan({
                TableName: process.env.USERS_TABLE
            }).promise();

            return {
                statusCode: 200,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify({
                    data: result.Items,
                    count: result.Count
                })
            };
        } catch (error) {
            console.error('列出用户失败:', error);
            
            return {
                statusCode: 500,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify({
                    error: '内部服务器错误'
                })
            };
        }
    }
}

module.exports = UserHandler;
```

**Serverless 配置文件：**
```yaml
# serverless.yml
service: user-service

provider:
  name: aws
  runtime: nodejs18.x
  region: us-east-1
  environment:
    USERS_TABLE: ${self:service}-${opt:stage, self:provider.stage}-users
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource: "arn:aws:dynamodb:${opt:region, self:provider.region}:*:table/${self:provider.environment.USERS_TABLE}"

functions:
  createUser:
    handler: functions/user/handler.createUser
    events:
      - http:
          path: users
          method: post
          cors: true

  getUser:
    handler: functions/user/handler.getUser
    events:
      - http:
          path: users/{id}
          method: get
          cors: true

  listUsers:
    handler: functions/user/handler.listUsers
    events:
      - http:
          path: users
          method: get
          cors: true

resources:
  Resources:
    UsersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.USERS_TABLE}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST

plugins:
  - serverless-offline
  - serverless-webpack

custom:
  webpack:
    webpackConfig: ./webpack.config.js
    includeModules: true
```

**本地开发工具：**
```javascript
// serverless/local/server.js
const express = require('express');
const bodyParser = require('body-parser');
const UserHandler = require('../functions/user/handler');

const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// 模拟 Serverless 环境
const createEvent = (method, path, body, pathParameters = {}) => ({
    httpMethod: method,
    path: path,
    body: body ? JSON.stringify(body) : null,
    pathParameters: pathParameters,
    headers: {
        'Content-Type': 'application/json'
    }
});

// 用户路由
app.post('/users', async (req, res) => {
    const event = createEvent('POST', '/users', req.body);
    const response = await UserHandler.createUser(event);
    res.status(response.statusCode).json(JSON.parse(response.body));
});

app.get('/users/:id', async (req, res) => {
    const event = createEvent('GET', `/users/${req.params.id}`, null, { id: req.params.id });
    const response = await UserHandler.getUser(event);
    res.status(response.statusCode).json(JSON.parse(response.body));
});

app.get('/users', async (req, res) => {
    const event = createEvent('GET', '/users');
    const response = await UserHandler.listUsers(event);
    res.status(response.statusCode).json(JSON.parse(response.body));
});

// 错误处理中间件
app.use((err, req, res, next) => {
    console.error('服务器错误:', err);
    res.status(500).json({ error: '内部服务器错误' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`本地开发服务器运行在端口 ${PORT}`);
    console.log('可用端点:');
    console.log('  POST   /users     - 创建用户');
    console.log('  GET    /users/:id - 获取用户');
    console.log('  GET    /users     - 列出用户');
});
```