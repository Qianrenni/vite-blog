## 18.1 Web 框架

### Express.js 框架特性

**Express.js 基础应用：**
```javascript
const express = require('express');
const path = require('path');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');

const app = express();

// 中间件配置
app.use(helmet()); // 安全头
app.use(compression()); // 压缩响应
app.use(cors()); // 跨域支持
app.use(express.json({ limit: '10mb' })); // JSON 解析
app.use(express.urlencoded({ extended: true })); // URL 编码解析

// 静态文件服务
app.use(express.static(path.join(__dirname, 'public')));

// 速率限制
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 100, // 限制每个IP 100个请求
    message: '请求过于频繁，请稍后再试'
});
app.use('/api/', limiter);

// 路由定义
app.get('/', (req, res) => {
    res.json({ message: '欢迎使用 Express.js' });
});

// API 路由
app.get('/api/users', async (req, res) => {
    try {
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        
        // 模拟数据获取
        const users = await getUsers(page, limit);
        
        res.json({
            data: users,
            pagination: {
                page,
                limit,
                total: 100
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/users', async (req, res) => {
    try {
        const { name, email } = req.body;
        
        // 数据验证
        if (!name || !email) {
            return res.status(400).json({ 
                error: '姓名和邮箱是必填项' 
            });
        }
        
        // 创建用户
        const user = await createUser({ name, email });
        res.status(201).json(user);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// 错误处理中间件
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: '服务器内部错误' });
});

// 404 处理
app.use((req, res) => {
    res.status(404).json({ error: '页面未找到' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`服务器运行在端口 ${PORT}`);
});
```

**Express.js 高级特性：**
```javascript
const express = require('express');
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redis = require('redis');
const multer = require('multer');
const sharp = require('sharp');

const app = express();

// Redis 客户端
const redisClient = redis.createClient({
    host: 'localhost',
    port: 6379
});

// Session 配置
app.use(session({
    store: new RedisStore({ client: redisClient }),
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: process.env.NODE_ENV === 'production',
        maxAge: 24 * 60 * 60 * 1000 // 24小时
    }
}));

// 文件上传配置
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({ 
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB
    },
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('只允许上传图片文件'));
        }
    }
});

// 文件上传路由
app.post('/api/upload', upload.single('avatar'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: '请选择文件' });
        }

        // 图片处理
        const outputPath = `processed/${req.file.filename}`;
        await sharp(req.file.path)
            .resize(300, 300)
            .jpeg({ quality: 80 })
            .toFile(outputPath);

        res.json({
            message: '文件上传成功',
            file: {
                originalName: req.file.originalname,
                fileName: req.file.filename,
                path: outputPath,
                size: req.file.size
            }
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// 路由模块化
const userRouter = express.Router();

userRouter.get('/', async (req, res) => {
    // 获取用户列表
});

userRouter.get('/:id', async (req, res) => {
    const { id } = req.params;
    // 获取单个用户
});

userRouter.put('/:id', async (req, res) => {
    const { id } = req.params;
    // 更新用户
});

userRouter.delete('/:id', async (req, res) => {
    const { id } = req.params;
    // 删除用户
});

app.use('/api/users', userRouter);

// 自定义中间件
const authMiddleware = (req, res, next) => {
    const token = req.headers.authorization;
    
    if (!token) {
        return res.status(401).json({ error: '未提供认证令牌' });
    }
    
    try {
        // 验证令牌
        const user = verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        res.status(401).json({ error: '无效的认证令牌' });
    }
};

app.use('/api/protected', authMiddleware);
```

### Koa.js 中间件机制

**Koa.js 基础应用：**
```javascript
const Koa = require('koa');
const Router = require('@koa/router');
const bodyParser = require('koa-bodyparser');
const cors = require('@koa/cors');
const helmet = require('koa-helmet');
const logger = require('koa-logger');
const serve = require('koa-static');
const path = require('path');

const app = new Koa();
const router = new Router();

// 中间件注册顺序很重要
app.use(logger()); // 日志
app.use(helmet()); // 安全头
app.use(cors()); // 跨域
app.use(bodyParser()); // 请求体解析
app.use(serve(path.join(__dirname, 'public'))); // 静态文件

// 错误处理中间件
app.use(async (ctx, next) => {
    try {
        await next();
    } catch (err) {
        ctx.status = err.status || 500;
        ctx.body = { error: err.message };
        ctx.app.emit('error', err, ctx);
    }
});

// 自定义中间件
const timingMiddleware = async (ctx, next) => {
    const start = Date.now();
    await next();
    const ms = Date.now() - start;
    ctx.set('X-Response-Time', `${ms}ms`);
};

app.use(timingMiddleware);

// 条件中间件
const conditionalMiddleware = (condition) => {
    return async (ctx, next) => {
        if (condition(ctx)) {
            // 执行特定逻辑
            console.log('条件满足，执行特定逻辑');
        }
        await next();
    };
};

app.use(conditionalMiddleware((ctx) => {
    return ctx.path.startsWith('/api');
}));

// 路由定义
router.get('/', async (ctx) => {
    ctx.body = { message: '欢迎使用 Koa.js' };
});

router.get('/api/users', async (ctx) => {
    try {
        const page = parseInt(ctx.query.page) || 1;
        const limit = parseInt(ctx.query.limit) || 10;
        
        const users = await getUsers(page, limit);
        
        ctx.body = {
            data: users,
            pagination: {
                page,
                limit,
                total: 100
            }
        };
    } catch (error) {
        ctx.throw(500, error.message);
    }
});

router.post('/api/users', async (ctx) => {
    try {
        const { name, email } = ctx.request.body;
        
        if (!name || !email) {
            ctx.throw(400, '姓名和邮箱是必填项');
        }
        
        const user = await createUser({ name, email });
        ctx.status = 201;
        ctx.body = user;
    } catch (error) {
        ctx.throw(500, error.message);
    }
});

// 路由参数验证中间件
const validateUserId = async (ctx, next) => {
    const { id } = ctx.params;
    if (!id || isNaN(id)) {
        ctx.throw(400, '无效的用户ID');
    }
    await next();
};

router.get('/api/users/:id', validateUserId, async (ctx) => {
    const { id } = ctx.params;
    const user = await getUserById(id);
    if (!user) {
        ctx.throw(404, '用户未找到');
    }
    ctx.body = user;
});

app.use(router.routes());
app.use(router.allowedMethods());

// 全局错误处理
app.on('error', (err, ctx) => {
    console.error('服务器错误:', err, ctx);
});

app.listen(3000, () => {
    console.log('Koa.js 服务器运行在端口 3000');
});
```

**Koa.js 高级中间件：**
```javascript
const Koa = require('koa');
const compose = require('koa-compose');

// 异步中间件
const asyncMiddleware = async (ctx, next) => {
    console.log('中间件开始');
    
    // 异步操作
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    ctx.state.middlewareData = '来自中间件的数据';
    
    await next();
    
    console.log('中间件结束');
};

// 流控制中间件
const rateLimitMiddleware = (maxRequests = 100, windowMs = 60000) => {
    const requestCounts = new Map();
    
    return async (ctx, next) => {
        const ip = ctx.ip;
        const now = Date.now();
        const windowStart = now - windowMs;
        
        if (!requestCounts.has(ip)) {
            requestCounts.set(ip, []);
        }
        
        const requests = requestCounts.get(ip);
        const validRequests = requests.filter(time => time > windowStart);
        validRequests.push(now);
        requestCounts.set(ip, validRequests);
        
        if (validRequests.length > maxRequests) {
            ctx.status = 429;
            ctx.body = { error: '请求过于频繁' };
            return;
        }
        
        await next();
    };
};

// 缓存中间件
const cacheMiddleware = (duration = 300000) => { // 5分钟
    const cache = new Map();
    
    return async (ctx, next) => {
        const key = ctx.url;
        const cached = cache.get(key);
        
        if (cached && Date.now() - cached.timestamp < duration) {
            ctx.body = cached.data;
            ctx.status = 200;
            return;
        }
        
        await next();
        
        if (ctx.status === 200) {
            cache.set(key, {
                data: ctx.body,
                timestamp: Date.now()
            });
        }
    };
};

// 响应时间中间件
const responseTimeMiddleware = async (ctx, next) => {
    const start = Date.now();
    await next();
    const ms = Date.now() - start;
    ctx.set('X-Response-Time', `${ms}ms`);
};

// 中间件组合
const middlewareStack = compose([
    responseTimeMiddleware,
    rateLimitMiddleware(),
    asyncMiddleware,
    cacheMiddleware()
]);

const app = new Koa();
app.use(middlewareStack);

// 条件中间件组合
const conditionalCompose = (condition, middleware) => {
    return async (ctx, next) => {
        if (condition(ctx)) {
            await middleware(ctx, next);
        } else {
            await next();
        }
    };
};

app.use(conditionalCompose(
    ctx => ctx.path.startsWith('/api'),
    compose([rateLimitMiddleware(), cacheMiddleware()])
));
```

### Fastify 性能优化

**Fastify 基础应用：**
```javascript
const fastify = require('fastify')({
    logger: true,
    ajv: {
        customOptions: {
            strict: 'log',
            keywords: ['kind', 'modifier']
        }
    }
});

// 插件注册
fastify.register(require('@fastify/cors'));
fastify.register(require('@fastify/helmet'));
fastify.register(require('@fastify/compress'));
fastify.register(require('@fastify/rate-limit'));
fastify.register(require('@fastify/static'), {
    root: path.join(__dirname, 'public'),
    prefix: '/public/'
});

// Schema 验证
const userSchema = {
    body: {
        type: 'object',
        required: ['name', 'email'],
        properties: {
            name: { type: 'string' },
            email: { type: 'string', format: 'email' }
        }
    },
    response: {
        201: {
            type: 'object',
            properties: {
                id: { type: 'number' },
                name: { type: 'string' },
                email: { type: 'string' }
            }
        }
    }
};

// 路由定义
fastify.get('/', async (request, reply) => {
    return { message: '欢迎使用 Fastify' };
});

fastify.get('/api/users', {
    schema: {
        querystring: {
            type: 'object',
            properties: {
                page: { type: 'integer', minimum: 1, default: 1 },
                limit: { type: 'integer', minimum: 1, maximum: 100, default: 10 }
            }
        },
        response: {
            200: {
                type: 'object',
                properties: {
                    data: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                id: { type: 'number' },
                                name: { type: 'string' },
                                email: { type: 'string' }
                            }
                        }
                    },
                    pagination: {
                        type: 'object',
                        properties: {
                            page: { type: 'number' },
                            limit: { type: 'number' },
                            total: { type: 'number' }
                        }
                    }
                }
            }
        }
    }
}, async (request, reply) => {
    const { page, limit } = request.query;
    const users = await getUsers(page, limit);
    
    return {
        data: users,
        pagination: {
            page,
            limit,
            total: 100
        }
    };
});

fastify.post('/api/users', { schema: userSchema }, async (request, reply) => {
    const { name, email } = request.body;
    const user = await createUser({ name, email });
    
    reply.code(201);
    return user;
});

// 错误处理
fastify.setErrorHandler((error, request, reply) => {
    fastify.log.error(error);
    
    if (error.validation) {
        reply.status(400).send({
            error: '验证错误',
            details: error.validation
        });
        return;
    }
    
    reply.status(500).send({
        error: '服务器内部错误'
    });
});

// 启动服务器
const start = async () => {
    try {
        await fastify.listen({ port: 3000, host: '0.0.0.0' });
        fastify.log.info(`服务器运行在端口 3000`);
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};

start();
```

**Fastify 高级特性：**
```javascript
const fastify = require('fastify')({ logger: true });

// 自定义插件
fastify.register(async (instance, opts) => {
    instance.decorate('db', {
        async query(sql, params) {
            // 数据库查询逻辑
            return { rows: [] };
        }
    });
    
    instance.decorateRequest('user', null);
    
    instance.addHook('onRequest', async (request, reply) => {
        // 请求前处理
        request.startTime = Date.now();
    });
    
    instance.addHook('onResponse', async (request, reply) => {
        // 响应后处理
        const duration = Date.now() - request.startTime;
        instance.log.info(`${request.method} ${request.url} - ${duration}ms`);
    });
});

// 装饰器和钩子
fastify.decorate('utils', {
    async hashPassword(password) {
        // 密码哈希逻辑
        return 'hashed_password';
    },
    
    async verifyToken(token) {
        // 令牌验证逻辑
        return { userId: 1, username: 'user' };
    }
});

// 认证插件
fastify.register(async (instance, opts) => {
    instance.decorateRequest('authenticate', async function() {
        const token = this.headers.authorization?.replace('Bearer ', '');
        if (!token) {
            throw new Error('未提供认证令牌');
        }
        
        try {
            const user = await instance.utils.verifyToken(token);
            this.user = user;
        } catch (error) {
            throw new Error('无效的认证令牌');
        }
    });
    
    // 认证钩子
    instance.addHook('preHandler', async (request, reply) => {
        if (request.routeConfig?.authRequired) {
            await request.authenticate();
        }
    });
});

// 需要认证的路由
fastify.get('/api/profile', {
    config: { authRequired: true }
}, async (request, reply) => {
    return { user: request.user };
});

// 缓存插件
fastify.register(async (instance, opts) => {
    const cache = new Map();
    
    instance.decorateReply('cache', function(duration = 300000) {
        this.header('Cache-Control', `public, max-age=${duration / 1000}`);
        return this;
    });
});

// 带缓存的路由
fastify.get('/api/public-data', async (request, reply) => {
    reply.cache(300000); // 缓存5分钟
    return { data: 'public information' };
});

// 监控和指标
fastify.get('/metrics', async (request, reply) => {
    return {
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        cpu: process.cpuUsage()
    };
});
```

### NestJS 企业级框架

**NestJS 基础应用：**
```typescript
// main.ts
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';

async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    
    // 全局管道
    app.useGlobalPipes(new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true
    }));
    
    // CORS
    app.enableCors();
    
    await app.listen(3000);
}
bootstrap();

// app.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserModule } from './user/user.module';
import { AuthModule } from './auth/auth.module';

@Module({
    imports: [
        TypeOrmModule.forRoot({
            type: 'postgres',
            host: 'localhost',
            port: 5432,
            username: 'postgres',
            password: 'password',
            database: 'myapp',
            autoLoadEntities: true,
            synchronize: true,
        }),
        UserModule,
        AuthModule,
    ],
})
export class AppModule {}

// user.entity.ts
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @Column({ unique: true })
    email: string;

    @Column({ select: false }) // 不在查询中返回
    password: string;

    @Column({ default: () => 'CURRENT_TIMESTAMP' })
    createdAt: Date;
}

// user.dto.ts
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export class CreateUserDto {
    @IsNotEmpty()
    name: string;

    @IsEmail()
    email: string;

    @IsNotEmpty()
    @MinLength(6)
    password: string;
}

// user.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';
import { CreateUserDto } from './user.dto';

@Injectable()
export class UserService {
    constructor(
        @InjectRepository(User)
        private userRepository: Repository<User>,
    ) {}

    async findAll(page: number = 1, limit: number = 10): Promise<[User[], number]> {
        return this.userRepository.findAndCount({
            skip: (page - 1) * limit,
            take: limit,
        });
    }

    async findOne(id: number): Promise<User> {
        return this.userRepository.findOne({ where: { id } });
    }

    async create(createUserDto: CreateUserDto): Promise<User> {
        const user = this.userRepository.create(createUserDto);
        return this.userRepository.save(user);
    }

    async findByEmail(email: string): Promise<User> {
        return this.userRepository.findOne({ where: { email } });
    }
}

// user.controller.ts
import {
    Controller,
    Get,
    Post,
    Body,
    Param,
    ParseIntPipe,
    Query,
    HttpStatus,
} from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './user.dto';

@Controller('users')
export class UserController {
    constructor(private readonly userService: UserService) {}

    @Get()
    async findAll(
        @Query('page') page: number = 1,
        @Query('limit') limit: number = 10,
    ) {
        const [data, total] = await this.userService.findAll(page, limit);
        
        return {
            data,
            pagination: {
                page,
                limit,
                total,
            },
        };
    }

    @Get(':id')
    async findOne(@Param('id', ParseIntPipe) id: number) {
        const user = await this.userService.findOne(id);
        if (!user) {
            throw new HttpException('用户未找到', HttpStatus.NOT_FOUND);
        }
        return user;
    }

    @Post()
    async create(@Body() createUserDto: CreateUserDto) {
        return await this.userService.create(createUserDto);
    }
}
```

**NestJS 高级特性：**
```typescript
// auth.guard.ts
import {
    Injectable,
    CanActivate,
    ExecutionContext,
    UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthGuard implements CanActivate {
    constructor(private jwtService: JwtService) {}

    async canActivate(context: ExecutionContext): Promise<boolean> {
        const request = context.switchToHttp().getRequest();
        const token = this.extractTokenFromHeader(request);
        
        if (!token) {
            throw new UnauthorizedException();
        }
        
        try {
            const payload = await this.jwtService.verifyAsync(token, {
                secret: process.env.JWT_SECRET,
            });
            request['user'] = payload;
        } catch {
            throw new UnauthorizedException();
        }
        
        return true;
    }

    private extractTokenFromHeader(request: any): string | undefined {
        const [type, token] = request.headers.authorization?.split(' ') ?? [];
        return type === 'Bearer' ? token : undefined;
    }
}

// roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private reflector: Reflector) {}

    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
            context.getHandler(),
            context.getClass(),
        ]);
        
        if (!requiredRoles) {
            return true;
        }
        
        const { user } = context.switchToHttp().getRequest();
        return requiredRoles.some((role) => user.roles?.includes(role));
    }
}

// user.controller.ts (with guards)
import { UseGuards, SetMetadata } from '@nestjs/common';

@Controller('users')
@UseGuards(AuthGuard)
export class UserController {
    constructor(private readonly userService: UserService) {}

    @Get(':id')
    @UseGuards(RolesGuard)
    @SetMetadata('roles', ['admin'])
    async findOne(@Param('id', ParseIntPipe) id: number) {
        return await this.userService.findOne(id);
    }

    @Post()
    async create(@Body() createUserDto: CreateUserDto) {
        return await this.userService.create(createUserDto);
    }
}

// app.interceptor.ts
import {
    Injectable,
    NestInterceptor,
    ExecutionContext,
    CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
        console.log('Before...');
        const now = Date.now();
        
        return next
            .handle()
            .pipe(
                tap(() => console.log(`After... ${Date.now() - now}ms`)),
            );
    }
}

// app.filter.ts
import {
    ExceptionFilter,
    Catch,
    ArgumentsHost,
    HttpException,
    HttpStatus,
} from '@nestjs/common';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
    catch(exception: unknown, host: ArgumentsHost) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse();
        const request = ctx.getRequest();

        const status = exception instanceof HttpException
            ? exception.getStatus()
            : HttpStatus.INTERNAL_SERVER_ERROR;

        response
            .status(status)
            .json({
                statusCode: status,
                timestamp: new Date().toISOString(),
                path: request.url,
                message: exception instanceof HttpException
                    ? exception.message
                    : 'Internal server error',
            });
    }
}

// main.ts (with interceptors and filters)
async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    
    app.useGlobalInterceptors(new LoggingInterceptor());
    app.useGlobalFilters(new AllExceptionsFilter());
    
    await app.listen(3000);
}
```