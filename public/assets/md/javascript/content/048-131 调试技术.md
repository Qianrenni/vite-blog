## 13.1 调试技术

### 1. 浏览器开发者工具（DevTools）

浏览器开发者工具是前端调试的“瑞士军刀”，以 Chrome DevTools 为例，核心功能包括：

#### 主要面板介绍：

| 面板 | 功能 |
|------|------|
| **Elements** | 查看和修改 DOM 结构、CSS 样式 |
| **Console** | 执行 JS、输出日志、捕获错误 |
| **Sources** | 设置断点、单步执行、查看调用栈 |
| **Network** | 监控 HTTP 请求、响应时间、资源大小 |
| **Performance** | 记录运行时性能，分析 FPS、CPU、内存 |
| **Memory** | 拍摄堆快照、记录内存分配，检测内存泄漏 |
| **Application** | 查看 Storage、Cookies、Service Workers、Cache |
| **Security** | 检查 HTTPS、证书、混合内容等安全问题 |

#### 高效使用技巧：

- `Ctrl+P`（或 `Cmd+P`）快速打开文件
- `console.log()` 可以传多个参数：`console.log("User:", user, "Count:", count)`
- 使用 `console.table()` 查看数组或对象表格化输出
- `console.time('label')` / `console.timeEnd('label')` 测量执行时间
- `$0` 表示当前选中的 DOM 元素（在 Elements 面板中右键选择）

```js
console.table([{name: "Alice", age: 25}, {name: "Bob", age: 30}]);
console.time("fetch");
await fetch('/api/data');
console.timeEnd("fetch");
```

---

### 2. 断点调试技巧

断点是调试的核心，允许你在代码执行到某一行时暂停，检查变量状态。

#### 设置断点的方式：

1. **行断点（Line Breakpoint）**
   - 在 Sources 面板点击行号左侧
   - 程序执行到该行时暂停

2. **条件断点（Conditional Breakpoint）**
   - 右键行号 → "Add conditional breakpoint"
   - 仅当条件为 `true` 时触发
   - 示例：`userId === 123`

3. **DOM 断点**
   - 在 Elements 面板右键 DOM 节点
   - 选择 "Break on" → "subtree modifications" 等
   - 当 DOM 被修改时暂停

4. **XHR/Fetch 断点**
   - 在 Sources 面板 → XHR Breakpoints
   - 输入 URL 关键字，当请求匹配时暂停

5. **事件监听器断点**
   - 在 Sources 面板 → Event Listener Breakpoints
   - 勾选 `click`、`scroll` 等事件，触发时暂停

#### 调试控制按钮：

- ▶️ **Resume**：继续执行（F8）
- ⏩ **Step over**：跳过当前函数调用（F10）
- ⏭️ **Step into**：进入函数内部（F11）
- ⏭️▶️ **Step out**：跳出当前函数（Shift+F11）
- ⏯️ **Deactivate breakpoints**：临时禁用所有断点（Ctrl+F8）

#### 调用栈（Call Stack）分析

- 查看函数调用链，定位错误源头
- 点击任意栈帧可跳转到对应代码位置
- 异步代码会显示 `async` 标记

#### 作用域（Scope）查看

- 查看当前执行上下文中的变量（Local、Closure、Global）
- 可直接修改变量值进行测试

---

### 3. 性能分析工具

用于识别性能瓶颈，如卡顿、加载慢、CPU 占用高等。

#### 使用 Performance 面板：

1. 打开 **Performance** 面板
2. 点击 ▶️ 开始记录
3. 执行目标操作（如页面加载、点击按钮）
4. 点击 ■ 停止记录

#### 分析关键指标：

- **FPS（Frames Per Second）**：绿色条越高越好，红色表示掉帧
- **CPU 使用率**：高 CPU 可能导致卡顿
- **Main 线程**：查看 JS 执行、渲染、合成等任务
- **火焰图（Flame Chart）**：自上而下显示函数调用栈和耗时

#### 常见性能问题识别：

- **长任务（Long Task）**：>50ms 的任务会阻塞主线程
- **频繁的重排/重绘**：Layout、Paint 任务过多
- **过多的垃圾回收（GC）**：频繁的内存分配

#### 示例：优化一个慢函数

```js
// ❌ 慢函数
function slowCalc(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length; j++) {
            // O(n²) 算法
        }
    }
}
```

通过 Performance 面板发现该函数耗时 800ms，可优化为哈希查找（O(n)）。

---

### 4. 内存分析方法

内存泄漏是隐蔽但致命的问题，会导致页面越来越卡，最终崩溃。

#### 使用 Memory 面板：

##### （1）堆快照（Heap Snapshot）

- 拍摄当前内存对象的快照
- 可对比多个快照，找出未释放的对象

**操作步骤：**
1. 打开 Memory 面板
2. 选择 "Heap snapshot"
3. 点击 "Take snapshot"
4. 执行操作（如打开关闭组件）
5. 再拍一张快照
6. 使用 "Objects allocated between GCs" 对比

**关键列：**
- **Distance**：到根对象的距离
- **Shallow Size**：对象自身占用内存
- **Retained Size**：该对象被回收后能释放的总内存

##### （2）记录内存分配时间线（Record Allocation Timeline）

- 实时记录对象分配和回收
- 红色柱子表示新分配的对象
- 如果红色不消失，说明未被回收 → 内存泄漏

##### （3）识别常见泄漏模式：

- `Detached DOM trees`：已从 DOM 移除但仍被 JS 引用
- `Closure`：闭包引用大型对象
- `Event listeners`：未移除的事件监听器

#### 示例：使用 `WeakMap` 避免泄漏

```js
// ❌ 普通 Map 持有强引用
const cache = new Map();
cache.set(domElement, data);

// ✅ WeakMap 键是弱引用，DOM 删除后自动清理
const weakCache = new WeakMap();
weakCache.set(domElement, data);
```

---