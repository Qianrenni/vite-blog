## 12.1 内存管理优化

### 1. 垃圾回收机制原理（Garbage Collection, GC）

JavaScript 是一门自动内存管理的语言，开发者无需手动分配或释放内存。引擎通过 **垃圾回收机制** 自动清理不再使用的对象。

#### 主要垃圾回收算法：

##### （1）**引用计数（Reference Counting）**
- 每个对象维护一个“被引用次数”的计数器。
- 当引用数为 0 时，对象被立即回收。
- ❌ 缺陷：无法处理**循环引用**。

```js
let obj1 = {};
let obj2 = {};
obj1.ref = obj2;
obj2.ref = obj1; // 循环引用，引用数始终 ≥1，无法回收
```

> 现代 JS 引擎已不再单独使用引用计数。

##### （2）**标记-清除（Mark-and-Sweep）** ✅ 主流算法
- 从根对象（如 `window`、`global`）开始遍历所有可达对象，进行“标记”。
- 扫描所有对象，未被标记的对象视为“不可达”，即垃圾，进行清除。
- ✅ 能正确处理循环引用。

```js
let obj = { data: "large" };
obj = null; // 原对象不再可达，下次 GC 时会被回收
```

#### 垃圾回收过程（以 V8 为例）：

V8 引擎采用 **分代回收（Generational Collection）** 策略：

| 代际 | 特点 | 回收频率 |
|------|------|----------|
| 新生代（Young Generation） | 存放短期存活对象（如局部变量） | 高频（Scavenge 算法） |
| 老生代（Old Generation） | 存放长期存活对象 | 低频（Mark-Sweep + Mark-Compact） |

> ✅ 优势：提高 GC 效率，减少停顿时间。

#### GC 对性能的影响：
- **Stop-The-World**：GC 执行时会暂停 JavaScript 执行，造成卡顿。
- 频繁 GC 会导致页面卡顿，应尽量减少对象创建。

---

### 2. 内存泄漏识别和预防

内存泄漏指“本应被释放的内存未被释放”，长期积累会导致页面变慢甚至崩溃。

#### 常见内存泄漏场景：

##### （1）意外的全局变量

```js
function leak() {
    leakVar = "I'm global!"; // 忘记 var/let/const → 成为 window.leakVar
}
```

✅ 预防：使用严格模式 `"use strict"`，会报错。

##### （2）未清理的定时器或事件监听

```js
setInterval(() => {
    const hugeData = fetchData();
    // hugeData 一直被闭包引用，无法释放
}, 1000);

// 事件监听未移除
element.addEventListener('click', handler);
// 忘记 element.removeEventListener(...)
```

✅ 预防：组件销毁时清理定时器和事件。

```js
let timer = setInterval(...);
// 销毁时
clearInterval(timer);
element.removeEventListener('click', handler);
```

##### （3）闭包引用大型对象

```js
function outer() {
    const bigData = new Array(1000000).fill('*');
    return function inner() {
        console.log("Still referencing bigData");
    };
}
const fn = outer(); // bigData 无法被回收
```

✅ 预防：避免闭包中长期持有大对象，使用完后置为 `null`。

##### （4）DOM 引用未释放

```js
const element = document.getElementById('myDiv');
const map = new Map();
map.set(element, someData);

// 即使 DOM 被移除，map 仍持有引用，无法回收
document.body.removeChild(element);
```

✅ 预防：使用 `WeakMap` 或手动清理。

```js
const weakMap = new WeakMap(); // 键是弱引用，DOM 删除后自动清理
weakMap.set(element, someData);
```

#### 识别内存泄漏工具：

- **Chrome DevTools → Memory 面板**
  - Heap Snapshot（堆快照）：查看当前内存对象
  - Record Allocation Timeline：记录内存分配过程
- **Performance 面板**：查看 GC 活动和内存增长趋势

> 🔍 技巧：操作前后拍两张堆快照，对比找出未释放的对象。

---

### 3. 对象池模式应用（Object Pool Pattern）

频繁创建和销毁对象会加重 GC 负担。对象池通过**复用对象**减少内存分配。

#### 适用场景：
- 频繁创建/销毁的短生命周期对象（如粒子、子弹、DOM 元素）
- 创建成本高的对象（如复杂配置对象）

#### 实现一个简单的对象池：

```js
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 5) {
        this.createFn = createFn;  // 创建对象的函数
        this.resetFn = resetFn;    // 重置对象状态的函数
        this.pool = [];
        // 预创建一些对象
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(createFn());
        }
    }

    acquire() {
        if (this.pool.length > 0) {
            return this.pool.pop();
        }
        return this.createFn(); // 池空时新建
    }

    release(obj) {
        this.resetFn(obj); // 重置状态
        this.pool.push(obj); // 放回池中
    }
}

// 使用示例：复用 DOM 元素
const divPool = new ObjectPool(
    () => document.createElement('div'),
    (div) => {
        div.textContent = '';
        div.className = '';
        if (div.parentNode) div.remove();
    }
);

// 获取
const div = divPool.acquire();
div.textContent = "Hello";
document.body.appendChild(div);

// 使用完放回
divPool.release(div);
```

✅ 优势：
- 减少 GC 压力
- 提升性能（避免重复创建开销）

⚠️ 注意：
- 不是所有场景都适用（如对象状态复杂难重置）
- 池过大也会浪费内存

---

### 4. 内存使用监控

主动监控内存使用情况，及时发现异常。

#### （1）浏览器中使用 Performance API

```js
// 获取内存信息（仅 Chrome 支持）
if (performance.memory) {
    console.log({
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit
    });
}
```

> ⚠️ 非标准 API，仅用于开发调试。

#### （2）Node.js 中使用 `process.memoryUsage()`

```js
setInterval(() => {
    const mem = process.memoryUsage();
    console.log({
        rss: (mem.rss / 1024 / 1024).toFixed(2) + ' MB', // 物理内存
        heapTotal: (mem.heapTotal / 1024 / 1024).toFixed(2) + ' MB',
        heapUsed: (mem.heapUsed / 1024 / 1024).toFixed(2) + ' MB',
    });
}, 5000);
```

#### （3）监控内存增长趋势

```js
let lastHeap = 0;
function checkMemoryLeak() {
    if (performance.memory) {
        const current = performance.memory.usedJSHeapSize;
        if (current - lastHeap > 10 * 1024 * 1024) { // 增长超过 10MB
            console.warn("内存增长过快，可能存在泄漏");
        }
        lastHeap = current;
    }
}
```

#### （4）集成监控工具

- **Sentry**：捕获错误并附带内存上下文
- **Datadog / New Relic**：监控 Node.js 内存指标
- **Lighthouse**：自动化性能审计

---