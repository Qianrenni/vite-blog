## 11.1 错误类型识别

### 1. JavaScript 内置错误类型

JavaScript 提供了多种内置的错误类型（Error 类型），它们都继承自 `Error` 构造函数。了解这些错误类型有助于我们识别错误来源并进行针对性处理。

#### 常见内置错误类型：

| 错误类型 | 触发场景 | 示例 |
|--------|--------|------|
| `Error` | 通用错误类型，通常用于自定义错误 | `throw new Error("出错了")` |
| `SyntaxError` | 语法错误，代码解析阶段出错 | `eval('var a = ')` |
| `ReferenceError` | 引用未声明的变量 | `console.log(x)`（x 未定义） |
| `TypeError` | 类型错误，调用值的方法或属性时类型不匹配 | `null.toString()` |
| `RangeError` | 数值超出允许范围 | `new Array(-1)` |
| `URIError` | URI 相关函数使用错误 | `decodeURIComponent('%')` |
| `EvalError` | `eval()` 使用错误（已废弃） | — |
| `InternalError` | 引擎内部错误（非标准） | 递归太深导致栈溢出 |

> 💡 注意：`SyntaxError` 通常在代码解析阶段发生，**无法被 `try...catch` 捕获**，因为代码根本没执行。

#### 示例：识别不同错误类型

```js
try {
    JSON.parse("{ bad json }");
} catch (err) {
    if (err instanceof SyntaxError) {
        console.error("JSON 语法错误:", err.message);
    } else {
        console.error("其他错误:", err.message);
    }
}
```

---

### 2. 自定义错误类创建

为了更清晰地表达业务逻辑中的异常情况，我们可以继承 `Error` 类创建自定义错误类型。

#### 创建自定义错误类

```js
class ValidationError extends Error {
    constructor(message) {
        super(message); // 调用父类构造函数
        this.name = "ValidationError"; // 设置错误名称
        this.code = "VALIDATION_ERROR"; // 可扩展字段
    }
}

// 使用
function validateEmail(email) {
    if (!email.includes("@")) {
        throw new ValidationError("邮箱格式不正确");
    }
}

try {
    validateEmail("not-an-email");
} catch (err) {
    if (err instanceof ValidationError) {
        console.error("验证失败:", err.message);
    }
}
```

#### 高级自定义错误（带额外信息）

```js
class ApiError extends Error {
    constructor(status, message, url) {
        super(`${status} ${message} - ${url}`);
        this.name = "ApiError";
        this.status = status;
        this.url = url;
    }
}

// 使用
throw new ApiError(404, "Not Found", "https://api.example.com/user");
```

> ✅ 最佳实践：
> - 继承 `Error`
> - 设置 `this.name`
> - 保留堆栈信息（现代 JS 引擎自动处理）
> - 添加业务相关属性（如 code、status 等）

---

### 3. 错误堆栈跟踪（Stack Trace）

错误对象通常包含 `.stack` 属性，提供错误发生的调用堆栈信息，对调试至关重要。

#### 示例：查看堆栈

```js
function inner() {
    throw new Error("出错了！");
}

function outer() {
    inner();
}

try {
    outer();
} catch (err) {
    console.log(err.stack);
}
```

输出示例：

```
Error: 出错了！
    at inner (script.js:2:11)
    at outer (script.js:5:5)
    at script.js:8:5
```

#### 堆栈的作用：

- 定位错误发生的具体文件和行号
- 查看函数调用链
- 在开发和生产环境中辅助调试

> ⚠️ 注意：
> - `stack` 属性是非标准但广泛支持的。
> - 生产环境中可考虑隐藏详细堆栈以防信息泄露。

---

### 4. 错误信息格式化

为了统一错误输出，提升可读性，我们可以对错误信息进行格式化处理。

#### 方法一：封装错误处理函数

```js
function formatError(err) {
    return {
        name: err.name,
        message: err.message,
        stack: err.stack?.split('\n').slice(0, 5), // 只保留前5行
        timestamp: new Date().toISOString(),
        ...(err.code && { code: err.code }),
        ...(err.status && { status: err.status })
    };
}

try {
    throw new ValidationError("用户名不能为空");
} catch (err) {
    console.error("格式化错误:", formatError(err));
}
```

#### 方法二：使用 `console.error` 配合自定义格式

```js
console.error(`[${new Date().toLocaleString()}] ${err.name}: ${err.message}`);
```

#### 方法三：日志系统集成（如 Winston、Pino）

```js
// 使用 Winston 示例
const logger = require('winston');
logger.error({
    level: 'error',
    message: err.message,
    stack: err.stack,
    meta: { userId: 123 }
});
```

---