## 16.1 异步编程

### 回调函数模式

**错误优先回调约定：**
```javascript
// Node.js 标准回调模式：(error, data) => {}
const fs = require('fs');

// 正确的回调函数模式
function readFile(filename, callback) {
    fs.readFile(filename, 'utf8', (err, data) => {
        if (err) {
            // 错误优先返回
            return callback(err, null);
        }
        callback(null, data);
    });
}

// 使用回调函数
readFile('example.txt', (err, data) => {
    if (err) {
        console.error('读取文件失败:', err.message);
        return;
    }
    console.log('文件内容:', data);
});

// 回调地狱示例
fs.readFile('file1.txt', 'utf8', (err, data1) => {
    if (err) throw err;
    fs.readFile('file2.txt', 'utf8', (err, data2) => {
        if (err) throw err;
        fs.readFile('file3.txt', 'utf8', (err, data3) => {
            if (err) throw err;
            console.log(data1, data2, data3);
        });
    });
});
```

**自定义回调函数实现：**
```javascript
// 模拟异步操作
function asyncOperation(data, callback) {
    setTimeout(() => {
        if (Math.random() > 0.5) {
            callback(null, `处理完成: ${data}`);
        } else {
            callback(new Error('处理失败'));
        }
    }, 1000);
}

// 并行执行
function parallelExecution(tasks, callback) {
    let completed = 0;
    let results = [];
    let hasError = false;

    if (tasks.length === 0) {
        return callback(null, []);
    }

    tasks.forEach((task, index) => {
        task((err, result) => {
            if (hasError) return;
            
            if (err) {
                hasError = true;
                return callback(err);
            }

            results[index] = result;
            completed++;

            if (completed === tasks.length) {
                callback(null, results);
            }
        });
    });
}

// 串行执行
function serialExecution(tasks, callback) {
    let results = [];

    function executeTask(index) {
        if (index >= tasks.length) {
            return callback(null, results);
        }

        tasks[index]((err, result) => {
            if (err) return callback(err);
            results.push(result);
            executeTask(index + 1);
        });
    }

    executeTask(0);
}
```

### Promise 在 Node.js 中的应用

**Promise 基本使用：**
```javascript
const fs = require('fs').promises;

// 将回调转换为 Promise
function promisify(fn) {
    return function(...args) {
        return new Promise((resolve, reject) => {
            fn.call(this, ...args, (err, result) => {
                if (err) reject(err);
                else resolve(result);
            });
        });
    };
}

// 使用 promisify
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

// Promise 链式调用
readFile('input.txt', 'utf8')
    .then(data => {
        console.log('读取数据:', data);
        return data.toUpperCase();
    })
    .then(upperData => {
        return writeFile('output.txt', upperData);
    })
    .then(() => {
        console.log('文件写入完成');
    })
    .catch(err => {
        console.error('操作失败:', err.message);
    });
```

**Promise 组合操作：**
```javascript
// 并行执行
Promise.all([
    fs.readFile('file1.txt', 'utf8'),
    fs.readFile('file2.txt', 'utf8'),
    fs.readFile('file3.txt', 'utf8')
]).then(results => {
    console.log('所有文件读取完成:', results);
}).catch(err => {
    console.error('读取失败:', err);
});

// 竞争执行
Promise.race([
    fetch('http://api1.com/data'),
    fetch('http://api2.com/data')
]).then(response => {
    console.log('最快的响应:', response);
});

// 全部完成（包括失败）
Promise.allSettled([
    fs.readFile('file1.txt', 'utf8'),
    fs.readFile('file2.txt', 'utf8')
]).then(results => {
    results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
            console.log(`文件${index + 1}读取成功:`, result.value);
        } else {
            console.log(`文件${index + 1}读取失败:`, result.reason);
        }
    });
});
```

### async/await 语法支持

**基本 async/await 使用：**
```javascript
const fs = require('fs').promises;

// async 函数
async function processFiles() {
    try {
        // 串行执行
        const data1 = await fs.readFile('file1.txt', 'utf8');
        const data2 = await fs.readFile('file2.txt', 'utf8');
        console.log('串行读取:', data1, data2);

        // 并行执行
        const [content1, content2] = await Promise.all([
            fs.readFile('file1.txt', 'utf8'),
            fs.readFile('file2.txt', 'utf8')
        ]);
        console.log('并行读取:', content1, content2);

        // 处理数据
        const processedData = await processData(content1, content2);
        await fs.writeFile('result.txt', processedData);
        
        return '处理完成';
    } catch (error) {
        console.error('处理过程中出错:', error.message);
        throw error;
    }
}

async function processData(data1, data2) {
    // 模拟异步数据处理
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(data1 + data2);
        }, 1000);
    });
}

// 调用 async 函数
processFiles()
    .then(result => console.log(result))
    .catch(err => console.error(err));
```

**错误处理最佳实践：**
```javascript
async function robustAsyncFunction() {
    try {
        // 可能失败的操作
        const data = await riskyOperation();
        return data;
    } catch (error) {
        // 记录错误
        console.error('操作失败:', error);
        
        // 返回默认值或重新抛出
        return null; // 或 throw error;
    }
}

// 错误边界处理
async function handleMultipleOperations() {
    const operations = [
        asyncOperation1(),
        asyncOperation2(),
        asyncOperation3()
    ];

    const results = [];
    for (let i = 0; i < operations.length; i++) {
        try {
            const result = await operations[i];
            results.push({ success: true,  result });
        } catch (error) {
            results.push({ success: false, error: error.message });
        }
    }

    return results;
}
```

### 错误优先回调约定

**自定义错误处理：**
```javascript
// 统一错误处理中间件
function createErrorHandler(callback) {
    return function(error, result) {
        if (error) {
            console.error('操作失败:', error.message);
            // 可以添加日志记录、监控等
            if (callback) callback(error);
            return;
        }
        if (callback) callback(null, result);
    };
}

// 使用错误处理中间件
function readFileWithHandler(filename, callback) {
    const handler = createErrorHandler(callback);
    
    fs.readFile(filename, 'utf8', (err, data) => {
        if (err) return handler(err);
        handler(null, data.toUpperCase());
    });
}

// 链式错误处理
function chainOperations(callback) {
    const handler = createErrorHandler(callback);
    
    step1((err, result1) => {
        if (err) return handler(err);
        
        step2(result1, (err, result2) => {
            if (err) return handler(err);
            
            step3(result2, handler);
        });
    });
}
```