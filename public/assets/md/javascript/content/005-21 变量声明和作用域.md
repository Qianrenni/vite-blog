## 2.1 变量声明和作用域

### var、let、const 的区别和使用场景

```javascript
// var - 函数作用域
function varExample() {
    if (true) {
        var x = 1;
    }
    console.log(x); // 1 - 可以访问，不受块级限制
}

// var - 变量提升
console.log(a); // undefined (不是报错)
var a = 5;

// var - 重复声明
var b = 1;
var b = 2; // 允许重复声明

// let - 块级作用域
function letExample() {
    if (true) {
        let y = 1;
    }
    // console.log(y); // ReferenceError: y is not defined
}

// let - 暂时性死区
// console.log(c); // ReferenceError: Cannot access 'c' before initialization
let c = 5;

// let - 禁止重复声明
let d = 1;
// let d = 2; // SyntaxError: Identifier 'd' has already been declared

// const - 块级作用域 + 禁止重新赋值
const PI = 3.14159;
// PI = 3.14; // TypeError: Assignment to constant variable

// const - 必须初始化
// const name; // SyntaxError: Missing initializer in const declaration

// const - 对象和数组可以修改内容
const obj = { name: "张三" };
obj.name = "李四"; // 可以修改属性
obj.age = 25; // 可以添加属性

const arr = [1, 2, 3];
arr.push(4); // 可以修改数组内容
// arr = [5, 6, 7]; // TypeError: Assignment to constant variable
```

### 变量提升机制

```javascript
// var 提升示例
console.log(name); // undefined
var name = "张三";
console.log(name); // "张三"

// 等价于：
// var name;
// console.log(name); // undefined
// name = "张三";
// console.log(name); // "张三"

// let/const 暂时性死区
function temporalDeadZone() {
    // console.log(x); // ReferenceError
    let x = 1;
}

// 函数提升
sayHello(); // "Hello!" - 函数声明被完全提升

function sayHello() {
    console.log("Hello!");
}

// 函数表达式只提升变量声明
// sayHi(); // TypeError: sayHi is not a function
var sayHi = function() {
    console.log("Hi!");
};

// 提升顺序示例
function hoistingOrder() {
    console.log(typeof foo); // "function"
    var foo = "变量";
    function foo() {
        return "函数";
    }
    console.log(typeof foo); // "string"
}
```

### 作用域链概念

```javascript
// 全局作用域
var globalVar = "全局变量";

function outer() {
    // 函数作用域
    var outerVar = "外层变量";
    
    function inner() {
        // 内层函数作用域
        var innerVar = "内层变量";
        
        // 作用域链查找：inner -> outer -> global
        console.log(innerVar);  // "内层变量"
        console.log(outerVar);  // "外层变量"
        console.log(globalVar); // "全局变量"
    }
    
    inner();
    // console.log(innerVar); // ReferenceError: innerVar is not defined
}

outer();
// console.log(outerVar); // ReferenceError: outerVar is not defined

// 闭包中的作用域链
function createCounter() {
    let count = 0; // 私有变量
    
    return function() {
        count++; // 保持对外层变量的引用
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

### 块级作用域和函数作用域

```javascript
// 函数作用域示例
function functionScope() {
    var i = 0;
    if (true) {
        var i = 1; // 同一个变量
        console.log(i); // 1
    }
    console.log(i); // 1 - 变量被覆盖
}

// 块级作用域示例
function blockScope() {
    let j = 0;
    if (true) {
        let j = 1; // 新的变量
        console.log(j); // 1
    }
    console.log(j); // 0 - 原变量未被影响
}

// 循环中的变量声明
// 使用 var 的问题
for (var k = 0; k < 3; k++) {
    setTimeout(() => {
        console.log(k); // 输出 3, 3, 3
    }, 100);
}

// 使用 let 的正确方式
for (let l = 0; l < 3; l++) {
    setTimeout(() => {
        console.log(l); // 输出 0, 1, 2
    }, 100);
}
```