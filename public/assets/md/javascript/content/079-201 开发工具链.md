## 20.1 开发工具链

### 代码编辑器配置

**VS Code 配置：**
```json
// .vscode/settings.json
{
    "editor.tabSize": 2,
    "editor.insertSpaces": true,
    "editor.renderWhitespace": "boundary",
    "editor.renderControlCharacters": true,
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.fixAll.eslint": true,
        "source.organizeImports": true
    },
    "files.trimTrailingWhitespace": true,
    "files.insertFinalNewline": true,
    "files.trimFinalNewlines": true,
    "emmet.includeLanguages": {
        "javascript": "javascriptreact",
        "typescript": "typescriptreact"
    },
    "javascript.preferences.importModuleSpecifier": "relative",
    "typescript.preferences.importModuleSpecifier": "relative",
    "search.exclude": {
        "**/node_modules": true,
        "**/dist": true,
        "**/build": true,
        "**/.git": true
    },
    "files.exclude": {
        "**/__pycache__": true,
        "**/*.pyc": true
    }
}
```

**VS Code 扩展推荐：**
```json
// .vscode/extensions.json
{
    "recommendations": [
        "ms-vscode.vscode-typescript-next",
        "esbenp.prettier-vscode",
        "dbaeumer.vscode-eslint",
        "bradlc.vscode-tailwindcss",
        "ms-azuretools.vscode-docker",
        "ms-vscode.vscode-node-azure-pack",
        "ms-vscode.vscode-typescript-next",
        "ms-vscode.vscode-json",
        "ms-vscode.vscode-javascript",
        "ms-vscode.vscode-css",
        "ms-vscode.vscode-html",
        "ms-vscode.vscode-debugger",
        "ms-vscode.vscode-terminal",
        "ms-vscode.vscode-remote",
        "ms-vscode.vscode-remote-extensionpack",
        "ms-vscode.vscode-docker",
        "ms-vscode.vscode-kubernetes-tools",
        "ms-vscode.vscode-azure-account",
        "ms-vscode.vscode-azure-app-service",
        "ms-vscode.vscode-azure-storage",
        "ms-vscode.vscode-azure-databases",
        "ms-vscode.vscode-azure-resource-groups",
        "ms-vscode.vscode-azure-static-web-apps",
        "ms-vscode.vscode-azure-vm",
        "ms-vscode.vscode-azure-iot-edge",
        "ms-vscode.vscode-azure-iot-toolkit",
        "ms-vscode.vscode-azure-iot-hub",
        "ms-vscode.vscode-azure-event-hub",
        "ms-vscode.vscode-azure-service-bus",
        "ms-vscode.vscode-azure-cosmosdb",
        "ms-vscode.vscode-azure-functions",
        "ms-vscode.vscode-azure-app-service",
        "ms-vscode.vscode-azure-storage",
        "ms-vscode.vscode-azure-databases",
        "ms-vscode.vscode-azure-resource-groups",
        "ms-vscode.vscode-azure-static-web-apps",
        "ms-vscode.vscode-azure-vm",
        "ms-vscode.vscode-azure-iot-edge",
        "ms-vscode.vscode-azure-iot-toolkit",
        "ms-vscode.vscode-azure-iot-hub",
        "ms-vscode.vscode-azure-event-hub",
        "ms-vscode.vscode-azure-service-bus",
        "ms-vscode.vscode-azure-cosmosdb",
        "ms-vscode.vscode-azure-functions"
    ]
}
```

**代码片段配置：**
```json
// .vscode/snippets/javascript.json
{
    "Express Route Handler": {
        "prefix": "exroute",
        "body": [
            "app.${1:get}('${2:/api/route}', async (req, res) => {",
            "  try {",
            "    ${3:// Your code here}",
            "    res.status(200).json({ message: 'Success' });",
            "  } catch (error) {",
            "    console.error(error);",
            "    res.status(500).json({ error: error.message });",
            "  }",
            "});"
        ],
        "description": "Express route handler with async/await"
    },
    "Try-Catch Block": {
        "prefix": "trycatch",
        "body": [
            "try {",
            "  ${1:// Your code here}",
            "} catch (error) {",
            "  console.error('${2:Error occurred}:', error);",
            "  ${3:// Handle error}",
            "}"
        ],
        "description": "Try-catch block with error logging"
    },
    "Jest Test Suite": {
        "prefix": "jesttest",
        "body": [
            "describe('${1:Test Suite Name}', () => {",
            "  beforeEach(() => {",
            "    ${2:// Setup code}",
            "  });",
            "",
            "  test('${3:should do something}', async () => {",
            "    ${4:// Test code}",
            "  });",
            "",
            "  afterEach(() => {",
            "    ${5:// Cleanup code}",
            "  });",
            "});"
        ],
        "description": "Jest test suite template"
    }
}
```

**调试配置：**
```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "program": "${workspaceFolder}/src/index.js",
            "env": {
                "NODE_ENV": "development"
            },
            "console": "integratedTerminal"
        },
        {
            "type": "node",
            "request": "attach",
            "name": "Attach to Process",
            "port": 9229,
            "restart": true,
            "skipFiles": [
                "<node_internals>/**"
            ]
        },
        {
            "type": "node",
            "request": "launch",
            "name": "Debug Jest Tests",
            "program": "${workspaceFolder}/node_modules/.bin/jest",
            "args": [
                "--runInBand",
                "--no-cache"
            ],
            "console": "integratedTerminal",
            "internalConsoleOptions": "neverOpen",
            "disableOptimisticBPs": true
        },
        {
            "type": "node",
            "request": "launch",
            "name": "Debug with Nodemon",
            "runtimeExecutable": "nodemon",
            "program": "${workspaceFolder}/src/index.js",
            "console": "integratedTerminal",
            "restart": true,
            "env": {
                "NODE_ENV": "development"
            }
        }
    ]
}
```

### 调试工具使用

**Node.js 调试器：**
```javascript
// 调试工具类
class Debugger {
    constructor(options = {}) {
        this.enabled = options.enabled || process.env.NODE_ENV === 'development';
        this.logLevel = options.logLevel || 'info';
    }

    log(level, message, data = {}) {
        if (!this.enabled) return;
        
        const levels = ['debug', 'info', 'warn', 'error'];
        const currentLevel = levels.indexOf(this.logLevel);
        const messageLevel = levels.indexOf(level);
        
        if (messageLevel >= currentLevel) {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
            
            if (Object.keys(data).length > 0) {
                console.log(logMessage, data);
            } else {
                console.log(logMessage);
            }
        }
    }

    debug(message, data) {
        this.log('debug', message, data);
    }

    info(message, data) {
        this.log('info', message, data);
    }

    warn(message, data) {
        this.log('warn', message, data);
    }

    error(message, data) {
        this.log('error', message, data);
    }

    // 性能监控
    time(label) {
        if (this.enabled) {
            console.time(label);
        }
    }

    timeEnd(label) {
        if (this.enabled) {
            console.timeEnd(label);
        }
    }

    // 内存使用监控
    memoryUsage() {
        if (this.enabled) {
            const usage = process.memoryUsage();
            this.info('Memory Usage', {
                rss: `${Math.round(usage.rss / 1024 / 1024)} MB`,
                heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)} MB`,
                heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)} MB`,
                external: `${Math.round(usage.external / 1024 / 1024)} MB`
            });
        }
    }

    // 调用栈跟踪
    trace(message) {
        if (this.enabled) {
            const stack = new Error().stack;
            this.debug(message, { stack });
        }
    }
}

// 使用示例
const debugger = new Debugger({ enabled: true, logLevel: 'debug' });

// 调试中间件
const debugMiddleware = (req, res, next) => {
    debugger.info('Incoming Request', {
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });

    const startTime = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        debugger.info('Response Sent', {
            method: req.method,
            url: req.url,
            statusCode: res.statusCode,
            duration: `${duration}ms`
        });
    });

    next();
};

// 调试路由处理器
app.get('/api/debug', debugMiddleware, async (req, res) => {
    debugger.time('api-debug-operation');
    
    try {
        debugger.debug('Starting debug operation');
        
        // 模拟一些操作
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        debugger.memoryUsage();
        debugger.trace('Operation completed');
        
        res.json({ message: 'Debug operation completed' });
    } catch (error) {
        debugger.error('Debug operation failed', { error: error.message });
        res.status(500).json({ error: error.message });
    } finally {
        debugger.timeEnd('api-debug-operation');
    }
});
```

**Chrome DevTools 调试：**
```bash
# 启动带调试的 Node.js 应用
node --inspect src/index.js

# 启动带调试和断点的 Node.js 应用
node --inspect-brk src/index.js

# 使用 nodemon 调试
nodemon --inspect src/index.js

# Docker 调试
docker run -p 9229:9229 --rm -it myapp node --inspect=0.0.0.0:9229 src/index.js
```

**调试工具集成：**
```javascript
// 自定义调试工具
class AdvancedDebugger {
    constructor(options = {}) {
        this.enabled = options.enabled || false;
        this.outputFile = options.outputFile || null;
        this.filters = options.filters || [];
        this.logs = [];
    }

    // 条件调试
    conditionalLog(condition, message, data) {
        if (this.enabled && condition) {
            this.log(message, data);
        }
    }

    // 过滤调试
    logWithFilter(filter, message, data) {
        if (this.enabled && this.filters.includes(filter)) {
            this.log(message, data);
        }
    }

    // 异步调试
    async asyncLog(asyncOperation, label) {
        if (this.enabled) {
            const startTime = Date.now();
            console.time(label);
            
            try {
                const result = await asyncOperation();
                const duration = Date.now() - startTime;
                
                this.log(`${label} completed`, {
                    duration: `${duration}ms`,
                    result: result
                });
                
                return result;
            } catch (error) {
                this.error(`${label} failed`, {
                    error: error.message,
                    duration: `${Date.now() - startTime}ms`
                });
                throw error;
            } finally {
                console.timeEnd(label);
            }
        } else {
            return await asyncOperation();
        }
    }

    // 数据库查询调试
    async debugQuery(query, params, connection) {
        if (this.enabled) {
            const startTime = Date.now();
            
            this.log('Executing query', {
                query: query,
                params: params
            });
            
            try {
                const result = await connection.query(query, params);
                const duration = Date.now() - startTime;
                
                this.log('Query executed successfully', {
                    rowCount: result.rowCount,
                    duration: `${duration}ms`
                });
                
                return result;
            } catch (error) {
                this.error('Query execution failed', {
                    error: error.message,
                    query: query,
                    duration: `${Date.now() - startTime}ms`
                });
                throw error;
            }
        } else {
            return await connection.query(query, params);
        }
    }

    // API 调用调试
    async debugApiCall(url, options = {}) {
        if (this.enabled) {
            const startTime = Date.now();
            
            this.log('Making API call', {
                url: url,
                method: options.method || 'GET',
                headers: options.headers
            });
            
            try {
                const response = await fetch(url, options);
                const duration = Date.now() - startTime;
                
                this.log('API call completed', {
                    status: response.status,
                    statusText: response.statusText,
                    duration: `${duration}ms`
                });
                
                return response;
            } catch (error) {
                this.error('API call failed', {
                    error: error.message,
                    url: url,
                    duration: `${Date.now() - startTime}ms`
                });
                throw error;
            }
        } else {
            return await fetch(url, options);
        }
    }
}

// 使用示例
const advancedDebugger = new AdvancedDebugger({
    enabled: true,
    filters: ['database', 'api', 'business-logic'],
    outputFile: './debug.log'
});

// 在服务中使用
class UserService {
    constructor(db, debugger) {
        this.db = db;
        this.debugger = debugger;
    }

    async getUserById(id) {
        return await this.debugger.debugQuery(
            'SELECT * FROM users WHERE id = $1',
            [id],
            this.db
        );
    }

    async createUser(userData) {
        return await this.debugger.asyncLog(
            async () => {
                const result = await this.db.query(
                    'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',
                    [userData.name, userData.email]
                );
                return result.rows[0];
            },
            'createUser'
        );
    }
}
```

### 性能分析工具

**内置性能分析：**
```javascript
// 性能分析工具类
class PerformanceAnalyzer {
    constructor() {
        this.metrics = new Map();
        this.timers = new Map();
    }

    // 启动计时器
    startTimer(label) {
        this.timers.set(label, process.hrtime());
    }

    // 停止计时器并记录
    stopTimer(label) {
        const startTime = this.timers.get(label);
        if (!startTime) return null;

        const diff = process.hrtime(startTime);
        const nanoseconds = diff[0] * 1e9 + diff[1];
        const milliseconds = nanoseconds / 1e6;

        this.timers.delete(label);
        
        if (!this.metrics.has(label)) {
            this.metrics.set(label, []);
        }
        
        this.metrics.get(label).push(milliseconds);
        return milliseconds;
    }

    // 获取统计信息
    getStats(label) {
        const times = this.metrics.get(label);
        if (!times || times.length === 0) return null;

        const sorted = [...times].sort((a, b) => a - b);
        const sum = times.reduce((a, b) => a + b, 0);
        const avg = sum / times.length;
        const min = sorted[0];
        const max = sorted[sorted.length - 1];
        const median = sorted[Math.floor(sorted.length / 2)];

        return {
            count: times.length,
            avg: avg.toFixed(2),
            min: min.toFixed(2),
            max: max.toFixed(2),
            median: median.toFixed(2),
            total: sum.toFixed(2)
        };
    }

    // 获取所有统计信息
    getAllStats() {
        const stats = {};
        for (const [label, times] of this.metrics) {
            stats[label] = this.getStats(label);
        }
        return stats;
    }

    // 清除指标
    clearMetrics() {
        this.metrics.clear();
        this.timers.clear();
    }

    // 性能装饰器
    performanceMonitor(label) {
        return (target, propertyName, descriptor) => {
            const method = descriptor.value;
            
            descriptor.value = async function(...args) {
                const analyzer = new PerformanceAnalyzer();
                analyzer.startTimer(label);
                
                try {
                    const result = await method.apply(this, args);
                    const duration = analyzer.stopTimer(label);
                    
                    console.log(`${label}: ${duration.toFixed(2)}ms`);
                    return result;
                } catch (error) {
                    analyzer.stopTimer(label);
                    throw error;
                }
            };
            
            return descriptor;
        };
    }
}

// 使用示例
const perfAnalyzer = new PerformanceAnalyzer();

// 手动性能分析
perfAnalyzer.startTimer('database-query');
// 执行数据库查询
const users = await db.query('SELECT * FROM users LIMIT 1000');
perfAnalyzer.stopTimer('database-query');

console.log('查询性能统计:', perfAnalyzer.getStats('database-query'));

// 装饰器使用
class UserService {
    @perfAnalyzer.performanceMonitor('getUserById')
    async getUserById(id) {
        return await this.db.query('SELECT * FROM users WHERE id = $1', [id]);
    }

    @perfAnalyzer.performanceMonitor('createUser')
    async createUser(userData) {
        return await this.db.query(
            'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',
            [userData.name, userData.email]
        );
    }
}
```

**外部性能分析工具：**
```javascript
// 使用 clinic.js 进行性能分析
const Clinic = require('clinic');
const { promisify } = require('util');
const { spawn } = require('child_process');

class ClinicAnalyzer {
    constructor() {
        this.clinic = new Clinic();
    }

    async analyzeDoctor(scriptPath, options = {}) {
        const collect = promisify(this.clinic.doctor.bind(this.clinic));
        const html = promisify(this.clinic.doctor.html.bind(this.clinic.doctor));
        
        try {
            // 收集数据
            const dataPath = await collect([process.execPath, scriptPath], {
                duration: options.duration || 30000,
                ...options
            });
            
            // 生成报告
            const htmlPath = await html(dataPath, {
                outputDir: options.outputDir || './clinic-reports'
            });
            
            console.log(`性能报告生成在: ${htmlPath}`);
            return htmlPath;
        } catch (error) {
            console.error('性能分析失败:', error);
            throw error;
        }
    }

    async analyzeBubbleprof(scriptPath, options = {}) {
        const collect = promisify(this.clinic.bubbleprof.bind(this.clinic));
        const html = promisify(this.clinic.bubbleprof.html.bind(this.clinic.bubbleprof));
        
        try {
            const dataPath = await collect([process.execPath, scriptPath], options);
            const htmlPath = await html(dataPath, {
                outputDir: options.outputDir || './clinic-reports'
            });
            
            console.log(`BubbleProf 报告生成在: ${htmlPath}`);
            return htmlPath;
        } catch (error) {
            console.error('BubbleProf 分析失败:', error);
            throw error;
        }
    }

    async analyzeFlame(scriptPath, options = {}) {
        const collect = promisify(this.clinic.flame.bind(this.clinic));
        const html = promisify(this.clinic.flame.html.bind(this.clinic.flame));
        
        try {
            const dataPath = await collect([process.execPath, scriptPath], options);
            const htmlPath = await html(dataPath, {
                outputDir: options.outputDir || './clinic-reports'
            });
            
            console.log(`火焰图报告生成在: ${htmlPath}`);
            return htmlPath;
        } catch (error) {
            console.error('火焰图分析失败:', error);
            throw error;
        }
    }
}

// 使用 0x 生成火焰图
class FlameGraphAnalyzer {
    async generateFlameGraph(scriptPath, options = {}) {
        return new Promise((resolve, reject) => {
            const args = [
                '--output-dir', options.outputDir || './flamegraphs',
                scriptPath
            ];
            
            if (options.duration) {
                args.unshift('--duration', options.duration.toString());
            }
            
            const child = spawn('0x', args, { stdio: 'inherit' });
            
            child.on('close', (code) => {
                if (code === 0) {
                    console.log('火焰图生成完成');
                    resolve();
                } else {
                    reject(new Error(`火焰图生成失败，退出码: ${code}`));
                }
            });
        });
    }
}

// 内存泄漏检测
class MemoryLeakDetector {
    constructor() {
        this.snapshots = [];
    }

    takeHeapSnapshot() {
        const snapshot = {
            timestamp: Date.now(),
            memory: process.memoryUsage(),
            heap: v8.getHeapStatistics()
        };
        
        this.snapshots.push(snapshot);
        return snapshot;
    }

    analyzeMemoryGrowth() {
        if (this.snapshots.length < 2) {
            return null;
        }
        
        const first = this.snapshots[0];
        const last = this.snapshots[this.snapshots.length - 1];
        
        const growth = {
            heapUsed: last.memory.heapUsed - first.memory.heapUsed,
            heapTotal: last.memory.heapTotal - first.memory.heapTotal,
            external: last.memory.external - first.memory.external,
            duration: last.timestamp - first.timestamp
        };
        
        return {
            growth,
            isLeaking: growth.heapUsed > 10 * 1024 * 1024, // 超过10MB增长
            snapshots: this.snapshots.length
        };
    }

    startMonitoring(interval = 5000) {
        setInterval(() => {
            const snapshot = this.takeHeapSnapshot();
            console.log('内存快照:', {
                heapUsed: `${Math.round(snapshot.memory.heapUsed / 1024 / 1024)} MB`,
                heapTotal: `${Math.round(snapshot.memory.heapTotal / 1024 / 1024)} MB`
            });
        }, interval);
    }
}

// 使用示例
const memoryDetector = new MemoryLeakDetector();
memoryDetector.startMonitoring(10000); // 每10秒记录一次

// 在应用中定期检查
setInterval(() => {
    const analysis = memoryDetector.analyzeMemoryGrowth();
    if (analysis && analysis.isLeaking) {
        console.warn('检测到可能的内存泄漏:', analysis.growth);
    }
}, 30000);
```