## 9.2 BOM 对象操作

### 1. window 对象功能

```javascript
// window 对象核心功能

// 窗口尺寸和位置
console.log('窗口尺寸:', {
    width: window.innerWidth,
    height: window.innerHeight,
    outerWidth: window.outerWidth,
    outerHeight: window.outerHeight
});

console.log('窗口位置:', {
    screenX: window.screenX,
    screenY: window.screenY,
    pageXOffset: window.pageXOffset,
    pageYOffset: window.pageYOffset
});

// 窗口操作
function windowOperations() {
    // 打开新窗口
    const newWindow = window.open(
        'https://example.com',
        'example',
        'width=800,height=600,scrollbars=yes'
    );
    
    // 调整窗口大小
    window.resizeTo(1024, 768);
    window.resizeBy(100, 50); // 相对调整
    
    // 移动窗口
    window.moveTo(100, 100);
    window.moveBy(50, 50); // 相对移动
    
    // 滚动窗口
    window.scrollTo(0, 100);
    window.scrollBy(0, 50);
    window.scroll({ top: 100, left: 0, behavior: 'smooth' });
}

// 窗口焦点和可见性
window.addEventListener('focus', () => {
    console.log('窗口获得焦点');
});

window.addEventListener('blur', () => {
    console.log('窗口失去焦点');
});

// Page Visibility API
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('页面隐藏');
    } else {
        console.log('页面可见');
    }
});

// 窗口关闭和刷新
function windowControl() {
    // 关闭窗口
    // window.close(); // 只能关闭通过 window.open 打开的窗口
    
    // 刷新页面
    // window.location.reload();
    
    // 前进后退
    window.history.back();
    window.history.forward();
    window.history.go(-2); // 后退两步
}

// 窗口对话框
function showDialogs() {
    // 警告对话框
    alert('这是一个警告');
    
    // 确认对话框
    const confirmed = confirm('确定要执行此操作吗？');
    if (confirmed) {
        console.log('用户确认');
    }
    
    // 输入对话框
    const userInput = prompt('请输入您的姓名：', '默认值');
    if (userInput !== null) {
        console.log('用户输入:', userInput);
    }
}

// 自定义对话框
class CustomDialog {
    constructor() {
        this.dialog = null;
    }
    
    show(message, options = {}) {
        return new Promise((resolve, reject) => {
            // 创建对话框元素
            this.dialog = document.createElement('div');
            this.dialog.className = 'custom-dialog';
            this.dialog.innerHTML = `
                <div class="dialog-overlay">
                    <div class="dialog-content">
                        <div class="dialog-message">${message}</div>
                        <div class="dialog-buttons">
                            <button class="btn-cancel">取消</button>
                            <button class="btn-confirm">确定</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加样式
            this.addStyles();
            
            // 添加到页面
            document.body.appendChild(this.dialog);
            
            // 绑定事件
            this.dialog.querySelector('.btn-confirm').addEventListener('click', () => {
                this.close();
                resolve(true);
            });
            
            this.dialog.querySelector('.btn-cancel').addEventListener('click', () => {
                this.close();
                resolve(false);
            });
            
            // ESC 键关闭
            const handleEsc = (event) => {
                if (event.key === 'Escape') {
                    this.close();
                    resolve(false);
                    document.removeEventListener('keydown', handleEsc);
                }
            };
            
            document.addEventListener('keydown', handleEsc);
        });
    }
    
    close() {
        if (this.dialog) {
            this.dialog.remove();
            this.dialog = null;
        }
    }
    
    addStyles() {
        if (!document.getElementById('custom-dialog-styles')) {
            const style = document.createElement('style');
            style.id = 'custom-dialog-styles';
            style.textContent = `
                .custom-dialog {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 10000;
                }
                .dialog-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                }
                .dialog-content {
                    background: white;
                    padding: 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    min-width: 300px;
                }
                .dialog-message {
                    margin-bottom: 20px;
                }
                .dialog-buttons {
                    display: flex;
                    justify-content: flex-end;
                    gap: 10px;
                }
                .dialog-buttons button {
                    padding: 8px 16px;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                }
                .btn-confirm {
                    background: #007bff;
                    color: white;
                }
                .btn-cancel {
                    background: #6c757d;
                    color: white;
                }
            `;
            document.head.appendChild(style);
        }
    }
}

// 使用自定义对话框
// const dialog = new CustomDialog();
// dialog.show('确定要删除这个项目吗？').then(result => {
//     if (result) {
//         console.log('用户确认删除');
//     } else {
//         console.log('用户取消删除');
//     }
// });

// 窗口存储
function windowStorage() {
    // localStorage - 持久存储
    localStorage.setItem('username', 'john');
    const username = localStorage.getItem('username');
    localStorage.removeItem('username');
    
    // sessionStorage - 会话存储
    sessionStorage.setItem('sessionData', 'temp');
    const sessionData = sessionStorage.getItem('sessionData');
    
    // 存储复杂对象
    const user = { name: 'John', age: 30 };
    localStorage.setItem('user', JSON.stringify(user));
    const storedUser = JSON.parse(localStorage.getItem('user') || '{}');
}

// 窗口通信
function windowCommunication() {
    // PostMessage API
    const newWindow = window.open('https://example.com', 'target');
    
    // 发送消息
    newWindow.postMessage({
        type: 'greeting',
        message: 'Hello from parent window'
    }, 'https://example.com');
    
    // 接收消息
    window.addEventListener('message', (event) => {
        // 安全检查
        if (event.origin !== 'https://example.com') {
            return;
        }
        
        console.log('收到消息:', event.data);
    });
}

// 窗口错误处理
window.addEventListener('error', (event) => {
    console.error('全局错误:', event.error);
    // 可以发送错误报告到服务器
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('未处理的 Promise 拒绝:', event.reason);
    event.preventDefault(); // 阻止默认的错误处理
});

// 窗口性能监控
class WindowPerformance {
    static getMetrics() {
        return {
            // 导航时间
            navigation: performance.getEntriesByType('navigation')[0],
            // 资源加载时间
            resources: performance.getEntriesByType('resource'),
            // 内存使用情况
            memory: performance.memory || {},
            // 用户计时
            measures: performance.getEntriesByType('measure')
        };
    }
    
    static mark(name) {
        performance.mark(name);
    }
    
    static measure(name, startMark, endMark) {
        performance.measure(name, startMark, endMark);
    }
    
    static getTiming() {
        return performance.timing;
    }
}

// 窗口实用工具类
class WindowUtils {
    // 获取视口尺寸
    static getViewportSize() {
        return {
            width: window.innerWidth || document.documentElement.clientWidth,
            height: window.innerHeight || document.documentElement.clientHeight
        };
    }
    
    // 检查是否为移动设备
    static isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    // 滚动到顶部
    static scrollToTop() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    }
    
    // 滚动到元素
    static scrollToElement(element, offset = 0) {
        const rect = element.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const targetPosition = rect.top + scrollTop - offset;
        
        window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
        });
    }
    
    // 防抖 resize 事件
    static onResize(callback, delay = 300) {
        let timeoutId;
        return window.addEventListener('resize', () => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(callback, delay);
        });
    }
    
    // 节流 scroll 事件
    static onScroll(callback, delay = 100) {
        let ticking = false;
        return window.addEventListener('scroll', () => {
            if (!ticking) {
                requestAnimationFrame(() => {
                    callback();
                    ticking = false;
                });
                ticking = true;
            }
        });
    }
    
    // 检测网络状态
    static isOnline() {
        return navigator.onLine;
    }
    
    // 监听网络状态变化
    static onNetworkChange(callback) {
        window.addEventListener('online', () => callback(true));
        window.addEventListener('offline', () => callback(false));
    }
}

// 使用示例
console.log('视口尺寸:', WindowUtils.getViewportSize());
console.log('是否为移动设备:', WindowUtils.isMobile());

WindowUtils.onResize(() => {
    console.log('窗口大小改变:', WindowUtils.getViewportSize());
});

WindowUtils.onScroll(() => {
    console.log('滚动位置:', window.scrollY);
});

WindowUtils.onNetworkChange((isOnline) => {
    console.log('网络状态:', isOnline ? '在线' : '离线');
});
```

### 2. location 和 history 对象

```javascript
// location 对象操作

// location 对象属性
console.log('Location 信息:', {
    href: location.href, // 完整 URL
    protocol: location.protocol, // 协议 (http:, https:)
    host: location.host, // 主机名和端口
    hostname: location.hostname, // 主机名
    port: location.port, // 端口
    pathname: location.pathname, // 路径
    search: location.search, // 查询字符串
    hash: location.hash, // 锚点
    origin: location.origin // 源 (协议 + 主机名 + 端口)
});

// URL 操作
function urlOperations() {
    // 修改 URL
    location.assign('https://example.com'); // 导航到新页面
    location.replace('https://example.com'); // 替换当前页面
    location.reload(); // 重新加载页面
    
    // 修改部分 URL
    location.hash = '#section1'; // 修改锚点
    location.search = '?param=value'; // 修改查询参数
}

// 查询参数处理
class URLParams {
    // 获取查询参数
    static get(name) {
        const urlParams = new URLSearchParams(location.search);
        return urlParams.get(name);
    }
    
    // 设置查询参数
    static set(name, value) {
        const urlParams = new URLSearchParams(location.search);
        urlParams.set(name, value);
        location.search = urlParams.toString();
    }
    
    // 删除查询参数
    static remove(name) {
        const urlParams = new URLSearchParams(location.search);
        urlParams.delete(name);
        location.search = urlParams.toString();
    }
    
    // 获取所有查询参数
    static getAll() {
        const urlParams = new URLSearchParams(location.search);
        const params = {};
        for (const [key, value] of urlParams.entries()) {
            params[key] = value;
        }
        return params;
    }
    
    // 构建带参数的 URL
    static build(baseUrl, params) {
        const url = new URL(baseUrl);
        Object.keys(params).forEach(key => {
            url.searchParams.set(key, params[key]);
        });
        return url.toString();
    }
}

// 使用示例
console.log('查询参数:', URLParams.getAll());
URLParams.set('page', '2');
URLParams.set('filter', 'active');

// URLSearchParams 实用方法
class URLSearchParamsUtils {
    // 解析查询字符串
    static parse(searchString) {
        const params = new URLSearchParams(searchString);
        const result = {};
        for (const [key, value] of params.entries()) {
            if (result[key]) {
                // 处理多个同名参数
                if (Array.isArray(result[key])) {
                    result[key].push(value);
                } else {
                    result[key] = [result[key], value];
                }
            } else {
                result[key] = value;
            }
        }
        return result;
    }
    
    // 序列化对象为查询字符串
    static stringify(obj) {
        const params = new URLSearchParams();
        Object.keys(obj).forEach(key => {
            const value = obj[key];
            if (Array.isArray(value)) {
                value.forEach(v => params.append(key, v));
            } else {
                params.set(key, value);
            }
        });
        return params.toString();
    }
    
    // 合并查询参数
    static merge(base, additional) {
        const params = new URLSearchParams(base);
        Object.keys(additional).forEach(key => {
            params.set(key, additional[key]);
        });
        return params.toString();
    }
}

// history 对象操作

// history 对象属性
console.log('History 信息:', {
    length: history.length, // 历史记录长度
    state: history.state // 当前状态
});

// history 导航操作
function historyNavigation() {
    history.back(); // 后退
    history.forward(); // 前进
    history.go(-2); // 后退两步
    history.go(1); // 前进一步
}

// HTML5 History API
class HistoryManager {
    // 推入新状态
    static pushState(state, title, url) {
        history.pushState(state, title, url);
    }
    
    // 替换当前状态
    static replaceState(state, title, url) {
        history.replaceState(state, title, url);
    }
    
    // 监听历史记录变化
    static onPopState(callback) {
        window.addEventListener('popstate', (event) => {
            callback(event.state, event);
        });
    }
    
    // 创建 SPA 路由
    static createRouter(routes) {
        const router = {
            routes,
            currentRoute: null,
            
            init() {
                this.handleCurrentRoute();
                this.setupPopStateListener();
            },
            
            handleCurrentRoute() {
                const path = location.pathname;
                const route = this.routes.find(r => r.path === path);
                
                if (route) {
                    this.currentRoute = route;
                    route.handler();
                } else {
                    // 处理 404
                    console.log('路由未找到:', path);
                }
            },
            
            navigate(path, state = {}) {
                const route = this.routes.find(r => r.path === path);
                if (route) {
                    history.pushState(state, route.title || '', path);
                    this.currentRoute = route;
                    route.handler(state);
                }
            },
            
            setupPopStateListener() {
                window.addEventListener('popstate', (event) => {
                    this.handleCurrentRoute();
                });
            }
        };
        
        return router;
    }
}

// 使用 History API 创建 SPA 路由
const router = HistoryManager.createRouter([
    {
        path: '/',
        title: '首页',
        handler: () => {
            console.log('显示首页');
            document.body.innerHTML = '<h1>首页</h1>';
        }
    },
    {
        path: '/about',
        title: '关于我们',
        handler: () => {
            console.log('显示关于我们');
            document.body.innerHTML = '<h1>关于我们</h1>';
        }
    },
    {
        path: '/contact',
        title: '联系我们',
        handler: () => {
            console.log('显示联系我们');
            document.body.innerHTML = '<h1>联系我们</h1>';
        }
    }
]);

// 初始化路由
// router.init();

// 导航到不同页面
// router.navigate('/about', { from: 'home' });

// SPA 路由管理器
class SPARouter {
    constructor() {
        this.routes = new Map();
        this.currentRoute = null;
        this.init();
    }
    
    // 添加路由
    addRoute(path, handler, title = '') {
        this.routes.set(path, { handler, title });
        return this;
    }
    
    // 初始化路由
    init() {
        this.handleRoute();
        window.addEventListener('popstate', () => {
            this.handleRoute();
        });
    }
    
    // 处理当前路由
    handleRoute() {
        const path = this.normalizePath(location.pathname);
        const route = this.routes.get(path);
        
        if (route) {
            this.currentRoute = path;
            document.title = route.title || document.title;
            route.handler();
        } else {
            this.handleNotFound();
        }
    }
    
    // 导航到指定路径
    navigate(path, state = {}, title = '') {
        const normalizedPath = this.normalizePath(path);
        
        if (this.routes.has(normalizedPath)) {
            history.pushState(state, title, normalizedPath);
            this.handleRoute();
        } else {
            console.warn('路由未找到:', normalizedPath);
        }
    }
    
    // 替换当前路由
    replace(path, state = {}, title = '') {
        const normalizedPath = this.normalizePath(path);
        history.replaceState(state, title, normalizedPath);
        this.handleRoute();
    }
    
    // 处理 404
    handleNotFound() {
        console.log('404 - 页面未找到');
        // 可以显示 404 页面
    }
    
    // 标准化路径
    normalizePath(path) {
        return path.replace(/\/+$/, '') || '/';
    }
    
    // 获取当前路由参数
    getParams() {
        return URLSearchParamsUtils.parse(location.search);
    }
    
    // 构建带参数的路由
    buildRoute(path, params = {}) {
        if (Object.keys(params).length === 0) {
            return path;
        }
        const queryString = URLSearchParamsUtils.stringify(params);
        return `${path}?${queryString}`;
    }
}

// 使用 SPA 路由
const spaRouter = new SPARouter();

spaRouter
    .addRoute('/', () => {
        console.log('首页');
    }, '首页')
    .addRoute('/users', () => {
        console.log('用户列表');
    }, '用户列表')
    .addRoute('/users/:id', (params) => {
        console.log('用户详情:', params.id);
    }, '用户详情');

// 页面切换函数
function goToPage(page, params = {}) {
    const route = spaRouter.buildRoute(page, params);
    spaRouter.navigate(route);
}

// URL 工具类
class URLUtils {
    // 解析完整 URL
    static parse(url) {
        const urlObj = new URL(url);
        return {
            protocol: urlObj.protocol,
            hostname: urlObj.hostname,
            port: urlObj.port,
            pathname: urlObj.pathname,
            search: urlObj.search,
            hash: urlObj.hash,
            origin: urlObj.origin,
            params: URLSearchParamsUtils.parse(urlObj.search)
        };
    }
    
    // 构建 URL
    static build(base, path = '', params = {}, hash = '') {
        const url = new URL(base);
        url.pathname = path;
        
        Object.keys(params).forEach(key => {
            url.searchParams.set(key, params[key]);
        });
        
        url.hash = hash;
        return url.toString();
    }
    
    // 检查 URL 是否有效
    static isValid(url) {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    }
    
    // 获取 URL 的文件扩展名
    static getExtension(url) {
        const path = new URL(url).pathname;
        const match = path.match(/\.([^.]+)$/);
        return match ? match[1] : '';
    }
    
    // 移除 URL 的查询参数
    static removeParams(url) {
        const urlObj = new URL(url);
        urlObj.search = '';
        return urlObj.toString();
    }
    
    // 移除 URL 的锚点
    static removeHash(url) {
        const urlObj = new URL(url);
        urlObj.hash = '';
        return urlObj.toString();
    }
}

// 使用 URL 工具
console.log('解析 URL:', URLUtils.parse('https://example.com/path?param=value#section'));
console.log('构建 URL:', URLUtils.build('https://example.com', '/api/users', { page: 1, limit: 10 }));
console.log('URL 有效性:', URLUtils.isValid('https://example.com'));
```

### 3. navigator 对象信息

```javascript
// navigator 对象 - 浏览器信息和功能检测

// 基本浏览器信息
console.log('浏览器信息:', {
    userAgent: navigator.userAgent,
    appName: navigator.appName,
    appVersion: navigator.appVersion,
    platform: navigator.platform,
    language: navigator.language,
    languages: navigator.languages,
    onLine: navigator.onLine,
    cookieEnabled: navigator.cookieEnabled
});

// 设备和屏幕信息
console.log('设备信息:', {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    hardwareConcurrency: navigator.hardwareConcurrency, // CPU 核心数
    deviceMemory: navigator.deviceMemory, // 设备内存 (GB)
    maxTouchPoints: navigator.maxTouchPoints // 触摸点数量
});

// 地理位置 API
class GeolocationAPI {
    // 获取当前位置
    static getCurrentPosition(options = {}) {
        return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
                reject(new Error('浏览器不支持地理位置'));
                return;
            }
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    resolve({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy,
                        heading: position.coords.heading,
                        speed: position.coords.speed,
                        timestamp: position.timestamp
                    });
                },
                (error) => {
                    reject(new Error(this.getErrorMessage(error)));
                },
                {
                    enableHighAccuracy: options.highAccuracy || false,
                    timeout: options.timeout || 10000,
                    maximumAge: options.maximumAge || 0
                }
            );
        });
    }
    
    // 监听位置变化
    static watchPosition(callback, options = {}) {
        if (!navigator.geolocation) {
            throw new Error('浏览器不支持地理位置');
        }
        
        return navigator.geolocation.watchPosition(
            (position) => {
                callback({
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    timestamp: position.timestamp
                });
            },
            (error) => {
                console.error('位置获取失败:', this.getErrorMessage(error));
            },
            {
                enableHighAccuracy: options.highAccuracy || false,
                timeout: options.timeout || 10000,
                maximumAge: options.maximumAge || 0
            }
        );
    }
    
    // 停止监听位置
    static clearWatch(watchId) {
        if (navigator.geolocation) {
            navigator.geolocation.clearWatch(watchId);
        }
    }
    
    // 获取错误信息
    static getErrorMessage(error) {
        const errorMessages = {
            1: '用户拒绝了位置请求',
            2: '位置信息不可用',
            3: '获取位置信息超时'
        };
        return errorMessages[error.code] || '未知错误';
    }
}

// 使用地理位置 API
// GeolocationAPI.getCurrentPosition({ highAccuracy: true, timeout: 5000 })
//     .then(position => {
//         console.log('当前位置:', position);
//     })
//     .catch(error => {
//         console.error('获取位置失败:', error.message);
//     });

// 媒体设备 API
class MediaDevicesAPI {
    // 获取媒体设备列表
    static async getDevices() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            throw new Error('浏览器不支持媒体设备枚举');
        }
        
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return {
                audioinput: devices.filter(device => device.kind === 'audioinput'),
                audiooutput: devices.filter(device => device.kind === 'audiooutput'),
                videoinput: devices.filter(device => device.kind === 'videoinput')
            };
        } catch (error) {
            throw new Error(`获取设备列表失败: ${error.message}`);
        }
    }
    
    // 获取用户媒体 (摄像头/麦克风)
    static async getUserMedia(constraints = { video: true, audio: true }) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('浏览器不支持 getUserMedia');
        }
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            return stream;
        } catch (error) {
            throw new Error(`获取媒体流失败: ${error.message}`);
        }
    }
    
    // 检查媒体设备支持
    static isSupported() {
        return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }
    
    // 获取显示媒体 (屏幕共享)
    static async getDisplayMedia(constraints = { video: true }) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            throw new Error('浏览器不支持屏幕共享');
        }
        
        try {
            const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
            return stream;
        } catch (error) {
            throw new Error(`获取显示媒体失败: ${error.message}`);
        }
    }
}

// 使用媒体设备 API
// MediaDevicesAPI.getDevices()
//     .then(devices => {
//         console.log('音频输入设备:', devices.audioinput);
//         console.log('视频输入设备:', devices.videoinput);
//     })
//     .catch(error => {
//         console.error('获取设备失败:', error.message);
//     });

// 网络信息 API
class NetworkInformation {
    // 获取网络连接信息
    static getConnectionInfo() {
        const connection = navigator.connection || 
                          navigator.mozConnection || 
                          navigator.webkitConnection;
        
        if (!connection) {
            return null;
        }
        
        return {
            effectiveType: connection.effectiveType, // 网络类型 (4g, 3g, 2g, slow-2g)
            downlink: connection.downlink, // 下行速度 (Mbps)
            downlinkMax: connection.downlinkMax, // 最大下行速度
            rtt: connection.rtt, // 往返时间 (ms)
            saveData: connection.saveData, // 是否启用数据保存模式
            type: connection.type // 连接类型
        };
    }
    
    // 监听网络变化
    static onConnectionChange(callback) {
        const connection = navigator.connection || 
                          navigator.mozConnection || 
                          navigator.webkitConnection;
        
        if (connection) {
            connection.addEventListener('change', () => {
                callback(this.getConnectionInfo());
            });
        }
    }
    
    // 检查是否为慢速网络
    static isSlowNetwork() {
        const info = this.getConnectionInfo();
        if (!info) return false;
        
        return info.effectiveType === 'slow-2g' || 
               info.effectiveType === '2g' ||
               (info.downlink && info.downlink < 0.5);
    }
}

// 使用网络信息 API
const networkInfo = NetworkInformation.getConnectionInfo();
console.log('网络信息:', networkInfo);

NetworkInformation.onConnectionChange((info) => {
    console.log('网络连接变化:', info);
});

// 剪贴板 API
class ClipboardAPI {
    // 读取文本
    static async readText() {
        if (!navigator.clipboard || !navigator.clipboard.readText) {
            throw new Error('浏览器不支持剪贴板读取');
        }
        
        try {
            const text = await navigator.clipboard.readText();
            return text;
        } catch (error) {
            throw new Error(`读取剪贴板失败: ${error.message}`);
        }
    }
    
    // 写入文本
    static async writeText(text) {
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
            throw new Error('浏览器不支持剪贴板写入');
        }
        
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (error) {
            throw new Error(`写入剪贴板失败: ${error.message}`);
        }
    }
    
    // 检查权限
    static async checkPermission() {
        if (!navigator.permissions) {
            return 'unknown';
        }
        
        try {
            const permission = await navigator.permissions.query({ name: 'clipboard-read' });
            return permission.state;
        } catch {
            return 'denied';
        }
    }
}

// 使用剪贴板 API
// ClipboardAPI.writeText('Hello, World!')
//     .then(() => {
//         console.log('文本已复制到剪贴板');
//     })
//     .catch(error => {
//         console.error('复制失败:', error.message);
//     });

// 通知 API
class NotificationAPI {
    // 请求通知权限
    static async requestPermission() {
        if (!('Notification' in window)) {
            throw new Error('浏览器不支持通知');
        }
        
        if (Notification.permission === 'granted') {
            return 'granted';
        }
        
        try {
            const permission = await Notification.requestPermission();
            return permission;
        } catch (error) {
            throw new Error(`请求通知权限失败: ${error.message}`);
        }
    }
    
    // 显示通知
    static showNotification(title, options = {}) {
        if (!('Notification' in window)) {
            throw new Error('浏览器不支持通知');
        }
        
        if (Notification.permission === 'granted') {
            return new Notification(title, options);
        } else {
            throw new Error('通知权限未授予');
        }
    }
    
    // 检查权限状态
    static getPermission() {
        if (!('Notification' in window)) {
            return 'unsupported';
        }
        return Notification.permission;
    }
}

// 使用通知 API
// NotificationAPI.requestPermission()
//     .then(permission => {
//         if (permission === 'granted') {
//             NotificationAPI.showNotification('Hello!', {
//                 body: '这是通知内容',
//                 icon: '/icon.png'
//             });
//         }
//     })
//     .catch(error => {
//         console.error('请求通知权限失败:', error.message);
//     });

// 电池状态 API (已废弃，但仍有浏览器支持)
class BatteryAPI {
    // 获取电池信息
    static async getBatteryInfo() {
        if (!navigator.getBattery) {
            throw new Error('浏览器不支持电池状态 API');
        }
        
        try {
            const battery = await navigator.getBattery();
            return {
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime,
                level: battery.level,
                addEventListener: (event, callback) => {
                    battery.addEventListener(event, callback);
                }
            };
        } catch (error) {
            throw new Error(`获取电池信息失败: ${error.message}`);
        }
    }
}

// 浏览器功能检测工具
class FeatureDetector {
    // 检测 Web Storage 支持
    static supportsWebStorage() {
        try {
            const test = '__storage_test__';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch {
            return false;
        }
    }
    
    // 检测 IndexedDB 支持
    static supportsIndexedDB() {
        return !!window.indexedDB;
    }
    
    // 检测 Service Worker 支持
    static supportsServiceWorker() {
        return 'serviceWorker' in navigator;
    }
    
    // 检测 WebGL 支持
    static supportsWebGL() {
        try {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext && canvas.getContext('webgl'));
        } catch {
            return false;
        }
    }
    
    // 检测 Web Workers 支持
    static supportsWebWorkers() {
        return !!window.Worker;
    }
    
    // 检测 Fetch API 支持
    static supportsFetch() {
        return !!window.fetch;
    }
    
    // 检测 Promise 支持
    static supportsPromise() {
        return !!window.Promise;
    }
    
    // 综合功能检测
    static getSupportedFeatures() {
        return {
            webStorage: this.supportsWebStorage(),
            indexedDB: this.supportsIndexedDB(),
            serviceWorker: this.supportsServiceWorker(),
            webGL: this.supportsWebGL(),
            webWorkers: this.supportsWebWorkers(),
            fetch: this.supportsFetch(),
            promise: this.supportsPromise(),
            geolocation: !!navigator.geolocation,
            mediaDevices: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
            notifications: 'Notification' in window,
            clipboard: !!(navigator.clipboard && navigator.clipboard.writeText),
            battery: !!navigator.getBattery,
            vibration: 'vibrate' in navigator,
            online: 'onLine' in navigator
        };
    }
}

// 使用功能检测
console.log('浏览器支持的功能:', FeatureDetector.getSupportedFeatures());

// 浏览器识别和兼容性处理
class BrowserDetector {
    constructor() {
        this.userAgent = navigator.userAgent;
    }
    
    // 检测浏览器类型
    getBrowser() {
        const browsers = [
            { name: 'Chrome', pattern: /Chrome\/(\d+)/ },
            { name: 'Firefox', pattern: /Firefox\/(\d+)/ },
            { name: 'Safari', pattern: /Safari\/(\d+)/ },
            { name: 'Edge', pattern: /Edge\/(\d+)/ },
            { name: 'IE', pattern: /MSIE (\d+)|Trident.*rv:(\d+)/ }
        ];
        
        for (const browser of browsers) {
            const match = this.userAgent.match(browser.pattern);
            if (match) {
                return {
                    name: browser.name,
                    version: parseInt(match[1] || match[2])
                };
            }
        }
        
        return { name: 'Unknown', version: 0 };
    }
    
    // 检测是否为移动浏览器
    isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(this.userAgent);
    }
    
    // 检测操作系统
    getOS() {
        const osPatterns = [
            { name: 'Windows', pattern: /Windows NT (\d+\.\d+)/ },
            { name: 'macOS', pattern: /Mac OS X (\d+[._]\d+)/ },
            { name: 'Linux', pattern: /Linux/ },
            { name: 'Android', pattern: /Android (\d+\.\d+)/ },
            { name: 'iOS', pattern: /OS (\d+)_(\d+)/ }
        ];
        
        for (const os of osPatterns) {
            const match = this.userAgent.match(os.pattern);
            if (match) {
                return {
                    name: os.name,
                    version: match[1] ? parseFloat(match[1].replace('_', '.')) : null
                };
            }
        }
        
        return { name: 'Unknown', version: null };
    }
    
    // 检测触摸支持
    supportsTouch() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }
    
    // 获取设备信息
    getDeviceInfo() {
        return {
            browser: this.getBrowser(),
            os: this.getOS(),
            isMobile: this.isMobile(),
            supportsTouch: this.supportsTouch(),
            userAgent: this.userAgent,
            language: navigator.language,
            languages: navigator.languages,
            cookiesEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine
        };
    }
}

// 使用浏览器检测
const detector = new BrowserDetector();
console.log('设备信息:', detector.getDeviceInfo());

// 根据浏览器特性提供降级方案
class CompatibilityManager {
    constructor() {
        this.features = FeatureDetector.getSupportedFeatures();
        this.browser = new BrowserDetector().getBrowser();
    }
    
    // 选择合适的存储方案
    getStorage() {
        if (this.features.webStorage) {
            return {
                set: (key, value) => localStorage.setItem(key, value),
                get: (key) => localStorage.getItem(key),
                remove: (key) => localStorage.removeItem(key)
            };
        } else {
            // 降级到 cookie
            return {
                set: (key, value) => this.setCookie(key, value),
                get: (key) => this.getCookie(key),
                remove: (key) => this.removeCookie(key)
            };
        }
    }
    
    // Cookie 操作方法
    setCookie(name, value, days = 7) {
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
    }
    
    getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }
    
    removeCookie(name) {
        this.setCookie(name, "", -1);
    }
    
    // 选择合适的请求方法
    getRequestMethod() {
        if (this.features.fetch) {
            return this.fetchRequest.bind(this);
        } else {
            return this.xhrRequest.bind(this);
        }
    }
    
    async fetchRequest(url, options = {}) {
        const response = await fetch(url, options);
        return response.json();
    }
    
    xhrRequest(url, options = {}) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open(options.method || 'GET', url);
            
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(JSON.parse(xhr.responseText));
                } else {
                    reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
                }
            };
            
            xhr.onerror = () => reject(new Error('网络错误'));
            xhr.send(options.body);
        });
    }
}

// 使用兼容性管理器
const compatManager = new CompatibilityManager();
const storage = compatManager.getStorage();
const request = compatManager.getRequestMethod();

// 存储数据
storage.set('user', 'John Doe');

// 发起请求
// request('/api/data')
//     .then(data => console.log(data))
//     .catch(error => console.error(error));
```

### 4. 定时器和动画控制

```javascript
// 定时器和动画控制

// 基本定时器
// setTimeout - 延迟执行
const timeoutId = setTimeout(() => {
    console.log('延迟执行的代码');
}, 1000);

// setInterval - 重复执行
const intervalId = setInterval(() => {
    console.log('重复执行的代码');
}, 2000);

// 清除定时器
clearTimeout(timeoutId);
clearInterval(intervalId);

// 定时器管理类
class TimerManager {
    constructor() {
        this.timeouts = new Map();
        this.intervals = new Map();
        this.counter = 0;
    }
    
    // 设置带标签的 timeout
    setTimeout(label, callback, delay, ...args) {
        const id = ++this.counter;
        const timeoutId = setTimeout(() => {
            callback(...args);
            this.timeouts.delete(label);
        }, delay);
        
        this.timeouts.set(label, { id: timeoutId, label });
        return id;
    }
    
    // 设置带标签的 interval
    setInterval(label, callback, delay, ...args) {
        const id = ++this.counter;
        const intervalId = setInterval(() => {
            callback(...args);
        }, delay);
        
        this.intervals.set(label, { id: intervalId, label });
        return id;
    }
    
    // 清除特定标签的定时器
    clearTimeout(label) {
        const timer = this.timeouts.get(label);
        if (timer) {
            clearTimeout(timer.id);
            this.timeouts.delete(label);
        }
    }
    
    // 清除特定标签的间隔
    clearInterval(label) {
        const timer = this.intervals.get(label);
        if (timer) {
            clearInterval(timer.id);
            this.intervals.delete(label);
        }
    }
    
    // 清除所有定时器
    clearAll() {
        this.timeouts.forEach(timer => clearTimeout(timer.id));
        this.intervals.forEach(timer => clearInterval(timer.id));
        this.timeouts.clear();
        this.intervals.clear();
    }
    
    // 获取定时器数量
    getCount() {
        return {
            timeouts: this.timeouts.size,
            intervals: this.intervals.size
        };
    }
}

// 使用定时器管理器
const timerManager = new TimerManager();

timerManager.setTimeout('userNotification', () => {
    console.log('用户通知');
}, 3000);

timerManager.setInterval('heartbeat', () => {
    console.log('心跳检测');
}, 5000);

// requestAnimationFrame - 动画帧
class AnimationFrameManager {
    constructor() {
        this.animations = new Map();
        this.frameId = null;
        this.running = false;
    }
    
    // 添加动画
    addAnimation(id, callback) {
        this.animations.set(id, callback);
        if (!this.running) {
            this.start();
        }
    }
    
    // 移除动画
    removeAnimation(id) {
        this.animations.delete(id);
        if (this.animations.size === 0) {
            this.stop();
        }
    }
    
    // 开始动画循环
    start() {
        if (this.running) return;
        
        this.running = true;
        const animate = (timestamp) => {
            if (this.animations.size > 0) {
                this.animations.forEach(callback => {
                    callback(timestamp);
                });
                this.frameId = requestAnimationFrame(animate);
            } else {
                this.running = false;
            }
        };
        
        this.frameId = requestAnimationFrame(animate);
    }
    
    // 停止动画循环
    stop() {
        if (this.frameId) {
            cancelAnimationFrame(this.frameId);
            this.frameId = null;
        }
        this.running = false;
    }
    
    // 清除所有动画
    clear() {
        this.animations.clear();
        this.stop();
    }
}

// 使用动画帧管理器
const animationManager = new AnimationFrameManager();

// 创建平滑动画
class SmoothAnimation {
    constructor(element, duration = 1000) {
        this.element = element;
        this.duration = duration;
        this.startTime = null;
        this.startValue = 0;
        this.endValue = 100;
    }
    
    animate() {
        const animate = (timestamp) => {
            if (!this.startTime) this.startTime = timestamp;
            
            const elapsed = timestamp - this.startTime;
            const progress = Math.min(elapsed / this.duration, 1);
            
            // 缓动函数
            const easeProgress = this.easeOutCubic(progress);
            const currentValue = this.startValue + (this.endValue - this.startValue) * easeProgress;
            
            this.element.style.transform = `translateX(${currentValue}px)`;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    // 缓动函数
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
}

// 高级动画控制类
class AdvancedAnimator {
    constructor() {
        this.animations = new Map();
        this.globalId = 0;
    }
    
    // 创建补间动画
    tween(element, properties, duration, options = {}) {
        const id = ++this.globalId;
        const startTime = performance.now();
        const startValues = {};
        const endValues = properties;
        
        // 获取起始值
        Object.keys(properties).forEach(prop => {
            if (prop === 'x' || prop === 'y' || prop === 'translateX' || prop === 'translateY') {
                const transform = getComputedStyle(element).transform;
                // 简化的变换值获取
                startValues[prop] = 0;
            } else if (prop === 'opacity') {
                startValues[prop] = parseFloat(getComputedStyle(element).opacity) || 1;
            } else {
                startValues[prop] = parseFloat(getComputedStyle(element)[prop]) || 0;
            }
        });
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 应用缓动函数
            const easedProgress = this.applyEasing(progress, options.easing || 'linear');
            
            // 更新属性
            Object.keys(properties).forEach(prop => {
                const startValue = startValues[prop];
                const endValue = endValues[prop];
                const currentValue = startValue + (endValue - startValue) * easedProgress;
                
                if (prop === 'x' || prop === 'translateX') {
                    this.updateTransform(element, 'translateX', currentValue);
                } else if (prop === 'y' || prop === 'translateY') {
                    this.updateTransform(element, 'translateY', currentValue);
                } else if (prop === 'scale') {
                    this.updateTransform(element, 'scale', currentValue);
                } else {
                    element.style[prop] = this.formatValue(prop, currentValue);
                }
            });
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // 动画完成回调
                if (options.onComplete) {
                    options.onComplete();
                }
            }
        };
        
        requestAnimationFrame(animate);
        return id;
    }
    
    // 更新变换属性
    updateTransform(element, property, value) {
        const currentTransform = element.style.transform || '';
        const regex = new RegExp(`${property}\\([^)]*\\)`, 'g');
        const newValue = `${property}(${this.formatValue(property, value)})`;
        
        if (regex.test(currentTransform)) {
            element.style.transform = currentTransform.replace(regex, newValue);
        } else {
            element.style.transform = `${currentTransform} ${newValue}`.trim();
        }
    }
    
    // 格式化值
    formatValue(property, value) {
        if (property.includes('translate') || property === 'x' || property === 'y') {
            return `${value}px`;
        } else if (property === 'scale' || property === 'opacity') {
            return value;
        } else {
            return `${value}px`;
        }
    }
    
    // 应用缓动函数
    applyEasing(progress, easing) {
        const easingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
        };
        
        return easingFunctions[easing] ? easingFunctions[easing](progress) : progress;
    }
    
    // 串行动画
    sequence(animations) {
        let index = 0;
        
        const runNext = () => {
            if (index < animations.length) {
                const animation = animations[index];
                const options = {
                    ...animation.options,
                    onComplete: () => {
                        if (animation.options && animation.options.onComplete) {
                            animation.options.onComplete();
                        }
                        index++;
                        runNext();
                    }
                };
                
                this.tween(animation.element, animation.properties, animation.duration, options);
            }
        };
        
        runNext();
    }
    
    // 并行动画
    parallel(animations) {
        animations.forEach(animation => {
            this.tween(animation.element, animation.properties, animation.duration, animation.options);
        });
    }
}

// 使用高级动画器
const animator = new AdvancedAnimator();

// 创建动画元素
const animatedElement = document.createElement('div');
animatedElement.style.width = '50px';
animatedElement.style.height = '50px';
animatedElement.style.backgroundColor = 'red';
animatedElement.style.position = 'absolute';
animatedElement.style.left = '0px';
animatedElement.style.top = '0px';

document.body.appendChild(animatedElement);

// 执行补间动画
// animator.tween(animatedElement, {
//     x: 200,
//     y: 100,
//     scale: 1.5,
//     opacity: 0.5
// }, 2000, {
//     easing: 'easeOutCubic',
//     onComplete: () => console.log('动画完成')
// });

// 定时器工具类
class TimerUtils {
    // 防抖函数
    static debounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }
    
    // 节流函数
    static throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    // 精确定时器
    static preciseInterval(callback, interval) {
        let startTime = performance.now();
        let expectedTime = startTime + interval;
        
        const tick = () => {
            const currentTime = performance.now();
            const drift = currentTime - expectedTime;
            
            callback();
            
            expectedTime += interval;
            const nextDelay = Math.max(0, interval - drift);
            
            setTimeout(tick, nextDelay);
        };
        
        setTimeout(tick, interval);
    }
    
    // 延迟执行直到条件满足
    static waitUntil(condition, callback, interval = 100, timeout = 5000) {
        const startTime = Date.now();
        
        const check = () => {
            if (condition()) {
                callback();
            } else if (Date.now() - startTime < timeout) {
                setTimeout(check, interval);
            } else {
                console.warn('等待超时');
            }
        };
        
        check();
    }
    
    // 批量延迟执行
    static batchDelay(tasks, delayBetween = 100) {
        let index = 0;
        
        const executeNext = () => {
            if (index < tasks.length) {
                tasks[index]();
                index++;
                setTimeout(executeNext, delayBetween);
            }
        };
        
        executeNext();
    }
}

// 使用定时器工具
const debouncedSearch = TimerUtils.debounce((query) => {
    console.log('执行搜索:', query);
}, 300);

const throttledScroll = TimerUtils.throttle(() => {
    console.log('处理滚动事件');
}, 100);

// 动画性能优化
class OptimizedAnimation {
    constructor() {
        this.animations = new Map();
        this.rafId = null;
        this.isRunning = false;
    }
    
    // 添加高性能动画
    addAnimation(id, element, updateFunction) {
        this.animations.set(id, {
            element,
            update: updateFunction,
            lastUpdate: 0
        });
        
        if (!this.isRunning) {
            this.start();
        }
    }
    
    // 启动动画循环
    start() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        
        const animate = (timestamp) => {
            if (this.animations.size > 0) {
                this.animations.forEach((animation, id) => {
                    // 可以添加帧率控制
                    animation.update(timestamp);
                    animation.lastUpdate = timestamp;
                });
                
                this.rafId = requestAnimationFrame(animate);
            } else {
                this.isRunning = false;
            }
        };
        
        this.rafId = requestAnimationFrame(animate);
    }
    
    // 移除动画
    removeAnimation(id) {
        this.animations.delete(id);
        if (this.animations.size === 0) {
            this.stop();
        }
    }
    
    // 停止所有动画
    stop() {
        if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
        }
        this.isRunning = false;
    }
    
    // 动画暂停和恢复
    pause() {
        this.stop();
    }
    
    resume() {
        if (this.animations.size > 0) {
            this.start();
        }
    }
}

// 实际应用：进度条动画
class ProgressBar {
    constructor(element, options = {}) {
        this.element = element;
        this.options = {
            duration: options.duration || 1000,
            easing: options.easing || 'easeOutCubic',
            ...options
        };
        this.currentProgress = 0;
    }
    
    setProgress(progress, animate = true) {
        const targetProgress = Math.max(0, Math.min(100, progress));
        
        if (!animate) {
            this.updateProgress(targetProgress);
            return;
        }
        
        const startTime = performance.now();
        const startProgress = this.currentProgress;
        const duration = this.options.duration;
        
        const animateProgress = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progressRatio = Math.min(elapsed / duration, 1);
            
            // 应用缓动
            const easedProgress = this.applyEasing(progressRatio, this.options.easing);
            const currentProgress = startProgress + (targetProgress - startProgress) * easedProgress;
            
            this.updateProgress(currentProgress);
            
            if (progressRatio < 1) {
                requestAnimationFrame(animateProgress);
            }
        };
        
        requestAnimationFrame(animateProgress);
    }
    
    updateProgress(progress) {
        this.currentProgress = progress;
        this.element.style.width = `${progress}%`;
        
        // 可选：更新文本
        const textElement = this.element.querySelector('.progress-text');
        if (textElement) {
            textElement.textContent = `${Math.round(progress)}%`;
        }
    }
    
    applyEasing(t, easing) {
        const functions = {
            linear: t => t,
            easeOutCubic: t => 1 - Math.pow(1 - t, 3),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
        };
        
        return functions[easing] ? functions[easing](t) : t;
    }
    
    // 重置进度条
    reset() {
        this.setProgress(0, false);
    }
    
    // 完成进度条
    complete(callback) {
        this.setProgress(100, true);
        if (callback) {
            setTimeout(callback, this.options.duration);
        }
    }
}

// 创建进度条元素
function createProgressBar() {
    const container = document.createElement('div');
    container.className = 'progress-container';
    container.style.width = '100%';
    container.style.height = '20px';
    container.style.backgroundColor = '#f0f0f0';
    container.style.borderRadius = '10px';
    container.style.overflow = 'hidden';
    
    const bar = document.createElement('div');
    bar.className = 'progress-bar';
    bar.style.height = '100%';
    bar.style.width = '0%';
    bar.style.backgroundColor = '#007bff';
    bar.style.transition = 'width 0.3s ease';
    bar.style.borderRadius = '10px';
    
    container.appendChild(bar);
    return container;
}

// 使用进度条
// const progressBarElement = createProgressBar();
// document.body.appendChild(progressBarElement);
// const progressBar = new ProgressBar(progressBarElement.querySelector('.progress-bar'));
// progressBar.setProgress(50);

// 动画性能监控
class AnimationPerformance {
    constructor() {
        this.metrics = [];
        this.frameCount = 0;
        this.lastTime = performance.now();
    }
    
    // 监控帧率
    monitorFPS(callback) {
        const measureFPS = (timestamp) => {
            this.frameCount++;
            
            if (timestamp >= this.lastTime + 1000) {
                const fps = Math.round((this.frameCount * 1000) / (timestamp - this.lastTime));
                this.metrics.push({ timestamp, fps });
                
                if (callback) callback(fps);
                
                this.frameCount = 0;
                this.lastTime = timestamp;
            }
            
            requestAnimationFrame(measureFPS);
        };
        
        requestAnimationFrame(measureFPS);
    }
    
    // 获取性能报告
    getReport() {
        if (this.metrics.length === 0) return null;
        
        const fpsValues = this.metrics.map(m => m.fps);
        const averageFPS = fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length;
        const minFPS = Math.min(...fpsValues);
        const maxFPS = Math.max(...fpsValues);
        
        return {
            average: Math.round(averageFPS),
            min: minFPS,
            max: maxFPS,
            samples: this.metrics.length
        };
    }
    
    // 检查性能问题
    checkPerformance() {
        const report = this.getReport();
        if (!report) return null;
        
        const issues = [];
        
        if (report.average < 30) {
            issues.push('平均帧率过低');
        }
        
        if (report.min < 15) {
            issues.push('最低帧率过低');
        }
        
        return issues.length > 0 ? issues : null;
    }
}

// 使用性能监控
const perfMonitor = new AnimationPerformance();
// perfMonitor.monitorFPS((fps) => {
//     console.log(`当前 FPS: ${fps}`);
// });
```