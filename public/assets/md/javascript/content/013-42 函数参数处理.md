## 4.2 函数参数处理

### 参数传递机制

#### 值传递 vs 引用传递

```javascript
// 基本类型 - 值传递
function modifyPrimitive(value) {
    value = value * 2;
    console.log('Inside function:', value); // 20
}

let num = 10;
modifyPrimitive(num);
console.log('Outside function:', num); // 10 (未改变)

// 对象类型 - 引用传递（传递引用的副本）
function modifyObject(obj) {
    obj.name = 'Modified';
    obj.newProperty = 'Added';
    console.log('Inside function:', obj); // { name: 'Modified', age: 25, newProperty: 'Added' }
}

let person = { name: 'Alice', age: 25 };
modifyObject(person);
console.log('Outside function:', person); // { name: 'Modified', age: 25, newProperty: 'Added' }

// 重新赋值对象引用不会影响原对象
function reassignObject(obj) {
    obj = { completely: 'new object' };
    console.log('Inside function:', obj); // { completely: 'new object' }
}

let originalObj = { name: 'Original' };
reassignObject(originalObj);
console.log('Outside function:', originalObj); // { name: 'Original' }
```

#### 深拷贝 vs 浅拷贝

```javascript
// 浅拷贝示例
function shallowModify(obj) {
    obj.name = 'Modified';
    obj.address.city = 'Modified City'; // 嵌套对象会被修改
}

const user = {
    name: 'Alice',
    address: {
        city: 'New York',
        country: 'USA'
    }
};

shallowModify(user);
console.log(user); // { name: 'Modified', address: { city: 'Modified City', country: 'USA' } }

// 深拷贝示例
function deepModify(originalObj) {
    // 简单深拷贝（实际项目中建议使用lodash.cloneDeep等库）
    const obj = JSON.parse(JSON.stringify(originalObj));
    obj.name = 'Modified';
    obj.address.city = 'Modified City';
    return obj;
}

const user2 = {
    name: 'Bob',
    address: {
        city: 'London',
        country: 'UK'
    }
};

const modifiedUser = deepModify(user2);
console.log(user2); // 原对象未改变
console.log(modifiedUser); // 修改后的对象
```

### 默认参数设置

#### ES6默认参数

```javascript
// 基本默认参数
function greet(name = 'Guest', greeting = 'Hello') {
    return `${greeting}, ${name}!`;
}

console.log(greet()); // Hello, Guest!
console.log(greet('Alice')); // Hello, Alice!
console.log(greet('Bob', 'Hi')); // Hi, Bob!

// 复杂默认值
function createUser(name, options = {}) {
    const defaults = {
        age: 18,
        active: true,
        role: 'user'
    };
    
    const config = { ...defaults, ...options };
    
    return {
        name,
        ...config
    };
}

console.log(createUser('Alice'));
// { name: 'Alice', age: 18, active: true, role: 'user' }

console.log(createUser('Bob', { age: 25, role: 'admin' }));
// { name: 'Bob', age: 25, active: true, role: 'admin' }
```

#### 默认参数表达式

```javascript
// 默认参数可以是表达式
function generateId(prefix = 'user_' + Date.now()) {
    return prefix + Math.random().toString(36).substr(2, 9);
}

console.log(generateId()); // user_1640995200000 + random
console.log(generateId('admin_')); // admin_ + random

// 默认参数可以引用前面的参数
function calculateTax(amount, taxRate = amount * 0.1) {
    return amount + taxRate;
}

console.log(calculateTax(100)); // 110 (默认税率10%)
console.log(calculateTax(100, 15)); // 115 (指定税率15)
```

#### 与arguments对象的关系

```javascript
// ES6默认参数不会影响arguments对象
function testDefaults(a = 1, b = 2) {
    console.log('Parameters:', a, b);
    console.log('Arguments length:', arguments.length);
    console.log('Arguments:', arguments);
}

testDefaults(); // Parameters: 1 2, Arguments length: 0, Arguments: []
testDefaults(5); // Parameters: 5 2, Arguments length: 1, Arguments: [5]
```

### 剩余参数和扩展运算符

#### 剩余参数（Rest Parameters）

```javascript
// 基本语法
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
console.log(sum()); // 0

// 与其他参数结合使用
function introduce(greeting, ...names) {
    return `${greeting} ${names.join(', ')}!`;
}

console.log(introduce('Hello', 'Alice', 'Bob', 'Charlie'));
// Hello Alice, Bob, Charlie!

// 剩余参数必须是最后一个参数
// function invalid(a, ...rest, b) {} // SyntaxError

// 剩余参数与数组方法结合
function findMax(...numbers) {
    return Math.max(...numbers);
}

console.log(findMax(1, 5, 3, 9, 2)); // 9
```

#### 扩展运算符（Spread Operator）

```javascript
// 数组扩展
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2, 7, 8];
console.log(combined); // [1, 2, 3, 4, 5, 6, 7, 8]

// 数组复制
const original = [1, 2, 3];
const copy = [...original];
copy.push(4);
console.log(original); // [1, 2, 3] (未改变)
console.log(copy); // [1, 2, 3, 4]

// 字符串扩展
const str = 'hello';
const chars = [...str];
console.log(chars); // ['h', 'e', 'l', 'l', 'o']

// 对象扩展
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2, e: 5 };
console.log(merged); // { a: 1, b: 2, c: 3, d: 4, e: 5 }

// 对象复制和更新
const user = { name: 'Alice', age: 25 };
const updatedUser = { ...user, age: 26, city: 'New York' };
console.log(updatedUser); // { name: 'Alice', age: 26, city: 'New York' }
```

#### 实际应用场景

```javascript
// 函数重载模拟
function formatMessage(template, ...values) {
    return template.replace(/{(\d+)}/g, (match, index) => {
        return values[index] !== undefined ? values[index] : match;
    });
}

console.log(formatMessage('Hello {0}, you have {1} messages', 'Alice', 5));
// Hello Alice, you have 5 messages

// 数组去重
function uniqueArray(...items) {
    return [...new Set(items)];
}

console.log(uniqueArray(1, 2, 2, 3, 3, 4)); // [1, 2, 3, 4]

// 数学运算
function calculate(operation, ...numbers) {
    switch (operation) {
        case 'sum':
            return numbers.reduce((a, b) => a + b, 0);
        case 'product':
            return numbers.reduce((a, b) => a * b, 1);
        case 'max':
            return Math.max(...numbers);
        case 'min':
            return Math.min(...numbers);
        default:
            throw new Error('Unknown operation');
    }
}

console.log(calculate('sum', 1, 2, 3, 4)); // 10
console.log(calculate('max', 5, 2, 8, 1)); // 8
```

### arguments 对象的使用

#### arguments对象特性

```javascript
// arguments对象是类数组对象
function showArguments() {
    console.log('Arguments object:', arguments);
    console.log('Length:', arguments.length);
    console.log('First argument:', arguments[0]);
    
    // 转换为真正的数组
    const argsArray = Array.from(arguments);
    // 或者使用扩展运算符
    const argsArray2 = [...arguments];
    // 或者使用slice
    const argsArray3 = Array.prototype.slice.call(arguments);
    
    return argsArray;
}

showArguments('a', 'b', 'c');
// Arguments object: Arguments(3) ['a', 'b', 'c']
// Length: 3
// First argument: a
```

#### 与剩余参数的区别

```javascript
// arguments对象（ES5方式）
function oldStyle() {
    console.log('Arguments length:', arguments.length);
    for (let i = 0; i < arguments.length; i++) {
        console.log(`Argument ${i}:`, arguments[i]);
    }
}

// 剩余参数（ES6方式）
function newStyle(...args) {
    console.log('Args length:', args.length);
    args.forEach((arg, index) => {
        console.log(`Arg ${index}:`, arg);
    });
}

oldStyle(1, 2, 3);
newStyle(1, 2, 3);
```

#### 实际应用

```javascript
// 函数代理
function createProxy(targetFunction) {
    return function() {
        console.log('Before calling target function');
        const result = targetFunction.apply(this, arguments);
        console.log('After calling target function');
        return result;
    };
}

function originalFunction(a, b) {
    return a + b;
}

const proxiedFunction = createProxy(originalFunction);
console.log(proxiedFunction(3, 4)); // 7

// 参数验证
function validateArguments(...validators) {
    return function(targetFunction) {
        return function() {
            for (let i = 0; i < validators.length; i++) {
                if (i < arguments.length && !validators[i](arguments[i])) {
                    throw new Error(`Argument ${i} failed validation`);
                }
            }
            return targetFunction.apply(this, arguments);
        };
    };
}

const numberValidator = value => typeof value === 'number';
const stringValidator = value => typeof value === 'string';

const validatedFunction = validateArguments(numberValidator, stringValidator)(
    function processData(num, str) {
        return `${str}: ${num}`;
    }
);

console.log(validatedFunction(42, 'Answer')); // Answer: 42
// validatedFunction('not a number', 'test'); // Error: Argument 0 failed validation
```