## 19.1 应用部署

### 服务器环境配置

**Ubuntu 服务器基础配置：**
```bash
# 系统更新和安全配置
sudo apt update && sudo apt upgrade -y

# 安装基础工具
sudo apt install -y curl wget git vim htop tree unzip

# 配置防火墙
sudo ufw enable
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw status verbose

# 创建专用用户
sudo adduser appuser
sudo usermod -aG sudo appuser
sudo su - appuser

# SSH 安全配置
sudo nano /etc/ssh/sshd_config
# 修改配置：
# Port 2222                    # 修改SSH端口
# PermitRootLogin no           # 禁止root登录
# PasswordAuthentication no    # 禁用密码认证
# PubkeyAuthentication yes     # 启用密钥认证

sudo systemctl restart ssh

# 安装 Node.js (使用 NodeSource)
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# 安装 PM2
sudo npm install -g pm2

# 安装 Nginx
sudo apt install -y nginx

# 配置 Nginx 防火墙
sudo ufw allow 'Nginx Full'

# 安装数据库 (以 PostgreSQL 为例)
sudo apt install -y postgresql postgresql-contrib
sudo systemctl start postgresql
sudo systemctl enable postgresql

# 创建数据库用户和数据库
sudo -u postgres createuser --interactive
sudo -u postgres createdb myapp_production
```

**环境变量配置：**
```bash
# ~/.bashrc 或 ~/.profile
export NODE_ENV=production
export PORT=3000
export DATABASE_URL=postgresql://username:password@localhost:5432/myapp_production
export REDIS_URL=redis://localhost:6379
export JWT_SECRET=your-super-secret-jwt-key
export API_KEY=your-api-key

# 应用特定的环境变量文件
# .env.production
NODE_ENV=production
PORT=3000
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp_production
DB_USER=appuser
DB_PASS=secure_password
REDIS_URL=redis://localhost:6379
JWT_SECRET=super_secret_key_here
LOG_LEVEL=info
API_RATE_LIMIT=100
```

**系统服务配置：**
```bash
# 创建 systemd 服务文件
sudo nano /etc/systemd/system/myapp.service

[Unit]
Description=My Node.js Application
After=network.target

[Service]
Type=simple
User=appuser
WorkingDirectory=/home/appuser/myapp
ExecStart=/usr/bin/node server.js
Restart=always
RestartSec=10
Environment=NODE_ENV=production
Environment=PORT=3000
EnvironmentFile=/home/appuser/myapp/.env.production

# 安全配置
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=true

[Install]
WantedBy=multi-user.target

# 启用服务
sudo systemctl daemon-reload
sudo systemctl enable myapp
sudo systemctl start myapp
sudo systemctl status myapp

# 查看日志
sudo journalctl -u myapp -f
```

### 进程管理工具 PM2

**PM2 基础配置：**
```javascript
// ecosystem.config.js
module.exports = {
    apps: [
        {
            name: 'myapp-api',
            script: './dist/server.js',
            instances: 'max', // 根据CPU核心数自动调整
            exec_mode: 'cluster',
            env: {
                NODE_ENV: 'development',
                PORT: 3000
            },
            env_production: {
                NODE_ENV: 'production',
                PORT: 3000,
                LOG_LEVEL: 'error'
            },
            // 日志配置
            error_file: './logs/err.log',
            out_file: './logs/out.log',
            log_file: './logs/combined.log',
            log_date_format: 'YYYY-MM-DD HH:mm:ss',
            
            // 重启策略
            max_memory_restart: '1G',
            restart_delay: 1000,
            max_restarts: 10,
            min_uptime: '5m',
            
            // 监控配置
            watch: false, // 生产环境不开启
            ignore_watch: ['node_modules', 'logs'],
            
            // 负载均衡
            node_args: '--max-old-space-size=4096',
            
            // 健康检查
            listen_timeout: 3000,
            kill_timeout: 1600
        },
        {
            name: 'myapp-worker',
            script: './dist/worker.js',
            instances: 1,
            exec_mode: 'fork',
            env_production: {
                NODE_ENV: 'production'
            }
        }
    ],
    
    // 部署配置
    deploy: {
        production: {
            user: 'appuser',
            host: ['192.168.1.100'],
            ref: 'origin/main',
            repo: 'git@github.com:user/myapp.git',
            path: '/home/appuser/myapp',
            'pre-deploy-local': '',
            'post-deploy': 'npm install && npm run build && pm2 reload ecosystem.config.js --env production',
            'pre-setup': ''
        }
    }
};
```

**PM2 高级配置和监控：**
```bash
# 启动应用
pm2 start ecosystem.config.js --env production

# 启动并保存配置
pm2 start ecosystem.config.js --env production
pm2 save

# 设置开机自启
pm2 startup

# 监控命令
pm2 list                    # 查看所有应用
pm2 monit                   # 实时监控
pm2 show myapp-api          # 查看应用详情
pm2 logs myapp-api          # 查看日志
pm2 logs myapp-api --lines 100  # 查看最后100行日志
pm2 logs myapp-api --nostream   # 查看日志但不持续监听

# 应用管理
pm2 restart myapp-api       # 重启应用
pm2 reload myapp-api        # 优雅重载
pm2 stop myapp-api          # 停止应用
pm2 delete myapp-api        # 删除应用

# 集群管理
pm2 scale myapp-api +3      # 增加3个实例
pm2 scale myapp-api 5       # 设置为5个实例

# 性能监控
pm2 monit                   # 交互式监控界面
pm2 web                     # 启动Web监控界面 (端口9615)
```

**PM2 日志管理：**
```javascript
// logrotate 配置
// /etc/logrotate.d/pm2-myapp
"/home/appuser/.pm2/logs/*.log" {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
    create 0644 appuser appuser
}

// 自定义日志格式化
const winston = require('winston');
const { format, transports } = winston;
const { combine, timestamp, printf, colorize } = format;

const logFormat = printf(({ level, message, timestamp, ...metadata }) => {
    let msg = `${timestamp} [${level}] : ${message} `;
    if (metadata && Object.keys(metadata).length > 0) {
        msg += JSON.stringify(metadata);
    }
    return msg;
});

const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: combine(
        timestamp(),
        logFormat
    ),
    transports: [
        new transports.File({ 
            filename: 'logs/error.log', 
            level: 'error',
            maxsize: 5242880, // 5MB
            maxFiles: 5
        }),
        new transports.File({ 
            filename: 'logs/combined.log',
            maxsize: 5242880,
            maxFiles: 5
        }),
        new transports.Console({
            format: combine(
                colorize(),
                timestamp(),
                logFormat
            )
        })
    ]
});

// 在应用中使用
logger.info('应用启动', { port: 3000 });
logger.error('数据库连接失败', { error: 'Connection timeout' });
```

### Docker 容器化部署

**Dockerfile 配置：**
```dockerfile
# 多阶段构建
# 构建阶段
FROM node:18-alpine AS builder

WORKDIR /app

# 复制 package 文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production && npm cache clean --force

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 生产阶段
FROM node:18-alpine AS production

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

WORKDIR /app

# 安装生产依赖
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 复制构建产物
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nextjs:nodejs /app/public ./public

# 复制环境变量文件
COPY --chown=nextjs:nodejs .env.production .env

# 切换到非root用户
USER nextjs

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# 暴露端口
EXPOSE 3000

# 启动命令
CMD ["node", "dist/server.js"]
```

**Docker Compose 配置：**
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    container_name: myapp
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
      - REDIS_URL=redis://redis:6379
    env_file:
      - .env.production
    depends_on:
      - db
      - redis
      - nginx
    volumes:
      - ./logs:/app/logs
      - ./uploads:/app/uploads
    restart: unless-stopped
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:14-alpine
    container_name: myapp-db
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: myapp-redis
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  nginx:
    image: nginx:alpine
    container_name: myapp-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
      - ./logs/nginx:/var/log/nginx
    depends_on:
      - app
    restart: unless-stopped
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
```

**Nginx 配置：**
```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;

    # 性能优化
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;

    # 安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    upstream app_servers {
        server app:3000;
    }

    server {
        listen 80;
        server_name example.com www.example.com;

        # 重定向到 HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name example.com www.example.com;

        # SSL 配置
        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;

        # 客户端证书验证（可选）
        # ssl_client_certificate /etc/nginx/ssl/client-cert.pem;
        # ssl_verify_client optional;

        # 静态文件缓存
        location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
            root /app/public;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # API 代理
        location /api/ {
            proxy_pass http://app_servers;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 90;
        }

        # 主应用
        location / {
            proxy_pass http://app_servers;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # 健康检查
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # 速率限制
        limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
        limit_req zone=api burst=20 nodelay;
    }
}
```

### 云平台部署方案

**AWS 部署方案：**
```bash
# AWS CLI 配置
aws configure
# 输入 Access Key ID, Secret Access Key, Region, Output format

# 使用 Elastic Beanstalk
# 安装 EB CLI
pip install awsebcli

# 初始化 EB 应用
eb init
# 选择区域和应用名称

# 部署应用
eb create production-env
eb deploy

# EB 配置文件
# .ebextensions/01_environment.config
option_settings:
  aws:elasticbeanstalk:application:environment:
    NODE_ENV: production
    DATABASE_URL: 
  aws:elasticbeanstalk:container:nodejs:
    NodeCommand: "npm start"
  aws:autoscaling:asg:
    MinSize: 2
    MaxSize: 10
  aws:autoscaling:trigger:
    BreachDuration: 5
    UpperThreshold: 60
    LowerThreshold: 20

# 使用 ECS 部署
# task-definition.json
{
  "family": "myapp-task",
  "containerDefinitions": [
    {
      "name": "myapp",
      "image": "123456789012.dkr.ecr.us-west-2.amazonaws.com/myapp:latest",
      "portMappings": [
        {
          "containerPort": 3000,
          "hostPort": 3000
        }
      ],
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "production"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/myapp",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3
      }
    }
  ]
}
```

**Azure 部署方案：**
```bash
# Azure CLI 配置
az login

# 创建资源组
az group create --name myapp-rg --location eastus

# 创建容器注册表
az acr create --resource-group myapp-rg --name myappregistry --sku Basic

# 构建并推送镜像
az acr build --image myapp:v1 --registry myappregistry --file Dockerfile .

# 创建应用服务
az appservice plan create --name myapp-plan --resource-group myapp-rg --sku B1 --is-linux
az webapp create --resource-group myapp-rg --plan myapp-plan --name myapp-webapp --deployment-container-image-name myappregistry.azurecr.io/myapp:v1

# 配置环境变量
az webapp config appsettings set --resource-group myapp-rg --name myapp-webapp --settings NODE_ENV=production DATABASE_URL=

# 部署代码
az webapp deployment source config-local-git --resource-group myapp-rg --name myapp-webapp
```