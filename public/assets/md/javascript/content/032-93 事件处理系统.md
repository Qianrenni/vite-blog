## 9.3 事件处理系统

### 1. 事件流和事件冒泡

```javascript
// 事件流和事件冒泡

// 事件流的三个阶段
// 1. 捕获阶段 (Capture Phase) - 从 document 到目标元素
// 2. 目标阶段 (Target Phase) - 到达目标元素
// 3. 冒泡阶段 (Bubbling Phase) - 从目标元素到 document

// 事件流示例
document.addEventListener('click', (event) => {
    console.log('Document - 捕获阶段', event.eventPhase); // 1
}, true); // true 表示捕获阶段

document.addEventListener('click', (event) => {
    console.log('Document - 冒泡阶段', event.eventPhase); // 3
}, false); // false 表示冒泡阶段

const container = document.getElementById('container');
container.addEventListener('click', (event) => {
    console.log('Container - 捕获阶段', event.eventPhase); // 1
}, true);

container.addEventListener('click', (event) => {
    console.log('Container - 冒泡阶段', event.eventPhase); // 3
}, false);

const button = document.getElementById('button');
button.addEventListener('click', (event) => {
    console.log('Button - 目标阶段', event.eventPhase); // 2
});

// 事件冒泡示例
const outer = document.getElementById('outer');
const middle = document.getElementById('middle');
const inner = document.getElementById('inner');

outer.addEventListener('click', (event) => {
    console.log('Outer clicked');
});

middle.addEventListener('click', (event) => {
    console.log('Middle clicked');
    // event.stopPropagation(); // 阻止事件继续冒泡
    // event.stopImmediatePropagation(); // 阻止同级监听器执行
});

inner.addEventListener('click', (event) => {
    console.log('Inner clicked');
    // event.stopPropagation(); // 阻止事件继续冒泡
});

// 事件捕获示例
outer.addEventListener('click', (event) => {
    console.log('Outer capture');
}, true);

middle.addEventListener('click', (event) => {
    console.log('Middle capture');
}, true);

inner.addEventListener('click', (event) => {
    console.log('Inner capture');
    // event.stopPropagation(); // 阻止事件继续捕获
}, true);

// 事件对象属性详解
function eventObjectDemo(event) {
    console.log('=== 事件对象属性 ===');
    console.log('type:', event.type); // 事件类型
    console.log('target:', event.target); // 实际触发事件的元素
    console.log('currentTarget:', event.currentTarget); // 当前处理事件的元素
    console.log('eventPhase:', event.eventPhase); // 事件阶段 (1:捕获, 2:目标, 3:冒泡)
    console.log('bubbles:', event.bubbles); // 是否冒泡
    console.log('cancelable:', event.cancelable); // 是否可取消默认行为
    console.log('defaultPrevented:', event.defaultPrevented); // 是否已阻止默认行为
    console.log('timeStamp:', event.timeStamp); // 事件时间戳
    console.log('isTrusted:', event.isTrusted); // 是否是用户触发的事件
}

// 阻止事件传播
function stopEventPropagation() {
    const button = document.getElementById('myButton');
    
    button.addEventListener('click', (event) => {
        console.log('按钮点击');
        
        // 阻止事件冒泡
        event.stopPropagation();
        
        // 阻止同级监听器执行
        // event.stopImmediatePropagation();
        
        // 阻止默认行为
        event.preventDefault();
    });
}

// 事件委托原理
class EventDelegationDemo {
    constructor() {
        this.setupDelegation();
    }
    
    setupDelegation() {
        // 在父容器上监听事件
        const container = document.getElementById('container');
        
        container.addEventListener('click', (event) => {
            const target = event.target;
            
            // 根据目标元素的特性处理不同事件
            if (target.matches('.button-delete')) {
                this.handleDelete(target, event);
            } else if (target.matches('.button-edit')) {
                this.handleEdit(target, event);
            } else if (target.matches('li')) {
                this.handleListItemClick(target, event);
            }
        });
    }
    
    handleDelete(button, event) {
        console.log('删除按钮点击');
        const item = button.closest('.item');
        if (item) {
            item.remove();
        }
    }
    
    handleEdit(button, event) {
        console.log('编辑按钮点击');
        const item = button.closest('.item');
        if (item) {
            const text = item.querySelector('.text');
            if (text) {
                text.contentEditable = true;
                text.focus();
            }
        }
    }
    
    handleListItemClick(item, event) {
        console.log('列表项点击:', item.textContent);
    }
}

// 事件流控制工具
class EventFlowController {
    // 在捕获阶段处理事件
    static capture(element, eventType, handler) {
        element.addEventListener(eventType, handler, true);
    }
    
    // 在冒泡阶段处理事件
    static bubble(element, eventType, handler) {
        element.addEventListener(eventType, handler, false);
    }
    
    // 一次性事件处理
    static once(element, eventType, handler, useCapture = false) {
        const onceHandler = (event) => {
            handler(event);
            element.removeEventListener(eventType, onceHandler, useCapture);
        };
        
        element.addEventListener(eventType, onceHandler, useCapture);
    }
    
    // 条件事件处理
    static conditional(element, eventType, condition, handler, useCapture = false) {
        const conditionalHandler = (event) => {
            if (condition(event)) {
                handler(event);
            }
        };
        
        element.addEventListener(eventType, conditionalHandler, useCapture);
    }
    
    // 委托事件处理
    static delegate(container, eventType, selector, handler) {
        container.addEventListener(eventType, (event) => {
            const target = event.target;
            if (target.matches && target.matches(selector)) {
                handler.call(target, event);
            }
        });
    }
}

// 使用事件流控制
// EventFlowController.capture(document, 'click', (event) => {
//     console.log('捕获阶段处理');
// });

// EventFlowController.once(button, 'click', (event) => {
//     console.log('只执行一次');
// });

// EventFlowController.conditional(button, 'click', 
//     (event) => event.ctrlKey, 
//     (event) => {
//         console.log('按住 Ctrl 点击');
//     }
// );

// 事件流可视化工具
class EventFlowVisualizer {
    constructor() {
        this.events = [];
    }
    
    logEvent(event, phase) {
        this.events.push({
            type: event.type,
            target: event.target.tagName,
            currentTarget: event.currentTarget.tagName,
            phase: phase,
            timestamp: Date.now()
        });
    }
    
    visualize() {
        console.table(this.events);
        return this.events;
    }
    
    clear() {
        this.events = [];
    }
}

// 使用可视化工具
const visualizer = new EventFlowVisualizer();

document.addEventListener('click', (event) => {
    visualizer.logEvent(event, '捕获');
}, true);

document.addEventListener('click', (event) => {
    visualizer.logEvent(event, '冒泡');
}, false);

// 高级事件流控制
class AdvancedEventFlow {
    constructor() {
        this.middleware = [];
    }
    
    // 添加中间件
    use(middleware) {
        this.middleware.push(middleware);
    }
    
    // 处理事件
    handleEvent(event) {
        let index = 0;
        const next = () => {
            if (index < this.middleware.length) {
                const middleware = this.middleware[index++];
                middleware(event, next);
            }
        };
        
        next();
    }
    
    // 在元素上应用中间件
    applyMiddleware(element, eventType) {
        element.addEventListener(eventType, (event) => {
            this.handleEvent(event);
        });
    }
}

// 使用中间件处理事件
const eventFlow = new AdvancedEventFlow();

// 日志中间件
eventFlow.use((event, next) => {
    console.log(`事件 ${event.type} 开始处理`);
    next();
    console.log(`事件 ${event.type} 处理完成`);
});

// 权限检查中间件
eventFlow.use((event, next) => {
    if (event.type === 'click' && event.target.hasAttribute('data-require-auth')) {
        console.log('需要权限验证');
        // 模拟权限检查
        setTimeout(() => {
            console.log('权限验证通过');
            next();
        }, 100);
    } else {
        next();
    }
});

// 性能监控中间件
eventFlow.use((event, next) => {
    const start = performance.now();
    next();
    const end = performance.now();
    console.log(`事件处理耗时: ${end - start}ms`);
});

// 事件流调试工具
class EventFlowDebugger {
    constructor() {
        this.breakpoints = new Set();
        this.logs = [];
    }
    
    // 设置断点
    setBreakpoint(element, eventType) {
        const key = `${element.tagName}_${eventType}`;
        this.breakpoints.add(key);
    }
    
    // 移除断点
    removeBreakpoint(element, eventType) {
        const key = `${element.tagName}_${eventType}`;
        this.breakpoints.delete(key);
    }
    
    // 监听事件
    watch(element, eventType, handler) {
        const originalHandler = handler;
        const debugHandler = (event) => {
            const key = `${event.currentTarget.tagName}_${event.type}`;
            
            if (this.breakpoints.has(key)) {
                debugger; // 触发断点
            }
            
            this.logEvent(event);
            originalHandler(event);
        };
        
        element.addEventListener(eventType, debugHandler);
    }
    
    // 记录事件
    logEvent(event) {
        this.logs.push({
            timestamp: Date.now(),
            type: event.type,
            target: event.target.tagName,
            currentTarget: event.currentTarget.tagName,
            phase: ['捕获', '目标', '冒泡'][event.eventPhase - 1]
        });
    }
    
    // 获取事件日志
    getLogs() {
        return this.logs;
    }
    
    // 清空日志
    clearLogs() {
        this.logs = [];
    }
}
```

### 2. 事件监听器管理

```javascript
// 事件监听器管理

// 基础事件管理器
class EventManager {
    constructor() {
        this.listeners = new Map(); // 存储监听器
        this.listenerId = 0; // 监听器 ID 计数器
    }
    
    // 添加事件监听器
    addListener(element, eventType, handler, options = {}) {
        const id = ++this.listenerId;
        const key = this.getElementKey(element);
        
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Map());
        }
        
        const elementListeners = this.listeners.get(key);
        
        if (!elementListeners.has(eventType)) {
            elementListeners.set(eventType, new Map());
        }
        
        const typeListeners = elementListeners.get(eventType);
        typeListeners.set(id, { handler, options });
        
        // 实际添加监听器
        element.addEventListener(eventType, handler, options);
        
        return id;
    }
    
    // 移除事件监听器
    removeListener(element, eventType, id) {
        const key = this.getElementKey(element);
        const elementListeners = this.listeners.get(key);
        
        if (!elementListeners) return false;
        
        const typeListeners = elementListeners.get(eventType);
        if (!typeListeners) return false;
        
        const listener = typeListeners.get(id);
        if (!listener) return false;
        
        // 实际移除监听器
        element.removeEventListener(eventType, listener.handler, listener.options);
        
        // 从管理器中移除
        typeListeners.delete(id);
        
        // 清理空的映射
        if (typeListeners.size === 0) {
            elementListeners.delete(eventType);
        }
        
        if (elementListeners.size === 0) {
            this.listeners.delete(key);
        }
        
        return true;
    }
    
    // 移除元素的所有监听器
    removeAllListeners(element) {
        const key = this.getElementKey(element);
        const elementListeners = this.listeners.get(key);
        
        if (!elementListeners) return false;
        
        elementListeners.forEach((typeListeners, eventType) => {
            typeListeners.forEach((listener) => {
                element.removeEventListener(eventType, listener.handler, listener.options);
            });
        });
        
        this.listeners.delete(key);
        return true;
    }
    
    // 获取元素的监听器数量
    getListenerCount(element) {
        const key = this.getElementKey(element);
        const elementListeners = this.listeners.get(key);
        
        if (!elementListeners) return 0;
        
        let count = 0;
        elementListeners.forEach(typeListeners => {
            count += typeListeners.size;
        });
        
        return count;
    }
    
    // 获取所有监听器信息
    getAllListeners() {
        const result = [];
        
        this.listeners.forEach((elementListeners, elementKey) => {
            elementListeners.forEach((typeListeners, eventType) => {
                typeListeners.forEach((listener, id) => {
                    result.push({
                        id,
                        element: elementKey,
                        eventType,
                        handler: listener.handler,
                        options: listener.options
                    });
                });
            });
        });
        
        return result;
    }
    
    // 生成元素键
    getElementKey(element) {
        return element.tagName + '_' + (element.id || element.className || element.innerHTML.substring(0, 20));
    }
}

// 使用事件管理器
const eventManager = new EventManager();

const button = document.getElementById('myButton');
const clickHandler = (event) => {
    console.log('按钮点击');
};

// 添加监听器
const listenerId = eventManager.addListener(button, 'click', clickHandler);

// 移除监听器
// eventManager.removeListener(button, 'click', listenerId);

// 高级事件管理器
class AdvancedEventManager {
    constructor() {
        this.events = new Map();
        this.groups = new Map();
        this.contexts = new Map();
    }
    
    // 添加带组的事件监听器
    addListener(element, eventType, handler, options = {}, group = 'default') {
        const eventId = this.generateId();
        
        const eventInfo = {
            id: eventId,
            element,
            eventType,
            handler,
            options,
            group
        };
        
        // 存储事件信息
        this.events.set(eventId, eventInfo);
        
        // 添加到组
        if (!this.groups.has(group)) {
            this.groups.set(group, new Set());
        }
        this.groups.get(group).add(eventId);
        
        // 实际添加监听器
        element.addEventListener(eventType, handler, options);
        
        return eventId;
    }
    
    // 移除特定事件监听器
    removeListener(eventId) {
        const eventInfo = this.events.get(eventId);
        if (!eventInfo) return false;
        
        const { element, eventType, handler, options, group } = eventInfo;
        
        // 实际移除监听器
        element.removeEventListener(eventType, handler, options);
        
        // 从管理器中移除
        this.events.delete(eventId);
        
        // 从组中移除
        if (this.groups.has(group)) {
            this.groups.get(group).delete(eventId);
            if (this.groups.get(group).size === 0) {
                this.groups.delete(group);
            }
        }
        
        return true;
    }
    
    // 按组移除事件监听器
    removeGroup(group) {
        const groupEvents = this.groups.get(group);
        if (!groupEvents) return false;
        
        const removed = [];
        groupEvents.forEach(eventId => {
            if (this.removeListener(eventId)) {
                removed.push(eventId);
            }
        });
        
        return removed;
    }
    
    // 按元素移除事件监听器
    removeByElement(element) {
        const removed = [];
        
        this.events.forEach((eventInfo, eventId) => {
            if (eventInfo.element === element) {
                if (this.removeListener(eventId)) {
                    removed.push(eventId);
                }
            }
        });
        
        return removed;
    }
    
    // 按事件类型移除监听器
    removeByType(eventType) {
        const removed = [];
        
        this.events.forEach((eventInfo, eventId) => {
            if (eventInfo.eventType === eventType) {
                if (this.removeListener(eventId)) {
                    removed.push(eventId);
                }
            }
        });
        
        return removed;
    }
    
    // 临时事件监听器（自动移除）
    once(element, eventType, handler, options = {}) {
        const onceHandler = (event) => {
            handler(event);
            // 自动移除
            this.events.forEach((eventInfo, eventId) => {
                if (eventInfo.handler === onceHandler) {
                    this.removeListener(eventId);
                }
            });
        };
        
        return this.addListener(element, eventType, onceHandler, options);
    }
    
    // 上下文绑定事件监听器
    bindContext(element, eventType, handler, context, options = {}) {
        const boundHandler = handler.bind(context);
        
        const eventId = this.addListener(element, eventType, boundHandler, options);
        
        // 存储上下文信息
        if (!this.contexts.has(context)) {
            this.contexts.set(context, new Set());
        }
        this.contexts.get(context).add(eventId);
        
        return eventId;
    }
    
    // 移除上下文的所有监听器
    removeContext(context) {
        const contextEvents = this.contexts.get(context);
        if (!contextEvents) return false;
        
        const removed = [];
        contextEvents.forEach(eventId => {
            if (this.removeListener(eventId)) {
                removed.push(eventId);
            }
        });
        
        this.contexts.delete(context);
        return removed;
    }
    
    // 获取事件统计信息
    getStats() {
        return {
            totalEvents: this.events.size,
            groups: Array.from(this.groups.keys()),
            contexts: this.contexts.size
        };
    }
    
    // 生成唯一 ID
    generateId() {
        return Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
}

// 使用高级事件管理器
const advancedEventManager = new AdvancedEventManager();

const button1 = document.getElementById('button1');
const button2 = document.getElementById('button2');

// 添加监听器到不同组
advancedEventManager.addListener(button1, 'click', () => {
    console.log('按钮1点击 - 组A');
}, {}, 'groupA');

advancedEventManager.addListener(button2, 'click', () => {
    console.log('按钮2点击 - 组B');
}, {}, 'groupB');

// 移除特定组的所有监听器
// advancedEventManager.removeGroup('groupA');

// 事件监听器池
class EventListenerPool {
    constructor(maxSize = 100) {
        this.pool = [];
        this.active = new Map();
        this.maxSize = maxSize;
    }
    
    // 获取事件监听器
    getListener(handler, context = null) {
        // 查找可用的监听器
        for (let i = 0; i < this.pool.length; i++) {
            const listener = this.pool[i];
            if (listener.handler === handler && listener.context === context) {
                this.pool.splice(i, 1);
                this.active.set(listener.id, listener);
                return listener.boundHandler;
            }
        }
        
        // 创建新的监听器
        const id = this.generateId();
        const boundHandler = context ? handler.bind(context) : handler;
        const listener = {
            id,
            handler,
            context,
            boundHandler
        };
        
        this.active.set(id, listener);
        return boundHandler;
    }
    
    // 释放事件监听器
    releaseListener(boundHandler) {
        this.active.forEach((listener, id) => {
            if (listener.boundHandler === boundHandler) {
                this.active.delete(id);
                
                // 如果池未满，将监听器放回池中
                if (this.pool.length < this.maxSize) {
                    this.pool.push(listener);
                }
            }
        });
    }
    
    // 清空池
    clear() {
        this.pool = [];
        this.active.clear();
    }
    
    // 生成唯一 ID
    generateId() {
        return 'listener_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
}

// 事件监听器装饰器
class EventDecorator {
    // 防抖装饰器
    static debounce(delay) {
        return function(target, propertyName, descriptor) {
            const method = descriptor.value;
            let timeoutId;
            
            descriptor.value = function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => method.apply(this, args), delay);
            };
            
            return descriptor;
        };
    }
    
    // 节流装饰器
    static throttle(limit) {
        return function(target, propertyName, descriptor) {
            const method = descriptor.value;
            let inThrottle;
            
            descriptor.value = function(...args) {
                if (!inThrottle) {
                    method.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
            
            return descriptor;
        };
    }
    
    // 一次性执行装饰器
    static once() {
        return function(target, propertyName, descriptor) {
            const method = descriptor.value;
            let executed = false;
            
            descriptor.value = function(...args) {
                if (!executed) {
                    executed = true;
                    return method.apply(this, args);
                }
            };
            
            return descriptor;
        };
    }
    
    // 条件执行装饰器
    static condition(conditionFunction) {
        return function(target, propertyName, descriptor) {
            const method = descriptor.value;
            
            descriptor.value = function(...args) {
                if (conditionFunction.apply(this, args)) {
                    return method.apply(this, args);
                }
            };
            
            return descriptor;
        };
    }
}

// 使用事件装饰器
class ButtonHandler {
    @EventDecorator.debounce(300)
    handleButtonClick(event) {
        console.log('按钮点击（防抖）');
    }
    
    @EventDecorator.throttle(1000)
    handleScroll(event) {
        console.log('滚动事件（节流）');
    }
    
    @EventDecorator.once()
    handleFirstClick(event) {
        console.log('只执行一次');
    }
    
    @EventDecorator.condition((event) => event.ctrlKey)
    handleCtrlClick(event) {
        console.log('按住 Ctrl 点击');
    }
}

// 事件监听器性能监控
class EventPerformanceMonitor {
    constructor() {
        this.metrics = new Map();
        this.activeListeners = new Map();
    }
    
    // 监控事件监听器性能
    monitorListener(element, eventType, handler, options = {}) {
        const listenerId = this.generateId();
        const startTime = performance.now();
        
        const monitoredHandler = (event) => {
            const handlerStart = performance.now();
            try {
                handler(event);
            } finally {
                const handlerEnd = performance.now();
                const duration = handlerEnd - handlerStart;
                
                // 记录性能指标
                if (!this.metrics.has(listenerId)) {
                    this.metrics.set(listenerId, {
                        element: element.tagName,
                        eventType,
                        callCount: 0,
                        totalTime: 0,
                        maxTime: 0,
                        minTime: Infinity
                    });
                }
                
                const metric = this.metrics.get(listenerId);
                metric.callCount++;
                metric.totalTime += duration;
                metric.maxTime = Math.max(metric.maxTime, duration);
                metric.minTime = Math.min(metric.minTime, duration);
            }
        };
        
        // 实际添加监听器
        element.addEventListener(eventType, monitoredHandler, options);
        
        // 记录活动监听器
        this.activeListeners.set(listenerId, {
            element,
            eventType,
            handler: monitoredHandler,
            originalHandler: handler,
            options
        });
        
        return listenerId;
    }
    
    // 移除监控的监听器
    removeMonitoredListener(listenerId) {
        const listenerInfo = this.activeListeners.get(listenerId);
        if (!listenerInfo) return false;
        
        const { element, eventType, handler } = listenerInfo;
        element.removeEventListener(eventType, handler);
        this.activeListeners.delete(listenerId);
        
        return true;
    }
    
    // 获取性能报告
    getPerformanceReport() {
        const report = [];
        
        this.metrics.forEach((metric, id) => {
            report.push({
                ...metric,
                averageTime: metric.totalTime / metric.callCount,
                listenerId: id
            });
        });
        
        return report.sort((a, b) => b.averageTime - a.averageTime);
    }
    
    // 获取慢监听器
    getSlowListeners(threshold = 16) { // 16ms = 60fps
        return this.getPerformanceReport()
            .filter(metric => metric.averageTime > threshold);
    }
    
    // 清空性能数据
    clearMetrics() {
        this.metrics.clear();
    }
    
    // 生成唯一 ID
    generateId() {
        return 'perf_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
}

// 使用性能监控
const perfMonitor = new EventPerformanceMonitor();

const button = document.getElementById('perfButton');
const slowHandler = (event) => {
    // 模拟慢操作
    for (let i = 0; i < 1000000; i++) {
        // 空循环
    }
    console.log('慢操作完成');
};

// perfMonitor.monitorListener(button, 'click', slowHandler);

// 事件监听器工具类
class EventUtils {
    // 批量添加事件监听器
    static addListeners(element, events, handler, options = {}) {
        const listenerIds = [];
        events.forEach(eventType => {
            const id = eventManager.addListener(element, eventType, handler, options);
            listenerIds.push(id);
        });
        return listenerIds;
    }
    
    // 批量移除事件监听器
    static removeListeners(listenerIds) {
        listenerIds.forEach(id => {
            eventManager.removeListener(null, null, id); // 需要改进
        });
    }
    
    // 事件委托
    static delegate(container, eventType, selector, handler) {
        return eventManager.addListener(container, eventType, (event) => {
            const target = event.target;
            if (target.matches && target.matches(selector)) {
                handler.call(target, event);
            }
        });
    }
    
    // 创建自定义事件
    static createCustomEvent(eventName, detail = {}) {
        return new CustomEvent(eventName, {
            detail,
            bubbles: true,
            cancelable: true
        });
    }
    
    // 触发自定义事件
    static dispatchEvent(element, eventName, detail = {}) {
        const event = this.createCustomEvent(eventName, detail);
        return element.dispatchEvent(event);
    }
    
    // 等待事件
    static waitForEvent(element, eventType, timeout = 5000) {
        return new Promise((resolve, reject) => {
            const handler = (event) => {
                element.removeEventListener(eventType, handler);
                resolve(event);
            };
            
            element.addEventListener(eventType, handler);
            
            if (timeout > 0) {
                setTimeout(() => {
                    element.removeEventListener(eventType, handler);
                    reject(new Error(`等待事件 ${eventType} 超时`));
                }, timeout);
            }
        });
    }
    
    // 事件组合器
    static combineEvents(element, eventTypes, handler) {
        let eventStates = {};
        eventTypes.forEach(type => eventStates[type] = false);
        
        eventTypes.forEach(type => {
            element.addEventListener(type, (event) => {
                eventStates[type] = true;
                
                const allFired = Object.values(eventStates).every(state => state);
                if (allFired) {
                    handler(eventStates);
                    // 重置状态
                    eventTypes.forEach(type => eventStates[type] = false);
                }
            });
        });
    }
}

// 使用事件工具
// EventUtils.addListeners(button, ['click', 'touchstart'], (event) => {
//     console.log('多事件处理:', event.type);
// });

// EventUtils.delegate(document, 'click', '.dynamic-button', (event) => {
//     console.log('委托事件处理');
// });

// EventUtils.waitForEvent(button, 'click', 3000)
//     .then(event => {
//         console.log('等待到点击事件');
//     })
//     .catch(error => {
//         console.log('等待超时:', error.message);
//     });
```

### 3. 自定义事件创建

```javascript
// 自定义事件创建

// 基础自定义事件
class CustomEventBasics {
    // 创建自定义事件
    static createEvent(eventName, detail = {}) {
        return new CustomEvent(eventName, {
            detail, // 传递的自定义数据
            bubbles: true, // 是否冒泡
            cancelable: true // 是否可以取消默认行为
        });
    }
    
    // 触发自定义事件
    static dispatchEvent(element, eventName, detail = {}) {
        const event = this.createEvent(eventName, detail);
        return element.dispatchEvent(event);
    }
    
    // 监听自定义事件
    static listenEvent(element, eventName, handler) {
        element.addEventListener(eventName, handler);
    }
    
    // 移除自定义事件监听器
    static removeEvent(element, eventName, handler) {
        element.removeEventListener(eventName, handler);
    }
}

// 使用基础自定义事件
const button = document.getElementById('customEventButton');

// 创建和触发自定义事件
CustomEventBasics.listenEvent(button, 'customClick', (event) => {
    console.log('自定义点击事件:', event.detail);
});

// 触发自定义事件
CustomEventBasics.dispatchEvent(button, 'customClick', {
    message: 'Hello Custom Event',
    timestamp: Date.now()
});

// 高级自定义事件系统
class AdvancedCustomEventSystem {
    constructor() {
        this.events = new Map();
        this.eventQueue = [];
        this.isProcessing = false;
    }
    
    // 创建自定义事件类
    createEventClass(eventName, options = {}) {
        class CustomEventClass extends Event {
            constructor(detail = {}, eventOptions = {}) {
                super(eventName, {
                    bubbles: options.bubbles !== false, // 默认冒泡
                    cancelable: options.cancelable !== false, // 默认可取消
                    composed: options.composed || false,
                    ...eventOptions
                });
                
                this.detail = detail;
                this.timestamp = Date.now();
                this.eventId = this.generateId();
            }
            
            generateId() {
                return `${eventName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
        }
        
        this.events.set(eventName, CustomEventClass);
        return CustomEventClass;
    }
    
    // 触发自定义事件
    emit(element, eventName, detail = {}, options = {}) {
        const EventClass = this.events.get(eventName);
        
        if (!EventClass) {
            console.warn(`事件 ${eventName} 未定义`);
            return false;
        }
        
        const event = new EventClass(detail, options);
        return element.dispatchEvent(event);
    }
    
    // 异步触发事件
    async emitAsync(element, eventName, detail = {}, options = {}) {
        return new Promise((resolve) => {
            this.eventQueue.push({
                element,
                eventName,
                detail,
                options,
                resolve
            });
            
            if (!this.isProcessing) {
                this.processQueue();
            }
        });
    }
    
    // 处理事件队列
    async processQueue() {
        this.isProcessing = true;
        
        while (this.eventQueue.length > 0) {
            const { element, eventName, detail, options, resolve } = this.eventQueue.shift();
            
            try {
                const result = this.emit(element, eventName, detail, options);
                resolve(result);
            } catch (error) {
                console.error('事件触发失败:', error);
                resolve(false);
            }
            
            // 让出控制权，避免阻塞
            await this.yield();
        }
        
        this.isProcessing = false;
    }
    
    // 让出控制权
    yield() {
        return new Promise(resolve => setTimeout(resolve, 0));
    }
    
    // 批量触发事件
    emitBatch(events) {
        const results = [];
        
        events.forEach(({ element, eventName, detail, options }) => {
            const result = this.emit(element, eventName, detail, options);
            results.push({ eventName, result });
        });
        
        return results;
    }
    
    // 延迟触发事件
    emitDelayed(element, eventName, detail = {}, delay = 0, options = {}) {
        return new Promise((resolve) => {
            setTimeout(() => {
                const result = this.emit(element, eventName, detail, options);
                resolve(result);
            }, delay);
        });
    }
    
    // 条件触发事件
    emitConditional(condition, element, eventName, detail = {}, options = {}) {
        if (condition) {
            return this.emit(element, eventName, detail, options);
        }
        return false;
    }
}

// 使用高级自定义事件系统
const eventSystem = new AdvancedCustomEventSystem();

// 创建自定义事件类
const UserLoginEvent = eventSystem.createEventClass('userLogin', {
    bubbles: true,
    cancelable: true
});

const DataUpdateEvent = eventSystem.createEventClass('dataUpdate', {
    bubbles: false,
    cancelable: false
});

// 监听自定义事件
document.addEventListener('userLogin', (event) => {
    console.log('用户登录事件:', event.detail);
    console.log('事件ID:', event.eventId);
});

// 触发自定义事件
eventSystem.emit(document, 'userLogin', {
    userId: 123,
    username: 'john_doe',
    loginTime: new Date()
});

// 自定义事件管理器
class CustomEventManager {
    constructor() {
        this.listeners = new Map();
        this.eventHistory = [];
        this.maxHistory = 100;
    }
    
    // 添加事件监听器
    on(eventName, handler, context = null) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, []);
        }
        
        const boundHandler = context ? handler.bind(context) : handler;
        this.listeners.get(eventName).push({
            handler: boundHandler,
            context,
            originalHandler: handler
        });
        
        return this;
    }
    
    // 移除事件监听器
    off(eventName, handler = null) {
        if (!this.listeners.has(eventName)) {
            return this;
        }
        
        if (!handler) {
            // 移除所有该事件的监听器
            this.listeners.delete(eventName);
        } else {
            // 移除特定监听器
            const listeners = this.listeners.get(eventName);
            const index = listeners.findIndex(l => l.originalHandler === handler);
            if (index > -1) {
                listeners.splice(index, 1);
            }
            
            if (listeners.length === 0) {
                this.listeners.delete(eventName);
            }
        }
        
        return this;
    }
    
    // 触发事件
    trigger(eventName, data = {}) {
        if (!this.listeners.has(eventName)) {
            return false;
        }
        
        const event = {
            name: eventName,
            data,
            timestamp: Date.now(),
            preventDefault: false
        };
        
        // 记录事件历史
        this.recordEvent(event);
        
        // 触发所有监听器
        const listeners = this.listeners.get(eventName);
        listeners.forEach(({ handler }) => {
            try {
                handler.call(null, event);
            } catch (error) {
                console.error(`事件处理错误 ${eventName}:`, error);
            }
        });
        
        return !event.preventDefault;
    }
    
    // 一次性事件监听器
    once(eventName, handler, context = null) {
        const onceHandler = (event) => {
            handler.call(context, event);
            this.off(eventName, onceHandler);
        };
        
        return this.on(eventName, onceHandler, context);
    }
    
    // 等待事件
    waitFor(eventName, timeout = 5000) {
        return new Promise((resolve, reject) => {
            let timeoutId;
            
            const handler = (event) => {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                resolve(event);
            };
            
            this.once(eventName, handler);
            
            if (timeout > 0) {
                timeoutId = setTimeout(() => {
                    this.off(eventName, handler);
                    reject(new Error(`等待事件 ${eventName} 超时`));
                }, timeout);
            }
        });
    }
    
    // 记录事件历史
    recordEvent(event) {
        this.eventHistory.push(event);
        
        if (this.eventHistory.length > this.maxHistory) {
            this.eventHistory.shift();
        }
    }
    
    // 获取事件历史
    getEventHistory(eventName = null) {
        if (eventName) {
            return this.eventHistory.filter(event => event.name === eventName);
        }
        return [...this.eventHistory];
    }
    
    // 清空事件历史
    clearEventHistory() {
        this.eventHistory = [];
    }
    
    // 获取所有事件类型
    getEventTypes() {
        return Array.from(this.listeners.keys());
    }
    
    // 获取事件监听器数量
    getListenerCount(eventName = null) {
        if (eventName) {
            return this.listeners.has(eventName) ? this.listeners.get(eventName).length : 0;
        }
        
        let count = 0;
        this.listeners.forEach(listeners => {
            count += listeners.length;
        });
        return count;
    }
}

// 使用自定义事件管理器
const customEventManager = new CustomEventManager();

// 添加事件监听器
customEventManager.on('userAction', (event) => {
    console.log('用户操作:', event.data);
});

customEventManager.once('pageLoad', (event) => {
    console.log('页面加载完成:', event.data);
});

// 触发事件
customEventManager.trigger('userAction', {
    action: 'click',
    element: 'button',
    timestamp: Date.now()
});

customEventManager.trigger('pageLoad', {
    url: window.location.href,
    loadTime: performance.now()
});

// 等待事件
// customEventManager.waitFor('dataReady', 3000)
//     .then(event => {
//         console.log('数据准备就绪:', event.data);
//     })
//     .catch(error => {
//         console.log('等待超时:', error.message);
//     });

// 自定义事件装饰器
class EventDecorator {
    // 事件发布装饰器
    static emit(eventName, eventManager) {
        return function(target, propertyName, descriptor) {
            const method = descriptor.value;
            
            descriptor.value = function(...args) {
                const result = method.apply(this, args);
                
                // 触发事件
                eventManager.trigger(eventName, {
                    args,
                    result,
                    context: this
                });
                
                return result;
            };
            
            return descriptor;
        };
    }
    
    // 事件订阅装饰器
    static listen(eventName, eventManager) {
        return function(target, propertyName, descriptor) {
            const method = descriptor.value;
            
            // 在类实例化时自动订阅事件
            const originalConstructor = target.constructor;
            const originalConnectedCallback = target.connectedCallback;
            
            target.connectedCallback = function() {
                if (originalConnectedCallback) {
                    originalConnectedCallback.call(this);
                }
                
                eventManager.on(eventName, method.bind(this));
            };
            
            return descriptor;
        };
    }
}

// 使用事件装饰器
const decoratorEventManager = new CustomEventManager();

class UserService {
    @EventDecorator.emit('userCreated', decoratorEventManager)
    createUser(userData) {
        console.log('创建用户:', userData);
        return { id: Date.now(), ...userData };
    }
    
    @EventDecorator.emit('userUpdated', decoratorEventManager)
    updateUser(userId, userData) {
        console.log('更新用户:', userId, userData);
        return { id: userId, ...userData };
    }
}

// 监听用户事件
decoratorEventManager.on('userCreated', (event) => {
    console.log('用户创建事件:', event.data);
});

decoratorEventManager.on('userUpdated', (event) => {
    console.log('用户更新事件:', event.data);
});

// 使用服务
const userService = new UserService();
const newUser = userService.createUser({ name: 'John', email: 'john@example.com' });
userService.updateUser(newUser.id, { name: 'John Doe' });

// 自定义事件总线
class EventBus {
    constructor() {
        this.channels = new Map();
        this.middlewares = [];
    }
    
    // 订阅频道
    subscribe(channel, handler) {
        if (!this.channels.has(channel)) {
            this.channels.set(channel, new Set());
        }
        
        this.channels.get(channel).add(handler);
        return () => this.unsubscribe(channel, handler); // 返回取消订阅函数
    }
    
    // 取消订阅
    unsubscribe(channel, handler) {
        if (this.channels.has(channel)) {
            this.channels.get(channel).delete(handler);
            
            if (this.channels.get(channel).size === 0) {
                this.channels.delete(channel);
            }
        }
    }
    
    // 发布消息
    publish(channel, message) {
        // 应用中间件
        let processedMessage = message;
        for (const middleware of this.middlewares) {
            processedMessage = middleware(channel, processedMessage);
            if (processedMessage === null) {
                return; // 中间件阻止了消息传递
            }
        }
        
        // 发送消息到订阅者
        if (this.channels.has(channel)) {
            this.channels.get(channel).forEach(handler => {
                try {
                    handler(processedMessage);
                } catch (error) {
                    console.error(`频道 ${channel} 处理错误:`, error);
                }
            });
        }
    }
    
    // 添加中间件
    use(middleware) {
        this.middlewares.push(middleware);
    }
    
    // 创建带命名空间的子总线
    createNamespace(namespace) {
        const namespacedBus = new EventBus();
        
        // 重写 publish 方法以支持命名空间
        const originalPublish = namespacedBus.publish;
        namespacedBus.publish = (channel, message) => {
            originalPublish.call(namespacedBus, `${namespace}.${channel}`, message);
        };
        
        // 重写 subscribe 方法以支持命名空间
        const originalSubscribe = namespacedBus.subscribe;
        namespacedBus.subscribe = (channel, handler) => {
            return originalSubscribe.call(namespacedBus, `${namespace}.${channel}`, handler);
        };
        
        return namespacedBus;
    }
    
    // 获取频道统计信息
    getStats() {
        const stats = {};
        this.channels.forEach((handlers, channel) => {
            stats[channel] = handlers.size;
        });
        return stats;
    }
    
    // 清空所有订阅
    clear() {
        this.channels.clear();
        this.middlewares = [];
    }
}

// 使用事件总线
const eventBus = new EventBus();

// 添加日志中间件
eventBus.use((channel, message) => {
    console.log(`[${new Date().toISOString()}] ${channel}:`, message);
    return message;
});

// 添加验证中间件
eventBus.use((channel, message) => {
    if (!message || typeof message !== 'object') {
        console.warn(`无效的消息格式在频道 ${channel}`);
        return null; // 阻止消息传递
    }
    return message;
});

// 订阅频道
const unsubscribeUser = eventBus.subscribe('user', (message) => {
    console.log('用户频道消息:', message);
});

const unsubscribeOrder = eventBus.subscribe('order', (message) => {
    console.log('订单频道消息:', message);
});

// 发布消息
eventBus.publish('user', { type: 'login', userId: 123 });
eventBus.publish('order', { type: 'created', orderId: 456 });

// 创建命名空间
const userBus = eventBus.createNamespace('user');
userBus.subscribe('profile', (message) => {
    console.log('用户配置文件消息:', message);
});

userBus.publish('profile', { action: 'updated', profile: { name: 'John' } });

// 自定义事件工具类
class CustomEventUtils {
    // 创建事件工厂
    static createEventFactory(eventDefinitions) {
        const factory = {};
        
        Object.keys(eventDefinitions).forEach(eventName => {
            const definition = eventDefinitions[eventName];
            
            factory[eventName] = (detail = {}, options = {}) => {
                return new CustomEvent(eventName, {
                    detail,
                    bubbles: definition.bubbles !== false,
                    cancelable: definition.cancelable !== false,
                    composed: definition.composed || false,
                    ...options
                });
            };
        });
        
        return factory;
    }
    
    // 批量监听事件
    static listenMultiple(element, eventMap) {
        const unsubscribers = [];
        
        Object.keys(eventMap).forEach(eventName => {
            const handler = eventMap[eventName];
            element.addEventListener(eventName, handler);
            
            unsubscribers.push(() => {
                element.removeEventListener(eventName, handler);
            });
        });
        
        return () => {
            unsubscribers.forEach(unsubscribe => unsubscribe());
        };
    }
    
    // 事件管道
    static pipeEvents(sourceElement, sourceEvent, targetElement, targetEvent, transformer = null) {
        const handler = (event) => {
            let data = event;
            
            if (transformer) {
                data = transformer(event);
            }
            
            const newEvent = new CustomEvent(targetEvent, {
                detail: data,
                bubbles: true,
                cancelable: true
            });
            
            targetElement.dispatchEvent(newEvent);
        };
        
        sourceElement.addEventListener(sourceEvent, handler);
        
        return () => {
            sourceElement.removeEventListener(sourceEvent, handler);
        };
    }
    
    // 事件节流
    static throttleEvent(element, eventName, handler, limit) {
        let inThrottle;
        
        const throttledHandler = (event) => {
            if (!inThrottle) {
                handler(event);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
        
        element.addEventListener(eventName, throttledHandler);
        
        return () => {
            element.removeEventListener(eventName, throttledHandler);
        };
    }
    
    // 事件防抖
    static debounceEvent(element, eventName, handler, delay) {
        let timeoutId;
        
        const debouncedHandler = (event) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => handler(event), delay);
        };
        
        element.addEventListener(eventName, debouncedHandler);
        
        return () => {
            clearTimeout(timeoutId);
            element.removeEventListener(eventName, debouncedHandler);
        };
    }
}

// 使用自定义事件工具
const eventDefinitions = {
    userLogin: { bubbles: true, cancelable: true },
    dataUpdate: { bubbles: false, cancelable: false },
    error: { bubbles: true, cancelable: false }
};

const eventFactory = CustomEventUtils.createEventFactory(eventDefinitions);

// 批量监听
const unlisten = CustomEventUtils.listenMultiple(document, {
    'userLogin': (event) => console.log('用户登录:', event.detail),
    'dataUpdate': (event) => console.log('数据更新:', event.detail),
    'error': (event) => console.log('错误:', event.detail)
});

// 触发事件
document.dispatchEvent(eventFactory.userLogin({ userId: 123 }));
document.dispatchEvent(eventFactory.dataUpdate({ data: 'new data' }));

// 管道事件
const input = document.getElementById('textInput');
const output = document.getElementById('textOutput');

CustomEventUtils.pipeEvents(
    input,
    'input',
    output,
    'textChanged',
    (event) => event.target.value
);
```

### 4. 事件委托模式

```javascript
// 事件委托模式

// 基础事件委托
class BasicEventDelegation {
    constructor(container) {
        this.container = container;
        this.delegates = new Map();
    }
    
    // 添加委托监听器
    delegate(eventType, selector, handler) {
        const key = `${eventType}_${selector}`;
        
        if (!this.delegates.has(key)) {
            this.container.addEventListener(eventType, (event) => {
                this.handleDelegatedEvent(event, eventType, selector, handler);
            });
            
            this.delegates.set(key, {
                eventType,
                selector,
                handler
            });
        }
    }
    
    // 处理委托事件
    handleDelegatedEvent(event, eventType, selector, handler) {
        const target = event.target;
        
        // 检查目标元素是否匹配选择器
        if (target.matches && target.matches(selector)) {
            handler.call(target, event);
        }
        
        // 检查祖先元素是否匹配选择器
        let parent = target.parentElement;
        while (parent && parent !== this.container) {
            if (parent.matches && parent.matches(selector)) {
                handler.call(parent, event);
                break;
            }
            parent = parent.parentElement;
        }
    }
    
    // 移除委托监听器
    undelegate(eventType, selector) {
        const key = `${eventType}_${selector}`;
        this.delegates.delete(key);
        // 注意：实际的事件监听器仍然存在，但不会处理该委托
    }
}

// 使用基础事件委托
const container = document.getElementById('eventContainer');
const delegation = new BasicEventDelegation(container);

delegation.delegate('click', '.button-delete', function(event) {
    console.log('删除按钮点击:', this);
    this.parentElement.remove();
});

delegation.delegate('click', '.button-edit', function(event) {
    console.log('编辑按钮点击:', this);
    const text = this.parentElement.querySelector('.text');
    if (text) {
        text.contentEditable = true;
        text.focus();
    }
});

// 高级事件委托系统
class AdvancedEventDelegation {
    constructor(container) {
        this.container = container;
        this.delegates = new Map();
        this.delegateId = 0;
    }
    
    // 添加委托监听器
    on(eventType, selector, handler, options = {}) {
        const id = ++this.delegateId;
        const key = `${eventType}_${selector}_${id}`;
        
        const delegate = {
            id,
            eventType,
            selector,
            handler,
            options,
            active: true
        };
        
        if (!this.delegates.has(eventType)) {
            this.delegates.set(eventType, new Map());
            this.setupEventListener(eventType);
        }
        
        this.delegates.get(eventType).set(key, delegate);
        
        return id;
    }
    
    // 设置事件监听器
    setupEventListener(eventType) {
        this.container.addEventListener(eventType, (event) => {
            this.processEvent(event);
        }, false);
    }
    
    // 处理事件
    processEvent(event) {
        const eventType = event.type;
        const delegates = this.delegates.get(eventType);
        
        if (!delegates) return;
        
        // 按照事件流顺序处理委托
        const matchedDelegates = [];
        
        let target = event.target;
        while (target && target !== this.container) {
            delegates.forEach((delegate, key) => {
                if (delegate.active && target.matches(delegate.selector)) {
                    matchedDelegates.push({
                        delegate,
                        target,
                        key
                    });
                }
            });
            target = target.parentElement;
        }
        
        // 按照添加顺序执行处理函数
        matchedDelegates.forEach(({ delegate, target }) => {
            if (delegate.active) {
                const result = delegate.handler.call(target, event);
                
                // 处理选项
                if (delegate.options.once && result !== false) {
                    delegate.active = false;
                }
                
                if (delegate.options.stopPropagation && result !== false) {
                    event.stopPropagation();
                }
                
                if (delegate.options.preventDefault && result !== false) {
                    event.preventDefault();
                }
                
                if (result === false) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        });
    }
    
    // 移除委托监听器
    off(id) {
        this.delegates.forEach((delegatesByType) => {
            delegatesByType.forEach((delegate, key) => {
                if (delegate.id === id) {
                    delegate.active = false;
                    delegatesByType.delete(key);
                }
            });
        });
    }
    
    // 移除特定事件类型的委托
    offByType(eventType) {
        if (this.delegates.has(eventType)) {
            this.delegates.get(eventType).forEach(delegate => {
                delegate.active = false;
            });
            this.delegates.delete(eventType);
        }
    }
    
    // 移除特定选择器的委托
    offBySelector(selector) {
        this.delegates.forEach((delegatesByType) => {
            delegatesByType.forEach((delegate, key) => {
                if (delegate.selector === selector) {
                    delegate.active = false;
                    delegatesByType.delete(key);
                }
            });
        });
    }
    
    // 一次性委托
    once(eventType, selector, handler, options = {}) {
        return this.on(eventType, selector, handler, { ...options, once: true });
    }
    
    // 条件委托
    conditional(eventType, selector, condition, handler, options = {}) {
        const conditionalHandler = (event) => {
            if (condition(event)) {
                return handler(event);
            }
        };
        
        return this.on(eventType, selector, conditionalHandler, options);
    }
}

// 使用高级事件委托
const advancedContainer = document.getElementById('advancedContainer');
const advancedDelegation = new AdvancedEventDelegation(advancedContainer);

// 基本委托
const deleteId = advancedDelegation.on('click', '.delete-btn', function(event) {
    console.log('删除按钮点击');
    this.closest('.item').remove();
});

// 一次性委托
const onceId = advancedDelegation.once('click', '.once-btn', function(event) {
    console.log('这只执行一次');
});

// 条件委托
const conditionalId = advancedDelegation.conditional(
    'click',
    '.conditional-btn',
    (event) => event.ctrlKey, // 只有按住 Ctrl 时才触发
    function(event) {
        console.log('按住 Ctrl 点击条件按钮');
    }
);

// 智能事件委托
class SmartEventDelegation {
    constructor(container) {
        this.container = container;
        this.delegates = new Map();
        this.delegateId = 0;
        this.eventCache = new Map();
    }
    
    // 智能委托
    delegate(config) {
        const id = ++this.delegateId;
        const delegate = {
            id,
            ...config,
            active: true,
            stats: {
                calls: 0,
                lastCall: 0
            }
        };
        
        // 处理多个事件类型
        const eventTypes = Array.isArray(config.event) ? config.event : [config.event];
        
        eventTypes.forEach(eventType => {
            if (!this.delegates.has(eventType)) {
                this.delegates.set(eventType, new Map());
                this.setupSmartListener(eventType);
            }
            
            const key = `${config.selector}_${id}`;
            this.delegates.get(eventType).set(key, delegate);
        });
        
        return id;
    }
    
    // 设置智能监听器
    setupSmartListener(eventType) {
        this.container.addEventListener(eventType, (event) => {
            this.processSmartEvent(event);
        }, false);
    }
    
    // 处理智能事件
    processSmartEvent(event) {
        const eventType = event.type;
        const delegates = this.delegates.get(eventType);
        
        if (!delegates) return;
        
        const matchedDelegates = this.findMatchingDelegates(event, delegates);
        
        // 按优先级排序
        matchedDelegates.sort((a, b) => {
            const priorityA = a.delegate.priority || 0;
            const priorityB = b.delegate.priority || 0;
            return priorityB - priorityA; // 高优先级先执行
        });
        
        // 执行匹配的委托
        matchedDelegates.forEach(({ delegate, target }) => {
            if (delegate.active && this.shouldExecute(delegate, event)) {
                this.executeDelegate(delegate, target, event);
            }
        });
    }
    
    // 查找匹配的委托
    findMatchingDelegates(event, delegates) {
        const matched = [];
        let target = event.target;
        
        while (target && target !== this.container) {
            delegates.forEach((delegate, key) => {
                if (delegate.active && this.matchesSelector(target, delegate.selector)) {
                    matched.push({ delegate, target, key });
                }
            });
            target = target.parentElement;
        }
        
        return matched;
    }
    
    // 检查选择器匹配
    matchesSelector(element, selector) {
        try {
            return element.matches(selector);
        } catch (error) {
            console.warn('无效的选择器:', selector);
            return false;
        }
    }
    
    // 检查是否应该执行委托
    shouldExecute(delegate, event) {
        // 检查条件
        if (delegate.condition && !delegate.condition(event)) {
            return false;
        }
        
        // 检查节流
        if (delegate.throttle) {
            const now = Date.now();
            if (now - delegate.stats.lastCall < delegate.throttle) {
                return false;
            }
        }
        
        // 检查防抖
        if (delegate.debounce) {
            if (delegate._debounceTimer) {
                clearTimeout(delegate._debounceTimer);
            }
            
            delegate._debounceTimer = setTimeout(() => {
                this.executeDelegate(delegate, event.target, event);
            }, delegate.debounce);
            
            return false;
        }
        
        return true;
    }
    
    // 执行委托
    executeDelegate(delegate, target, event) {
        try {
            // 更新统计信息
            delegate.stats.calls++;
            delegate.stats.lastCall = Date.now();
            
            // 执行处理函数
            const result = delegate.handler.call(target, event, delegate);
            
            // 处理选项
            this.handleOptions(delegate, event, result);
            
        } catch (error) {
            console.error('委托执行错误:', error);
            if (delegate.onError) {
                delegate.onError(error, event, delegate);
            }
        }
    }
    
    // 处理选项
    handleOptions(delegate, event, result) {
        // 一次性执行
        if (delegate.once) {
            delegate.active = false;
        }
        
        // 阻止冒泡
        if (delegate.stopPropagation) {
            event.stopPropagation();
        }
        
        // 阻止默认行为
        if (delegate.preventDefault) {
            event.preventDefault();
        }
        
        // 返回 false 时阻止默认行为和冒泡
        if (result === false) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    
    // 移除委托
    undelegate(id) {
        this.delegates.forEach((delegatesByType) => {
            delegatesByType.forEach((delegate, key) => {
                if (delegate.id === id) {
                    delegate.active = false;
                    delegatesByType.delete(key);
                    
                    // 清理防抖定时器
                    if (delegate._debounceTimer) {
                        clearTimeout(delegate._debounceTimer);
                    }
                }
            });
        });
    }
    
    // 获取委托统计信息
    getStats() {
        const stats = [];
        this.delegates.forEach((delegatesByType, eventType) => {
            delegatesByType.forEach((delegate) => {
                stats.push({
                    id: delegate.id,
                    eventType,
                    selector: delegate.selector,
                    calls: delegate.stats.calls,
                    lastCall: delegate.stats.lastCall
                });
            });
        });
        return stats;
    }
    
    // 清空所有委托
    clear() {
        this.delegates.forEach((delegatesByType) => {
            delegatesByType.forEach((delegate) => {
                delegate.active = false;
                if (delegate._debounceTimer) {
                    clearTimeout(delegate._debounceTimer);
                }
            });
        });
        this.delegates.clear();
        this.eventCache.clear();
    }
}

// 使用智能事件委托
const smartContainer = document.getElementById('smartContainer');
const smartDelegation = new SmartEventDelegation(smartContainer);

// 基本委托
smartDelegation.delegate({
    event: 'click',
    selector: '.btn-primary',
    handler: function(event, delegate) {
        console.log('主要按钮点击');
    }
});

// 带优先级的委托
smartDelegation.delegate({
    event: 'click',
    selector: '.btn-danger',
    handler: function(event, delegate) {
        console.log('危险按钮点击（高优先级）');
    },
    priority: 10
});

// 带节流的委托
smartDelegation.delegate({
    event: 'scroll',
    selector: '.scroll-container',
    handler: function(event, delegate) {
        console.log('滚动事件（节流）');
    },
    throttle: 100 // 100ms 内最多执行一次
});

// 带防抖的委托
smartDelegation.delegate({
    event: 'input',
    selector: '.search-input',
    handler: function(event, delegate) {
        console.log('搜索输入（防抖）:', event.target.value);
    },
    debounce: 300 // 300ms 后执行
});

// 带条件的委托
smartDelegation.delegate({
    event: 'click',
    selector: '.conditional-btn',
    handler: function(event, delegate) {
        console.log('条件按钮点击');
    },
    condition: (event) => event.ctrlKey // 只有按住 Ctrl 时才执行
});

// 一次性委托
smartDelegation.delegate({
    event: 'click',
    selector: '.once-btn',
    handler: function(event, delegate) {
        console.log('这只执行一次');
    },
    once: true
});

// 带错误处理的委托
smartDelegation.delegate({
    event: 'click',
    selector: '.error-btn',
    handler: function(event, delegate) {
        throw new Error('模拟错误');
    },
    onError: (error, event, delegate) => {
        console.log('处理错误:', error.message);
    }
});

// 事件委托工具类
class EventDelegationUtils {
    // 创建委托配置
    static createDelegate(event, selector, handler, options = {}) {
        return {
            event: Array.isArray(event) ? event : [event],
            selector,
            handler,
            ...options
        };
    }
    
    // 批量委托
    static batchDelegate(container, delegates) {
        const delegation = new SmartEventDelegation(container);
        const ids = [];
        
        delegates.forEach(delegate => {
            const id = delegation.delegate(delegate);
            ids.push(id);
        });
        
        return {
            delegation,
            ids,
            destroy: () => ids.forEach(id => delegation.undelegate(id))
        };
    }
    
    // 委托事件映射
    static mapEvents(container, eventMap) {
        const delegation = new SmartEventDelegation(container);
        const ids = [];
        
        Object.keys(eventMap).forEach(key => {
            const [eventType, selector] = key.split(' ');
            const handler = eventMap[key];
            
            const id = delegation.delegate({
                event: eventType,
                selector: selector,
                handler: handler
            });
            
            ids.push(id);
        });
        
        return {
            delegation,
            ids,
            destroy: () => ids.forEach(id => delegation.undelegate(id))
        };
    }
    
    // 动态委托
    static dynamicDelegate(container, getDelegateConfig) {
        const delegation = new SmartEventDelegation(container);
        
        return (event) => {
            const config = getDelegateConfig(event);
            if (config) {
                return delegation.delegate(config);
            }
            return null;
        };
    }
    
    // 委托链
    static chainDelegates(container, ...delegates) {
        const delegation = new SmartEventDelegation(container);
        const chain = [];
        
        delegates.forEach((delegate, index) => {
            const id = delegation.delegate({
                ...delegate,
                priority: delegates.length - index, // 后面的优先级更高
                handler: function(event, delegateInfo) {
                    const result = delegate.handler.call(this, event, delegateInfo);
                    if (result !== false && chain[index + 1]) {
                        // 继续执行下一个委托
                        return chain[index + 1].handler.call(this, event, chain[index + 1]);
                    }
                    return result;
                }
            });
            
            chain.push({ ...delegate, id });
        });
        
        return {
            delegation,
            chain,
            destroy: () => chain.forEach(item => delegation.undelegate(item.id))
        };
    }
}

// 使用事件委托工具
// 批量委托
const batchResult = EventDelegationUtils.batchDelegate(document, [
    {
        event: 'click',
        selector: '.btn-save',
        handler: function() { console.log('保存按钮'); }
    },
    {
        event: 'click',
        selector: '.btn-cancel',
        handler: function() { console.log('取消按钮'); }
    }
]);

// 事件映射
const mapResult = EventDelegationUtils.mapEvents(document, {
    'click .btn-submit': function() { console.log('提交按钮'); },
    'click .btn-reset': function() { console.log('重置按钮'); },
    'input .form-input': function() { console.log('表单输入'); }
});

// 动态委托
const dynamicHandler = EventDelegationUtils.dynamicDelegate(document, (event) => {
    if (event.target.classList.contains('dynamic-btn')) {
        return {
            event: 'click',
            selector: '.dynamic-btn',
            handler: function() { console.log('动态按钮'); }
        };
    }
    return null;
});

// 委托链
const chainResult = EventDelegationUtils.chainDelegates(document,
    {
        event: 'click',
        selector: '.chain-btn',
        handler: function() { 
            console.log('链式委托1'); 
            return true; // 继续执行下一个
        }
    },
    {
        event: 'click',
        selector: '.chain-btn',
        handler: function() { 
            console.log('链式委托2'); 
            return false; // 停止执行
        }
    }
);

// 事件委托性能优化
class OptimizedEventDelegation {
    constructor(container) {
        this.container = container;
        this.delegates = new Map();
        this.selectorCache = new Map();
        this.eventCache = new Map();
    }
    
    // 优化的选择器匹配
    matchesSelector(element, selector) {
        // 缓存选择器函数
        if (!this.selectorCache.has(selector)) {
            try {
                // 预编译选择器
                const testElement = document.createElement('div');
                testElement.matches(selector); // 测试选择器有效性
                this.selectorCache.set(selector, (el) => el.matches(selector));
            } catch (error) {
                console.warn('无效的选择器:', selector);
                this.selectorCache.set(selector, () => false);
            }
        }
        
        return this.selectorCache.get(selector)(element);
    }
    
    // 事件委托性能监控
    delegate(eventType, selector, handler, options = {}) {
        const startTime = performance.now();
        
        // 实际委托逻辑
        const result = this.addDelegate(eventType, selector, handler, options);
        
        const endTime = performance.now();
        console.log(`委托添加耗时: ${endTime - startTime}ms`);
        
        return result;
    }
    
    addDelegate(eventType, selector, handler, options) {
        // 实现委托逻辑
        return Math.random(); // 返回模拟的 ID
    }
    
    // 懒加载委托
    lazyDelegate(eventType, selector, handlerFactory, options = {}) {
        let handler;
        
        return this.delegate(eventType, selector, (event) => {
            if (!handler) {
                handler = handlerFactory();
            }
            return handler(event);
        }, options);
    }
    
    // 委托池
    delegatePool(maxSize = 100) {
        const pool = [];
        const active = new Set();
        
        return {
            get: (eventType, selector, handler) => {
                // 从池中获取或创建委托
                const delegate = pool.pop() || this.createDelegate(eventType, selector, handler);
                active.add(delegate);
                return delegate;
            },
            
            release: (delegate) => {
                if (active.has(delegate)) {
                    active.delete(delegate);
                    if (pool.length < maxSize) {
                        pool.push(delegate);
                    }
                }
            }
        };
    }
}

// 使用优化的事件委托
const optimizedContainer = document.getElementById('optimizedContainer');
const optimizedDelegation = new OptimizedEventDelegation(optimizedContainer);

// 懒加载委托
const lazyId = optimizedDelegation.lazyDelegate('click', '.heavy-btn', () => {
    // 懒加载重型处理函数
    return function(event) {
        console.log('重型处理函数执行');
    };
});

// 委托池
const pool = optimizedDelegation.delegatePool();
```