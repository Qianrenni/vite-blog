## 18.2 数据库集成

### 关系型数据库连接

**MySQL 集成：**
```javascript
const mysql = require('mysql2/promise');
const { createPool } = require('mysql2/promise');

// 基础连接
const connection = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'myapp',
    charset: 'utf8mb4'
});

// 连接池配置
const pool = createPool({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'myapp',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    acquireTimeout: 60000,
    timeout: 60000
});

// 用户模型
class UserModel {
    constructor(pool) {
        this.pool = pool;
    }

    async findAll(page = 1, limit = 10) {
        const offset = (page - 1) * limit;
        const [rows] = await this.pool.execute(
            'SELECT * FROM users LIMIT ? OFFSET ?',
            [limit, offset]
        );
        const [[countResult]] = await this.pool.execute('SELECT COUNT(*) as total FROM users');
        
        return {
            data: rows,
            pagination: {
                page,
                limit,
                total: countResult.total
            }
        };
    }

    async findById(id) {
        const [rows] = await this.pool.execute(
            'SELECT * FROM users WHERE id = ?',
            [id]
        );
        return rows[0];
    }

    async create(userData) {
        const { name, email, password } = userData;
        const [result] = await this.pool.execute(
            'INSERT INTO users (name, email, password) VALUES (?, ?, ?)',
            [name, email, password]
        );
        return { id: result.insertId, ...userData };
    }

    async update(id, userData) {
        const fields = [];
        const values = [];
        
        Object.keys(userData).forEach(key => {
            if (key !== 'id') {
                fields.push(`${key} = ?`);
                values.push(userData[key]);
            }
        });
        
        values.push(id);
        
        const [result] = await this.pool.execute(
            `UPDATE users SET ${fields.join(', ')} WHERE id = ?`,
            values
        );
        
        return result.affectedRows > 0;
    }

    async delete(id) {
        const [result] = await this.pool.execute(
            'DELETE FROM users WHERE id = ?',
            [id]
        );
        return result.affectedRows > 0;
    }

    async findByEmail(email) {
        const [rows] = await this.pool.execute(
            'SELECT * FROM users WHERE email = ?',
            [email]
        );
        return rows[0];
    }
}

// 事务处理
class UserService {
    constructor(userModel) {
        this.userModel = userModel;
    }

    async createUserWithProfile(userData, profileData) {
        const connection = await pool.getConnection();
        
        try {
            await connection.beginTransaction();
            
            // 创建用户
            const [userResult] = await connection.execute(
                'INSERT INTO users (name, email, password) VALUES (?, ?, ?)',
                [userData.name, userData.email, userData.password]
            );
            
            const userId = userResult.insertId;
            
            // 创建用户资料
            await connection.execute(
                'INSERT INTO user_profiles (user_id, bio, avatar) VALUES (?, ?, ?)',
                [userId, profileData.bio, profileData.avatar]
            );
            
            await connection.commit();
            
            return { userId, ...userData };
        } catch (error) {
            await connection.rollback();
            throw error;
        } finally {
            connection.release();
        }
    }
}

// 使用示例
const userModel = new UserModel(pool);
const userService = new UserService(userModel);

// 查询优化
class OptimizedUserModel {
    async findWithPosts(userId) {
        const [rows] = await this.pool.execute(`
            SELECT u.*, 
                   JSON_ARRAYAGG(
                       JSON_OBJECT(
                           'id', p.id,
                           'title', p.title,
                           'content', p.content
                       )
                   ) as posts
            FROM users u
            LEFT JOIN posts p ON u.id = p.user_id
            WHERE u.id = ?
            GROUP BY u.id
        `, [userId]);
        
        return rows[0];
    }
}
```

**PostgreSQL 集成：**
```javascript
const { Pool, Client } = require('pg');
const { promisify } = require('util');

// PostgreSQL 连接池
const pool = new Pool({
    user: 'postgres',
    host: 'localhost',
    database: 'myapp',
    password: 'password',
    port: 5432,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});

// 数据库查询构建器
class QueryBuilder {
    constructor(pool) {
        this.pool = pool;
        this.table = '';
        this.selectFields = ['*'];
        this.whereConditions = [];
        this.orderByClause = '';
        this.limitClause = '';
        this.offsetClause = '';
    }

    table(tableName) {
        this.table = tableName;
        return this;
    }

    select(fields) {
        this.selectFields = Array.isArray(fields) ? fields : [fields];
        return this;
    }

    where(field, operator, value) {
        this.whereConditions.push({ field, operator, value });
        return this;
    }

    orderBy(field, direction = 'ASC') {
        this.orderByClause = `ORDER BY ${field} ${direction}`;
        return this;
    }

    limit(count) {
        this.limitClause = `LIMIT ${count}`;
        return this;
    }

    offset(count) {
        this.offsetClause = `OFFSET ${count}`;
        return this;
    }

    async execute() {
        if (!this.table) {
            throw new Error('Table name is required');
        }

        let query = `SELECT ${this.selectFields.join(', ')} FROM ${this.table}`;
        const values = [];

        if (this.whereConditions.length > 0) {
            const whereClause = this.whereConditions
                .map((condition, index) => {
                    values.push(condition.value);
                    return `${condition.field} ${condition.operator} $${values.length}`;
                })
                .join(' AND ');
            query += ` WHERE ${whereClause}`;
        }

        if (this.orderByClause) query += ` ${this.orderByClause}`;
        if (this.limitClause) query += ` ${this.limitClause}`;
        if (this.offsetClause) query += ` ${this.offsetClause}`;

        const result = await this.pool.query(query, values);
        return result.rows;
    }
}

// 用户服务
class UserService {
    constructor(pool) {
        this.pool = pool;
    }

    async findAll(options = {}) {
        const { page = 1, limit = 10, sortBy = 'id', sortOrder = 'ASC' } = options;
        
        const offset = (page - 1) * limit;
        
        const query = `
            SELECT u.*, 
                   COUNT(p.id) as post_count
            FROM users u
            LEFT JOIN posts p ON u.id = p.user_id
            GROUP BY u.id
            ORDER BY ${sortBy} ${sortOrder}
            LIMIT $1 OFFSET $2
        `;
        
        const countQuery = 'SELECT COUNT(*) as total FROM users';
        
        const [result, countResult] = await Promise.all([
            this.pool.query(query, [limit, offset]),
            this.pool.query(countQuery)
        ]);
        
        return {
            data: result.rows,
            pagination: {
                page,
                limit,
                total: parseInt(countResult.rows[0].total)
            }
        };
    }

    async findById(id) {
        const query = `
            SELECT u.*, 
                   json_agg(
                       json_build_object(
                           'id', p.id,
                           'title', p.title,
                           'created_at', p.created_at
                       )
                   ) as posts
            FROM users u
            LEFT JOIN posts p ON u.id = p.user_id
            WHERE u.id = $1
            GROUP BY u.id
        `;
        
        const result = await this.pool.query(query, [id]);
        return result.rows[0];
    }

    async create(userData) {
        const { name, email, password } = userData;
        
        const query = `
            INSERT INTO users (name, email, password, created_at)
            VALUES ($1, $2, $3, NOW())
            RETURNING *
        `;
        
        const result = await this.pool.query(query, [name, email, password]);
        return result.rows[0];
    }

    async update(id, userData) {
        const fields = [];
        const values = [];
        let index = 1;
        
        Object.keys(userData).forEach(key => {
            if (key !== 'id') {
                fields.push(`${key} = $${index}`);
                values.push(userData[key]);
                index++;
            }
        });
        
        if (fields.length === 0) {
            throw new Error('No fields to update');
        }
        
        values.push(id);
        
        const query = `
            UPDATE users 
            SET ${fields.join(', ')}, updated_at = NOW()
            WHERE id = $${index}
            RETURNING *
        `;
        
        const result = await this.pool.query(query, values);
        return result.rows[0];
    }

    async delete(id) {
        const query = 'DELETE FROM users WHERE id = $1 RETURNING *';
        const result = await this.pool.query(query, [id]);
        return result.rowCount > 0;
    }
}

// 数据库连接管理
class DatabaseManager {
    constructor() {
        this.pool = pool;
        this.setupListeners();
    }

    setupListeners() {
        this.pool.on('connect', (client) => {
            console.log('数据库连接建立');
        });

        this.pool.on('error', (err) => {
            console.error('数据库连接错误:', err);
        });

        this.pool.on('acquire', (client) => {
            console.log('获取数据库连接');
        });

        this.pool.on('release', (client) => {
            console.log('释放数据库连接');
        });
    }

    async query(text, params) {
        const start = Date.now();
        const res = await this.pool.query(text, params);
        const duration = Date.now() - start;
        console.log('执行查询', { text, duration, rows: res.rowCount });
        return res;
    }

    async close() {
        await this.pool.end();
    }
}

// 使用示例
const dbManager = new DatabaseManager();
const userService = new UserService(dbManager.pool);

// 批量操作
class BatchOperations {
    static async batchInsert(pool, tableName, data) {
        if (data.length === 0) return [];
        
        const columns = Object.keys(data[0]);
        const values = data.map(row => Object.values(row));
        
        const placeholders = values.map((_, index) => {
            const start = index * columns.length + 1;
            return `(${Array(columns.length).fill().map((_, i) => `$${start + i}`).join(', ')})`;
        }).join(', ');
        
        const flatValues = values.flat();
        const query = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES ${placeholders} RETURNING *`;
        
        const result = await pool.query(query, flatValues);
        return result.rows;
    }

    static async batchUpdate(pool, tableName, updates, conditionField) {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');
            
            for (const update of updates) {
                const fields = Object.keys(update).filter(key => key !== conditionField);
                const values = fields.map(field => update[field]);
                values.push(update[conditionField]);
                
                const query = `
                    UPDATE ${tableName}
                    SET ${fields.map((field, index) => `${field} = $${index + 1}`).join(', ')}
                    WHERE ${conditionField} = $${fields.length + 1}
                `;
                
                await client.query(query, values);
            }
            
            await client.query('COMMIT');
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }
}
```

### NoSQL 数据库操作

**MongoDB 集成：**
```javascript
const mongoose = require('mongoose');
const { MongoClient } = require('mongodb');

// Mongoose 模型定义
const userSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        trim: true,
        maxlength: 100
    },
    email: {
        type: String,
        required: true,
        unique: true,
        lowercase: true,
        match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, '请输入有效的邮箱']
    },
    password: {
        type: String,
        required: true,
        minlength: 6
    },
    profile: {
        bio: String,
        avatar: String,
        location: String
    },
    preferences: {
        newsletter: { type: Boolean, default: false },
        notifications: {
            email: { type: Boolean, default: true },
            push: { type: Boolean, default: true }
        }
    },
    roles: [{
        type: String,
        enum: ['user', 'admin', 'moderator']
    }],
    isActive: {
        type: Boolean,
        default: true
    }
}, {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// 虚拟字段
userSchema.virtual('fullName').get(function() {
    return `${this.firstName} ${this.lastName}`;
});

// 索引
userSchema.index({ email: 1 });
userSchema.index({ createdAt: -1 });
userSchema.index({ 'profile.location': 1 });

// 中间件
userSchema.pre('save', function(next) {
    if (this.isModified('password')) {
        // 密码加密逻辑
        this.password = hashPassword(this.password);
    }
    next();
});

userSchema.pre('find', function() {
    this.where({ isActive: true });
});

// 实例方法
userSchema.methods.comparePassword = function(candidatePassword) {
    return comparePasswords(candidatePassword, this.password);
};

// 静态方法
userSchema.statics.findByEmail = function(email) {
    return this.findOne({ email: email.toLowerCase() });
};

userSchema.statics.findActiveUsers = function() {
    return this.find({ isActive: true });
};

const User = mongoose.model('User', userSchema);

// MongoDB 原生驱动
class MongoService {
    constructor() {
        this.client = null;
        this.db = null;
    }

    async connect(uri, dbName) {
        this.client = new MongoClient(uri, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            maxPoolSize: 10,
            serverSelectionTimeoutMS: 5000,
            socketTimeoutMS: 45000,
        });
        
        await this.client.connect();
        this.db = this.client.db(dbName);
        console.log('MongoDB 连接成功');
    }

    async disconnect() {
        if (this.client) {
            await this.client.close();
            console.log('MongoDB 连接关闭');
        }
    }

    getCollection(collectionName) {
        return this.db.collection(collectionName);
    }

    // 聚合查询
    async getUserStats() {
        const collection = this.getCollection('users');
        
        const pipeline = [
            {
                $group: {
                    _id: null,
                    totalUsers: { $sum: 1 },
                    activeUsers: {
                        $sum: {
                            $cond: [{ $eq: ['$isActive', true] }, 1, 0]
                        }
                    },
                    avgAge: { $avg: '$age' }
                }
            }
        ];
        
        const result = await collection.aggregate(pipeline).toArray();
        return result[0] || { totalUsers: 0, activeUsers: 0, avgAge: 0 };
    }

    // 复杂查询
    async searchUsers(searchTerm, options = {}) {
        const { page = 1, limit = 10, sortBy = 'createdAt', sortOrder = -1 } = options;
        const skip = (page - 1) * limit;
        
        const collection = this.getCollection('users');
        
        const searchPipeline = [
            {
                $search: {
                    index: 'default',
                    text: {
                        query: searchTerm,
                        path: ['name', 'email', 'bio']
                    }
                }
            },
            {
                $match: {
                    isActive: true
                }
            },
            {
                $addFields: {
                    score: { $meta: 'searchScore' }
                }
            },
            {
                $sort: {
                    score: { $meta: 'textScore' },
                    [sortBy]: sortOrder
                }
            },
            {
                $skip: skip
            },
            {
                $limit: limit
            }
        ];
        
        const [results, totalCount] = await Promise.all([
            collection.aggregate(searchPipeline).toArray(),
            collection.countDocuments({
                $text: { $search: searchTerm },
                isActive: true
            })
        ]);
        
        return {
            data: results,
            pagination: {
                page,
                limit,
                total: totalCount
            }
        };
    }
}

// Redis 集成
const redis = require('redis');

class CacheService {
    constructor() {
        this.client = redis.createClient({
            host: 'localhost',
            port: 6379,
            retry_strategy: (options) => {
                if (options.error && options.error.code === 'ECONNREFUSED') {
                    return new Error('Redis 服务器拒绝连接');
                }
                if (options.total_retry_time > 1000 * 60 * 60) {
                    return new Error('重试时间已用完');
                }
                if (options.attempt > 10) {
                    return undefined;
                }
                return Math.min(options.attempt * 100, 3000);
            }
        });
        
        this.client.on('error', (err) => {
            console.error('Redis 错误:', err);
        });
        
        this.client.on('connect', () => {
            console.log('Redis 连接成功');
        });
    }

    async get(key) {
        try {
            const value = await this.client.get(key);
            return value ? JSON.parse(value) : null;
        } catch (error) {
            console.error('Redis GET 错误:', error);
            return null;
        }
    }

    async set(key, value, expireSeconds = 3600) {
        try {
            await this.client.setex(key, expireSeconds, JSON.stringify(value));
            return true;
        } catch (error) {
            console.error('Redis SET 错误:', error);
            return false;
        }
    }

    async del(key) {
        try {
            await this.client.del(key);
            return true;
        } catch (error) {
            console.error('Redis DEL 错误:', error);
            return false;
        }
    }

    async exists(key) {
        try {
            const result = await this.client.exists(key);
            return result === 1;
        } catch (error) {
            console.error('Redis EXISTS 错误:', error);
            return false;
        }
    }

    async hset(hashKey, field, value) {
        try {
            await this.client.hset(hashKey, field, JSON.stringify(value));
            return true;
        } catch (error) {
            console.error('Redis HSET 错误:', error);
            return false;
        }
    }

    async hget(hashKey, field) {
        try {
            const value = await this.client.hget(hashKey, field);
            return value ? JSON.parse(value) : null;
        } catch (error) {
            console.error('Redis HGET 错误:', error);
            return null;
        }
    }
}

// 使用示例
const mongoService = new MongoService();
const cacheService = new CacheService();

class UserService {
    constructor(mongoService, cacheService) {
        this.mongoService = mongoService;
        this.cacheService = cacheService;
    }

    async getUserById(id) {
        // 先从缓存获取
        const cacheKey = `user:${id}`;
        let user = await this.cacheService.get(cacheKey);
        
        if (user) {
            console.log('从缓存获取用户数据');
            return user;
        }
        
        // 从数据库获取
        const collection = this.mongoService.getCollection('users');
        user = await collection.findOne({ _id: new ObjectId(id), isActive: true });
        
        if (user) {
            // 存入缓存
            await this.cacheService.set(cacheKey, user, 3600); // 缓存1小时
        }
        
        return user;
    }

    async updateUser(id, updateData) {
        const collection = this.mongoService.getCollection('users');
        const result = await collection.updateOne(
            { _id: new ObjectId(id) },
            { $set: { ...updateData, updatedAt: new Date() } }
        );
        
        if (result.modifiedCount > 0) {
            // 清除缓存
            const cacheKey = `user:${id}`;
            await this.cacheService.del(cacheKey);
        }
        
        return result.modifiedCount > 0;
    }
}
```

### ORM 框架使用

**Sequelize ORM：**
```javascript
const { Sequelize, DataTypes, Model } = require('sequelize');

// 数据库连接
const sequelize = new Sequelize('database', 'username', 'password', {
    host: 'localhost',
    dialect: 'mysql',
    pool: {
        max: 5,
        min: 0,
        acquire: 30000,
        idle: 10000
    },
    logging: false, // 生产环境关闭日志
    timezone: '+08:00'
});

// 模型定义
class User extends Model {
    // 实例方法
    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    
    // 验证方法
    async isValidPassword(password) {
        return await bcrypt.compare(password, this.password);
    }
}

User.init({
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    firstName: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
            notEmpty: true,
            len: [2, 50]
        }
    },
    lastName: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
            notEmpty: true,
            len: [2, 50]
        }
    },
    email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: {
            isEmail: true,
            notEmpty: true
        }
    },
    password: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
            notEmpty: true,
            len: [6, 100]
        }
    },
    isActive: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
    }
}, {
    sequelize,
    modelName: 'User',
    tableName: 'users',
    timestamps: true,
    paranoid: true, // 软删除
    indexes: [
        {
            unique: true,
            fields: ['email']
        }
    ],
    hooks: {
        beforeCreate: async (user) => {
            if (user.password) {
                user.password = await bcrypt.hash(user.password, 10);
            }
        },
        beforeUpdate: async (user) => {
            if (user.changed('password')) {
                user.password = await bcrypt.hash(user.password, 10);
            }
        }
    }
});

// 关联关系
class Post extends Model {}
Post.init({
    title: DataTypes.STRING,
    content: DataTypes.TEXT,
    published: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
    }
}, { sequelize, modelName: 'Post' });

// 一对多关系
User.hasMany(Post, { foreignKey: 'userId' });
Post.belongsTo(User, { foreignKey: 'userId' });

// 多对多关系
class Tag extends Model {}
Tag.init({ name: DataTypes.STRING }, { sequelize, modelName: 'Tag' });

const PostTag = sequelize.define('PostTag', {}, { timestamps: false });

Post.belongsToMany(Tag, { through: PostTag });
Tag.belongsToMany(Post, { through: PostTag });

// 查询构建器
class UserQuery {
    constructor() {
        this.options = {
            where: {},
            include: [],
            order: [],
            limit: null,
            offset: 0
        };
    }

    where(conditions) {
        Object.assign(this.options.where, conditions);
        return this;
    }

    include(models) {
        this.options.include = this.options.include.concat(models);
        return this;
    }

    order(field, direction = 'ASC') {
        this.options.order.push([field, direction]);
        return this;
    }

    paginate(page = 1, limit = 10) {
        this.options.limit = limit;
        this.options.offset = (page - 1) * limit;
        return this;
    }

    async execute() {
        return await User.findAndCountAll(this.options);
    }
}

// 服务层
class UserService {
    static async createUser(userData) {
        try {
            const user = await User.create(userData);
            return user;
        } catch (error) {
            if (error.name === 'SequelizeUniqueConstraintError') {
                throw new Error('邮箱已存在');
            }
            throw error;
        }
    }

    static async findUsers(options = {}) {
        const { page = 1, limit = 10, search, sortBy = 'id', sortOrder = 'ASC' } = options;
        
        const query = new UserQuery()
            .paginate(page, limit)
            .order(sortBy, sortOrder);

        if (search) {
            query.where({
                [Sequelize.Op.or]: [
                    { firstName: { [Sequelize.Op.like]: `%${search}%` } },
                    { lastName: { [Sequelize.Op.like]: `%${search}%` } },
                    { email: { [Sequelize.Op.like]: `%${search}%` } }
                ]
            });
        }

        const result = await query.execute();
        
        return {
            data: result.rows,
            pagination: {
                page,
                limit,
                total: result.count
            }
        };
    }

    static async getUserWithPosts(userId) {
        return await User.findByPk(userId, {
            include: [{
                model: Post,
                where: { published: true },
                required: false
            }]
        });
    }

    static async getUserWithTags(userId) {
        return await User.findByPk(userId, {
            include: [{
                model: Post,
                include: [Tag]
            }]
        });
    }
}

// 事务处理
class TransactionService {
    static async transferMoney(fromUserId, toUserId, amount) {
        const transaction = await sequelize.transaction();
        
        try {
            // 扣除金额
            const fromUser = await User.findByPk(fromUserId, { transaction });
            if (fromUser.balance < amount) {
                throw new Error('余额不足');
            }
            await fromUser.update({ balance: fromUser.balance - amount }, { transaction });
            
            // 增加金额
            const toUser = await User.findByPk(toUserId, { transaction });
            await toUser.update({ balance: toUser.balance + amount }, { transaction });
            
            // 记录交易
            await Transaction.create({
                fromUserId,
                toUserId,
                amount,
                status: 'completed'
            }, { transaction });
            
            await transaction.commit();
            return { success: true };
        } catch (error) {
            await transaction.rollback();
            throw error;
        }
    }
}

// 数据库同步
async function syncDatabase() {
    try {
        await sequelize.authenticate();
        console.log('数据库连接成功');
        
        // 同步模型
        await sequelize.sync({ alter: true }); // 开发环境使用
        // await sequelize.sync({ force: true }); // 生产环境谨慎使用
        
        console.log('数据库同步完成');
    } catch (error) {
        console.error('数据库连接失败:', error);
    }
}

syncDatabase();
```

### 数据库连接池

**连接池管理：**
```javascript
// 通用连接池管理器
class ConnectionPool {
    constructor(createConnection, options = {}) {
        this.createConnection = createConnection;
        this.maxConnections = options.maxConnections || 10;
        this.minConnections = options.minConnections || 2;
        this.idleTimeout = options.idleTimeout || 30000;
        this.acquireTimeout = options.acquireTimeout || 30000;
        
        this.pool = [];
        this.busy = new Set();
        this.waiting = [];
        this.closed = false;
        
        // 初始化最小连接数
        this.initialize();
    }

    async initialize() {
        for (let i = 0; i < this.minConnections; i++) {
            try {
                const connection = await this.createConnection();
                this.pool.push({
                    connection,
                    lastUsed: Date.now(),
                    idle: true
                });
            } catch (error) {
                console.error('连接池初始化失败:', error);
            }
        }
    }

    async acquire() {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('获取连接超时'));
            }, this.acquireTimeout);

            const tryAcquire = () => {
                // 查找空闲连接
                const idleIndex = this.pool.findIndex(item => item.idle);
                if (idleIndex !== -1) {
                    const item = this.pool[idleIndex];
                    item.idle = false;
                    item.lastUsed = Date.now();
                    this.busy.add(item.connection);
                    clearTimeout(timeout);
                    resolve(item.connection);
                    return;
                }

                // 创建新连接（如果未达到最大连接数）
                if (this.pool.length + this.busy.size < this.maxConnections) {
                    this.createConnection()
                        .then(connection => {
                            const item = {
                                connection,
                                lastUsed: Date.now(),
                                idle: false
                            };
                            this.pool.push(item);
                            this.busy.add(connection);
                            clearTimeout(timeout);
                            resolve(connection);
                        })
                        .catch(error => {
                            clearTimeout(timeout);
                            reject(error);
                        });
                    return;
                }

                // 等待连接释放
                this.waiting.push({ resolve, reject, timeout });
            };

            tryAcquire();
        });
    }

    release(connection) {
        const item = this.pool.find(item => item.connection === connection);
        if (item) {
            item.idle = true;
            item.lastUsed = Date.now();
            this.busy.delete(connection);
            
            // 处理等待队列
            if (this.waiting.length > 0) {
                const { resolve, reject, timeout } = this.waiting.shift();
                clearTimeout(timeout);
                this.acquire().then(resolve).catch(reject);
            }
        }
    }

    async close() {
        this.closed = true;
        
        // 关闭所有连接
        const connections = [...this.pool.map(item => item.connection)];
        await Promise.all(connections.map(conn => this.closeConnection(conn)));
        
        this.pool = [];
        this.busy.clear();
        this.waiting.forEach(({ reject }) => {
            reject(new Error('连接池已关闭'));
        });
        this.waiting = [];
    }

    async closeConnection(connection) {
        if (typeof connection.end === 'function') {
            await connection.end();
        } else if (typeof connection.close === 'function') {
            await connection.close();
        }
    }

    getStats() {
        return {
            total: this.pool.length,
            idle: this.pool.filter(item => item.idle).length,
            busy: this.busy.size,
            waiting: this.waiting.length
        };
    }

    // 定期清理空闲连接
    startCleanup() {
        this.cleanupInterval = setInterval(() => {
            const now = Date.now();
            const idleConnections = this.pool
                .filter(item => item.idle && now - item.lastUsed > this.idleTimeout);
            
            idleConnections.forEach(async (item) => {
                const index = this.pool.indexOf(item);
                if (index !== -1) {
                    this.pool.splice(index, 1);
                    await this.closeConnection(item.connection);
                }
            });
        }, this.idleTimeout);
    }

    stopCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
    }
}

// MySQL 连接池
const mysql = require('mysql2/promise');

class MySQLPool extends ConnectionPool {
    constructor(options) {
        const createConnection = () => mysql.createConnection(options);
        super(createConnection, {
            maxConnections: options.connectionLimit || 10,
            minConnections: 2,
            idleTimeout: 30000,
            acquireTimeout: 30000
        });
    }
}

// 使用示例
const mysqlPool = new MySQLPool({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'myapp',
    connectionLimit: 10
});

mysqlPool.startCleanup();

// 数据库操作类
class DatabaseService {
    constructor(pool) {
        this.pool = pool;
    }

    async query(sql, params = []) {
        const connection = await this.pool.acquire();
        
        try {
            const [rows] = await connection.execute(sql, params);
            return rows;
        } finally {
            this.pool.release(connection);
        }
    }

    async transaction(callback) {
        const connection = await this.pool.acquire();
        
        try {
            await connection.beginTransaction();
            
            const result = await callback(connection);
            
            await connection.commit();
            return result;
        } catch (error) {
            await connection.rollback();
            throw error;
        } finally {
            this.pool.release(connection);
        }
    }

    getStats() {
        return this.pool.getStats();
    }
}

// 使用连接池
const dbService = new DatabaseService(mysqlPool);

// 查询操作
async function getUsers() {
    return await dbService.query('SELECT * FROM users LIMIT 10');
}

// 事务操作
async function transferMoney(fromId, toId, amount) {
    return await dbService.transaction(async (connection) => {
        await connection.execute(
            'UPDATE accounts SET balance = balance - ? WHERE id = ?',
            [amount, fromId]
        );
        
        await connection.execute(
            'UPDATE accounts SET balance = balance + ? WHERE id = ?',
            [amount, toId]
        );
        
        await connection.execute(
            'INSERT INTO transactions (from_id, to_id, amount) VALUES (?, ?, ?)',
            [fromId, toId, amount]
        );
    });
}

// 监控连接池状态
setInterval(() => {
    console.log('连接池状态:', dbService.getStats());
}, 5000);
```