## 16.2 进程管理

### process 对象使用

**process 对象属性和方法：**
```javascript
// 进程信息
console.log('进程ID:', process.pid);
console.log('进程标题:', process.title);
console.log('Node.js版本:', process.version);
console.log('平台信息:', process.platform);
console.log('架构信息:', process.arch);
console.log('当前工作目录:', process.cwd());
console.log('环境变量:', process.env);

// 内存使用情况
const memoryUsage = process.memoryUsage();
console.log('内存使用:', {
    rss: `${Math.round(memoryUsage.rss / 1024 / 1024)} MB`,
    heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)} MB`,
    heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)} MB`,
    external: `${Math.round(memoryUsage.external / 1024 / 1024)} MB`
});

// CPU 使用时间
const cpuUsage = process.cpuUsage();
console.log('CPU使用:', cpuUsage);

// 进程控制
process.nextTick(() => {
    console.log('下次事件循环开始时执行');
});

// 退出处理
process.on('exit', (code) => {
    console.log(`进程即将退出，退出码: ${code}`);
});

process.on('beforeExit', (code) => {
    console.log(`进程准备退出，退出码: ${code}`);
});

// 信号处理
process.on('SIGINT', () => {
    console.log('接收到 SIGINT 信号 (Ctrl+C)');
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('接收到 SIGTERM 信号');
    process.exit(0);
});

// 异常处理
process.on('uncaughtException', (err) => {
    console.error('未捕获的异常:', err);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('未处理的 Promise 拒绝:', reason);
    process.exit(1);
});
```

### 子进程创建和管理

**child_process 模块使用：**
```javascript
const { spawn, exec, execFile, fork } = require('child_process');
const path = require('path');

// spawn - 执行命令
function spawnExample() {
    const ls = spawn('ls', ['-lh', '/usr']);

    ls.stdout.on('data', (data) => {
        console.log(`stdout: ${data}`);
    });

    ls.stderr.on('data', (data) => {
        console.error(`stderr: ${data}`);
    });

    ls.on('close', (code) => {
        console.log(`子进程退出，退出码 ${code}`);
    });
}

// exec - 执行命令并缓存输出
function execExample() {
    exec('node --version', (error, stdout, stderr) => {
        if (error) {
            console.error(`执行错误: ${error}`);
            return;
        }
        if (stderr) {
            console.error(`stderr: ${stderr}`);
            return;
        }
        console.log(`stdout: ${stdout}`);
    });
}

// execFile - 执行可执行文件
function execFileExample() {
    const child = execFile('node', ['--version'], (error, stdout, stderr) => {
        if (error) {
            throw error;
        }
        console.log(stdout);
    });
}

// fork - 创建 Node.js 子进程
function forkExample() {
    const child = fork(path.join(__dirname, 'child.js'));

    child.on('message', (message) => {
        console.log('来自主进程的消息:', message);
    });

    child.send({ hello: 'world' });

    child.on('exit', (code) => {
        console.log(`子进程退出，退出码: ${code}`);
    });
}
```

**子进程通信：**
```javascript
// parent.js
const { fork } = require('child_process');
const path = require('path');

const child = fork(path.join(__dirname, 'worker.js'));

// 向子进程发送消息
child.send({ type: 'start',  [1, 2, 3, 4, 5] });

// 接收子进程消息
child.on('message', (message) => {
    switch (message.type) {
        case 'result':
            console.log('计算结果:', message.data);
            break;
        case 'progress':
            console.log('进度:', message.data);
            break;
        case 'error':
            console.error('子进程错误:', message.data);
            break;
    }
});

child.on('exit', (code) => {
    console.log('子进程退出，代码:', code);
});

// worker.js
process.on('message', (message) => {
    if (message.type === 'start') {
        const data = message.data;
        
        // 模拟长时间运行的任务
        let result = 0;
        for (let i = 0; i < data.length; i++) {
            result += data[i] * data[i];
            
            // 发送进度更新
            if (i % 1000 === 0) {
                process.send({
                    type: 'progress',
                    data: { current: i, total: data.length }
                });
            }
        }
        
        // 发送结果
        process.send({
            type: 'result',
             result
        });
    }
});

process.on('disconnect', () => {
    console.log('与父进程断开连接');
    process.exit(0);
});
```

### 集群模式应用

**cluster 模块使用：**
```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
    console.log(`主进程 ${process.pid} 正在运行`);
    
    // 衍生工作进程
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
    }
    
    // 工作进程死亡时重新衍生
    cluster.on('exit', (worker, code, signal) => {
        console.log(`工作进程 ${worker.process.pid} 已死亡`);
        cluster.fork(); // 重新启动
    });
    
    // 监听工作进程消息
    cluster.on('message', (worker, message) => {
        console.log(`来自主进程 ${worker.id} 的消息:`, message);
    });
    
} else {
    // 工作进程可以共享任何 TCP 连接
    // 在本例中，它是一个 HTTP 服务器
    http.createServer((req, res) => {
        res.writeHead(200);
        res.end(`Hello World from worker ${process.pid}`);
        
        // 向主进程发送消息
        process.send({ 
            pid: process.pid, 
            url: req.url,
            timestamp: Date.now()
        });
    }).listen(8000);
    
    console.log(`工作进程 ${process.pid} 已启动`);
}
```

**负载均衡集群：**
```javascript
const cluster = require('cluster');
const express = require('express');

if (cluster.isMaster) {
    const numWorkers = require('os').cpus().length;
    
    console.log(`主进程 ${process.pid} 启动，创建 ${numWorkers} 个工作进程`);
    
    // 创建工作进程
    for (let i = 0; i < numWorkers; i++) {
        const worker = cluster.fork();
        
        // 监控工作进程状态
        worker.on('message', (msg) => {
            if (msg.cmd === 'status') {
                console.log(`工作进程 ${worker.id}: ${msg.data}`);
            }
        });
    }
    
    // 处理工作进程死亡
    cluster.on('exit', (worker, code, signal) => {
        console.log(`工作进程 ${worker.process.pid} 退出 (code: ${code})`);
        
        // 重启工作进程
        if (!worker.exitedAfterDisconnect) {
            console.log('重新启动工作进程...');
            cluster.fork();
        }
    });
    
} else {
    // 工作进程代码
    const app = express();
    
    // 中间件统计请求
    let requestCount = 0;
    app.use((req, res, next) => {
        requestCount++;
        next();
    });
    
    // 路由
    app.get('/', (req, res) => {
        res.json({
            message: 'Hello from worker',
            workerId: cluster.worker.id,
            pid: process.pid,
            requestCount: requestCount
        });
    });
    
    app.get('/status', (req, res) => {
        res.json({
            workerId: cluster.worker.id,
            pid: process.pid,
            requestCount: requestCount,
            uptime: process.uptime()
        });
    });
    
    // 定期向主进程报告状态
    setInterval(() => {
        process.send({
            cmd: 'status',
            data: `Worker ${cluster.worker.id} serving ${requestCount} requests`
        });
    }, 5000);
    
    const server = app.listen(3000, () => {
        console.log(`工作进程 ${process.pid} 监听端口 3000`);
    });
    
    // 优雅关闭
    process.on('SIGTERM', () => {
        console.log(`工作进程 ${process.pid} 正在关闭`);
        server.close(() => {
            process.exit(0);
        });
    });
}
```

### 进程间通信机制

**IPC 通信示例：**
```javascript
// master.js
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
    console.log('主进程启动');
    
    // 存储工作进程引用
    const workers = [];
    
    // 创建工作进程
    for (let i = 0; i < numCPUs; i++) {
        const worker = cluster.fork();
        workers.push(worker);
        
        // 处理工作进程消息
        worker.on('message', (msg) => {
            handleWorkerMessage(worker, msg, workers);
        });
    }
    
    // 向所有工作进程广播消息
    function broadcast(message) {
        workers.forEach(worker => {
            if (worker.isConnected()) {
                worker.send(message);
            }
        });
    }
    
    // 处理工作进程消息
    function handleWorkerMessage(sender, message, allWorkers) {
        switch (message.type) {
            case 'task':
                console.log(`收到任务请求 from worker ${sender.id}`);
                // 分配任务给其他工作进程
                const otherWorkers = allWorkers.filter(w => w.id !== sender.id);
                if (otherWorkers.length > 0) {
                    const targetWorker = otherWorkers[0];
                    targetWorker.send({
                        type: 'assigned_task',
                        data: message.data,
                        from: sender.id
                    });
                }
                break;
                
            case 'result':
                console.log(`收到结果 from worker ${sender.id}:`, message.data);
                // 将结果转发给原始请求者
                if (message.originalSender) {
                    const originalWorker = allWorkers.find(w => w.id == message.originalSender);
                    if (originalWorker && originalWorker.isConnected()) {
                        originalWorker.send({
                            type: 'task_result',
                            data: message.data
                        });
                    }
                }
                break;
                
            case 'health_check':
                console.log(`健康检查 from worker ${sender.id}`);
                sender.send({ type: 'health_response', status: 'ok' });
                break;
        }
    }
    
} else {
    // worker.js
    console.log(`工作进程 ${process.pid} 启动`);
    
    // 处理主进程消息
    process.on('message', (message) => {
        switch (message.type) {
            case 'assigned_task':
                console.log(`收到分配的任务:`, message.data);
                // 处理任务
                setTimeout(() => {
                    const result = `处理完成: ${message.data}`;
                    process.send({
                        type: 'result',
                        data: result,
                        originalSender: message.from
                    });
                }, 1000);
                break;
                
            case 'health_response':
                console.log('健康检查响应:', message.status);
                break;
                
            case 'broadcast':
                console.log('广播消息:', message.data);
                break;
        }
    });
    
    // 定期发送健康检查
    setInterval(() => {
        if (process.connected) {
            process.send({ type: 'health_check' });
        }
    }, 10000);
    
    // 发送任务请求
    setTimeout(() => {
        process.send({
            type: 'task',
             '处理大量数据'
        });
    }, 2000);
}
```