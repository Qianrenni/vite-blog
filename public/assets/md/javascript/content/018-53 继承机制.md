## 5.3 继承机制

### 1. 原型链继承

通过原型链实现继承：

```javascript
// 父类
function Animal(name) {
    this.name = name;
    this.colors = ['red', 'blue'];
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

// 子类
function Dog(name, breed) {
    this.name = name;
    this.breed = breed;
}

// 继承
Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log(`${this.name} barks`);
};

const dog1 = new Dog('Buddy', 'Golden Retriever');
const dog2 = new Dog('Max', 'Labrador');

dog1.colors.push('green');
console.log(dog2.colors); // ['red', 'blue', 'green'] - 问题：引用类型属性被共享
```

### 2. 构造函数继承

使用 call/apply 调用父构造函数：

```javascript
function Animal(name) {
    this.name = name;
    this.colors = ['red', 'blue'];
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

function Dog(name, breed) {
    // 继承实例属性
    Animal.call(this, name);
    this.breed = breed;
}

const dog1 = new Dog('Buddy', 'Golden Retriever');
const dog2 = new Dog('Max', 'Labrador');

dog1.colors.push('green');
console.log(dog1.colors); // ['red', 'blue', 'green']
console.log(dog2.colors); // ['red', 'blue'] - 解决了引用类型属性共享问题

// 问题：无法继承原型方法
// dog1.speak(); // TypeError: dog1.speak is not a function
```

### 3. 组合继承模式

结合原型链继承和构造函数继承：

```javascript
function Animal(name) {
    this.name = name;
    this.colors = ['red', 'blue'];
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

function Dog(name, breed) {
    // 继承实例属性（构造函数继承）
    Animal.call(this, name);
    this.breed = breed;
}

// 继承原型方法（原型链继承）
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log(`${this.name} barks`);
};

const dog1 = new Dog('Buddy', 'Golden Retriever');
const dog2 = new Dog('Max', 'Labrador');

dog1.colors.push('green');
console.log(dog1.colors); // ['red', 'blue', 'green']
console.log(dog2.colors); // ['red', 'blue']

dog1.speak(); // Buddy makes a sound
dog1.bark(); // Buddy barks

// 问题：调用了两次父构造函数
```

### 4. ES6 类继承语法

现代的继承方式：

```javascript
// 父类
class Animal {
    constructor(name) {
        this.name = name;
        this.colors = ['red', 'blue'];
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
    
    static getKingdom() {
        return 'Animalia';
    }
}

// 子类
class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 调用父类构造函数
        this.breed = breed;
    }
    
    speak() {
        super.speak(); // 调用父类方法
        console.log(`${this.name} barks`);
    }
    
    bark() {
        console.log(`${this.name} barks loudly`);
    }
}

const dog = new Dog('Buddy', 'Golden Retriever');
dog.speak(); // Buddy makes a sound \n Buddy barks
dog.bark(); // Buddy barks loudly

console.log(Animal.getKingdom()); // Animalia
console.log(Dog.getKingdom()); // Animalia (继承静态方法)

// 检查继承关系
console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
console.log(Dog instanceof Animal); // false
console.log(Dog.prototype instanceof Animal); // true
```

### 高级继承示例

```javascript
// 复杂继承示例
class Shape {
    constructor(color) {
        this.color = color;
    }
    
    getColor() {
        return this.color;
    }
    
    // 抽象方法
    getArea() {
        throw new Error('getArea method must be implemented');
    }
}

class Rectangle extends Shape {
    constructor(color, width, height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    getArea() {
        return this.width * this.height;
    }
    
    getPerimeter() {
        return 2 * (this.width + this.height);
    }
}

class Square extends Rectangle {
    constructor(color, side) {
        super(color, side, side);
        this.side = side;
    }
    
    // 重写方法
    getPerimeter() {
        return 4 * this.side;
    }
}

const rect = new Rectangle('red', 5, 3);
const square = new Square('blue', 4);

console.log(rect.getArea()); // 15
console.log(square.getArea()); // 16
console.log(rect.getPerimeter()); // 16
console.log(square.getPerimeter()); // 16

// Mixin 模式
const Flyable = {
    fly() {
        console.log(`${this.name} is flying`);
    }
};

const Swimmable = {
    swim() {
        console.log(`${this.name} is swimming`);
    }
};

class Bird extends Animal {
    constructor(name) {
        super(name);
    }
}

// 添加 mixin
Object.assign(Bird.prototype, Flyable);

class Duck extends Bird {
    constructor(name) {
        super(name);
    }
}

Object.assign(Duck.prototype, Swimmable);

const duck = new Duck('Donald');
duck.fly(); // Donald is flying
duck.swim(); // Donald is swimming
```