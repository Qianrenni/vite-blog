## 8.3 现代异步语法

### 1. async/await 语法糖

```javascript
// async/await 基础语法

// async 函数声明
async function fetchData() {
    try {
        console.log('开始获取数据');
        const response = await fetch('https://api.github.com/users/octocat');
        const data = await response.json();
        console.log('数据获取完成');
        return data;
    } catch (error) {
        console.error('获取数据失败:', error);
        throw error;
    }
}

// async 函数表达式
const fetchDataExpression = async function() {
    const response = await fetch('https://api.github.com/users/octocat');
    return response.json();
};

// async 箭头函数
const fetchDataArrow = async () => {
    const response = await fetch('https://api.github.com/users/octocat');
    return response.json();
};

// async 方法
class DataFetcher {
    async fetchUser(username) {
        const response = await fetch(`https://api.github.com/users/${username}`);
        return response.json();
    }
    
    async fetchMultipleUsers(usernames) {
        const users = [];
        for (const username of usernames) {
            const user = await this.fetchUser(username);
            users.push(user);
        }
        return users;
    }
}

// async 函数总是返回 Promise
async function asyncFunction() {
    return 'async result';
}

console.log(asyncFunction() instanceof Promise); // true
asyncFunction().then(result => {
    console.log(result); // 'async result'
});

// await 只能在 async 函数内部使用
// 错误示例（会报语法错误）
// const result = await Promise.resolve('outside async');

// 正确示例
async function useAwait() {
    const result = await Promise.resolve('inside async');
    console.log(result);
}

// async/await 与 Promise 的转换
// 使用 Promise
function withPromise() {
    return fetch('https://api.github.com/users/octocat')
        .then(response => response.json())
        .then(data => {
            console.log(data);
            return data;
        })
        .catch(error => {
            console.error(error);
            throw error;
        });
}

// 使用 async/await
async function withAsyncAwait() {
    try {
        const response = await fetch('https://api.github.com/users/octocat');
        const data = await response.json();
        console.log(data);
        return data;
    } catch (error) {
        console.error(error);
        throw error;
    }
}

// 实际应用：用户数据处理
class UserService {
    async getUser(userId) {
        console.log(`获取用户 ${userId}`);
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
            throw new Error(`获取用户失败: ${response.status}`);
        }
        return response.json();
    }
    
    async updateUser(userId, userData) {
        console.log(`更新用户 ${userId}`);
        const response = await fetch(`/api/users/${userId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(userData)
        });
        
        if (!response.ok) {
            throw new Error(`更新用户失败: ${response.status}`);
        }
        
        return response.json();
    }
    
    async processUser(userId) {
        try {
            const user = await this.getUser(userId);
            console.log('用户信息:', user);
            
            const updatedUser = await this.updateUser(userId, {
                ...user,
                lastUpdated: new Date().toISOString()
            });
            
            console.log('更新后的用户:', updatedUser);
            return updatedUser;
        } catch (error) {
            console.error('处理用户失败:', error);
            throw error;
        }
    }
}

// 使用示例
const userService = new UserService();
// userService.processUser(123);

// async/await 错误处理对比
// Promise 方式
function handleWithPromise() {
    return fetch('/api/data')
        .then(response => {
            if (!response.ok) {
                throw new Error('网络错误');
            }
            return response.json();
        })
        .then(data => {
            return processData(data);
        })
        .catch(error => {
            console.error('处理失败:', error);
            return { error: error.message };
        });
}

// async/await 方式
async function handleWithAsyncAwait() {
    try {
        const response = await fetch('/api/data');
        if (!response.ok) {
            throw new Error('网络错误');
        }
        
        const data = await response.json();
        return await processData(data);
    } catch (error) {
        console.error('处理失败:', error);
        return { error: error.message };
    }
}

// 模拟数据处理
async function processData(data) {
    // 模拟异步处理
    await new Promise(resolve => setTimeout(resolve, 100));
    return { ...data, processed: true };
}
```

### 2. 异步函数错误处理

```javascript
// 异步函数错误处理

// try/catch 基本用法
async function basicErrorHandling() {
    try {
        const result = await Promise.reject(new Error('测试错误'));
        console.log('这不会执行');
    } catch (error) {
        console.log('捕获错误:', error.message);
    }
}

// 多层 try/catch
async function nestedErrorHandling() {
    try {
        await firstOperation();
    } catch (error) {
        console.log('第一层错误处理:', error.message);
        try {
            await fallbackOperation();
        } catch (fallbackError) {
            console.log('备用操作也失败:', fallbackError.message);
            throw new Error('所有操作都失败');
        }
    }
}

async function firstOperation() {
    throw new Error('主要操作失败');
}

async function fallbackOperation() {
    throw new Error('备用操作失败');
}

// 错误类型检查
async function typeSpecificErrorHandling() {
    try {
        const result = await riskyOperation();
        return result;
    } catch (error) {
        if (error instanceof TypeError) {
            console.error('类型错误:', error.message);
        } else if (error instanceof ReferenceError) {
            console.error('引用错误:', error.message);
        } else if (error.message.includes('network')) {
            console.error('网络错误:', error.message);
            // 可以进行重试
            return await retryOperation();
        } else {
            console.error('未知错误:', error.message);
            throw error; // 重新抛出未知错误
        }
    }
}

async function riskyOperation() {
    const random = Math.random();
    if (random < 0.3) {
        throw new TypeError('类型错误示例');
    } else if (random < 0.6) {
        throw new Error('network timeout');
    } else {
        throw new Error('其他错误');
    }
}

async function retryOperation() {
    console.log('重试操作');
    return '重试成功';
}

// finally 块的使用
async function withFinally() {
    try {
        console.log('开始操作');
        const result = await Promise.resolve('成功结果');
        console.log('操作成功');
        return result;
    } catch (error) {
        console.log('操作失败:', error.message);
        throw error;
    } finally {
        console.log('清理资源');
        // 这里的代码总是会执行
    }
}

// 错误传播
async function errorPropagation() {
    const result = await level1();
    console.log('最终结果:', result);
}

async function level1() {
    return await level2();
}

async function level2() {
    return await level3();
}

async function level3() {
    throw new Error('深层错误');
}

// 错误边界模式
class AsyncErrorBoundary {
    constructor() {
        this.errorCount = 0;
    }
    
    async execute(asyncFunction, retries = 3) {
        for (let i = 0; i < retries; i++) {
            try {
                return await asyncFunction();
            } catch (error) {
                this.errorCount++;
                console.log(`尝试 ${i + 1} 失败:`, error.message);
                
                if (i === retries - 1) {
                    console.log('所有重试都失败');
                    throw error;
                }
                
                // 等待后重试
                await this.delay(1000 * (i + 1));
            }
        }
    }
    
    async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    getErrorCount() {
        return this.errorCount;
    }
}

// 使用示例
const errorBoundary = new AsyncErrorBoundary();

async function flakyOperation() {
    if (Math.random() < 0.7) {
        throw new Error('随机失败');
    }
    return '成功';
}

// errorBoundary.execute(flakyOperation)
//     .then(result => console.log('最终结果:', result))
//     .catch(error => console.log('最终失败:', error.message));

// 统一错误处理装饰器模式
function withErrorHandling(target, propertyName, descriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function(...args) {
        try {
            return await method.apply(this, args);
        } catch (error) {
            console.error(`方法 ${propertyName} 执行失败:`, error.message);
            
            // 可以在这里添加统一的错误处理逻辑
            this.handleError?.(error);
            
            throw error;
        }
    };
    
    return descriptor;
}

class ServiceWithLogging {
    @withErrorHandling
    async fetchData() {
        throw new Error('服务错误');
    }
    
    handleError(error) {
        console.log('统一错误处理:', error.message);
    }
}

// 实际应用：API 客户端错误处理
class APIClient {
    constructor(baseURL) {
        this.baseURL = baseURL;
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        
        try {
            console.log(`请求: ${url}`);
            const response = await fetch(url, options);
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`HTTP ${response.status}: ${errorData.message || response.statusText}`);
            }
            
            const data = await response.json();
            console.log(`响应: ${url}`, data);
            return data;
        } catch (error) {
            console.error(`请求失败: ${url}`, error);
            
            // 根据错误类型进行不同处理
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
                throw new Error('网络连接失败，请检查网络');
            }
            
            throw error;
        }
    }
    
    async get(endpoint) {
        return this.request(endpoint, { method: 'GET' });
    }
    
    async post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
    }
    
    async withRetry(asyncFunction, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await asyncFunction();
            } catch (error) {
                console.log(`重试 ${i + 1}/${maxRetries}:`, error.message);
                
                if (i === maxRetries - 1) {
                    throw error;
                }
                
                await this.delay(1000 * Math.pow(2, i)); // 指数退避
            }
        }
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// 使用示例
const apiClient = new APIClient('https://api.example.com');

async function fetchUserData() {
    try {
        const user = await apiClient.withRetry(() => 
            apiClient.get('/users/123')
        );
        console.log('用户数据:', user);
    } catch (error) {
        console.error('获取用户数据失败:', error.message);
    }
}
```

### 3. 并行和串行执行

```javascript
// 并行和串行执行

// 串行执行 - 一个接一个执行
async function serialExecution() {
    console.log('开始串行执行');
    
    const result1 = await operation1();
    console.log('操作1完成:', result1);
    
    const result2 = await operation2();
    console.log('操作2完成:', result2);
    
    const result3 = await operation3();
    console.log('操作3完成:', result3);
    
    return [result1, result2, result3];
}

// 并行执行 - 同时执行多个操作
async function parallelExecution() {
    console.log('开始并行执行');
    
    // 同时启动所有操作
    const [result1, result2, result3] = await Promise.all([
        operation1(),
        operation2(),
        operation3()
    ]);
    
    console.log('所有操作完成');
    console.log('结果1:', result1);
    console.log('结果2:', result2);
    console.log('结果3:', result3);
    
    return [result1, result2, result3];
}

// 模拟异步操作
function operation1() {
    return new Promise(resolve => {
        setTimeout(() => resolve('操作1结果'), 1000);
    });
}

function operation2() {
    return new Promise(resolve => {
        setTimeout(() => resolve('操作2结果'), 1500);
    });
}

function operation3() {
    return new Promise(resolve => {
        setTimeout(() => resolve('操作3结果'), 800);
    });
}

// 性能对比
async function performanceComparison() {
    console.log('=== 性能对比 ===');
    
    // 串行执行
    console.time('串行执行');
    await serialExecution();
    console.timeEnd('串行执行'); // 约 3300ms
    
    // 并行执行
    console.time('并行执行');
    await parallelExecution();
    console.timeEnd('并行执行'); // 约 1500ms
}

// 限制并发数量
async function limitedParallelExecution(tasks, limit = 3) {
    const results = [];
    
    for (let i = 0; i < tasks.length; i += limit) {
        const batch = tasks.slice(i, i + limit);
        const batchResults = await Promise.all(
            batch.map(task => task())
        );
        results.push(...batchResults);
        console.log(`批次 ${Math.floor(i/limit) + 1} 完成`);
    }
    
    return results;
}

// 使用示例
const tasks = [
    () => operation1(),
    () => operation2(),
    () => operation3(),
    () => operation1(),
    () => operation2()
];

// limitedParallelExecution(tasks, 2);

// 混合执行模式 - 部分并行，部分串行
async function mixedExecution() {
    console.log('开始混合执行');
    
    // 先并行执行一组操作
    const [user, permissions] = await Promise.all([
        fetchUser(),
        fetchPermissions()
    ]);
    
    console.log('用户和权限获取完成');
    
    // 基于前面的结果串行执行后续操作
    const profile = await fetchProfile(user.id);
    const preferences = await fetchPreferences(user.id);
    
    console.log('详细信息获取完成');
    
    return {
        user,
        permissions,
        profile,
        preferences
    };
}

async function fetchUser() {
    await delay(500);
    return { id: 1, name: 'John' };
}

async function fetchPermissions() {
    await delay(300);
    return ['read', 'write'];
}

async function fetchProfile(userId) {
    await delay(400);
    return { avatar: 'avatar.jpg', bio: 'Developer' };
}

async function fetchPreferences(userId) {
    await delay(200);
    return { theme: 'dark', language: 'en' };
}

async function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 实际应用：批量数据处理
class BatchProcessor {
    constructor() {
        this.processedCount = 0;
        this.errorCount = 0;
    }
    
    // 串行处理
    async processSerial(items, processor) {
        const results = [];
        
        for (const item of items) {
            try {
                const result = await processor(item);
                results.push(result);
                this.processedCount++;
            } catch (error) {
                console.error(`处理项目失败:`, error);
                this.errorCount++;
                results.push(null); // 或者抛出错误
            }
        }
        
        return results;
    }
    
    // 并行处理
    async processParallel(items, processor, concurrency = 5) {
        const results = new Array(items.length);
        
        // 分批处理
        for (let i = 0; i < items.length; i += concurrency) {
            const batch = items.slice(i, i + concurrency);
            const batchPromises = batch.map((item, index) => 
                processor(item).then(
                    result => ({ success: true, result, originalIndex: i + index }),
                    error => ({ success: false, error, originalIndex: i + index })
                )
            );
            
            const batchResults = await Promise.all(batchPromises);
            
            batchResults.forEach(({ success, result, error, originalIndex }) => {
                if (success) {
                    results[originalIndex] = result;
                    this.processedCount++;
                } else {
                    console.error(`处理项目失败:`, error);
                    results[originalIndex] = null;
                    this.errorCount++;
                }
            });
        }
        
        return results;
    }
    
    // 流水线处理 - 保持最大并发数
    async processPipeline(items, processor, concurrency = 5) {
        const results = [];
        const executing = [];
        
        for (const item of items) {
            const promise = processor(item)
                .then(result => {
                    results.push({ success: true, result, item });
                    this.processedCount++;
                })
                .catch(error => {
                    results.push({ success: false, error, item });
                    this.errorCount++;
                })
                .finally(() => {
                    const index = executing.indexOf(promise);
                    if (index > -1) {
                        executing.splice(index, 1);
                    }
                });
            
            executing.push(promise);
            
            if (executing.length >= concurrency) {
                await Promise.race(executing);
            }
        }
        
        await Promise.all(executing);
        return results;
    }
    
    getStats() {
        return {
            processed: this.processedCount,
            errors: this.errorCount,
            successRate: this.processedCount > 0 
                ? ((this.processedCount - this.errorCount) / this.processedCount * 100).toFixed(2) + '%'
                : '0%'
        };
    }
    
    resetStats() {
        this.processedCount = 0;
        this.errorCount = 0;
    }
}

// 使用示例
const processor = new BatchProcessor();

// 模拟处理函数
async function processItem(item) {
    // 模拟随机处理时间
    await delay(Math.random() * 1000);
    
    // 模拟随机失败
    if (Math.random() < 0.1) {
        throw new Error(`处理 ${item} 失败`);
    }
    
    return `处理完成: ${item}`;
}

const items = Array.from({ length: 20 }, (_, i) => `项目${i + 1}`);

// 串行处理
console.log('=== 串行处理 ===');
processor.resetStats();
// const serialResults = await processor.processSerial(items, processItem);
// console.log('串行结果:', processor.getStats());

// 并行处理
console.log('=== 并行处理 ===');
processor.resetStats();
// const parallelResults = await processor.processParallel(items, processItem, 5);
// console.log('并行结果:', processor.getStats());

// 流水线处理
console.log('=== 流水线处理 ===');
processor.resetStats();
// const pipelineResults = await processor.processPipeline(items, processItem, 5);
// console.log('流水线结果:', processor.getStats());

// 高级并行控制：依赖图执行
class DependencyExecutor {
    constructor() {
        this.results = new Map();
        this.executing = new Set();
    }
    
    async execute(tasks) {
        const results = {};
        
        // 找到没有依赖的任务
        const readyTasks = Object.keys(tasks).filter(
            name => !tasks[name].dependencies || tasks[name].dependencies.length === 0
        );
        
        // 并行执行没有依赖的任务
        await Promise.all(
            readyTasks.map(name => this.executeTask(name, tasks, results))
        );
        
        return results;
    }
    
    async executeTask(name, tasks, results) {
        if (this.results.has(name)) {
            return this.results.get(name);
        }
        
        if (this.executing.has(name)) {
            // 等待正在执行的任务
            return new Promise(resolve => {
                const check = () => {
                    if (this.results.has(name)) {
                        resolve(this.results.get(name));
                    } else {
                        setTimeout(check, 10);
                    }
                };
                check();
            });
        }
        
        this.executing.add(name);
        
        try {
            const task = tasks[name];
            
            // 等待依赖任务完成
            if (task.dependencies && task.dependencies.length > 0) {
                await Promise.all(
                    task.dependencies.map(dep => 
                        this.executeTask(dep, tasks, results)
                    )
                );
            }
            
            // 执行当前任务
            const result = await task.fn();
            this.results.set(name, result);
            results[name] = result;
            
            return result;
        } finally {
            this.executing.delete(name);
        }
    }
}

// 使用示例
const dependencyExecutor = new DependencyExecutor();

const tasks = {
    'fetchUser': {
        fn: () => delay(500).then(() => ({ id: 1, name: 'John' })),
        dependencies: []
    },
    'fetchPermissions': {
        fn: () => delay(300).then(() => ['read', 'write']),
        dependencies: []
    },
    'fetchProfile': {
        fn: () => delay(400).then(() => ({ avatar: 'avatar.jpg' })),
        dependencies: ['fetchUser']
    },
    'generateReport': {
        fn: () => delay(600).then(() => '报告生成完成'),
        dependencies: ['fetchUser', 'fetchPermissions', 'fetchProfile']
    }
};

// dependencyExecutor.execute(tasks).then(results => {
//     console.log('依赖执行结果:', results);
// });
```

### 4. 异步迭代器

```javascript
// 异步迭代器 (Async Iterator) 和异步生成器 (Async Generator)

// 异步迭代器基础
class AsyncCounter {
    constructor(max) {
        this.max = max;
        this.current = 0;
    }
    
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                await this.delay(100); // 模拟异步操作
                
                if (this.current < this.max) {
                    return {
                        value: this.current++,
                        done: false
                    };
                } else {
                    return {
                        value: undefined,
                        done: true
                    };
                }
            }
        };
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// 使用 for-await-of 循环
async function useAsyncCounter() {
    console.log('开始异步计数');
    
    const counter = new AsyncCounter(5);
    
    for await (const value of counter) {
        console.log('计数值:', value);
    }
    
    console.log('计数完成');
}

// useAsyncCounter();

// 异步生成器函数
async function* asyncNumberGenerator(max) {
    for (let i = 0; i < max; i++) {
        await delay(100); // 模拟异步操作
        yield i;
    }
}

async function useAsyncGenerator() {
    console.log('使用异步生成器');
    
    for await (const value of asyncNumberGenerator(5)) {
        console.log('生成值:', value);
    }
    
    console.log('生成完成');
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// useAsyncGenerator();

// 实际应用：异步数据流处理
async function* fetchPaginatedData(url, maxPages = 10) {
    let page = 1;
    let hasMore = true;
    
    while (hasMore && page <= maxPages) {
        try {
            console.log(`获取第 ${page} 页数据`);
            
            // 模拟 API 调用
            const response = await fetch(`${url}?page=${page}`);
            const data = await response.json();
            
            // 检查是否还有更多数据
            hasMore = data.hasMore;
            page++;
            
            yield data.items;
            
            // 添加延迟避免过于频繁的请求
            await delay(100);
        } catch (error) {
            console.error(`获取第 ${page} 页失败:`, error);
            break;
        }
    }
}

// 使用异步生成器处理分页数据
async function processPaginatedData() {
    console.log('开始处理分页数据');
    
    let totalCount = 0;
    
    for await (const items of fetchPaginatedData('/api/data')) {
        console.log(`处理 ${items.length} 个项目`);
        totalCount += items.length;
        
        // 处理每个项目
        for (const item of items) {
            await processItem(item);
        }
    }
    
    console.log(`总共处理了 ${totalCount} 个项目`);
}

async function processItem(item) {
    // 模拟项目处理
    await delay(10);
    // console.log('处理项目:', item);
}

// 异步生成器的实际应用：文件读取
const fs = require('fs').promises;
const { createReadStream } = require('fs');
const { createInterface } = require('readline');

async function* readLines(filename) {
    const fileStream = createReadStream(filename);
    const rl = createInterface({
        input: fileStream,
        crlfDelay: Infinity
    });
    
    for await (const line of rl) {
        yield line;
    }
}

// 使用示例
async function processFile() {
    try {
        for await (const line of readLines('large-file.txt')) {
            // 处理每一行
            console.log('处理行:', line.substring(0, 50));
        }
    } catch (error) {
        console.error('文件处理失败:', error);
    }
}

// 异步迭代器组合和转换
async function* mapAsync(asyncIterable, mapper) {
    for await (const item of asyncIterable) {
        yield await mapper(item);
    }
}

async function* filterAsync(asyncIterable, predicate) {
    for await (const item of asyncIterable) {
        if (await predicate(item)) {
            yield item;
        }
    }
}

async function* takeAsync(asyncIterable, count) {
    let taken = 0;
    for await (const item of asyncIterable) {
        if (taken >= count) break;
        yield item;
        taken++;
    }
}

// 使用组合函数
async function processDataPipeline() {
    const numbers = asyncNumberGenerator(20);
    
    const pipeline = takeAsync(
        filterAsync(
            mapAsync(numbers, async x => x * 2),
            async x => x > 10
        ),
        5
    );
    
    console.log('处理管道结果:');
    for await (const value of pipeline) {
        console.log('管道值:', value);
    }
}

// processDataPipeline();

// 异步迭代器工具类
class AsyncIterableUtils {
    // 将普通数组转换为异步可迭代对象
    static async* fromArray(array) {
        for (const item of array) {
            yield item;
        }
    }
    
    // 将 Promise 数组转换为异步可迭代对象
    static async* fromPromises(promises) {
        for (const promise of promises) {
            yield await promise;
        }
    }
    
    // 异步扁平化
    static async* flatten(asyncIterable) {
        for await (const item of asyncIterable) {
            if (item && typeof item[Symbol.asyncIterator] === 'function') {
                yield* item;
            } else if (item && typeof item[Symbol.iterator] === 'function') {
                yield* item;
            } else {
                yield item;
            }
        }
    }
    
    // 异步归约
    static async reduce(asyncIterable, reducer, initialValue) {
        let accumulator = initialValue;
        for await (const item of asyncIterable) {
            accumulator = await reducer(accumulator, item);
        }
        return accumulator;
    }
    
    // 转换为数组
    static async toArray(asyncIterable) {
        const results = [];
        for await (const item of asyncIterable) {
            results.push(item);
        }
        return results;
    }
}

// 使用工具类
async function useAsyncIterableUtils() {
    // 从数组创建
    const arrayIterable = AsyncIterableUtils.fromArray([1, 2, 3, 4, 5]);
    
    // 映射和过滤
    const mapped = mapAsync(arrayIterable, async x => x * 2);
    const filtered = filterAsync(mapped, async x => x > 4);
    
    const result = await AsyncIterableUtils.toArray(filtered);
    console.log('结果:', result); // [6, 8, 10]
    
    // 异步归约
    const sum = await AsyncIterableUtils.reduce(
        AsyncIterableUtils.fromArray([1, 2, 3, 4, 5]),
        async (acc, val) => acc + val,
        0
    );
    console.log('求和结果:', sum); // 15
}

// useAsyncIterableUtils();

// 实际应用：实时数据处理
class RealTimeDataProcessor {
    constructor() {
        this.processing = false;
    }
    
    async* dataStream() {
        while (this.processing) {
            // 模拟实时数据
            yield {
                id: Date.now(),
                value: Math.random(),
                timestamp: new Date()
            };
            
            await delay(1000); // 每秒产生一个数据点
        }
    }
    
    async* processData() {
        for await (const data of this.dataStream()) {
            // 处理数据
            const processed = {
                ...data,
                processedValue: data.value * 100,
                category: data.value > 0.5 ? 'high' : 'low'
            };
            
            yield processed;
        }
    }
    
    async startProcessing(callback) {
        this.processing = true;
        console.log('开始实时数据处理');
        
        try {
            for await (const processedData of this.processData()) {
                await callback(processedData);
            }
        } finally {
            this.processing = false;
        }
    }
    
    stopProcessing() {
        this.processing = false;
        console.log('停止实时数据处理');
    }
}

// 使用示例
const processor = new RealTimeDataProcessor();

// 启动处理（5秒后停止）
// setTimeout(() => processor.stopProcessing(), 5000);

// processor.startProcessing(async (data) => {
//     console.log('处理数据:', data);
// });

// 异步迭代器错误处理
async function* errorHandlingGenerator() {
    try {
        yield 1;
        yield 2;
        throw new Error('生成器中的错误');
        yield 3; // 这不会执行
    } catch (error) {
        console.log('生成器内部捕获错误:', error.message);
        yield 'error-recovery';
    }
}

async function useErrorHandlingGenerator() {
    try {
        for await (const value of errorHandlingGenerator()) {
            console.log('值:', value);
        }
    } catch (error) {
        console.log('外部捕获错误:', error.message);
    }
}

// useErrorHandlingGenerator();

// 异步迭代器的并发控制
class ConcurrentAsyncProcessor {
    constructor(concurrency = 3) {
        this.concurrency = concurrency;
    }
    
    async* processWithConcurrency(asyncIterable, processor) {
        const queue = [];
        let active = 0;
        
        for await (const item of asyncIterable) {
            if (active >= this.concurrency) {
                // 等待队列中有完成的项目
                const completed = await Promise.race(queue);
                const index = queue.indexOf(completed);
                if (index > -1) {
                    queue.splice(index, 1);
                }
                active--;
            }
            
            const promise = processor(item)
                .then(result => ({ success: true, result, item }))
                .catch(error => ({ success: false, error, item }));
            
            queue.push(promise);
            active++;
            
            // 如果队列未满，继续添加项目
            if (active < this.concurrency) {
                continue;
            }
            
            // 等待一个项目完成
            const completed = await Promise.race(queue);
            const index = queue.indexOf(completed);
            if (index > -1) {
                queue.splice(index, 1);
            }
            active--;
            
            if (completed.success) {
                yield completed.result;
            } else {
                console.error('处理失败:', completed.error);
                yield null;
            }
        }
        
        // 处理剩余的项目
        while (queue.length > 0) {
            const completed = await Promise.race(queue);
            const index = queue.indexOf(completed);
            if (index > -1) {
                queue.splice(index, 1);
            }
            
            if (completed.success) {
                yield completed.result;
            } else {
                console.error('处理失败:', completed.error);
                yield null;
            }
        }
    }
}

// 使用并发控制
async function useConcurrentProcessor() {
    const processor = new ConcurrentAsyncProcessor(3);
    
    const numbers = asyncNumberGenerator(10);
    
    const processItem = async (item) => {
        await delay(Math.random() * 1000); // 随机处理时间
        return item * 2;
    };
    
    console.log('开始并发处理');
    for await (const result of processor.processWithConcurrency(numbers, processItem)) {
        console.log('处理结果:', result);
    }
    console.log('并发处理完成');
}

// useConcurrentProcessor();
```