## 7.2 正则表达式应用

### 1. 字符串匹配和验证

```javascript
// 常用验证正则表达式

// 邮箱验证
function validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

console.log(validateEmail('user@example.com')); // true
console.log(validateEmail('invalid.email')); // false

// 更严格的邮箱验证
function validateEmailStrict(email) {
    const strictEmailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return strictEmailRegex.test(email);
}

// 手机号验证 (中国)
function validatePhone(phone) {
    const phoneRegex = /^1[3-9]\d{9}$/;
    return phoneRegex.test(phone);
}

console.log(validatePhone('13812345678')); // true
console.log(validatePhone('12345678901')); // false

// 身份证验证 (中国18位)
function validateIDCard(id) {
    const idRegex = /^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
    return idRegex.test(id);
}

// 密码强度验证
function validatePassword(password) {
    // 至少8位，包含大小写字母、数字和特殊字符
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
}

console.log(validatePassword('Password123!')); // true
console.log(validatePassword('password')); // false

// URL验证
function validateURL(url) {
    const urlRegex = /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
    return urlRegex.test(url);
}

// IP地址验证
function validateIP(ip) {
    const ipRegex = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    return ipRegex.test(ip);
}

console.log(validateIP('192.168.1.1')); // true
console.log(validateIP('999.999.999.999')); // false

// 综合验证器
class Validator {
    static patterns = {
        email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        phone: /^1[3-9]\d{9}$/,
        url: /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/,
        ip: /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
        hexColor: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
    };
    
    static validate(type, value) {
        const pattern = this.patterns[type];
        return pattern ? pattern.test(value) : false;
    }
}

console.log(Validator.validate('email', 'test@example.com')); // true
console.log(Validator.validate('hexColor', '#ff0000')); // true
```

### 2. 文本搜索和替换

```javascript
// 文本搜索应用

// 搜索所有匹配项
const text = 'The quick brown fox jumps over the lazy dog. The fox is quick.';
const foxRegex = /fox/gi; // 全局、不区分大小写
const matches = text.match(foxRegex);
console.log(matches); // ['fox', 'fox']

// 搜索匹配位置
const positions = [];
let match;
while ((match = foxRegex.exec(text)) !== null) {
    positions.push({
        match: match[0],
        index: match.index
    });
}
console.log(positions); // [{match: 'fox', index: 16}, {match: 'fox', index: 44}]

// 搜索和替换应用

// 基本替换
const newText = text.replace(/fox/gi, 'cat');
console.log(newText); // 'The quick brown cat jumps over the lazy dog. The cat is quick.'

// 使用捕获组进行替换
const dateText = '2023-12-25 is Christmas';
const formattedDate = dateText.replace(/(\d{4})-(\d{2})-(\d{2})/, '$2/$3/$1');
console.log(formattedDate); // '12/25/2023 is Christmas'

// 使用函数进行复杂替换
const prices = 'Price: $29.99, Discount: $5.00, Tax: $2.70';
const updatedPrices = prices.replace(/\$(\d+\.\d+)/g, (match, price) => {
    const newPrice = (parseFloat(price) * 1.1).toFixed(2);
    return `$${newPrice}`;
});
console.log(updatedPrices); // 'Price: $32.99, Discount: $5.50, Tax: $2.97'

// 文本高亮
function highlightText(text, searchTerm) {
    const regex = new RegExp(`(${searchTerm})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
}

const content = 'JavaScript is a programming language. JavaScript is versatile.';
const highlighted = highlightText(content, 'javascript');
console.log(highlighted); // '<mark>JavaScript</mark> is a programming language. <mark>JavaScript</mark> is versatile.'

// 敏感词过滤
function filterSensitiveWords(text, sensitiveWords) {
    const pattern = sensitiveWords.map(word => word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
    const regex = new RegExp(`(${pattern})`, 'gi');
    return text.replace(regex, '***');
}

const sensitiveWords = ['badword', 'spam', 'scam'];
const filtered = filterSensitiveWords('This is a badword and spam message', sensitiveWords);
console.log(filtered); // 'This is a *** and *** message'

// 批量替换
function batchReplace(text, replacements) {
    let result = text;
    for (const [pattern, replacement] of Object.entries(replacements)) {
        const regex = new RegExp(pattern, 'g');
        result = result.replace(regex, replacement);
    }
    return result;
}

const replacements = {
    'hello': 'hi',
    'world': 'universe',
    '\\d+': 'NUMBER'
};

const originalText = 'Hello world! I have 5 apples and 3 oranges.';
const replacedText = batchReplace(originalText, replacements);
console.log(replacedText); // 'hi universe! I have NUMBER apples and NUMBER oranges.'
```

### 3. 数据提取和解析

```javascript
// 数据提取应用

// 从文本中提取邮箱地址
function extractEmails(text) {
    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
    return text.match(emailRegex) || [];
}

const textWithEmails = 'Contact us at support@example.com or sales@company.org';
console.log(extractEmails(textWithEmails)); // ['support@example.com', 'sales@company.org']

// 从HTML中提取链接
function extractLinks(html) {
    const linkRegex = /<a\s+(?:[^>]*?\s+)?href=(["'])(.*?)\1/g;
    const links = [];
    let match;
    while ((match = linkRegex.exec(html)) !== null) {
        links.push(match[2]);
    }
    return links;
}

const html = '<a href="https://example.com">Example</a><a href="mailto:test@example.com">Email</a>';
console.log(extractLinks(html)); // ['https://example.com', 'mailto:test@example.com']

// 解析CSV数据
function parseCSV(csv) {
    const lines = csv.trim().split('\n');
    const headers = lines[0].split(',').map(header => header.trim());
    const data = [];
    
    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        const row = {};
        headers.forEach((header, index) => {
            row[header] = values[index] ? values[index].trim() : '';
        });
        data.push(row);
    }
    
    return data;
}

const csvData = `name,age,city
John,25,New York
Jane,30,Los Angeles
Bob,35,Chicago`;

console.log(parseCSV(csvData));

// 从日志中提取信息
function parseLog(logLine) {
    const logRegex = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+)$/;
    const match = logLine.match(logRegex);
    
    if (match) {
        return {
            timestamp: match[1],
            level: match[2],
            message: match[3]
        };
    }
    return null;
}

const logLine = '2023-12-25 14:30:45 [ERROR] Database connection failed';
console.log(parseLog(logLine));
// {timestamp: '2023-12-25 14:30:45', level: 'ERROR', message: 'Database connection failed'}

// 解析URL参数
function parseURLParams(url) {
    const params = {};
    const queryString = url.split('?')[1];
    
    if (queryString) {
        const pairs = queryString.split('&');
        pairs.forEach(pair => {
            const [key, value] = pair.split('=');
            params[decodeURIComponent(key)] = decodeURIComponent(value || '');
        });
    }
    
    return params;
}

const url = 'https://example.com/search?q=javascript&category=tutorial&page=1';
console.log(parseURLParams(url)); // {q: 'javascript', category: 'tutorial', page: '1'}

// 使用正则表达式解析复杂数据
function parseStructuredData(text) {
    // 解析类似 "Name: John, Age: 25, Email: john@example.com" 的数据
    const dataRegex = /(\w+):\s*([^,]+)/g;
    const data = {};
    let match;
    
    while ((match = dataRegex.exec(text)) !== null) {
        const key = match[1].toLowerCase();
        const value = match[2].trim();
        data[key] = value;
    }
    
    return data;
}

const structuredText = 'Name: John Doe, Age: 25, Email: john@example.com, City: New York';
console.log(parseStructuredData(structuredText));
// {name: 'John Doe', age: '25', email: 'john@example.com', city: 'New York'}

// 提取电话号码
function extractPhoneNumbers(text) {
    const phoneRegex = /(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g;
    const phones = [];
    let match;
    
    while ((match = phoneRegex.exec(text)) !== null) {
        const fullNumber = match[0];
        const areaCode = match[2];
        const exchange = match[3];
        const number = match[4];
        phones.push({
            full: fullNumber,
            formatted: `(${areaCode}) ${exchange}-${number}`,
            areaCode: areaCode
        });
    }
    
    return phones;
}

const textWithPhones = 'Call me at 123-456-7890 or (987) 654-3210';
console.log(extractPhoneNumbers(textWithPhones));
```

### 4. 性能优化技巧

```javascript
// 正则表达式性能优化

// 1. 避免回溯灾难
// 危险示例：可能导致指数级时间复杂度
const dangerousRegex = /^(a+)+$/;
// dangerousRegex.test('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'); // 可能导致浏览器卡死

// 安全替代方案
const safeRegex = /^a+$/;
safeRegex.test('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'); // 快速返回 false

// 2. 使用具体字符而非通配符
// 慢：使用 .*
const slowRegex = /<div>.*<\/div>/;

// 快：使用具体字符类
const fastRegex = /<div>[^]*?<\/div>/; // [^]* 匹配包括换行符的所有字符

// 3. 预编译正则表达式
// 避免在循环中重复创建
function processData(items) {
    // 不好的做法
    // items.forEach(item => {
    //     const regex = /pattern/g; // 每次循环都创建
    //     // ...
    // });
    
    // 好的做法
    const regex = /pattern/g; // 预先创建
    items.forEach(item => {
        // 使用预编译的正则表达式
        regex.lastIndex = 0; // 重置 lastIndex
        // ...
    });
}

// 4. 使用 lastIndex 优化连续匹配
function findWords(text) {
    const wordRegex = /\w+/g;
    const words = [];
    let match;
    
    while ((match = wordRegex.exec(text)) !== null) {
        words.push(match[0]);
    }
    
    return words;
}

// 5. 缓存正则表达式
class RegexCache {
    constructor() {
        this.cache = new Map();
    }
    
    get(pattern, flags = '') {
        const key = `${pattern}_${flags}`;
        if (!this.cache.has(key)) {
            this.cache.set(key, new RegExp(pattern, flags));
        }
        return this.cache.get(key);
    }
}

const regexCache = new RegexCache();
const emailRegex = regexCache.get('^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$');

// 6. 使用非捕获分组减少内存使用
// 不需要捕获时使用 (?:...)
const nonCapturing = /(?:https?):\/\/(\w+)/; // 只捕获域名
const capturing = /(https?):\/\/(\w+)/; // 捕获协议和域名

// 7. 避免不必要的全局标志
// 只需要检查是否存在时，不需要全局标志
const hasEmail = /[^\s@]+@[^\s@]+\.[^\s@]+/.test(text); // 比 /g 更快

// 8. 使用字符类而非选择符
// 慢：使用选择符
const slowCharClass = /(a|b|c)/;

// 快：使用字符类
const fastCharClass = /[abc]/;

// 9. 实际性能测试示例
function performanceTest() {
    const text = 'a'.repeat(1000) + 'b';
    
    // 测试不同正则表达式的性能
    const tests = [
        { name: '贪婪匹配', regex: /a+b/ },
        { name: '非贪婪匹配', regex: /a+?b/ },
        { name: 'possessive匹配', regex: /a++b/ } // 注意：JavaScript不支持possessive量词
    ];
    
    tests.forEach(test => {
        const start = performance.now();
        test.regex.test(text);
        const end = performance.now();
        console.log(`${test.name}: ${end - start}ms`);
    });
}

// 10. 正则表达式调试工具
function debugRegex(pattern, text) {
    const regex = new RegExp(pattern, 'g');
    const matches = [];
    let match;
    let iterations = 0;
    
    console.log(`Testing pattern: ${pattern}`);
    console.log(`Against text: ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`);
    
    while ((match = regex.exec(text)) !== null && iterations < 1000) {
        matches.push({
            match: match[0],
            index: match.index,
            groups: match.slice(1)
        });
        iterations++;
    }
    
    console.log(`Found ${matches.length} matches in ${iterations} iterations`);
    console.log('Matches:', matches);
    
    return matches;
}

// 11. 避免在循环中使用复杂的正则表达式
// 不好的做法
function badPractice(items) {
    return items.map(item => {
        return item.replace(/复杂的正则表达式/g, 'replacement');
    });
}

// 好的做法：预编译
function goodPractice(items) {
    const regex = /复杂的正则表达式/g;
    return items.map(item => {
        regex.lastIndex = 0; // 重置
        return item.replace(regex, 'replacement');
    });
}

// 12. 使用正则表达式进行预过滤
function efficientSearch(text, searchTerm) {
    // 先用简单检查快速排除
    if (!text.includes(searchTerm)) {
        return [];
    }
    
    // 再用正则表达式进行精确匹配
    const regex = new RegExp(searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
    return text.match(regex) || [];
}
```