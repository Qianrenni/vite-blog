## 19.3 安全防护

### 服务器安全配置

**安全加固脚本：**
```bash
#!/bin/bash
# security-setup.sh

echo "开始服务器安全加固..."

# 1. 更新系统
sudo apt update && sudo apt upgrade -y

# 2. 安装安全工具
sudo apt install -y fail2ban ufw logwatch clamav

# 3. 配置防火墙
sudo ufw --force enable
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 允许必要端口
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# 4. 配置 SSH 安全
sudo sed -i 's/#Port 22/Port 2222/' /etc/ssh/sshd_config
sudo sed -i 's/PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
sudo systemctl restart ssh

# 5. 配置 fail2ban
sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local

# 自定义 fail2ban 规则
sudo tee /etc/fail2ban/jail.local > /dev/null <<EOL
[DEFAULT]
bantime = 1h
findtime = 10m
maxretry = 3

[sshd]
enabled = true
port = 2222
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 1h

[nginx-http-auth]
enabled = true
filter = nginx-http-auth
port = http,https
logpath = /var/log/nginx/error.log

[nginx-botsearch]
enabled = true
filter = nginx-botsearch
port = http,https
logpath = /var/log/nginx/access.log
maxretry = 2
EOL

sudo systemctl restart fail2ban

# 6. 配置自动安全更新
sudo apt install -y unattended-upgrades
sudo dpkg-reconfigure -plow unattended-upgrades

# 7. 禁用不必要的服务
sudo systemctl disable bluetooth
sudo systemctl disable cups
sudo systemctl disable avahi-daemon

# 8. 设置文件权限
sudo chmod 700 /home/appuser
sudo chown root:root /etc/passwd /etc/shadow /etc/group /etc/gshadow

echo "安全加固完成！"
```

**用户和权限管理：**
```bash
# 创建安全用户
sudo adduser --disabled-password --gecos "" appuser
sudo usermod -aG docker appuser  # 如果使用 Docker

# 设置 SSH 密钥认证
sudo mkdir -p /home/appuser/.ssh
sudo cp /tmp/id_rsa.pub /home/appuser/.ssh/authorized_keys
sudo chown -R appuser:appuser /home/appuser/.ssh
sudo chmod 700 /home/appuser/.ssh
sudo chmod 600 /home/appuser/.ssh/authorized_keys

# 限制 sudo 权限
sudo tee /etc/sudoers.d/appuser > /dev/null <<EOL
appuser ALL=(ALL) NOPASSWD: /usr/bin/systemctl, /usr/bin/docker
EOL

# 禁用 root SSH 登录
sudo sed -i 's/PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config

# 设置密码策略
sudo apt install -y libpam-pwquality
sudo tee -a /etc/pam.d/common-password > /dev/null <<EOL
password requisite pam_pwquality.so retry=3 minlen=12 difok=3 ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1
EOL
```

### HTTPS 证书管理

**Let's Encrypt 证书管理：**
```bash
# 安装 Certbot
sudo apt install -y certbot python3-certbot-nginx

# 获取证书
sudo certbot --nginx -d example.com -d www.example.com

# 自动续期
sudo crontab -e
# 添加以下行：
# 0 12 * * * /usr/bin/certbot renew --quiet

# 手动续期测试
sudo certbot renew --dry-run

# 证书监控脚本
#!/bin/bash
# ssl-monitor.sh

DOMAINS=("example.com" "www.example.com")
EMAIL="admin@example.com"

for domain in "${DOMAINS[@]}"; do
    EXPIRY_DATE=$(echo | openssl s_client -servername $domain -connect $domain:443 2>/dev/null | openssl x509 -noout -enddate | cut -d= -f2)
    EXPIRY_SECONDS=$(date -d "$EXPIRY_DATE" +%s)
    CURRENT_SECONDS=$(date +%s)
    DAYS_LEFT=$(( (EXPIRY_SECONDS - CURRENT_SECONDS) / 86400 ))
    
    if [ $DAYS_LEFT -lt 30 ]; then
        echo "警告: $domain 证书将在 $DAYS_LEFT 天后过期" | mail -s "SSL证书即将过期" $EMAIL
    fi
done
```

**Nginx HTTPS 配置：**
```nginx
# nginx.conf
server {
    listen 80;
    server_name example.com www.example.com;
    
    # Let's Encrypt 验证
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    
    # 重定向到 HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

server {
    listen 443 ssl http2;
    server_name example.com www.example.com;
    
    # SSL 证书
    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
    
    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # 安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    
    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### 访问控制策略

**API 访问控制：**
```javascript
const rateLimit = require('express-rate-limit');
const slowDown = require('express-slow-down');

// 基础速率限制
const basicLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 100, // 限制每个IP 100个请求
    message: {
        error: '请求过于频繁，请稍后再试'
    },
    standardHeaders: true,
    legacyHeaders: false,
});

// 严格速率限制（敏感API）
const strictLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 5, // 限制每个IP 5个请求
    message: {
        error: '请求过于频繁，账户已被临时限制'
    },
    standardHeaders: true,
    legacyHeaders: false,
});

// 速率减缓
const speedLimiter = slowDown({
    windowMs: 15 * 60 * 1000, // 15分钟
    delayAfter: 100, // 100个请求后开始减缓
    delayMs: 500 // 每个请求增加500ms延迟
});

// IP 白名单
const ipWhitelist = [
    '127.0.0.1',
    '::1',
    // 添加可信IP
];

const ipWhitelistMiddleware = (req, res, next) => {
    const clientIP = req.ip || req.connection.remoteAddress;
    
    if (ipWhitelist.includes(clientIP)) {
        return next();
    }
    
    res.status(403).json({ error: '访问被拒绝' });
};

// JWT 认证中间件
const jwt = require('jsonwebtoken');

const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({ error: '未提供访问令牌' });
    }
    
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: '无效的访问令牌' });
        }
        
        req.user = user;
        next();
    });
};

// 角色权限控制
const checkPermission = (requiredRole) => {
    return (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({ error: '需要认证' });
        }
        
        if (req.user.role !== requiredRole && req.user.role !== 'admin') {
            return res.status(403).json({ error: '权限不足' });
        }
        
        next();
    };
};

// API 密钥认证
const authenticateApiKey = (req, res, next) => {
    const apiKey = req.headers['x-api-key'] || req.query.api_key;
    
    if (!apiKey || apiKey !== process.env.API_KEY) {
        return res.status(401).json({ error: '无效的 API 密钥' });
    }
    
    next();
};

// CORS 配置
const cors = require('cors');

const corsOptions = {
    origin: function (origin, callback) {
        const allowedOrigins = [
            'https://example.com',
            'https://www.example.com',
            'http://localhost:3000'
        ];
        
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('不允许的来源'));
        }
    },
    credentials: true,
    optionsSuccessStatus: 200
};

// 在应用中使用
app.use('/api/', basicLimiter);
app.use('/api/auth/', strictLimiter);
app.use('/api/', speedLimiter);
app.use('/api/', cors(corsOptions));

// 敏感路由保护
app.post('/api/admin/*', authenticateToken, checkPermission('admin'));
app.get('/api/private/*', authenticateApiKey);
app.get('/api/internal/*', ipWhitelistMiddleware);
```

**安全中间件：**
```javascript
const helmet = require('helmet');
const hpp = require('hpp');
const xss = require('xss-clean');

// 安全头设置
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"],
            fontSrc: ["'self'", "https:", "data:"],
            objectSrc: ["'none'"],
            mediaSrc: ["'self'"],
            frameSrc: ["'none'"],
        },
    },
    dnsPrefetchControl: { allow: false },
    frameguard: { action: 'deny' },
    hidePoweredBy: true,
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    },
    ieNoOpen: true,
    noSniff: true,
    referrerPolicy: { policy: 'no-referrer' },
    xssFilter: true,
}));

// 防止 HTTP 参数污染
app.use(hpp());

// 防止 XSS 攻击
app.use(xss());

// 输入验证中间件
const { body, validationResult } = require('express-validator');

const validateUserInput = [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/),
    body('name').trim().isLength({ min: 2, max: 50 }),
    
    (req, res, next) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ 
                error: '输入验证失败',
                details: errors.array() 
            });
        }
        next();
    }
];

// 在路由中使用
app.post('/api/users', validateUserInput, async (req, res) => {
    // 处理用户创建逻辑
});
```

### 数据备份方案

**自动化备份脚本：**
```bash
#!/bin/bash
# backup.sh

# 配置
BACKUP_DIR="/backup"
DATE=$(date +%Y%m%d_%H%M%S)
RETENTION_DAYS=30

# 创建备份目录
mkdir -p $BACKUP_DIR

# 数据库备份
backup_database() {
    local db_name=$1
    local backup_file="$BACKUP_DIR/db_${db_name}_${DATE}.sql.gz"
    
    echo "备份数据库: $db_name"
    
    if [ "$db_name" = "postgresql" ]; then
        pg_dump -U postgres -h localhost $db_name | gzip > $backup_file
    elif [ "$db_name" = "mysql" ]; then
        mysqldump -u root -p $db_name | gzip > $backup_file
    fi
    
    if [ $? -eq 0 ]; then
        echo "数据库备份成功: $backup_file"
        return 0
    else
        echo "数据库备份失败"
        return 1
    fi
}

# 文件备份
backup_files() {
    local source_dir=$1
    local backup_file="$BACKUP_DIR/files_${DATE}.tar.gz"
    
    echo "备份文件: $source_dir"
    
    tar -czf $backup_file $source_dir
    
    if [ $? -eq 0 ]; then
        echo "文件备份成功: $backup_file"
        return 0
    else
        echo "文件备份失败"
        return 1
    fi
}

# 上传到云存储
upload_to_cloud() {
    local backup_file=$1
    local bucket_name=$2
    
    echo "上传到云存储: $backup_file"
    
    # AWS S3
    if [ ! -z "$AWS_ACCESS_KEY_ID" ]; then
        aws s3 cp $backup_file s3://$bucket_name/backups/
    fi
    
    # Google Cloud Storage
    if [ ! -z "$GOOGLE_APPLICATION_CREDENTIALS" ]; then
        gsutil cp $backup_file gs://$bucket_name/backups/
    fi
}

# 清理旧备份
cleanup_old_backups() {
    echo "清理 $RETENTION_DAYS 天前的备份"
    find $BACKUP_DIR -name "*.gz" -mtime +$RETENTION_DAYS -delete
}

# 主备份流程
main() {
    echo "开始备份流程 - $(date)"
    
    # 备份数据库
    backup_database "postgresql" || exit 1
    
    # 备份重要文件
    backup_files "/home/appuser/uploads" || exit 1
    backup_files "/home/appuser/logs" || exit 1
    
    # 上传到云存储
    if [ ! -z "$BACKUP_BUCKET" ]; then
        for file in $BACKUP_DIR/*.gz; do
            upload_to_cloud $file $BACKUP_BUCKET
        done
    fi
    
    # 清理旧备份
    cleanup_old_backups
    
    echo "备份流程完成 - $(date)"
}

# 执行备份
main
```

**备份策略配置：**
```bash
# crontab 配置
# 每天凌晨2点执行完整备份
0 2 * * * /home/appuser/scripts/backup.sh >> /var/log/backup.log 2>&1

# 每小时执行增量备份
0 * * * * /home/appuser/scripts/incremental_backup.sh >> /var/log/incremental_backup.log 2>&1

# 每周日凌晨3点执行完整备份并清理
0 3 * * 0 /home/appuser/scripts/backup.sh && /home/appuser/scripts/cleanup.sh >> /var/log/weekly_backup.log 2>&1

# 备份监控脚本
#!/bin/bash
# backup_monitor.sh

check_backup_status() {
    local log_file="/var/log/backup.log"
    local last_backup=$(tail -20 $log_file | grep "备份流程完成" | tail -1)
    
    if [ -z "$last_backup" ]; then
        echo "警告: 最近没有成功的备份"
        # 发送告警
        echo "备份失败告警" | mail -s "备份失败" admin@example.com
        return 1
    fi
    
    local backup_time=$(echo $last_backup | cut -d'-' -f3- | xargs)
    local backup_timestamp=$(date -d "$backup_time" +%s)
    local current_timestamp=$(date +%s)
    local time_diff=$((current_timestamp - backup_timestamp))
    
    # 如果超过25小时没有备份，发送告警
    if [ $time_diff -gt 90000 ]; then
        echo "警告: 备份已超过25小时未执行"
        echo "备份超时告警" | mail -s "备份超时" admin@example.com
        return 1
    fi
    
    echo "备份状态正常"
    return 0
}

# 检查备份完整性
check_backup_integrity() {
    local backup_dir="/backup"
    local latest_backup=$(ls -t $backup_dir/*.gz | head -1)
    
    if [ ! -f "$latest_backup" ]; then
        echo "错误: 没有找到备份文件"
        return 1
    fi
    
    # 检查文件大小
    local file_size=$(stat -c%s "$latest_backup")
    if [ $file_size -lt 1024 ]; then
        echo "错误: 备份文件过小，可能不完整"
        return 1
    fi
    
    echo "备份文件完整性检查通过"
    return 0
}

# 主监控函数
monitor_backups() {
    echo "开始备份监控 - $(date)"
    
    check_backup_status
    local status_result=$?
    
    check_backup_integrity
    local integrity_result=$?
    
    if [ $status_result -ne 0 ] || [ $integrity_result -ne 0 ]; then
        echo "备份监控发现问题"
        return 1
    else
        echo "备份监控正常"
        return 0
    fi
}

# 执行监控
monitor_backups
```

**灾难恢复计划：**
```bash
#!/bin/bash
# disaster_recovery.sh

# 灾难恢复脚本
restore_database() {
    local backup_file=$1
    local db_name=$2
    
    echo "恢复数据库: $db_name 从 $backup_file"
    
    if [ ! -f "$backup_file" ]; then
        echo "错误: 备份文件不存在"
        return 1
    fi
    
    # 停止应用服务
    sudo systemctl stop myapp
    
    # 恢复数据库
    if [ "$db_name" = "postgresql" ]; then
        gunzip -c $backup_file | psql -U postgres -h localhost $db_name
    elif [ "$db_name" = "mysql" ]; then
        gunzip -c $backup_file | mysql -u root -p $db_name
    fi
    
    if [ $? -eq 0 ]; then
        echo "数据库恢复成功"
        sudo systemctl start myapp
        return 0
    else
        echo "数据库恢复失败"
        return 1
    fi
}

restore_files() {
    local backup_file=$1
    local target_dir=$2
    
    echo "恢复文件到: $target_dir 从 $backup_file"
    
    if [ ! -f "$backup_file" ]; then
        echo "错误: 备份文件不存在"
        return 1
    fi
    
    # 创建备份
    sudo tar -czf "${target_dir}_backup_$(date +%Y%m%d_%H%M%S).tar.gz" $target_dir
    
    # 恢复文件
    sudo tar -xzf $backup_file -C /
    
    if [ $? -eq 0 ]; then
        echo "文件恢复成功"
        return 0
    else
        echo "文件恢复失败"
        return 1
    fi
}

# 快速恢复脚本
quick_restore() {
    local backup_date=$1
    
    echo "执行快速恢复到: $backup_date"
    
    # 查找最近的备份
    local db_backup=$(ls -t /backup/db_postgresql_${backup_date}*.sql.gz | head -1)
    local files_backup=$(ls -t /backup/files_${backup_date}*.tar.gz | head -1)
    
    # 恢复数据库
    restore_database $db_backup "postgresql"
    
    # 恢复文件
    restore_files $files_backup "/home/appuser"
    
    echo "快速恢复完成"
}

# 完整恢复脚本
full_restore() {
    local backup_date=$1
    
    echo "执行完整恢复到: $backup_date"
    
    # 停止所有服务
    sudo systemctl stop nginx
    sudo systemctl stop myapp
    sudo systemctl stop postgresql
    
    # 恢复步骤
    quick_restore $backup_date
    
    # 启动服务
    sudo systemctl start postgresql
    sudo systemctl start myapp
    sudo systemctl start nginx
    
    echo "完整恢复完成"
}

# 使用说明
case "$1" in
    quick)
        quick_restore $2
        ;;
    full)
        full_restore $2
        ;;
    *)
        echo "使用方法: $0 {quick|full} [备份日期]"
        echo "示例: $0 quick 20231201"
        ;;
esac
```