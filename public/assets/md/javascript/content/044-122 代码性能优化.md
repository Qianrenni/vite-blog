## 12.2 代码性能优化

### 1. 算法复杂度分析

选择高效的算法是性能优化的根基。常用复杂度：

| 复杂度 | 名称 | 示例 |
|--------|------|------|
| O(1) | 常数时间 | 数组索引、哈希表查找 |
| O(log n) | 对数时间 | 二分查找 |
| O(n) | 线性时间 | 遍历数组 |
| O(n log n) | 线性对数 | 快速排序、归并排序 |
| O(n²) | 平方时间 | 双重循环、冒泡排序 |
| O(2ⁿ) | 指数时间 | 递归斐波那契（无缓存） |

#### 优化示例：从 O(n²) 到 O(n)

```js
// ❌ O(n²)：查找数组中是否有重复元素
function hasDuplicate(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j]) return true;
        }
    }
    return false;
}

// ✅ O(n)：使用 Set
function hasDuplicate(arr) {
    const seen = new Set();
    for (const item of arr) {
        if (seen.has(item)) return true;
        seen.add(item);
    }
    return false;
}
```

✅ 建议：
- 尽量避免嵌套循环
- 优先使用哈希结构（`Object`、`Map`、`Set`）提升查找效率

---

### 2. DOM 操作优化

DOM 操作是性能瓶颈之一，因其涉及 **重排（reflow）** 和 **重绘（repaint）**。

#### 重排 vs 重绘：
- **重排**：元素几何属性改变（宽高、位置），触发布局重新计算（昂贵）
- **重绘**：元素样式改变但不影响布局（如颜色），只需重绘（较轻）

#### 优化策略：

##### （1）批量 DOM 操作

```js
// ❌ 每次都触发重排
for (let i = 0; i < items.length; i++) {
    const el = document.createElement('li');
    el.textContent = items[i];
    list.appendChild(el); // 每次都修改 DOM
}

// ✅ 使用 DocumentFragment 批量插入
const fragment = document.createDocumentFragment();
for (let i = 0; i < items.length; i++) {
    const el = document.createElement('li');
    el.textContent = items[i];
    fragment.appendChild(el);
}
list.appendChild(fragment); // 仅一次 DOM 修改
```

##### （2）离线操作 DOM

```js
// 隐藏元素 → 修改 → 显示
list.style.display = 'none';
// 大量修改...
list.style.display = 'block';
```

##### （3）使用 `requestAnimationFrame` 批量更新

```js
let updates = [];
function updateDOM(prop, value) {
    updates.push([prop, value]);
    requestAnimationFrame(applyUpdates);
}

function applyUpdates() {
    updates.forEach(([prop, value]) => {
        element[prop] = value;
    });
    updates = [];
}
```

##### （4）避免强制同步布局（Forced Synchronous Layout）

```js
// ❌ 强制同步布局：读写交替，导致多次重排
el.style.height = el.scrollHeight + 'px';
el.style.width = el.scrollWidth + 'px';

// ✅ 先读后写
const height = el.scrollHeight;
const width = el.scrollWidth;
el.style.height = height + 'px';
el.style.width = width + 'px';
```

---

### 3. 事件处理优化

事件处理不当会导致内存泄漏或卡顿。

#### 优化策略：

##### （1）事件委托（Event Delegation）

避免为每个子元素绑定事件。

```js
// ❌ 为每个按钮绑定
buttons.forEach(btn => btn.addEventListener('click', handler));

// ✅ 委托给父容器
container.addEventListener('click', (e) => {
    if (e.target.matches('.btn')) {
        handler(e);
    }
});
```

✅ 优势：
- 减少事件监听器数量
- 动态添加的元素也能响应

##### （2）节流（Throttle）与防抖（Debounce）

适用于高频事件：`scroll`、`resize`、`input` 等。

```js
// 防抖：最后一次触发后执行
function debounce(fn, delay) {
    let timer;
    return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
    };
}

// 节流：固定时间间隔执行一次
function throttle(fn, delay) {
    let last = 0;
    return function (...args) {
        const now = Date.now();
        if (now - last > delay) {
            fn.apply(this, args);
            last = now;
        }
    };
}

// 使用
window.addEventListener('scroll', throttle(handleScroll, 100));
input.addEventListener('input', debounce(search, 300));
```

---

### 4. 网络请求优化

减少请求数量和数据体积，提升加载速度。

#### 优化策略：

##### （1）减少请求数量
- 合并 CSS/JS 文件（使用 Webpack、Vite 等构建工具）
- 使用 CSS Sprites 合并小图标
- 使用 HTTP/2 多路复用

##### （2）压缩资源
- 启用 Gzip/Brotli 压缩
- 图片使用 WebP 格式
- JS 使用 Terser 压缩

##### （3）缓存策略
- 设置 `Cache-Control`、`ETag`
- 使用 Service Worker 实现离线缓存

##### （4）懒加载（Lazy Loading）

```js
// 图片懒加载
const img = document.querySelector('img[data-src]');
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.src = entry.target.dataset.src;
            observer.unobserve(entry.target);
        }
    });
});
observer.observe(img);
```

##### （5）预加载与预连接

```html
<!-- 预加载关键资源 -->
<link rel="preload" href="critical.js" as="script">

<!-- 预连接第三方域名 -->
<link rel="preconnect" href="https://api.example.com">
```

##### （6）使用 Web Workers 处理耗时任务

避免阻塞主线程：

```js
// worker.js
self.onmessage = function(e) {
    const result = heavyComputation(e.data);
    self.postMessage(result);
};

// main.js
const worker = new Worker('worker.js');
worker.postMessage(data);
worker.onmessage = (e) => {
    console.log('结果:', e.data);
};
```

---