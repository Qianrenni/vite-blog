## **3. 高级数据结构**

### **栈（Stack）**

- **定义**：后进先出（LIFO）的线性数据结构，仅允许在栈顶进行插入（push）和删除（pop）操作。
- **核心操作**：
  - `push(x)`：将元素 `x` 压入栈顶。
  - `pop()`：弹出栈顶元素。
  - `peek()`：查看栈顶元素但不弹出。
  - `isEmpty()`：判断栈是否为空。
- **时间复杂度**：所有操作均为 \(O(1)\)。
- **应用场景**：
  - 函数调用栈（递归/非递归）。
  - 括号匹配、表达式求值（中缀转后缀）。
  - 浏览器前进后退、撤销操作（双栈实现）。

### **队列（Queue）**

- **定义**：先进先出（FIFO）的线性数据结构，支持在队尾插入（enqueue）和队首删除（dequeue）。
- **核心操作**：
  - `enqueue(x)`：将元素 `x` 加入队尾。
  - `dequeue()`：移除队首元素。
  - `front()`：获取队首元素。
  - `isEmpty()`：判断队列是否为空。
- **变种**：
  - **双端队列（Deque）**：两端均可插入和删除。
  - **优先队列（Priority Queue）**：按优先级出队（通常用堆实现）。
- **时间复杂度**：普通队列操作均为 \(O(1)\)；优先队列的插入/删除为 \(O(\log n)\)。
- **应用场景**：
  - BFS（广度优先搜索）。
  - 任务调度、消息队列。

### **堆（Heap）**

- **定义**：完全二叉树，满足堆性质（父节点值 ≥ 或 ≤ 子节点值）。
- **类型**：
  - **大顶堆**：父节点 ≥ 子节点，根节点为最大值。
  - **小顶堆**：父节点 ≤ 子节点，根节点为最小值。
- **核心操作**：
  - `insert(x)`：插入元素并调整堆结构。
  - `extractMax()/extractMin()`：取出堆顶元素并调整堆。
  - `heapify()`：将无序数组构建为堆。
- **时间复杂度**：
  - 插入/删除：\(O(\log n)\)。
  - 建堆：\(O(n)\)。
- **应用场景**：
  - 优先队列、Top K 问题。
  - 堆排序（时间复杂度 \(O(n \log n)\)）。

### **二叉搜索树（Binary Search Tree, BST）**

- **定义**：二叉树，满足：
  - 左子树所有节点值 < 根节点值。
  - 右子树所有节点值 > 根节点值。
  - 左右子树也分别为 BST。
- **核心操作**：
  - `search(x)`：查找值为 `x` 的节点。
  - `insert(x)`：插入新节点。
  - `delete(x)`：删除节点（需处理子节点合并）。
- **时间复杂度**：
  - 平均：$O(log n)$（平衡时）。
  - 最坏：$O(n)$（退化为链表）。
- **缺点**：不平衡时性能退化，需通过平衡二叉树（如 AVL、红黑树）优化。

### **红黑树（Red-Black Tree）**

- **定义**：自平衡二叉搜索树，通过颜色和规则保持平衡：
  1. 节点为红或黑。
  2. 根节点和叶子节点（NIL）为黑。
  3. 红节点的子节点必须为黑。
  4. 从任一节点到叶子节点的路径包含相同数量的黑节点。
- **平衡操作**：旋转（左旋/右旋）和颜色调整。
- **时间复杂度**：插入、删除、查找均为 $O(\log n)$。
- **应用场景**：
  - C++ STL `map`/`set`、Java `TreeMap`/`TreeSet`。
  - 数据库索引（如 B 树变种）。

### **树状数组（Fenwick Tree）**

- **定义**：用于高效维护前缀和的动态数据结构，基于二进制低位技术（Lowbit）。
- **核心操作**：
  - `update(i, delta)`：将第 `i` 个元素的值增加 `delta`。
  - `query(i)`：查询前 `i` 个元素的前缀和。
- **时间复杂度**：
  - 更新和查询均为 $O(\log n)$。
- **优势**：代码简洁，空间占用小$O(n)$。
- **应用场景**：
  - 动态前缀和、逆序对统计。
  - 替代线段树处理单点更新+区间查询问题。

```python

class BinaryIndexedTree:
  def __init__(self, nums):
    """
    初始化树状数组
    :param nums: 原始数组
    """
    self.n = len(nums)
    self.tree = [0] * (self.n + 1)  # 树状数组从索引1开始
    for i in range(self.n):
      self.update(i, nums[i])

  def lowbit(self, x):
    """
    计算x的lowbit，即x二进制表示中最低位1所对应的值
    :param x: 输入值
    :return: lowbit(x)
    """
    return x & (-x)

  def update(self, index, delta):
    """
    更新数组中index位置的值，增加delta
    :param index: 需要更新的位置（原数组中的索引）
    :param delta: 增加的值
    """
    # 转换为树状数组中的索引
    i = index + 1
    while i <= self.n:
      self.tree[i] += delta
      i += self.lowbit(i)

  def query(self, index):
    """
    查询数组中前index个元素的前缀和
    :param index: 查询前缀和的索引（原数组中的索引）
    :return: 前index个元素的前缀和
    """
    res = 0
    i = index + 1
    while i > 0:
      res += self.tree[i]
      i -= self.lowbit(i)
    return res

  def get_value(self, index):
    """
    获取数组中index位置的值
    :param index: 查询位置的索引
    :return: index位置的值
    """
    if index < 0 or index >= self.n:
      return 0
    return self.query(index) - self.query(index - 1)

  def set_value(self, index, value):
    """
    设置数组中index位置的值为value
    :param index: 设置位置的索引
    :param value: 新的值
    """
    current_value = self.get_value(index)
    self.update(index, value - current_value)
```

### **线段树（Segment Tree）**

- **定义**：二叉树结构，用于高效处理区间查询（如区间和、最大值）和区间更新。
- **核心操作**：
  - `build()`：构建线段树。
  - `query(l, r)`：查询区间 `[l, r]` 的聚合值。
  - `update(i, x)`：单点更新。
  - `rangeUpdate(l, r, delta)`：区间更新（需懒惰标记优化）。
- **时间复杂度**：
  - 构建：$O(n)$。
  - 查询/更新：$O(\log n)$。
- **变种**：
  - **懒惰传播（Lazy Propagation）**：优化区间更新。
  - **动态开点**：处理稀疏区间。
- **应用场景**：
  - 区间最值、区间和、区间覆盖问题。
  - 二维线段树（处理矩阵问题）。

```python
class SegmentTree:
  """
  通用线段树（支持区间更新 + 区间查询）
  支持自定义合并函数、懒标记更新函数、默认值
  适用于：区间求和、最大值、最小值、区间加、区间覆盖等场景
  """

  def __init__(self, data, root_func, merge_func=sum, default=0):
    """
    初始化线段树

    :param data: 原始数据列表 (list)
    :param root_func: 懒标记应用函数，签名：f(left, right, lazy_value, old_value) -> new_value
                      用于计算：当区间 [left, right] 被赋予 lazy_value 时，节点应变成什么值
                      例如：
                        - 覆盖型：lambda l, r, v, _: v
                        - 增量型（区间加）：lambda l, r, v, old: old + v * (r - l + 1)
    :param merge_func: 合并函数，签名：f(a, b) -> merged_value，如 sum, max, min
    :param default: 查询无效区间时的返回值（单位元），如 0（sum）、-inf（max）、+inf（min）
    """
    self.n = len(data)  # 原始数据长度
    self.merge = merge_func  # 节点合并函数（如求和、最大值）
    self.root_func = root_func  # 懒标记生效函数（决定 lazy 如何影响节点值）
    self.size = 1  # 线段树底层满二叉树的“叶子层”大小（≥n 的最小 2 的幂）
    self.default = default  # 无效查询返回值（如空区间）

    # 计算 size：扩展成满二叉树叶子数
    while self.size < self.n:
      self.size *= 2

    # 初始化线段树数组和懒标记数组（1-based，tree[1] 是根）
    self.tree = [self.default] * (2 * self.size)  # 线段树节点值
    self.lazy = [0] * (2 * self.size)  # 懒标记（默认 0 表示无标记）

    # 叶子节点赋值：原始数据放在 [size, size + n - 1]
    for i in range(self.n):
      self.tree[self.size + i] = data[i]

    # 自底向上构建内部节点：从 size-1 到 1
    for i in range(self.size - 1, 0, -1):
      self.tree[i] = self.merge(self.tree[2 * i], self.tree[2 * i + 1])

  def _push(self, root, left, right):
    """
    懒标记下推函数（Lazy Propagation）
    将当前节点的 lazy 值推给子节点，并更新子节点的 tree 值

    :param root: 当前节点编号（1-based）
    :param left: 当前节点管理的左边界（逻辑索引）
    :param right: 当前节点管理的右边界（逻辑索引）
    """
    if self.lazy[root] != 0:  # 有懒标记需要下推
      if left != right:  # 不是叶子节点 → 需要推给左右子树
        mid = (left + right) // 2

        # 更新左子树的 lazy 和 tree 值
        self.lazy[root * 2] = self.lazy[root]
        self.tree[root * 2] = self.root_func(left, mid, self.lazy[root], self.tree[root * 2])

        # 更新右子树的 lazy 和 tree 值
        self.lazy[root * 2 + 1] = self.lazy[root]
        self.tree[root * 2 + 1] = self.root_func(mid + 1, right, self.lazy[root], self.tree[root * 2 + 1])

      # 清空当前节点的 lazy 标记
      self.lazy[root] = 0

  def _update(self, root, start, end, left, right, value):
    """
    递归更新函数：将区间 [left, right] 的值设为 value（或按 root_func 计算）

    :param root: 当前节点编号
    :param start: 当前节点管理的区间左端点
    :param end: 当前节点管理的区间右端点
    :param left: 待更新区间的左端点（用户输入）
    :param right: 待更新区间的右端点（用户输入）
    :param value: 要设置/增加的值
    """
    # 区间无交集，直接返回
    if end < left or right < start:
      return

    # 当前节点区间完全被 [left, right] 覆盖
    if left <= start and end <= right:
      # 应用 lazy：更新当前节点值
      self.tree[root] = self.root_func(start, end, value, self.tree[root])
      # 设置懒标记（子节点暂不更新）
      self.lazy[root] = value
      return

    # 递归前先下推懒标记，确保子节点数据最新
    self._push(root, start, end)

    # 递归更新左右子树
    mid = (start + end) // 2
    self._update(root * 2, start, mid, left, right, value)
    self._update(root * 2 + 1, mid + 1, end, left, right, value)

    # 回溯：用子节点更新当前节点
    self.tree[root] = self.merge(self.tree[root * 2], self.tree[root * 2 + 1])

  def update(self, left, right, value):
    """
    对外接口：更新区间 [left, right]（闭区间）

    :param left: 更新区间左端点（0-based，原始数组索引）
    :param right: 更新区间右端点
    :param value: 要设置/增加的值
    """
    # 根节点管理 [0, size-1]，递归更新
    self._update(1, 0, self.size - 1, left, right, value)

  def _query(self, node, left, right, query_left, query_right):
    """
    递归查询函数：查询区间 [query_left, query_right] 的合并值

    :param node: 当前节点编号
    :param left: 当前节点管理的左边界
    :param right: 当前节点管理的右边界
    :param query_left: 查询区间的左端点
    :param query_right: 查询区间的右端点
    :return: 区间合并值
    """
    # 无交集 → 返回单位元
    if left > query_right or right < query_left:
      return self.default

    # 下推懒标记，确保当前节点值是最新的
    self._push(node, left, right)

    # 当前节点区间完全在查询区间内 → 直接返回
    if left >= query_left and right <= query_right:
      return self.tree[node]

    # 递归查询左右子树
    mid = (left + right) // 2
    leftRes = self._query(node * 2, left, mid, query_left, query_right)
    rightRes = self._query(node * 2 + 1, mid + 1, right, query_left, query_right)

    # 合并左右子树结果
    return self.merge(leftRes, rightRes)

  def query(self, left, right):
    """
    对外接口：查询区间 [left, right] 的合并值

    :param left: 查询区间左端点（0-based）
    :param right: 查询区间右端点
    :return: 合并结果（如区间和、最大值等）
    """
    return self._query(1, 0, self.size - 1, left, right)

```

---