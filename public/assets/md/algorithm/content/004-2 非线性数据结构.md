## **2. 非线性数据结构**

### 哈希表

- **特点**：
  - **快速查找**
    ：哈希表通过哈希函数将键（key）映射到一个较小范围的整数，通常用作数组的索引，从而实现快速查找、插入和删除操作，平均时间复杂度为O(
    1)。
  - **冲突处理**：由于哈希函数可能会将不同的键映射到同一个索引，因此需要解决冲突问题。常见的冲突解决方法包括链地址法（拉链法）、开放定址法等。
  - **动态扩展**：当哈希表中的元素过多时，可能会导致冲突增加和性能下降，因此需要动态扩展哈希表的大小，重新计算哈希值并重新分配元素。

- **操作**：
  - **插入**：计算键的哈希值，将其映射到哈希表中的某个位置，并将键值对存储在该位置。如果发生冲突，则根据冲突解决方法进行处理。
  - **查找**：计算键的哈希值，直接定位到哈希表中的某个位置，然后查找该位置的链表或其他数据结构，找到对应的键值对。
  - **删除**：计算键的哈希值，定位到哈希表中的某个位置，然后从该位置的链表或其他数据结构中删除对应的键值对。

- **应用**：
  - **快速查找**：用于实现字典、符号表等需要快速查找的数据结构，如Python中的字典类型。
  - **去重**：用于存储唯一元素，快速判断一个元素是否已经存在，如集合（set）数据结构。
  - **缓存**：在缓存系统中，通过哈希表快速查找缓存项，提高系统的性能。

- **经典问题**：
  - **两数之和**：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的

    ```python
    def twoSum(nums: List[int], target: int) -> List[int]:
        num_set = set()
        for num in nums:
            complement = target - num
            if complement in num_dict:
                return [num_dict[complement], num]
            num_set.add(num)
        return []
    ```

  - **三数之和**：给定一个整数数组，找出其中三个数，使它们的和与目标值最接近。

    ```python
    def threeSum(nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        res,n = [],len(nums)
        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i-1]: 
              continue
            left,right = i+1,n-1
            while left < right:
                s = nums[i] + nums[left] + nums[right]
                if s == target:
                    res.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left+1]: 
                    left += 1
                while left < right and nums[right] == nums[right-1]: 
                    right -= 1
                if s < target:
                    left += 1
                if s > target:
                    right -= 1
        return res
    ```

  - **无重复字符的最长子串**：给定一个字符串，找到其中不含有重复字符的最长子串的长度。

---

### 树

- **特点**：
  - **层次结构**：树是一种层次化的数据结构，具有明确的父子关系，每个节点最多有一个父节点，但可以有多个子节点。
  - **递归定义**：树可以递归地定义为一个节点和若干子树的集合，这种递归性质使得树的很多操作可以通过递归算法实现。
  - **多样性**：树有多种类型，如二叉树、二叉搜索树、平衡树、堆等，每种树都有其特定的性质和应用场景。

- **操作**：
  - **遍历**：树的遍历是树的基本操作之一，常见的遍历方式包括前序遍历、中序遍历、后序遍历和层序遍历。遍历可以用于访问树中的所有节点。
  - **插入和删除**：在树中插入或删除节点时，需要根据树的类型和性质进行操作，如在二叉搜索树中插入或删除节点需要保持树的有序性。
  - **查找**：在树中查找特定的节点，如在二叉搜索树中，可以根据节点的值进行快速查找。

- **应用**：
  - **文件系统**：文件系统中的目录结构可以用树来表示，每个节点代表一个文件或目录，父子关系表示文件和目录的包含关系。
  - **组织结构**：在企业或组织中，员工的层级关系可以用树来表示，每个节点代表一个员工，父子关系表示上下级关系。
  - **决策树**：在机器学习和数据分析中，决策树是一种常用的分类和回归模型，通过树的结构来表示决策过程。

---

### 图

- **特点**：
  - **复杂关系**：图是一种用于表示复杂关系的数据结构，可以表示任意两个节点之间的关系，这种关系可以是有向的或无向的。
  - **多样性**：图有多种类型，如无向图、有向图、加权图、无权图等，每种图都有其特定的性质和应用场景。
  - **路径和连通性**：图的很多问题都与路径和连通性有关，如最短路径问题、连通分量问题等。
  - **存储方式**：图可以以邻接矩阵或邻接表两种方式存储，邻接矩阵表示为二维数组，邻接表表示为链表或其他数据结构。

- **操作**：
  - **遍历**：图的遍历包括层次遍历,深度优先搜索（DFS）和广度优先搜索（BFS），用于访问图中的所有节点。

    ```python
    def bfs(graph, start):
      visited = set()
      queue = deque([start])
      while queue:
        node = queue.popleft()
        visited.add(node)
        for neighbor in graph[node]:
          if neighbor not in visited:
            queue.append(neighbor)
    def dfs(graph, start,visited: set):
        visited.add(start)
        for neighbor in graph[start]:
          if neighbor not in visited:
            dfs(graph, neighbor,visited)
    ```

  - **最短路径**：在加权图中，可以使用Dijkstra算法或Bellman-Ford算法计算从一个节点到其他所有节点的最短路径。
  - **连通分量**：在无向图中，可以使用DFS或BFS算法计算图的连通分量，即图中所有相互连通的节点集合。

- **应用**：
  - **社交网络**：在社交网络中，用户之间的关系可以用图来表示，节点代表用户，边代表用户之间的关系，如好友关系、关注关系等。
  - **交通网络**：在交通网络中，城市之间的交通连接可以用图来表示，节点代表城市，边代表交通线路，边的权重可以表示距离、时间或费用等。
  - **网页链接**：在互联网中，网页之间的链接关系可以用图来表示，节点代表网页，边代表网页之间的链接。

- **经典问题**：
  - **最短路径问题**：在加权图中，计算从一个节点到其他所有节点的最短路径。
  - **最小生成树问题**：在无向加权图中，找到一个包含所有节点的最小权重的生成树。
  - **连通分量问题**：在无向图中，计算图的连通分量，即图中所有相互连通的节点集合。