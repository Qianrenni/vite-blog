## **1. 线性结构**

### 顺序表

- **特点**：
  - **存储结构**：顺序表中的所有元素在内存中以连续的存储空间存储，这种存储方式使得顺序表可以通过索引快速访问任意位置的元素。
  - **内存分配**：通常需要预先分配一块足够大的内存空间来存储元素，这可能导致空间的浪费（如果实际存储的元素较少）或空间不足（如果实际存储的元素超出预分配空间）。
  - **操作效率**：插入和删除操作效率较低，尤其是中间位置的操作，平均时间复杂度为$O(n)$，因为需要移动大量元素来保持存储空间的连续性。
  - **随机访问**：支持快速随机访问，通过索引可以直接定位元素，时间复杂度为$O(1)$。

- **操作**：
  - **查找**：通过索引直接访问元素，时间复杂度为$O(1)$。
  - **插入**
    ：在指定位置插入一个新元素时，需要将该位置及其之后的所有元素向后移动一位，以腾出空间来插入新元素，时间复杂度为$O(n)$。
  - **删除**：删除指定位置的元素时，需要将该位置之后的所有元素向前移动一位，以填补被删除元素留下的空位，时间复杂度为$O(n)$。
  - **遍历**：从头到尾依次访问顺序表中的每个元素，时间复杂度为$O(n)$。

- **应用**：
  - **数组**：顺序表是数组的底层实现方式，适用于元素数量相对固定且需要频繁随机访问的场景，如存储学生的成绩、商品的库存等。
  - **栈和队列**：顺序表可以用来实现栈和队列这两种数据结构，通过限制插入和删除操作的位置来满足栈和队列的特性。
  - **矩阵**：在某些情况下，可以使用多维顺序表（即数组）来存储矩阵，方便进行矩阵运算和操作。
- **经典问题**:
  - 最大最小值：在顺序表中，可以使用线性搜索算法找到最大值和最小值，时间复杂度为$O(n)
    $。排序之后可以使用二分查找来快速找到最大值和最小值，时间复杂度为$O(\log n)$。
  - 排序：在顺序表中，可以使用各种排序算法（如冒泡排序、选择排序、插入排序、归并排序、快速排序等）对元素进行排序，时间复杂度为$O(
    n\log n)$。
  - 搜索：在顺序表中，可以使用线性搜索算法进行搜索，时间复杂度为$O(n)$。
  ---

### 链表

- **特点**：
  - **存储结构**：链表由一系列节点组成，每个节点包含数据和指向下一个节点的引用，这种存储方式使得链表的存储空间可以分散在内存中，不需要连续的存储空间。
  - **内存分配**：链表的存储空间是动态分配的，可以根据实际需要动态地申请和释放节点，避免了空间的浪费和不足问题。
  - **操作效率**：插入和删除操作灵活，时间复杂度为$O(1)$，只需修改相邻节点的指针，而不需要移动大量元素。
  - **随机访问**：不支持随机访问，访问任意节点需要从头开始遍历，时间复杂度为$O(n)$。

- **操作**：
  - **查找**：从头节点开始，依次遍历链表，直到找到目标节点或到达链表末尾，时间复杂度为$O(n)$。
  - **插入**：在指定位置插入一个新节点时，只需修改相邻节点的指针，将新节点插入到链表中，时间复杂度为$O(1)$。
  - **删除**：删除指定位置的节点时，只需修改前驱节点的指针，使其指向被删除节点的后继节点，时间复杂度为$O(1)$。
  - **遍历**：从头节点开始，依次访问链表中的每个节点，时间复杂度为$O(n)$。

- **应用**：
  - **动态数据存储**：适用于元素数量不固定且需要频繁插入和删除元素的场景，如存储待处理的任务列表、动态的用户信息等。
  - **实现复杂数据结构**：链表可以用来实现一些复杂的数据结构，如双向链表、循环链表、链式队列、链式栈等，满足不同的应用场景需求。
  - **内存管理**：在某些内存管理算法中，使用链表来管理空闲内存块，方便动态地分配和回收内存空间。

---