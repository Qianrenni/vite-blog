### 一、索引失效的常见场景

#### 1. **对索引列使用函数或表达式**
- **示例**：
  ```sql
  SELECT * FROM users WHERE YEAR(create_time) = 2023;
  ```
- **原因**：MySQL 无法直接使用 `create_time` 上的索引，因为对列进行了函数运算。
- **优化**：
  ```sql
  SELECT * FROM users 
  WHERE create_time >= '2023-01-01' AND create_time < '2024-01-01';
  ```

---

#### 2. **对索引列进行隐式类型转换**
- **示例**：
  ```sql
  -- user_id 是 INT 类型
  SELECT * FROM users WHERE user_id = '123';
  ```
- **原因**：字符串 `'123'` 被隐式转换为整数，可能导致索引失效（尤其在某些版本或复杂情况下）。
- **优化**：确保传入值类型与列类型一致。
  ```sql
  SELECT * FROM users WHERE user_id = 123;
  ```

---

#### 3. **对索引列使用 `!=` 或 `<>`**
- **示例**：
  ```sql
  SELECT * FROM users WHERE status != 1;
  ```
- **原因**：非等值查询无法高效利用 B+ 树索引（除非是覆盖索引且选择性极高）。
- **优化**：
  - 如果可能，改用 `IN` 或范围查询。
  - 若数据分布稀疏，可考虑是否值得建立索引。

---

#### 4. **使用 `NOT IN`、`NOT EXISTS`**
- **示例**：
  ```sql
  SELECT * FROM users WHERE id NOT IN (SELECT user_id FROM orders);
  ```
- **原因**：通常无法有效使用索引，尤其子查询结果大时。
- **优化**：
  - 改用 `LEFT JOIN ... IS NULL`
  - 或使用 `NOT EXISTS`（有时更优）

---

#### 5. **`LIKE` 以通配符开头（`%xxx`）**
- **示例**：
  ```sql
  SELECT * FROM users WHERE name LIKE '%john%';
  ```
- **原因**：B+ 树索引从左匹配，前导通配符导致无法使用索引。
- **优化**：
  - 避免前导 `%`，如 `name LIKE 'john%'` 可用索引。
  - 全文检索：使用 `FULLTEXT` 索引（仅 MyISAM / InnoDB 5.6+）。
  - 使用 Elasticsearch 等外部搜索引擎。

---

#### 6. **复合索引未遵循最左前缀原则**
- **示例**：
  ```sql
  -- 索引：(a, b, c)
  SELECT * FROM t WHERE b = 1 AND c = 2;  -- a 未使用
  ```
- **原因**：跳过最左列 `a`，导致索引失效。
- **优化**：
  - 查询条件包含最左列。
  - 重新设计索引顺序（如 `(b, a, c)` 如果常查 b）。

> ✅ 有效使用复合索引的情况：
> - `WHERE a = 1`
> - `WHERE a = 1 AND b = 2`
> - `WHERE a = 1 AND b = 2 AND c = 3`
> - `WHERE a = 1 AND c = 3` → **b 被跳过，c 无法使用索引**

---

#### 7. **`OR` 条件中部分列无索引**
- **示例**：
  ```sql
  -- idx_a(a), 但 b 无索引
  SELECT * FROM t WHERE a = 1 OR b = 2;
  ```
- **原因**：MySQL 无法对 `b = 2` 使用索引，可能全表扫描。
- **优化**：
  - 为 `b` 添加索引。
  - 拆分为 `UNION`：
    ```sql
    SELECT * FROM t WHERE a = 1
    UNION
    SELECT * FROM t WHERE b = 2;
    ```

> ⚠️ 注意：MySQL 8.0+ 对 `OR` 优化有所增强，但仍需谨慎。

---

#### 8. **索引列参与计算**
- **示例**：
  ```sql
  SELECT * FROM products WHERE price * 1.1 > 100;
  ```
- **原因**：`price` 被计算，无法直接查索引。
- **优化**：
  ```sql
  SELECT * FROM products WHERE price > 100 / 1.1;
  ```

---

#### 9. **使用 `IS NULL` / `IS NOT NULL`（视情况）**
- **InnoDB 中，NULL 值会被索引**，所以 `IS NULL` 通常**可以走索引**。
- 但 `IS NOT NULL` 在某些情况下（如选择性低）优化器可能放弃索引。
- **建议**：通过 `EXPLAIN` 确认执行计划。

---

#### 10. **数据分布极度倾斜（低选择性）**
- **示例**：`status` 列只有 0 和 1，且 99% 是 1。
- **原因**：即使有索引，优化器认为全表扫描更快。
- **优化**：
  - 删除低选择性索引。
  - 考虑组合索引提升选择性。

---

#### 11. **强制类型转换（字符集/排序规则不一致）**
- **示例**：连接两个表，但字符集不同（如 utf8 vs utf8mb4）。
- **原因**：隐式转换导致索引失效。
- **优化**：统一字符集和排序规则。

---

#### 12. **使用 `SELECT *` 且非覆盖索引**
- **不是索引失效，但导致回表**，性能下降。
- **优化**：只查需要的字段，或建立**覆盖索引**（包含 SELECT 所有字段）。

---