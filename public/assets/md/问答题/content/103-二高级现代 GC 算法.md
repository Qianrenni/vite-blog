### 二、高级/现代 GC 算法

#### 5. **分代收集（Generational GC）**

- **核心思想**：**弱代假说**（Most objects die young）。
- **实现**：
    - 将堆分为 **新生代（Young）** 和 **老年代（Old）**。
    - 新生代频繁 GC（Minor GC），使用复制算法。
    - 老年代较少 GC（Major/Full GC），使用标记-清除或标记-整理。
- **优点**：
    - 针对性优化，提升整体效率。
- **典型应用**：
    - Java（HotSpot JVM）、C#、Go（虽不分代但有类似思想）。

---

#### 6. **增量 GC（Incremental GC）**

- **原理**：将 GC 工作拆分为多个小步骤，与程序交替执行。
- **优点**：减少单次 STW 时间。
- **缺点**：总 GC 时间可能增加，实现复杂。
- **应用**：早期浏览器 JS 引擎。

---

#### 7. **并发 GC（Concurrent GC）**

- **原理**：GC 线程与应用线程**并发执行**（大部分阶段不暂停应用）。
- **代表算法**：
    - **CMS（Concurrent Mark-Sweep）**（Java）：
        - 并发标记 + 并发清除。
        - 缺点：碎片化、CPU 占用高、已废弃。
    - **G1（Garbage-First）**（Java）：
        - 将堆划分为 Region，优先回收垃圾最多的 Region。
        - 支持并发标记，可预测停顿时间。
    - **ZGC / Shenandoah**（Java 11+）：
        - **几乎无停顿**（<10ms），使用 **Load Barrier** 技术实现并发标记与移动。
        - 支持 TB 级堆。

---

#### 8. **三色标记法（Tri-color Marking）**

- **原理**（用于并发/增量 GC）：
    - **白色**：未访问，待回收。
    - **灰色**：已访问，但其引用对象未全标记。
    - **黑色**：已访问，且所有引用对象已标记。
- **关键问题**：**并发修改导致漏标**（如黑色对象新增指向白色对象）。
- **解决方案**：
    - **写屏障（Write Barrier）**：
        - **增量更新（Incremental Update）**：CMS 使用，记录新增引用。
        - **原始快照（Snapshot-At-The-Beginning, SATB）**：G1/ZGC 使用，保留对象修改前的状态。

---