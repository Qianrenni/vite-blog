## 前端算法4

#### 问题描述:
```typescript
// 每5个job并行,当有一个job执行完毕,就执行下一个job,直到所有job执行完毕
async exec(jobs: (() => Promise<any>)[]):Promise<any[]>{};

```

#### 解答1
```typescript
async function exec(jobs: (() => Promise<any>)[]): Promise<any[]> {
  const results: any[] = new Array(jobs.length);
  const concurrency = 5;
  let index = 0;

  // 用一个函数来递归执行任务
  async function worker(workerId: number): Promise<void> {
    while (index < jobs.length) {
      const i = index++; // 原子获取当前任务索引
      try {
        const result = await jobs[i]();
        results[i] = result;
      } catch (err) {
        results[i] = err; // 或者 throw err，根据需求决定
        // 如果希望失败中断整个流程，可以在这里 re-throw
      }
    }
  }

  // 启动最多 concurrency 个 worker
  const workers = Array.from({ length: Math.min(concurrency, jobs.length) }, (_, id) => worker(id));
  await Promise.all(workers);

  return results;
}
```

#### 解答2
```typescript
async function exec(jobs) {
  let result = new Array(jobs.length);
  let count = 0;
  let finishCount = 0; // 修正拼写

  for (let i = 0; i < jobs.length; i++) {
    if (count < 5) {
      count += 1;
      new Promise(async (resolve, reject) => {
        try {
          let res = await jobs[i]();
          result[i] = res;
          resolve();
        } catch (err) {
          result[i] = err; // 可选：保存错误
          reject(err);
        }
      }).finally(() => {
        count -= 1;
        finishCount += 1;
      }).catch(() => {}); // 避免未处理 rejection
    } else {
      // 修复：>= 5，不是 > 5
      while (count >= 5) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
      count += 1;
      new Promise(async (resolve, reject) => {
        try {
          let res = await jobs[i]();
          result[i] = res;
          resolve();
        } catch (err) {
          result[i] = err;
          reject(err);
        }
      }).finally(() => {
        count -= 1;
        finishCount += 1;
      }).catch(() => {});
    }
  }

  while (finishCount < jobs.length) {
    await new Promise(resolve => setTimeout(resolve, 0));
  }

  return result;
}
```
#### 解答3
```typescript
async exec(jobs: (() => Promise<any>)[]): Promise<any[]> {
  const result: any[] = new Array(jobs.length);
  let count = 0;
  let finished = 0;
  const total = jobs.length;

  // 用于在任务完成时通知等待者
  let resolveNext: (() => void) | null = null;

  // 包装每个任务，执行后更新状态并通知
  const runJob = async (i: number) => {
    try {
      const res = await jobs[i]();
      result[i] = res;
    } catch (err) {
      result[i] = err; // 保留错误，也可 throw
    } finally {
      count--;
      finished++;
      // 如果有等待者，唤醒它（只唤醒一个）
      if (resolveNext) {
        resolveNext();
        resolveNext = null;
      }
    }
  };

  for (let i = 0; i < total; i++) {
    if (count >= 5) {
      // 等待一个任务完成（即 count < 5）
      await new Promise<void>(resolve => {
        resolveNext = resolve;
      });
    }

    count++;
    // 启动任务（不 await，让它在后台跑）
    runJob(i);
  }

  // 等待所有任务完成
  while (finished < total) {
    await new Promise(resolve => setTimeout(resolve, 0));
  }

  return result;
}
```