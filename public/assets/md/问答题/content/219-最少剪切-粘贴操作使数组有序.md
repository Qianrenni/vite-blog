### 最少剪切-粘贴操作使数组有序
>描述:
给定一个由 1 到 n 的整数组成的排列（即无重复、长度为 n），你可以执行如下操作任意次：
选择一个连续子数组（区间），将其“剪切”并“粘贴”到数组中任意其他位置（包括开头或末尾）。 
问：最少需要多少次这样的操作，才能使数组变为严格升序（即 [1, 2, 3, ..., n]）？
```python

from functools import lru_cache

oprs = None
path = []
@lru_cache()
def verify(arr: tuple[int],level: int,k):
    global oprs
    if level == k:
        if all( i+1==arr[i]  for i in range(len(arr)-1)):
            oprs = path.copy()
            return  True
        else:
            return False
    for length in range(1,len(arr)):
        for i in range(len(arr)-length+1):
            slice = arr[i:i+length]
            pre = arr[:i]
            post = arr[i+length:]
            rest = pre + post
            for j in range(len(rest)+1):
                left = rest[:j]
                right = rest[j:]
                path.append([slice,left+slice+right])
                if verify(left+slice+right,level+1,k):
                    return True
                path.pop()
    return False
n = 7
arr = tuple(n-i for i in range(n))
left,right = 0,n-1
answer = right 
print(arr)
while left <= right:
    path = []
    mid = (left+right)//2
    temp = arr[::]
    if verify(temp,0,mid):
        answer = mid
        right = mid-1
    else:
        left = mid+1
print(answer)
print(oprs )
```