### ✅ 补充：六、防止哈希值溢出（中间结果过大）

在计算哈希值（尤其是多项式滚动哈希）时，若字符串较长或基数较大，中间结果 `h` 可能迅速增长，超出编程语言整数范围（如 32/64 位整数上限），导致：
- **溢出错误**（某些语言会报错）；
- **自动截断/回绕**（如 C/C++ 中无符号整数溢出），虽有时可利用此特性，但行为不可控；
- **性能下降**（Python 虽支持大整数，但大数运算慢）。

#### ✅ 解决方案：

1. **每一步都取模（推荐）**  
   在每次迭代中立即对当前哈希值取模，确保中间结果始终小于 `size`（或一个更大的模数）：
   ```python
   h = 0
   for c in s:
       h = (h * base + ord(c)) % size   # 每步取模，防溢出
   ```
   - 优点：数值始终可控，适合任意长度字符串；
   - 数学依据：`(a * b + c) % m = ((a % m) * b + c) % m`，取模可提前。

2. **使用更大的中间模数（双重取模）**  
   若担心 `size` 太小导致分布不均（如 size=100），可先对一个**大质数**（如 \(2^{31} - 1 = 2147483647\)）取模，最后再对 `size` 取模：
   ```python
   MOD = 2147483647  # 大质数
   h = 0
   for c in s:
       h = (h * base + ord(c)) % MOD
   return h % size
   ```
   - 优点：保留更多哈希信息，减少因小模数导致的冲突；
   - 常用于字符串匹配（如 Rabin-Karp 算法）。

3. **语言层面处理**  
   - **Python**：整数自动支持任意精度，不会溢出，但大数运算慢 → 建议仍每步取模；
   - **C/C++/Java**：必须显式处理溢出，通常用无符号整数 + 自然溢出（等价于对 \(2^{32}\) 或 \(2^{64}\) 取模），但需注意这与 `size` 是否互质。

> 💡 **关键原则**：**取模操作可以且应该尽早进行**，不影响最终结果，却能有效控制数值范围。

---