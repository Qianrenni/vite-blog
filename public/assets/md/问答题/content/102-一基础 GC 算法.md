### 一、基础 GC 算法

#### 1. **引用计数（Reference Counting）**

- **原理**：每个对象维护一个引用计数器，当引用增加时 +1，减少时 -1；计数为 0 时立即回收。
- **优点**：
    - 回收及时，内存释放延迟低。
    - 实现简单。
- **缺点**：
    - 无法处理**循环引用**（如 A → B → A）。
    - 每次引用变更都有开销（原子操作在多线程下更重）。
- **典型应用**：
    - Python（主 GC 机制之一）、PHP、Objective-C（ARC 基于编译期引用计数）。

> 📌 补充：Python 使用引用计数 + **分代循环检测器**（`gc` 模块）来解决循环引用问题。

---

#### 2. **标记-清除（Mark-Sweep）**

- **原理**：
    1. **标记阶段**：从根对象（如全局变量、栈变量）出发，DFS/BFS 遍历所有可达对象并标记。
    2. **清除阶段**：遍历堆，回收未被标记的对象。
- **优点**：
    - 能处理循环引用。
    - 实现相对简单。
- **缺点**：
    - **内存碎片化**（回收后内存不连续）。
    - 需要暂停程序（Stop-The-World, STW）。
- **典型应用**：
    - 早期 JVM、JavaScript 引擎（如早期 V8）。

---

#### 3. **标记-整理（Mark-Compact）**

- **原理**：在标记-清除基础上，将存活对象**向一端移动**，消除碎片。
- **优点**：
    - 无内存碎片，利于后续分配。
- **缺点**：
    - 整理阶段开销大（需移动对象并更新引用）。
    - 仍需 STW。
- **典型应用**：
    - Java 的 Serial GC、Parallel Old GC（老年代使用）。

---

#### 4. **复制算法（Copying）**

- **原理**：
    - 将堆分为 **From** 和 **To** 两个区域。
    - GC 时，将 From 中存活对象复制到 To，然后交换角色。
- **优点**：
    - 无碎片。
    - 分配只需移动指针（高效）。
- **缺点**：
    - **内存利用率低**（只用一半空间）。
    - 对象存活率高时复制开销大。
- **典型应用**：
    - Java 的新生代（Eden + Survivor 区）、Go 的 GC（部分阶段）。

> 💡 优化：现代 JVM 将新生代分为 Eden + 两个 Survivor（S0/S1），只使用一个 Survivor 作为 To 区，提高空间利用率。

---