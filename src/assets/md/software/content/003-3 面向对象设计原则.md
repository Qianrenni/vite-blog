# **3. 面向对象设计原则**

## **单一职责原则（Single Responsibility Principle, SRP）**

**定义**：单一职责原则指出，一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。如果一个类承担了多个职责，那么在任何一个职责的需求发生改变时，都可能导致该类需要修改。这不仅增加了代码出错的风险，也使得类难以维护和理解。

**例子**：假设我们有一个`Employee`类，它既处理员工的薪资计算又管理员工的工作分配。根据SRP，我们应该将这两个职责分离到不同的类中，比如创建一个`SalaryCalculator`类来处理薪资计算，而`Employee`类则专注于工作分配相关的功能。

## **开闭原则（Open/Closed Principle, OCP）**

**定义**：开闭原则主张软件实体（如类、模块、函数等）应该是可以扩展的，但是不可修改。也就是说，当应用的需求发生改变时，在不修改软件实体源代码的前提下，能够通过添加新的代码来实现功能上的扩展。这一原则支持系统向未来的更改开放，同时保持对已有代码的封闭，从而减少因变更带来的风险。

**例子**：在一个图形绘制应用中，有多种形状（如圆形、矩形）。为了遵循OCP，我们可以定义一个抽象的`Shape`基类，并让所有具体形状（如`Circle`, `Rectangle`）继承自它。当需要添加新形状时，只需创建新的类实现`Shape`接口，而无需修改现有的代码。

## **里氏替换原则（Liskov Substitution Principle, LSP）**

**定义**：里氏替换原则表明，超类出现的地方都可以用子类来替换，且程序行为不会受到影响。换句话说，子类必须能够替换其父类而不影响程序的正确性。这一原则强调继承关系中的子类应当是对基类的合理扩展，而不是基类的特例化。

**例子**：考虑一个`Bird`基类和它的子类`Ostrich`（鸵鸟）。如果`Bird`有一个飞行的方法，但`Ostrich`作为不能飞的鸟类，直接继承并使用这个方法就不符合LSP。正确做法是重新设计`Bird`类，使其不假定所有鸟类都能飞行，或者为`Ostrich`提供一个适当的实现。

## **接口隔离原则（Interface Segregation Principle, ISP）**

**定义**：接口隔离原则建议不应强迫客户端依赖于它们不使用的接口。换句话说，应将臃肿的接口拆分为更小和更具体的接口，以确保实现类只需关注自己所需的方法，从而使系统更加清晰和高效。这样做可以避免“胖接口”带来的问题。

**例子**：如果我们有一个庞大的`Worker`接口，包含了全职员工和兼职员工的所有方法。这会导致某些实现类不得不实现一些根本用不到的方法。ISP建议我们将`Worker`接口拆分为`FullTimeWorker`和`PartTimeWorker`等更小的接口，以满足不同需求。

## **依赖倒置原则（Dependency Inversion Principle, DIP）**

**定义**：依赖倒置原则包含两个部分：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。这意味着我们应该尽量针对接口编程，而不是具体实现，这样可以降低模块之间的耦合度，增强系统的灵活性和重用性。

**例子**：在支付系统中，不要让订单处理逻辑直接依赖具体的支付方式（如信用卡支付、PayPal支付）。相反，定义一个`PaymentProcessor`接口，并让各种支付方式实现此接口。这样，订单处理逻辑只需要知道如何与`PaymentProcessor`交互，而不关心具体的支付实现。

## **合成复用原则（Composite Reuse Principle, CRP）**

**定义**：合成复用原则提倡尽可能使用对象组合/聚合，而不是通过继承来达到复用的目的。相比于继承，组合提供了更大的灵活性，并能有效避免因层次结构过深而引起的复杂性和脆弱性。通过组合方式，可以在运行时动态地改变组件的行为或特性，增强了系统的适应性。

**例子**：若要设计一个汽车类，避免通过继承发动机、车轮等类来构建汽车类。更好的方法是通过组合的方式，在`Car`类中包含`Engine`和`Wheel`的对象实例。这种方式不仅提高了灵活性，也减少了由于继承带来的复杂性。

## **迪米特法则（Law of Demeter, LoD）**

**定义**：迪米特法则又称最少知识原则，它规定一个对象应该对其它对象有尽可能少的了解，尤其是只与那些直接的朋友（即当前对象本身、作为方法参数传入的对象、当前对象创建的对象以及当前对象的属性）交互。通过限制对象之间的直接交互，可以减少系统的耦合度，使系统更容易维护和升级。

**例子**：在一个游戏开发场景中，角色（`Character`）想要获取其装备（`Equipment`）的状态信息。按照LoD，`Character`不应该直接访问`Equipment`中的私有属性或方法，而是通过`Equipment`提供的公共接口来间接获取这些信息，从而限制了`Character`与`Equipment`之间的紧密耦合

---