## **2. 内存泄漏与预防**

### **2.1 什么是内存泄漏？**

- **定义**：
  - 内存泄漏是指程序在动态分配内存后，未能释放这些内存，导致内存被占用而无法再次使用。
  - 长时间运行的程序如果存在内存泄漏，可能会耗尽系统资源，最终导致程序崩溃或系统性能下降。
- **示例**：

  ```c
  void memoryLeak() {
      int *ptr = (int *)malloc(sizeof(int));
      *ptr = 10;
      // 忘记释放内存
  }
  ```

  - 每次调用 `memoryLeak` 都会分配一块内存，但从未释放，导致内存泄漏。

---

### **2.2 内存泄漏的原因**

1. **忘记释放动态分配的内存**：
   - 使用 `malloc`, `calloc`, `realloc` 后未调用 `free`。
2. **丢失指针引用**：
   - 指针被重新赋值，导致原内存块无法访问。
   - 示例：

     ```c
     int *ptr = (int *)malloc(sizeof(int));
     ptr = NULL;  // 原内存块丢失，无法释放
     ```

3. **异常退出**：
   - 程序因错误或异常提前退出，未执行释放代码。

---

### **2.3 如何预防内存泄漏？**

#### **1. 始终释放动态分配的内存**

- 确保每次调用 `malloc`, `calloc`, `realloc` 后都调用 `free`。
- 示例：

  ```c
  int *arr = (int *)malloc(5 * sizeof(int));
  if (arr != NULL) {
      // 使用 arr
      free(arr);  // 释放内存
  }
  ```

#### **2. 使用智能指针（C++ 中更常见）**

- 在 C++ 中，可以使用智能指针（如 `std::unique_ptr` 或 `std::shared_ptr`）自动管理内存。
- 在 C 中，可以通过封装函数实现类似的功能。

#### **3. 避免指针丢失**

- 不要随意覆盖指针变量。
- 示例：

  ```c
  int *ptr = (int *)malloc(sizeof(int));
  int *temp = ptr;  // 保存指针
  free(temp);       // 正确释放内存
  ```

#### **4. 检查返回值**

- 在动态分配内存时检查返回值是否为 `NULL`，确保分配成功。
- 示例：

  ```c
  int *ptr = (int *)malloc(sizeof(int));
  if (ptr == NULL) {
      printf("Memory allocation failed.\n");
      return -1;
  }
  ```

#### **5. 使用工具检测内存泄漏**

- 工具如 **Valgrind** 和 **AddressSanitizer** 可以帮助检测内存泄漏。
- 示例（使用 Valgrind）：

  ```bash
  valgrind --leak-check=full ./program
  ```

---

### **总结**

内存管理是 C 编程中的核心技能，以下是关键点的总结：

1. **内存布局**：
   - 栈：存储局部变量，生命周期短。
   - 堆：用于动态分配，需手动管理。
   - 全局/静态区：存储全局和静态变量。
   - 常量区：存储不可修改的常量。

2. **内存泄漏与预防**：
   - 内存泄漏会导致资源浪费，影响程序性能。
   - 预防措施包括始终释放动态分配的内存、避免指针丢失、检查返回值以及使用工具检测问题。